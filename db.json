{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/alipay.JPG","path":"img/alipay.JPG","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/wechat.JPG","path":"img/wechat.JPG","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/Valine.min.js","path":"js/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/assets/头像.JPG","path":"img/assets/头像.JPG","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/background/樱花1.jpg","path":"img/background/樱花1.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/background/樱花2.jpg","path":"img/background/樱花2.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/image/Database-Interview/13526879-3037b144ed09eb88.png","path":"image/Database-Interview/13526879-3037b144ed09eb88.png","modified":1,"renderable":0},{"_id":"source/image/Database-Interview/aof-work-process.png","path":"image/Database-Interview/aof-work-process.png","modified":1,"renderable":0},{"_id":"source/image/Database-Interview/redis-event-handler.png","path":"image/Database-Interview/redis-event-handler.png","modified":1,"renderable":0},{"_id":"source/image/Hand-Torn-Code/20230615083937874.png","path":"image/Hand-Torn-Code/20230615083937874.png","modified":1,"renderable":0},{"_id":"source/image/Hand-Torn-Code/20230615085001544.png","path":"image/Hand-Torn-Code/20230615085001544.png","modified":1,"renderable":0},{"_id":"source/image/Hand-Torn-Code/20230615085019913.png","path":"image/Hand-Torn-Code/20230615085019913.png","modified":1,"renderable":0},{"_id":"source/image/Hand-Torn-Code/20230615085141896.png","path":"image/Hand-Torn-Code/20230615085141896.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/1.png","path":"image/k8s部署云笔记系统/1.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/2.png","path":"image/k8s部署云笔记系统/2.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/3.png","path":"image/k8s部署云笔记系统/3.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/4.png","path":"image/k8s部署云笔记系统/4.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/5.png","path":"image/k8s部署云笔记系统/5.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/6.png","path":"image/k8s部署云笔记系统/6.png","modified":1,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/可莉.png","path":"image/k8s部署云笔记系统/可莉.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/6.png","path":"image/云笔记系统扩容/6.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/add-labels.png","path":"image/云笔记系统扩容/add-labels.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/backup-desktop.png","path":"image/云笔记系统扩容/backup-desktop.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/backup.png","path":"image/云笔记系统扩容/backup.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/delete-pod.png","path":"image/云笔记系统扩容/delete-pod.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/expand.png","path":"image/云笔记系统扩容/expand.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/login.png","path":"image/云笔记系统扩容/login.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-after-deleted.png","path":"image/云笔记系统扩容/pod-after-deleted.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-after-deploy.png","path":"image/云笔记系统扩容/pod-after-deploy.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-deploy.png","path":"image/云笔记系统扩容/pod-deploy.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-node.png","path":"image/云笔记系统扩容/pod-node.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod.png","path":"image/云笔记系统扩容/pod.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/setting.png","path":"image/云笔记系统扩容/setting.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/vmware.png","path":"image/云笔记系统扩容/vmware.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/shutdown.png","path":"image/云笔记系统扩容/shutdown.png","modified":1,"renderable":0},{"_id":"source/image/云笔记系统扩容/xftp.png","path":"image/云笔记系统扩容/xftp.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/A3C.png","path":"image/强化学习/A3C.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/A3C1.png","path":"image/强化学习/A3C1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/AC算法.png","path":"image/强化学习/AC算法.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DDPG1.png","path":"image/强化学习/DDPG1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DDPG2.png","path":"image/强化学习/DDPG2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DQN.png","path":"image/强化学习/DQN.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DQN公式.png","path":"image/强化学习/DQN公式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DQN更新的是Q值.png","path":"image/强化学习/DQN更新的是Q值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DuelDQN.png","path":"image/强化学习/DuelDQN.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/DuelDQN网络架构.png","path":"image/强化学习/DuelDQN网络架构.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/G值的意义.png","path":"image/强化学习/G值的意义.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Magic'(X).png","path":"image/强化学习/Magic'(X).png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Magic(X).png","path":"image/强化学习/Magic(X).png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q'估算Q 1.png","path":"image/强化学习/Q'估算Q 1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q'估计Q 2.png","path":"image/强化学习/Q'估计Q 2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q=S+A表格.png","path":"image/强化学习/Q=S+A表格.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Qlearning公式.png","path":"image/强化学习/Qlearning公式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Qlearning图解.png","path":"image/强化学习/Qlearning图解.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Qtable三维可视化.png","path":"image/强化学习/Qtable三维可视化.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q值的定义.png","path":"image/强化学习/Q值的定义.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q值转V值.png","path":"image/强化学习/Q值转V值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/Q值转V值1.png","path":"image/强化学习/Q值转V值1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/SARSA.png","path":"image/强化学习/SARSA.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/SARSA公式.png","path":"image/强化学习/SARSA公式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD(0).png","path":"image/强化学习/TD(0).png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD(0)与SARSA对比.png","path":"image/强化学习/TD(0)与SARSA对比.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD(0)图解.png","path":"image/强化学习/TD(0)图解.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD(0)更新公式.png","path":"image/强化学习/TD(0)更新公式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD-error.png","path":"image/强化学习/TD-error.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD3.png","path":"image/强化学习/TD3.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/TD(N).png","path":"image/强化学习/TD(N).png","modified":1,"renderable":0},{"_id":"source/image/强化学习/V值的定义.png","path":"image/强化学习/V值的定义.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/V值转Q值.png","path":"image/强化学习/V值转Q值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/V值转Q值1.png","path":"image/强化学习/V值转Q值1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/V值转V值.png","path":"image/强化学习/V值转V值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/fix-Q-targets.png","path":"image/强化学习/fix-Q-targets.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/两种理解方式.png","path":"image/强化学习/两种理解方式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/为什么不估算Q.png","path":"image/强化学习/为什么不估算Q.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/二维曲线.png","path":"image/强化学习/二维曲线.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/例子1.png","path":"image/强化学习/例子1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/公式1.png","path":"image/强化学习/公式1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/回顾DQN.png","path":"image/强化学习/回顾DQN.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/坑的解释.png","path":"image/强化学习/坑的解释.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/公式2.png","path":"image/强化学习/公式2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/学习路线.png","path":"image/强化学习/学习路线.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/扭曲的曲线.png","path":"image/强化学习/扭曲的曲线.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/复习MC.png","path":"image/强化学习/复习MC.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/数据加工厂.png","path":"image/强化学习/数据加工厂.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/普通DQN.png","path":"image/强化学习/普通DQN.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/更新公式.png","path":"image/强化学习/更新公式.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/正态分布.png","path":"image/强化学习/正态分布.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/理解DDPG1.png","path":"image/强化学习/理解DDPG1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/理解DDPG2.png","path":"image/强化学习/理解DDPG2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/用TD估计Q值.png","path":"image/强化学习/用TD估计Q值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/用下一个动作的Q代替V.png","path":"image/强化学习/用下一个动作的Q代替V.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/由G值算V值.png","path":"image/强化学习/由G值算V值.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/直观感受PG1.png","path":"image/强化学习/直观感受PG1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/直观感受PG3.png","path":"image/强化学习/直观感受PG3.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/直观感受PG2.png","path":"image/强化学习/直观感受PG2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/离散动作-策略分布.png","path":"image/强化学习/离散动作-策略分布.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略1.png","path":"image/强化学习/策略1.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略2.png","path":"image/强化学习/策略2.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略3.png","path":"image/强化学习/策略3.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略4.png","path":"image/强化学习/策略4.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略P和策略B.png","path":"image/强化学习/策略P和策略B.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/策略P和策略B更新示意图.png","path":"image/强化学习/策略P和策略B更新示意图.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/连续型概率分布示意图.png","path":"image/强化学习/连续型概率分布示意图.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/重要性权重表格.png","path":"image/强化学习/重要性权重表格.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/马尔科夫树.png","path":"image/强化学习/马尔科夫树.png","modified":1,"renderable":0},{"_id":"source/image/强化学习/马尔科夫链.png","path":"image/强化学习/马尔科夫链.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/DNS-process.png","path":"image/Computer-Basic/DNS-process.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/DNS-process2.png","path":"image/Computer-Basic/DNS-process2.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/URL-parts.png","path":"image/Computer-Basic/URL-parts.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/dns-overview.png","path":"image/Computer-Basic/dns-overview.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/tcp-waves-four-times.png","path":"image/Computer-Basic/tcp-waves-four-times.png","modified":1,"renderable":0},{"_id":"source/image/Computer-Basic/tcp-shakes-hands-three-times.png","path":"image/Computer-Basic/tcp-shakes-hands-three-times.png","modified":1,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img.png","path":"image/RNN-LSTM-GRU-GCN/img.png","modified":1,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_1.png","path":"image/RNN-LSTM-GRU-GCN/img_1.png","modified":1,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_2.png","path":"image/RNN-LSTM-GRU-GCN/img_2.png","modified":1,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_3.png","path":"image/RNN-LSTM-GRU-GCN/img_3.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img.png","path":"image/MARL/img.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_1.png","path":"image/MARL/img_1.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_10.png","path":"image/MARL/img_10.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_11.png","path":"image/MARL/img_11.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_12.png","path":"image/MARL/img_12.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_13.png","path":"image/MARL/img_13.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_14.png","path":"image/MARL/img_14.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_15.png","path":"image/MARL/img_15.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_16.png","path":"image/MARL/img_16.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_17.png","path":"image/MARL/img_17.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_18.png","path":"image/MARL/img_18.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_19.png","path":"image/MARL/img_19.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_20.png","path":"image/MARL/img_20.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_2.png","path":"image/MARL/img_2.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_22.png","path":"image/MARL/img_22.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_23.png","path":"image/MARL/img_23.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_21.png","path":"image/MARL/img_21.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_24.png","path":"image/MARL/img_24.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_25.png","path":"image/MARL/img_25.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_26.png","path":"image/MARL/img_26.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_27.png","path":"image/MARL/img_27.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_28.png","path":"image/MARL/img_28.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_29.png","path":"image/MARL/img_29.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_3.png","path":"image/MARL/img_3.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_30.png","path":"image/MARL/img_30.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_31.png","path":"image/MARL/img_31.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_32.png","path":"image/MARL/img_32.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_33.png","path":"image/MARL/img_33.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_34.png","path":"image/MARL/img_34.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_36.png","path":"image/MARL/img_36.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_35.png","path":"image/MARL/img_35.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_37.png","path":"image/MARL/img_37.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_38.png","path":"image/MARL/img_38.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_39.png","path":"image/MARL/img_39.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_4.png","path":"image/MARL/img_4.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_40.png","path":"image/MARL/img_40.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_41.png","path":"image/MARL/img_41.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_42.png","path":"image/MARL/img_42.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_43.png","path":"image/MARL/img_43.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_44.png","path":"image/MARL/img_44.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_45.png","path":"image/MARL/img_45.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_46.png","path":"image/MARL/img_46.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_47.png","path":"image/MARL/img_47.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_48.png","path":"image/MARL/img_48.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_49.png","path":"image/MARL/img_49.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_5.png","path":"image/MARL/img_5.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_50.png","path":"image/MARL/img_50.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_51.png","path":"image/MARL/img_51.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_52.png","path":"image/MARL/img_52.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_53.png","path":"image/MARL/img_53.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_54.png","path":"image/MARL/img_54.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_55.png","path":"image/MARL/img_55.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_56.png","path":"image/MARL/img_56.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_6.png","path":"image/MARL/img_6.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_7.png","path":"image/MARL/img_7.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_8.png","path":"image/MARL/img_8.png","modified":1,"renderable":0},{"_id":"source/image/MARL/img_9.png","path":"image/MARL/img_9.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"93894d35822db147684c8ca1511132fc38db0725","modified":1708432925823},{"_id":"source/_data/link.yml","hash":"f98992c0731559bcdc7fdc1af1f93b8dbae10649","modified":1694621161236},{"_id":"source/.DS_Store","hash":"4bea7c63a8123ff9b87f74cb1ef1c4388efd940c","modified":1695195358048},{"_id":"source/_posts/C-知识点.md","hash":"9e1d7b55cc407db8cc7d852a44ba014b71cb2ddf","modified":1719478706809},{"_id":"source/_posts/MARL.md","hash":"1b6cbb73246abe5709a446006d13539daa635f1d","modified":1719479157505},{"_id":"source/_posts/RNN-LSTM-GRU-GCN.md","hash":"d6807535b2a825b43e8163750137eaf82eab8e5c","modified":1719479209636},{"_id":"source/_posts/Python知识点.md","hash":"5e7e3860aff2d8e97be98ebc39e79d6cec7ca542","modified":1719478739169},{"_id":"source/_posts/hello-world.md","hash":"c4dabc86aa226113f500f9c79b3daab53cc7f19e","modified":1716813908177},{"_id":"source/_posts/k8s部署云笔记系统.md","hash":"31daab24a778ebf1f415e6f4bffb2ce4156a35e0","modified":1695395735500},{"_id":"source/_posts/云笔记系统扩容.md","hash":"087584c24cf1a57462f77d6463053fefb4d1ce82","modified":1707225167307},{"_id":"source/_posts/react技巧.md","hash":"5b404eaf82d603fe8e3975bc08976dbd56334f24","modified":1716813849685},{"_id":"source/_posts/强化学习.md","hash":"ccebfe756916da1294ca3e02e33e20e15b22a755","modified":1707225304696},{"_id":"source/_posts/前端-移动端面经.md","hash":"1766057fb3b49ce9c2f657460c9b354feca11ba5","modified":1718261648563},{"_id":"source/_posts/手撕相关.md","hash":"906628005e53874dd7b42da5496c6dbc2255fc34","modified":1719471399386},{"_id":"source/_posts/测开面经.md","hash":"44b88263e2ea161f860234caa8e37b0858a74bbb","modified":1719317941500},{"_id":"source/_posts/框架等面经.md","hash":"76161a70f7e491b3f31ad0dcb5f6015227475bbf","modified":1719124849446},{"_id":"source/_posts/面经汇总.md","hash":"c3a29c656890bbe059e4208c10dd1af11539697d","modified":1719477009611},{"_id":"source/link/index.md","hash":"7a17f4dc4cf4eae0b205dceccf4d76c81d226f58","modified":1693482301378},{"_id":"source/categories/index.md","hash":"8327a464fbe3f93cac6b89401e6315c63eba895f","modified":1693482273118},{"_id":"source/movies/index.md","hash":"9fdcdf109e4daff4f0a66d140a764c5ce2a55dd7","modified":1693482586713},{"_id":"source/music/index.md","hash":"35648eb9af8d7b9fe29bb63e7b321c9cda6fefa0","modified":1693482586718},{"_id":"source/_posts/计算机基础.md","hash":"0ac2a0fd082144e020e6c63ab7da8ea6bd960a41","modified":1719479455577},{"_id":"source/tags/index.md","hash":"e9b98a407b92523541efe47ea7d4ad42e157124e","modified":1694620980990},{"_id":"source/pictures/index.md","hash":"60581014aace73d200a0719c720bc5f5aba08708","modified":1707225802948},{"_id":"source/image/Database-Interview/13526879-3037b144ed09eb88.png","hash":"6a6ba5d6f15a0fdd546018e5cacbd3509e887c17","modified":1718540301438},{"_id":"source/image/Database-Interview/redis-event-handler.png","hash":"773474147812fb41eb9c5f823afdb81c5b155600","modified":1718952867213},{"_id":"source/image/Database-Interview/aof-work-process.png","hash":"acd44a08854c1e9958813211b765f46b01b4114d","modified":1718947518579},{"_id":"source/image/Hand-Torn-Code/20230615085141896.png","hash":"99e7f5236807d1aa6fa94d772989736077eca0cc","modified":1719325904863},{"_id":"source/image/k8s部署云笔记系统/4.png","hash":"ad4e697fc59a97823ecea4b0b1518e1b47ac554f","modified":1695135164081},{"_id":"source/image/k8s部署云笔记系统/1.png","hash":"cbbc86c9fa5786c5d9f3a2572f2404cd2e28343c","modified":1695134749835},{"_id":"source/image/云笔记系统扩容/backup.png","hash":"5f24217b2cedf48df437fd12b07a40714b3aef42","modified":1695193380118},{"_id":"source/image/云笔记系统扩容/add-labels.png","hash":"bda66f4607328559c6c30ffdb8c72a609440b6d2","modified":1695193699809},{"_id":"source/image/云笔记系统扩容/expand.png","hash":"b7b091f13ebee50e6be59d2d1c49cb69c459a87d","modified":1695194083229},{"_id":"source/image/云笔记系统扩容/pod-after-deleted.png","hash":"39cda3ef81cc34d9080163e85134bcad21d70521","modified":1695193632554},{"_id":"source/image/云笔记系统扩容/login.png","hash":"a004fc668d822d77284e1cceeee3c06e09501eec","modified":1695193348520},{"_id":"source/image/云笔记系统扩容/delete-pod.png","hash":"555dd5ad746957138bf6322fad5a9c016b1c6c8b","modified":1695193512011},{"_id":"source/image/云笔记系统扩容/pod-node.png","hash":"47f61d747d459f2e0a4728c77e01c6f14f287436","modified":1695193233122},{"_id":"source/image/云笔记系统扩容/pod-after-deploy.png","hash":"ddb7e4b717be6f48c7f7090c34b5d9fec746589d","modified":1695193845583},{"_id":"source/image/云笔记系统扩容/pod.png","hash":"77a844b176d7492e31868b9ba95bb9e468997de8","modified":1695193123630},{"_id":"source/image/云笔记系统扩容/setting.png","hash":"4ca95d8e457eba8f21ffe74743f00d479623f20f","modified":1695194013834},{"_id":"source/image/云笔记系统扩容/vmware.png","hash":"08bd99db55ee3786a77142de854b7d046410e100","modified":1695193301246},{"_id":"source/image/云笔记系统扩容/shutdown.png","hash":"e320600cd94d80e5b89012afdc90a4a8e2668d5d","modified":1695193961828},{"_id":"source/image/强化学习/DQN更新的是Q值.png","hash":"1513561ff6159ff47546cdd7e625840395a7a9ee","modified":1698396480795},{"_id":"source/image/强化学习/DDPG1.png","hash":"ec86ecd8427b549620d9421d9667205585b401f3","modified":1698651842765},{"_id":"source/image/强化学习/DQN公式.png","hash":"c5853cc32e2e37efa40de4b2a428f4dd7e7fd0ee","modified":1698131302833},{"_id":"source/image/强化学习/DQN.png","hash":"b6054f8acddb250924d87682e59743bfae1d4355","modified":1698130997432},{"_id":"source/image/强化学习/Magic(X).png","hash":"c4b28174d7b8d1ba5cfe66c80ca2f287193cfd35","modified":1698127119630},{"_id":"source/image/强化学习/Qlearning公式.png","hash":"3210173c653c2537862c9dc63ec95346e4295e13","modified":1698075767236},{"_id":"source/image/强化学习/SARSA.png","hash":"ea6aaf0c6b5dc7953045fb7700800ee3fdc700db","modified":1698075261938},{"_id":"source/image/强化学习/TD(0)与SARSA对比.png","hash":"ff6c716f5f1a06c11eae440995a09e310ce9b4bd","modified":1698075486710},{"_id":"source/image/强化学习/SARSA公式.png","hash":"40ca3c4957b16bc405d1da6ba263502c7e67e33a","modified":1698075438789},{"_id":"source/image/强化学习/TD(0)更新公式.png","hash":"70db3a258e3932edcdaa7ee9ccf8bc5e398fff89","modified":1698073783866},{"_id":"source/image/强化学习/V值转Q值1.png","hash":"a40ef07f53519b337bf0ff6b7ae97be0267b4c90","modified":1698067290092},{"_id":"source/image/强化学习/为什么不估算Q.png","hash":"bdd8c9609d188eccae505e62cd91653f97f44bff","modified":1698142267178},{"_id":"source/image/强化学习/二维曲线.png","hash":"79d6d24224cb080eebcbacf9ea3fc9150f0e1efa","modified":1698130005699},{"_id":"source/image/强化学习/公式1.png","hash":"40830fb8aa8c518414a8990c89574e7bc776afde","modified":1698066893279},{"_id":"source/image/强化学习/公式2.png","hash":"6581547a28f03a38bb1ff7f6795b54ce4b8ceb34","modified":1698067330761},{"_id":"source/image/强化学习/复习MC.png","hash":"58bb9a31d6fe9d72e328eb968c3f3efdb89d49b2","modified":1698139201629},{"_id":"source/image/强化学习/更新公式.png","hash":"b35143195b71b232c3dab90a86407538ba47319e","modified":1698072937063},{"_id":"source/image/强化学习/正态分布.png","hash":"3b4c5269bc41c9847e25e991a4fa9cddf4cba1d5","modified":1698393944004},{"_id":"source/image/强化学习/普通DQN.png","hash":"477f4e29663b44367dbd4beb42add37a4d9a9390","modified":1698137439974},{"_id":"source/image/强化学习/用下一个动作的Q代替V.png","hash":"8223f6e6e3013863bf48ca6af031129bb47ece6c","modified":1698074546181},{"_id":"source/image/强化学习/策略1.png","hash":"03e05721672d45f7d1cfcecc8dc1c49330b49080","modified":1698066048393},{"_id":"source/image/强化学习/策略2.png","hash":"6338e81e51fa44716e4bb5aa7153001f7002f37b","modified":1698066082805},{"_id":"source/image/强化学习/离散动作-策略分布.png","hash":"7ea3a2855155e0ba0d4340490c30e665520ef086","modified":1698393601833},{"_id":"source/image/强化学习/马尔科夫链.png","hash":"d54e77948355fb074bff4974edd3d4ee30756835","modified":1698075038617},{"_id":"source/image/强化学习/重要性权重表格.png","hash":"c636ebf159c7d5a8abdcb5324b0fb2e9dd7cbdb6","modified":1698649484352},{"_id":"source/image/Computer-Basic/URL-parts.png","hash":"7faa7be90cfaed2bc262f0b5b7eefd937b0ae875","modified":1719066447268},{"_id":"source/image/Computer-Basic/DNS-process2.png","hash":"6bad2527cb03c372e3ad4c022e5c5042a2c717c5","modified":1719123732476},{"_id":"source/image/Computer-Basic/DNS-process.png","hash":"c900bfef275a213578a809382501a804189942a9","modified":1719123726220},{"_id":"source/image/Computer-Basic/dns-overview.png","hash":"41f755a00f56710f1abf380c0f409a591a002569","modified":1719121733186},{"_id":"source/image/Computer-Basic/tcp-waves-four-times.png","hash":"fbb8f3303409a6a1be5e82ed0e711a34ab9d69ce","modified":1719143000020},{"_id":"source/image/Computer-Basic/tcp-shakes-hands-three-times.png","hash":"cdfc0638b8563d5f21e2b1b6d085ca19e501bcf6","modified":1719142993202},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_1.png","hash":"9c4d7fb94cf4d88efa0f1d57c50837b1e5aa113f","modified":1703162286448},{"_id":"source/image/MARL/img_23.png","hash":"6ca8cadc7d839d30cd37a6274948a1c4d906241d","modified":1699429510588},{"_id":"source/image/MARL/img_26.png","hash":"ffe5deb6ad0a6bc709308d4eb7b91e989540d106","modified":1699430679176},{"_id":"source/image/MARL/img_29.png","hash":"a6830f8337fb9a859d4a2c1b07a6a349dad993b8","modified":1699431955161},{"_id":"source/image/MARL/img_31.png","hash":"3a056d2f64c018aad380d09337d10960278e7afe","modified":1699432536093},{"_id":"source/image/MARL/img_36.png","hash":"6f6d264d3ccd0ec188cbaaa59d717e150361de42","modified":1699435203008},{"_id":"source/image/MARL/img_37.png","hash":"7fd6214a4f31c0c2174ea359fed9ffbd47135036","modified":1699435251687},{"_id":"source/image/MARL/img_38.png","hash":"ee0c90f890da5e81d41b0a26bd6c1ac2baf8a44f","modified":1699445855380},{"_id":"source/image/MARL/img_39.png","hash":"63c5ae9cec80b06bad00c35c5e515fb235ea032b","modified":1699445961327},{"_id":"source/image/MARL/img_4.png","hash":"3a15c0caf011c5d537c2ee6c81ba034271135ae5","modified":1699269298460},{"_id":"source/image/MARL/img_40.png","hash":"3f96da5e3b653c15749281c96391a6d5f7e4ef67","modified":1699445975883},{"_id":"source/image/MARL/img_44.png","hash":"e2577e0813fbf9cc4042287e4b7e3fdd8e041960","modified":1699447161097},{"_id":"source/image/MARL/img_43.png","hash":"f1abcb06f1c25a812a7c6ed23d247fe9fa0bfb3e","modified":1699447100650},{"_id":"source/image/MARL/img_42.png","hash":"76b07804b780b73e29f99bb4c603c9adb7ab4c42","modified":1699447044627},{"_id":"source/image/MARL/img_51.png","hash":"438c730fee36179be3196cfb65ac79509f378a0c","modified":1699520914234},{"_id":"source/image/MARL/img_54.png","hash":"44936f25b9fc28b501e9dec0042473a4ea443bb7","modified":1699521055616},{"_id":"source/image/MARL/img_52.png","hash":"d1e26fa21fcf1c9d14374d298de37459511c05f8","modified":1699520939564},{"_id":"source/image/MARL/img_56.png","hash":"e9462c7dbb24de3d1387d770a1bff9ebb0d6862a","modified":1699521123464},{"_id":"source/pictures/gallery_groups/genshin.md","hash":"c4ef1a50d83f665cb7aeda388515a3cd1c02174e","modified":1707225666368},{"_id":"source/pictures/gallery_groups/lol-kda.md","hash":"71adee600848e1aa15d90b8702421760f29e6127","modified":1707225758126},{"_id":"source/pictures/gallery_groups/wabobo.md","hash":"73164a4be798f334646a928e9850e16f3c755e64","modified":1703580802200},{"_id":"source/image/k8s部署云笔记系统/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1695135238989},{"_id":"source/image/云笔记系统扩容/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1695135238989},{"_id":"source/image/云笔记系统扩容/xftp.png","hash":"e3cb8d796d3576397b91f6168a106dcc215b85d6","modified":1695193439539},{"_id":"source/image/强化学习/A3C1.png","hash":"3005353326c11c8aebe3a637638f7be5f43a7825","modified":1698655179811},{"_id":"source/image/强化学习/AC算法.png","hash":"a1a024144b42ea965070692c87648dbc17640a5a","modified":1698143519699},{"_id":"source/image/强化学习/DuelDQN.png","hash":"e6a024745d81a004dbc9372754e0afcbea8500cd","modified":1698137595387},{"_id":"source/image/强化学习/DDPG2.png","hash":"e4df30b144f63e269dde8e2bd9fd613bc2a55551","modified":1698652051389},{"_id":"source/image/强化学习/DuelDQN网络架构.png","hash":"5faebac7e88f43d768347d2a44f5ea635aef5f93","modified":1698137812624},{"_id":"source/image/强化学习/Magic'(X).png","hash":"915a394ba63779fa45fb4ab337d35e9aa3656a1d","modified":1698127506423},{"_id":"source/image/强化学习/Qtable三维可视化.png","hash":"19e2457ff644019941c4e4889e271ae19851c8b7","modified":1698129622900},{"_id":"source/image/强化学习/Qlearning图解.png","hash":"99e1f7c3c09e8b8ff40013e5274197e84bbeccac","modified":1698075645794},{"_id":"source/image/强化学习/TD(0)图解.png","hash":"442c7c3185254c616b7dd581d3122c5b287d0609","modified":1698073834475},{"_id":"source/image/强化学习/TD3.png","hash":"f742b6d7ea08bddec59b241f4623e3a292fc8a99","modified":1698652474564},{"_id":"source/image/强化学习/TD-error.png","hash":"6cd354a8357bd9b351204db8ffbc86f14fa46388","modified":1698142535138},{"_id":"source/image/强化学习/V值转V值.png","hash":"04d61bd802407d82933d4fc3d48f655f82195df6","modified":1698067562607},{"_id":"source/image/强化学习/fix-Q-targets.png","hash":"28054b2d0b4c65f2e515366675d183072dc0670c","modified":1698132299748},{"_id":"source/image/强化学习/例子1.png","hash":"9f00eb53650a1323eed0c41405bc446f1edc0bc0","modified":1698065976437},{"_id":"source/image/强化学习/回顾DQN.png","hash":"3d6ef5df0f373b7e934dce35691e99cc2274e453","modified":1698651187817},{"_id":"source/image/强化学习/扭曲的曲线.png","hash":"1e785c5e507fcb8999cddd62724b194be6dbbae0","modified":1698129712910},{"_id":"source/image/强化学习/数据加工厂.png","hash":"0f6de0db66dba3926063c5e15801273c016eefe6","modified":1698127723223},{"_id":"source/image/强化学习/用TD估计Q值.png","hash":"4ae7ab1a840d2f66a6796920a561642608012404","modified":1698074262645},{"_id":"source/image/强化学习/直观感受PG3.png","hash":"76a2980409108c0cb4330cee7d3bf27d0c7ea8b5","modified":1698139536195},{"_id":"source/image/强化学习/直观感受PG1.png","hash":"abe569e686536c668a3f038c9a57052c6bcbc9d4","modified":1698139289526},{"_id":"source/image/强化学习/直观感受PG2.png","hash":"dc3b790d0138431bd36ca86d9cecb4c3724948d0","modified":1698139454702},{"_id":"source/image/强化学习/由G值算V值.png","hash":"4cd7c7aa68eba7d540f8d6ad3700f913b98b14d0","modified":1698068207405},{"_id":"source/image/强化学习/策略3.png","hash":"07c8459c5961babf996f8b4c16ab17b11c7f4c43","modified":1698068386281},{"_id":"source/image/强化学习/策略4.png","hash":"e7bfcbf76f24fe190ab7ed50a0f2085b22496cd6","modified":1698068425514},{"_id":"source/image/强化学习/策略P和策略B.png","hash":"2ea5ef3287f9d2a216c9d2abf8ddf49bf0ab8989","modified":1698395660821},{"_id":"source/image/强化学习/策略P和策略B更新示意图.png","hash":"61b7166aad0636090777247c4d4cff7d05177234","modified":1698396201316},{"_id":"source/image/RNN-LSTM-GRU-GCN/img.png","hash":"b5e3b81743830a235f98a3ed98888664ac1b8c01","modified":1703162192732},{"_id":"source/image/强化学习/连续型概率分布示意图.png","hash":"b3772e1cf96f08a1e289bc51c9c44750ce3c07ce","modified":1698393732421},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_3.png","hash":"3ccf1aae722c09b1b8ab22b5270e33b37eafcb55","modified":1703162506776},{"_id":"source/image/MARL/img_11.png","hash":"99d56908d7c6e6e00ee9cdebe963f253dd55f2c3","modified":1699275805693},{"_id":"source/image/MARL/img_1.png","hash":"6d1ebca900fd3c98a7382ea4cc52c9f9fb4bf6d6","modified":1699263064926},{"_id":"source/image/MARL/img.png","hash":"1a15c68b483bbe455c739a3e63d00f9bf517dd8f","modified":1699447688422},{"_id":"source/image/MARL/img_10.png","hash":"19a0f333d77505aa50e3ce3a4cf8dbdef15a9a08","modified":1699275769385},{"_id":"source/image/MARL/img_12.png","hash":"04e35d22666436dd7c937da31d6107769694cfe1","modified":1699276141729},{"_id":"source/image/MARL/img_14.png","hash":"a4270b1a9cc1d89e4ef81eb6288306bccd423293","modified":1699276381627},{"_id":"source/image/MARL/img_22.png","hash":"7ae93ca4e125194633a84b6623e892d306563147","modified":1699429410488},{"_id":"source/image/MARL/img_21.png","hash":"159c9d40e4c3b86ce74dad3627eea0925c05d3d8","modified":1699348867917},{"_id":"source/image/MARL/img_28.png","hash":"3331cbf3b0f5e02aad69ae549a2ca2992e4bc09b","modified":1699431810901},{"_id":"source/image/MARL/img_25.png","hash":"780801543fbad5a539da734659da4267e98f6226","modified":1699430563834},{"_id":"source/image/MARL/img_27.png","hash":"7f45efb57054b5c741adf1338e074b7cb72f4682","modified":1699431715584},{"_id":"source/image/MARL/img_32.png","hash":"d19088279eea2d8be2c91789bed07bb8b9157cf3","modified":1699433871624},{"_id":"source/image/MARL/img_33.png","hash":"1d5a7d97483e1b7f9b15babafa9edaecd16a1ae5","modified":1699434003076},{"_id":"source/image/MARL/img_3.png","hash":"3cd6383d45a693af460d791b6397edadefb54dd7","modified":1699264231549},{"_id":"source/image/MARL/img_34.png","hash":"c40b199cbfa1e48eeb2f48703d97612b10cf8ddd","modified":1699434698850},{"_id":"source/image/MARL/img_41.png","hash":"dc99ef84a23747bf1df39ffa75f65142833c50f2","modified":1699446131663},{"_id":"source/image/MARL/img_35.png","hash":"9c3f707a1e976d26367cef5b697a1e1713e9d30a","modified":1699434762807},{"_id":"source/image/MARL/img_46.png","hash":"075ab0887e92c81a785a7fd5cc529e02d5b827a2","modified":1699510865035},{"_id":"source/image/MARL/img_49.png","hash":"6f42c5de881e8e0e2f9205397492403608d305ea","modified":1699520732221},{"_id":"source/image/MARL/img_48.png","hash":"4a35a0f5f5d3db09ed2ffaed576384bd8b3a5b7f","modified":1699520709218},{"_id":"source/image/MARL/img_47.png","hash":"97bd6ad4c936907889397163b6b82f058bfeb8a5","modified":1699520646167},{"_id":"source/image/MARL/img_45.png","hash":"653093958a2cd8ec02eb57999be05dae36d22c78","modified":1699510828329},{"_id":"source/image/MARL/img_50.png","hash":"d2a92cb31f82e75f76a836677ba630056c8a76de","modified":1699520797975},{"_id":"source/image/MARL/img_53.png","hash":"e77f4991c711db44fc958f9ff5848b3d23fa2155","modified":1699520990504},{"_id":"source/image/MARL/img_55.png","hash":"2ae039d4635d2584df1aa70813fe0823ba64cd9a","modified":1699521090374},{"_id":"source/image/MARL/img_6.png","hash":"34f870290763316b68e4b0654992943d463b55ad","modified":1699272206553},{"_id":"source/image/MARL/img_9.png","hash":"5c9bd19962a9def0dc103325550201d406ebf1f9","modified":1699275717293},{"_id":"source/_posts/Java后端面经.md","hash":"0bf75eb72ed4f5ce4510541cfc09dfc8ba13adbf","modified":1719475267328},{"_id":"source/_posts/数据库.md","hash":"8123e64f2e8ff9d96b69093d8f7d9938b09444e3","modified":1719406087965},{"_id":"source/image/MARL/img_7.png","hash":"069091e238963421f52d381826bea91e89ca7fda","modified":1699272259493},{"_id":"source/image/Hand-Torn-Code/20230615085019913.png","hash":"a0a5aab5eeb45e0340de0cb73d1ab5968638209b","modified":1719325046946},{"_id":"source/image/k8s部署云笔记系统/2.png","hash":"eae90eb1b195c84430fe54a09819862bdd352a2f","modified":1695135048964},{"_id":"source/image/k8s部署云笔记系统/5.png","hash":"1432b61eb04256e0627913d0e3323eff178626b1","modified":1695135226787},{"_id":"source/image/云笔记系统扩容/backup-desktop.png","hash":"e6ec39385bcd11c4db8a3599509e3fc40f0bce83","modified":1695193567047},{"_id":"source/image/强化学习/A3C.png","hash":"137d1bfc646d4aec2c83a97b339b58bc59ff81fa","modified":1698655021495},{"_id":"source/image/强化学习/Q'估算Q 1.png","hash":"fe5352cc8507ff0748c0e3bb0d90acd8055753e8","modified":1698654037660},{"_id":"source/image/强化学习/G值的意义.png","hash":"68992cb8a2194c779748e9a34ffccfb4156d25df","modified":1698067941803},{"_id":"source/image/强化学习/Q=S+A表格.png","hash":"8277d01e72f923f488d82cda32befd415d203f40","modified":1698137333051},{"_id":"source/image/强化学习/Q'估计Q 2.png","hash":"d4b88893a5d0c2d81e9ca846e4129c53ef989d1b","modified":1698654081600},{"_id":"source/image/强化学习/Q值的定义.png","hash":"969a8e6a7d764e5f3366de0b46fd22d34f6c90a2","modified":1698066186438},{"_id":"source/image/强化学习/Q值转V值1.png","hash":"e168cf4b797ea342ea2cf45a15030424f594c7bf","modified":1698066824962},{"_id":"source/image/强化学习/TD(0).png","hash":"46c1b1d85bc500d3317fc98af24cc00407e4c3a2","modified":1698072622958},{"_id":"source/image/强化学习/V值的定义.png","hash":"9a95cb005f86b501901dbe8ecd63f4857ce45857","modified":1698065682845},{"_id":"source/image/强化学习/TD(N).png","hash":"cf4525e94a10fd8c40d5324f9a616edf0bb5e04d","modified":1698650138224},{"_id":"source/image/强化学习/两种理解方式.png","hash":"8ce85b9a7824394c5ff8eb685af6be073093b9d2","modified":1698070616781},{"_id":"source/image/强化学习/坑的解释.png","hash":"dc5251c2966f88383d3eaa7c92ac1961ab29b739","modified":1698074712932},{"_id":"source/image/强化学习/学习路线.png","hash":"34e7356e916c72ca4c778d116badc860ea1b8146","modified":1698063001345},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_2.png","hash":"0e93fa825353061329cc917c8f98cd30f4591370","modified":1703162400100},{"_id":"source/image/MARL/img_15.png","hash":"e8f55f26c5bed2b0e1f9926d71fb84480180790b","modified":1699276421196},{"_id":"source/image/MARL/img_13.png","hash":"439f1936f67cafa07c0e856eb64d49720f67637b","modified":1699276162593},{"_id":"source/image/MARL/img_16.png","hash":"66909131a240f3e754bc656e4303d21815e7d100","modified":1699276517300},{"_id":"source/image/MARL/img_17.png","hash":"f4a452e9775d395bfa369d54c14fca91c00b7a17","modified":1699276590851},{"_id":"source/image/MARL/img_20.png","hash":"0a3e3919dc0fa73b206df79f1c3c600d92defc2a","modified":1699276662379},{"_id":"source/image/MARL/img_2.png","hash":"ab12cb07c1c4e44b70dc35a0a925544ac2a6e115","modified":1699263964324},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1693301015683},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1693301015683},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1693301015694},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1693301015683},{"_id":"themes/butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1693301015683},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1693301015684},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1693301015684},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1693301015684},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1693301015684},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1693301015694},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1693301015684},{"_id":"themes/butterfly/.DS_Store","hash":"3c9af3e41223fcbc007179853fab8522390ad97a","modified":1697703842380},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1693301015684},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1693301015694},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1693301015694},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1693301015694},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1693301015694},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1693301015683},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1693301015694},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1693301015683},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1693301015682},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1693301015695},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1693301015683},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1693301015695},{"_id":"themes/butterfly/source/.DS_Store","hash":"2ff68457468623d62e1bfed5ae9879e1611800b6","modified":1697703837344},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1693301015683},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1693301015687},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1693301015695},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1693301015695},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1693301015696},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1693301015687},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1693301015696},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1693301015687},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1693301015696},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693301015701},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693301015701},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693301015702},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"b8e05ea08ef5548c37d8022e76403c77d62d5d1a","modified":1695209464605},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1693301015701},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1693301015701},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1693301015702},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1693301015695},{"_id":"themes/butterfly/source/img/wechat.JPG","hash":"6f338f11da8b9f568bde4a9255b4eefe29343c22","modified":1693472433708},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1693301015695},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1693301015685},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1693301015702},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1693301015703},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1693301015694},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1693301015694},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1693301015693},{"_id":"themes/butterfly/source/img/background/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1697817149228},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1693301015697},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1693301015697},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1693301015699},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1693301015699},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1693301015699},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1693301015699},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1693301015699},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1693301015700},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1693301015700},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1693301015700},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1693301015700},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1693301015701},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1693301015701},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1693301015702},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1693301015688},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1693301015702},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"00960bf483318e76ee4e1d90456f0e934959a8c5","modified":1695269671591},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1693301015692},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1693301015697},{"_id":"source/image/MARL/img_5.png","hash":"fa4cb933ca9f685f35f49d8262b4192a1955968b","modified":1699269359830},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1693301015693},{"_id":"source/image/MARL/img_8.png","hash":"803f9cd2e5768da860f76667e589d5b77a201340","modified":1699274324531},{"_id":"source/image/Hand-Torn-Code/20230615085001544.png","hash":"c41613a046d173efc1abce08d3dc3074518cd64c","modified":1719324826445},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1693301015697},{"_id":"source/image/k8s部署云笔记系统/3.png","hash":"85cfb5ad615d808491052523c665dd38c152b148","modified":1695135130751},{"_id":"source/image/强化学习/Q值转V值.png","hash":"2aff0b6882884466d6a727e42a9df19c6117b768","modified":1698066509888},{"_id":"source/image/强化学习/V值转Q值.png","hash":"2abc3e4c268f8a277ff1b1596d1fcd2d6f328d0a","modified":1698067186694},{"_id":"source/image/强化学习/理解DDPG1.png","hash":"31f1afbdee99c095a0939941bc0cf2f815c3a2e1","modified":1698651459850},{"_id":"source/image/强化学习/理解DDPG2.png","hash":"d96a5ac6aa63978a4bca742c5c13319cc5acdd8f","modified":1698651557112},{"_id":"source/image/强化学习/马尔科夫树.png","hash":"60c324eaffab2259fbdcb415a356f29088b182bd","modified":1698064272462},{"_id":"source/image/MARL/img_18.png","hash":"98e324069ae326b697ea9fcdec3bfe9c8246ad19","modified":1699276636497},{"_id":"source/image/MARL/img_19.png","hash":"6f2d0f1b01b1e55d1132aba9841ce70c908871ab","modified":1699276652495},{"_id":"themes/butterfly/source/img/alipay.JPG","hash":"242f28ac6b31ce2fae669f9b357f88b19a1a755a","modified":1693472403927},{"_id":"source/image/MARL/img_30.png","hash":"cd0054217d899963732fd6f7f7244fdf8ec27ee5","modified":1699432426918},{"_id":"themes/butterfly/source/js/Valine.min.js","hash":"c19fcca376470c5049873475548131c31e8a950b","modified":1695225699254},{"_id":"themes/butterfly/source/img/background/樱花2.jpg","hash":"858a926496f17529430ef9c1b56aa3a25abb97af","modified":1695213776091},{"_id":"source/image/Hand-Torn-Code/20230615083937874.png","hash":"efc34a6ccd222ccb4189275ecfb27013206bdf95","modified":1719318388973},{"_id":"themes/butterfly/source/img/assets/头像.JPG","hash":"2982b004f5f53918d2a6083056455bf3a479d60d","modified":1667716281000},{"_id":"themes/butterfly/source/img/background/樱花1.jpg","hash":"ffa38044c2b06e88c45468340c916e862b599b51","modified":1695213803321},{"_id":"source/image/云笔记系统扩容/pod-deploy.png","hash":"5d7087ce3dfa3e1c38cee56e75eef71845787de5","modified":1695193780237},{"_id":"source/image/MARL/img_24.png","hash":"db26640a9ac6de9c1e6f5a4c436f10a8598ecead","modified":1699430434980},{"_id":"source/image/k8s部署云笔记系统/可莉.png","hash":"19e482e216be26cf376cce9c2f26f95507cc8963","modified":1690225383971},{"_id":"public/search.xml","hash":"fc3b9d9fff914863d182bc3af52e02b3707b4e84","modified":1719479617975},{"_id":"public/about/index.html","hash":"1f8a64cfe27224052457ea6b75e41e7bf269ec54","modified":1719479617975},{"_id":"public/link/index.html","hash":"26246fb58e8d22900dfe0f60b68b9221bdf20442","modified":1719479617975},{"_id":"public/categories/index.html","hash":"f87d690d9c50e2e2659842345c98070c1adfec28","modified":1719479617975},{"_id":"public/music/index.html","hash":"34b11e83cf28e18b6b4e1f0c0a6e5b2431073405","modified":1719479617975},{"_id":"public/movies/index.html","hash":"53e33b3834ede96c55aea92daa1d7b8a33999446","modified":1719479617975},{"_id":"public/pictures/index.html","hash":"d3cb779a4480c3c5cb9fb6789d9a10ee46553aa9","modified":1719479617975},{"_id":"public/tags/index.html","hash":"d4fe792e87f53e20066aacb66cb3dc8621973ec1","modified":1719479617975},{"_id":"public/pictures/gallery_groups/genshin.html","hash":"4627077cd6fda337f2737fa642a1dca9ae33fdaa","modified":1719479617975},{"_id":"public/pictures/gallery_groups/lol-kda.html","hash":"aa903c05634da285c5984e4c0152597afa2ca48a","modified":1719479617975},{"_id":"public/pictures/gallery_groups/wabobo.html","hash":"3cbab72b0f957d1a524a98581d263d8387e1abaa","modified":1719479617975},{"_id":"public/posts/17776.html","hash":"43bc8690f6ca07330468f42eb468c01980e08024","modified":1719479617975},{"_id":"public/posts/17775.html","hash":"85d8d5e2d04de870e577a33fb808a543f7c8707f","modified":1719479617975},{"_id":"public/posts/17773.html","hash":"9830c3ebd3cb4c8c11833099b36c6f830b786b20","modified":1719479617975},{"_id":"public/posts/17772.html","hash":"0127dbaaecd42d9f503e22b2a2d8b682c9c74de1","modified":1719479617975},{"_id":"public/posts/17771.html","hash":"9ca17957732ece946b20b132b0dbb06f79a34d88","modified":1719479617975},{"_id":"public/posts/17769.html","hash":"75cbbece4429af0219a5f079843eea44db38b8f8","modified":1719479617975},{"_id":"public/posts/17770.html","hash":"acfae52d665a1e92d28447913d8292cb518fbe40","modified":1719479617975},{"_id":"public/posts/17768.html","hash":"4c1cba9f2178ca7fd06546ab9bd38b9bc0d5a90b","modified":1719479617975},{"_id":"public/posts/17767.html","hash":"18ddae45b9bed8dc95767724279f037da867f155","modified":1719479617975},{"_id":"public/posts/17766.html","hash":"0f38593a7c7a0bb3e11c6c7b2bb486097a464e3a","modified":1719479617975},{"_id":"public/posts/17765.html","hash":"4a0ec8839dd3f5105889b110089c10fc6389e30a","modified":1719479617975},{"_id":"public/posts/17763.html","hash":"d52989bc85739bfea55891183b375bfb022b51bc","modified":1719479617975},{"_id":"public/posts/17762.html","hash":"b22da7825f16a79f3452d598c3fb98f41c1629dd","modified":1719479617975},{"_id":"public/posts/56292.html","hash":"5c7068c145a21b1743eb4c5b3fd20d1037182075","modified":1719479617975},{"_id":"public/posts/36313.html","hash":"40dc8b9bd0317369b307d824eb3dd8cb255ec9d3","modified":1719479617975},{"_id":"public/posts/16330.html","hash":"55452f7172b94327a31a05b75fdadaaf27c73fe8","modified":1719479617975},{"_id":"public/posts/16107.html","hash":"35999462916874c5d590fe9ae538f60a98c79c59","modified":1719479617975},{"_id":"public/archives/index.html","hash":"f7c4369981e9208b1be9db16b171dad85de0395e","modified":1719479617975},{"_id":"public/archives/page/2/index.html","hash":"e3cf4919437966abe54feab138fc7bf46a4ff17b","modified":1719479617975},{"_id":"public/archives/2018/index.html","hash":"ac3314210615b9460e1d426545da8c8afadb0be8","modified":1719479617975},{"_id":"public/archives/2018/01/index.html","hash":"84a85f12fa84ec18b39224dbb23b53f864d39492","modified":1719479617975},{"_id":"public/archives/2023/index.html","hash":"3e9a2b2a219dc9fc94d966f0fcf5ed16298ed7e6","modified":1719479617975},{"_id":"public/archives/2023/09/index.html","hash":"a85cf62d2346e8ec4d8234c43a4de0add1111def","modified":1719479617975},{"_id":"public/archives/2023/10/index.html","hash":"409169993773a1289c443bbae51f33b9a2738c09","modified":1719479617975},{"_id":"public/archives/2023/12/index.html","hash":"989c2b3eb846c4e0b9d83554f23a61080ecfd39f","modified":1719479617975},{"_id":"public/archives/2024/index.html","hash":"bd129cd57282265a8da9e7679c99425f713bde74","modified":1719479617975},{"_id":"public/archives/2024/05/index.html","hash":"7711309f68dc4925150cb6c9524c399d7e60190d","modified":1719479617975},{"_id":"public/archives/2024/06/index.html","hash":"e012d7c365df1d88e6dbf69ade3d893826ef6f05","modified":1719479617975},{"_id":"public/categories/面经/index.html","hash":"cfff5dc0f90947c6b401e7489a851668a07cee75","modified":1719479617975},{"_id":"public/categories/强化学习/index.html","hash":"cc3b7bdd5cd0fd3e34280a4f49f48c6ac5137d01","modified":1719479617975},{"_id":"public/categories/算法/index.html","hash":"4da4e1293624b5e3c9686224bdfbeb6b56e411bf","modified":1719479617975},{"_id":"public/categories/hexo/index.html","hash":"1510573af7d2cf2bd70768df255a7687a21fdcc0","modified":1719479617975},{"_id":"public/categories/强化学习/多智能体强化学习/index.html","hash":"1b6072fdccd290cd8bdbddb8c7a49a85e0d36a38","modified":1719479617975},{"_id":"public/categories/react/index.html","hash":"5637d332c21bd21bfd101f9f09142b80e86fd0ac","modified":1719479617975},{"_id":"public/categories/Kubernetes/index.html","hash":"9d868067406d7e47e73990e0f1fbd792f958ae1e","modified":1719479617975},{"_id":"public/index.html","hash":"dcfb478a1e549e2343562ba764f66ab1a473610c","modified":1719479617975},{"_id":"public/page/2/index.html","hash":"4a81d4169945d26ed9c816fae8e93e72abc011d9","modified":1719479617975},{"_id":"public/tags/C/index.html","hash":"6f523e2e398a2305dd773cf077ec9b6e258a607d","modified":1719479617975},{"_id":"public/tags/面经/index.html","hash":"3887d3db6b44a6a12ff62465095c19b4dd0cb84e","modified":1719479617975},{"_id":"public/tags/强化学习/index.html","hash":"5ac4b7fbbd040c0d083e9a8684aa0920df1ed604","modified":1719479617975},{"_id":"public/tags/多智能体强化学习/index.html","hash":"687d17a31d55542a553bbc96461050facb3e5e21","modified":1719479617975},{"_id":"public/tags/算法/index.html","hash":"31f59896d421af6e925e1ec83b619d4cb3156f85","modified":1719479617975},{"_id":"public/tags/Java/index.html","hash":"c740131b1de10429ed96420c1d25b05c51512d3d","modified":1719479617975},{"_id":"public/tags/hexo/index.html","hash":"47f4e2ad5dcd737358470492e1f71afb2d466b87","modified":1719479617975},{"_id":"public/tags/教程/index.html","hash":"78c176060451c5e2f38f15ab376bba6cdb492258","modified":1719479617975},{"_id":"public/tags/移动端/index.html","hash":"6e294e14768333077efb1c55f5ad326ef4be2244","modified":1719479617975},{"_id":"public/tags/前端/index.html","hash":"e8d8491a98cd8d4548d91b00a6a5c693a0e14457","modified":1719479617975},{"_id":"public/tags/react/index.html","hash":"058c4ac067114e52674252cd8032cae756d10439","modified":1719479617975},{"_id":"public/tags/react-native/index.html","hash":"5f6344a140fe2edb1dd9ecd6c93416159cd6effb","modified":1719479617975},{"_id":"public/tags/k8s/index.html","hash":"1a9e70a0a20fab2f3266527ebda6e04d997c37b6","modified":1719479617975},{"_id":"public/tags/Kubernetes/index.html","hash":"26d3daaf9ead70626ff54eec92605d8fa5e22510","modified":1719479617975},{"_id":"public/tags/手撕技巧/index.html","hash":"adf54051daf3b88ec39b4e493fe50250a8baddc8","modified":1719479617975},{"_id":"public/tags/测试开发/index.html","hash":"8ea442ff3d351b854d5aa9ca4892250e04467f1c","modified":1719479617975},{"_id":"public/tags/框架/index.html","hash":"2c1cb32fce89b65de1bad229e5dc56d09287037d","modified":1719479617975},{"_id":"public/tags/数据库/index.html","hash":"dff7f7c87f0c1f7d771c90d8abec75a8eece75b0","modified":1719479617975},{"_id":"public/tags/SQL/index.html","hash":"eb312daf1f324e0e4d7a4992d1d099ca17eebfef","modified":1719479617975},{"_id":"public/tags/NoSQL/index.html","hash":"8cfc61a74717a593e9e98fa51102fff3f09e343f","modified":1719479617975},{"_id":"public/tags/MySQL/index.html","hash":"440f90b718bc484f4549aaad16d1767e77be0de2","modified":1719479617975},{"_id":"public/tags/mongodb/index.html","hash":"4ecb95028c92e39025d017c3dc105c1ec565f19a","modified":1719479617975},{"_id":"public/tags/Redis/index.html","hash":"49824000787c0879c50fa28128739822ce973bdc","modified":1719479617975},{"_id":"public/tags/计算机网络/index.html","hash":"83954cc5eeba447ddd1cdbbfcac442386cc0cb18","modified":1719479617975},{"_id":"public/tags/操作系统/index.html","hash":"f49ede68bc8d38b6ff4cb1ab138b8e48348d56aa","modified":1719479617975},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1719479617975},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1719479617975},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1719479617975},{"_id":"public/image/Database-Interview/13526879-3037b144ed09eb88.png","hash":"6a6ba5d6f15a0fdd546018e5cacbd3509e887c17","modified":1719479617975},{"_id":"public/img/wechat.JPG","hash":"6f338f11da8b9f568bde4a9255b4eefe29343c22","modified":1719479617975},{"_id":"public/image/Database-Interview/aof-work-process.png","hash":"acd44a08854c1e9958813211b765f46b01b4114d","modified":1719479617975},{"_id":"public/image/Database-Interview/redis-event-handler.png","hash":"773474147812fb41eb9c5f823afdb81c5b155600","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/1.png","hash":"cbbc86c9fa5786c5d9f3a2572f2404cd2e28343c","modified":1719479617975},{"_id":"public/image/Hand-Torn-Code/20230615085141896.png","hash":"99e7f5236807d1aa6fa94d772989736077eca0cc","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/4.png","hash":"ad4e697fc59a97823ecea4b0b1518e1b47ac554f","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/add-labels.png","hash":"bda66f4607328559c6c30ffdb8c72a609440b6d2","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/backup.png","hash":"5f24217b2cedf48df437fd12b07a40714b3aef42","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/delete-pod.png","hash":"555dd5ad746957138bf6322fad5a9c016b1c6c8b","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/expand.png","hash":"b7b091f13ebee50e6be59d2d1c49cb69c459a87d","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/pod-after-deleted.png","hash":"39cda3ef81cc34d9080163e85134bcad21d70521","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/pod-after-deploy.png","hash":"ddb7e4b717be6f48c7f7090c34b5d9fec746589d","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/pod-node.png","hash":"47f61d747d459f2e0a4728c77e01c6f14f287436","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/login.png","hash":"a004fc668d822d77284e1cceeee3c06e09501eec","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/pod.png","hash":"77a844b176d7492e31868b9ba95bb9e468997de8","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/setting.png","hash":"4ca95d8e457eba8f21ffe74743f00d479623f20f","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/shutdown.png","hash":"e320600cd94d80e5b89012afdc90a4a8e2668d5d","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/vmware.png","hash":"08bd99db55ee3786a77142de854b7d046410e100","modified":1719479617975},{"_id":"public/image/强化学习/DQN.png","hash":"b6054f8acddb250924d87682e59743bfae1d4355","modified":1719479617975},{"_id":"public/image/强化学习/DDPG1.png","hash":"ec86ecd8427b549620d9421d9667205585b401f3","modified":1719479617975},{"_id":"public/image/强化学习/DQN公式.png","hash":"c5853cc32e2e37efa40de4b2a428f4dd7e7fd0ee","modified":1719479617975},{"_id":"public/image/强化学习/DQN更新的是Q值.png","hash":"1513561ff6159ff47546cdd7e625840395a7a9ee","modified":1719479617975},{"_id":"public/image/强化学习/Magic(X).png","hash":"c4b28174d7b8d1ba5cfe66c80ca2f287193cfd35","modified":1719479617975},{"_id":"public/image/强化学习/Qlearning公式.png","hash":"3210173c653c2537862c9dc63ec95346e4295e13","modified":1719479617975},{"_id":"public/image/强化学习/SARSA.png","hash":"ea6aaf0c6b5dc7953045fb7700800ee3fdc700db","modified":1719479617975},{"_id":"public/image/强化学习/SARSA公式.png","hash":"40ca3c4957b16bc405d1da6ba263502c7e67e33a","modified":1719479617975},{"_id":"public/image/强化学习/TD(0)与SARSA对比.png","hash":"ff6c716f5f1a06c11eae440995a09e310ce9b4bd","modified":1719479617975},{"_id":"public/image/强化学习/TD(0)更新公式.png","hash":"70db3a258e3932edcdaa7ee9ccf8bc5e398fff89","modified":1719479617975},{"_id":"public/image/强化学习/V值转Q值1.png","hash":"a40ef07f53519b337bf0ff6b7ae97be0267b4c90","modified":1719479617975},{"_id":"public/image/强化学习/为什么不估算Q.png","hash":"bdd8c9609d188eccae505e62cd91653f97f44bff","modified":1719479617975},{"_id":"public/image/强化学习/公式1.png","hash":"40830fb8aa8c518414a8990c89574e7bc776afde","modified":1719479617975},{"_id":"public/image/强化学习/二维曲线.png","hash":"79d6d24224cb080eebcbacf9ea3fc9150f0e1efa","modified":1719479617975},{"_id":"public/image/强化学习/公式2.png","hash":"6581547a28f03a38bb1ff7f6795b54ce4b8ceb34","modified":1719479617975},{"_id":"public/image/强化学习/复习MC.png","hash":"58bb9a31d6fe9d72e328eb968c3f3efdb89d49b2","modified":1719479617975},{"_id":"public/image/强化学习/普通DQN.png","hash":"477f4e29663b44367dbd4beb42add37a4d9a9390","modified":1719479617975},{"_id":"public/image/强化学习/正态分布.png","hash":"3b4c5269bc41c9847e25e991a4fa9cddf4cba1d5","modified":1719479617975},{"_id":"public/image/强化学习/更新公式.png","hash":"b35143195b71b232c3dab90a86407538ba47319e","modified":1719479617975},{"_id":"public/image/强化学习/用下一个动作的Q代替V.png","hash":"8223f6e6e3013863bf48ca6af031129bb47ece6c","modified":1719479617975},{"_id":"public/image/强化学习/策略2.png","hash":"6338e81e51fa44716e4bb5aa7153001f7002f37b","modified":1719479617975},{"_id":"public/image/强化学习/策略1.png","hash":"03e05721672d45f7d1cfcecc8dc1c49330b49080","modified":1719479617975},{"_id":"public/image/强化学习/离散动作-策略分布.png","hash":"7ea3a2855155e0ba0d4340490c30e665520ef086","modified":1719479617975},{"_id":"public/image/强化学习/重要性权重表格.png","hash":"c636ebf159c7d5a8abdcb5324b0fb2e9dd7cbdb6","modified":1719479617975},{"_id":"public/image/强化学习/马尔科夫链.png","hash":"d54e77948355fb074bff4974edd3d4ee30756835","modified":1719479617975},{"_id":"public/image/Computer-Basic/DNS-process.png","hash":"c900bfef275a213578a809382501a804189942a9","modified":1719479617975},{"_id":"public/image/Computer-Basic/dns-overview.png","hash":"41f755a00f56710f1abf380c0f409a591a002569","modified":1719479617975},{"_id":"public/image/Computer-Basic/tcp-waves-four-times.png","hash":"fbb8f3303409a6a1be5e82ed0e711a34ab9d69ce","modified":1719479617975},{"_id":"public/image/Computer-Basic/DNS-process2.png","hash":"6bad2527cb03c372e3ad4c022e5c5042a2c717c5","modified":1719479617975},{"_id":"public/image/Computer-Basic/tcp-shakes-hands-three-times.png","hash":"cdfc0638b8563d5f21e2b1b6d085ca19e501bcf6","modified":1719479617975},{"_id":"public/image/Computer-Basic/URL-parts.png","hash":"7faa7be90cfaed2bc262f0b5b7eefd937b0ae875","modified":1719479617975},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_1.png","hash":"9c4d7fb94cf4d88efa0f1d57c50837b1e5aa113f","modified":1719479617975},{"_id":"public/image/MARL/img_23.png","hash":"6ca8cadc7d839d30cd37a6274948a1c4d906241d","modified":1719479617975},{"_id":"public/image/MARL/img_26.png","hash":"ffe5deb6ad0a6bc709308d4eb7b91e989540d106","modified":1719479617975},{"_id":"public/image/MARL/img_29.png","hash":"a6830f8337fb9a859d4a2c1b07a6a349dad993b8","modified":1719479617975},{"_id":"public/image/MARL/img_31.png","hash":"3a056d2f64c018aad380d09337d10960278e7afe","modified":1719479617975},{"_id":"public/image/MARL/img_38.png","hash":"ee0c90f890da5e81d41b0a26bd6c1ac2baf8a44f","modified":1719479617975},{"_id":"public/image/MARL/img_37.png","hash":"7fd6214a4f31c0c2174ea359fed9ffbd47135036","modified":1719479617975},{"_id":"public/image/MARL/img_39.png","hash":"63c5ae9cec80b06bad00c35c5e515fb235ea032b","modified":1719479617975},{"_id":"public/image/MARL/img_36.png","hash":"6f6d264d3ccd0ec188cbaaa59d717e150361de42","modified":1719479617975},{"_id":"public/image/MARL/img_4.png","hash":"3a15c0caf011c5d537c2ee6c81ba034271135ae5","modified":1719479617975},{"_id":"public/image/MARL/img_40.png","hash":"3f96da5e3b653c15749281c96391a6d5f7e4ef67","modified":1719479617975},{"_id":"public/image/MARL/img_42.png","hash":"76b07804b780b73e29f99bb4c603c9adb7ab4c42","modified":1719479617975},{"_id":"public/image/MARL/img_44.png","hash":"e2577e0813fbf9cc4042287e4b7e3fdd8e041960","modified":1719479617975},{"_id":"public/image/MARL/img_43.png","hash":"f1abcb06f1c25a812a7c6ed23d247fe9fa0bfb3e","modified":1719479617975},{"_id":"public/image/MARL/img_52.png","hash":"d1e26fa21fcf1c9d14374d298de37459511c05f8","modified":1719479617975},{"_id":"public/image/MARL/img_51.png","hash":"438c730fee36179be3196cfb65ac79509f378a0c","modified":1719479617975},{"_id":"public/image/MARL/img_54.png","hash":"44936f25b9fc28b501e9dec0042473a4ea443bb7","modified":1719479617975},{"_id":"public/image/MARL/img_56.png","hash":"e9462c7dbb24de3d1387d770a1bff9ebb0d6862a","modified":1719479617975},{"_id":"public/img/alipay.JPG","hash":"242f28ac6b31ce2fae669f9b357f88b19a1a755a","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/xftp.png","hash":"e3cb8d796d3576397b91f6168a106dcc215b85d6","modified":1719479617975},{"_id":"public/image/强化学习/A3C1.png","hash":"3005353326c11c8aebe3a637638f7be5f43a7825","modified":1719479617975},{"_id":"public/image/强化学习/AC算法.png","hash":"a1a024144b42ea965070692c87648dbc17640a5a","modified":1719479617975},{"_id":"public/image/强化学习/DDPG2.png","hash":"e4df30b144f63e269dde8e2bd9fd613bc2a55551","modified":1719479617975},{"_id":"public/image/强化学习/DuelDQN.png","hash":"e6a024745d81a004dbc9372754e0afcbea8500cd","modified":1719479617975},{"_id":"public/image/强化学习/Magic'(X).png","hash":"915a394ba63779fa45fb4ab337d35e9aa3656a1d","modified":1719479617975},{"_id":"public/image/强化学习/DuelDQN网络架构.png","hash":"5faebac7e88f43d768347d2a44f5ea635aef5f93","modified":1719479617975},{"_id":"public/image/强化学习/Qlearning图解.png","hash":"99e1f7c3c09e8b8ff40013e5274197e84bbeccac","modified":1719479617975},{"_id":"public/image/强化学习/Qtable三维可视化.png","hash":"19e2457ff644019941c4e4889e271ae19851c8b7","modified":1719479617975},{"_id":"public/image/强化学习/TD3.png","hash":"f742b6d7ea08bddec59b241f4623e3a292fc8a99","modified":1719479617975},{"_id":"public/image/强化学习/TD(0)图解.png","hash":"442c7c3185254c616b7dd581d3122c5b287d0609","modified":1719479617975},{"_id":"public/image/强化学习/TD-error.png","hash":"6cd354a8357bd9b351204db8ffbc86f14fa46388","modified":1719479617975},{"_id":"public/image/强化学习/V值转V值.png","hash":"04d61bd802407d82933d4fc3d48f655f82195df6","modified":1719479617975},{"_id":"public/image/强化学习/fix-Q-targets.png","hash":"28054b2d0b4c65f2e515366675d183072dc0670c","modified":1719479617975},{"_id":"public/image/强化学习/回顾DQN.png","hash":"3d6ef5df0f373b7e934dce35691e99cc2274e453","modified":1719479617975},{"_id":"public/image/强化学习/例子1.png","hash":"9f00eb53650a1323eed0c41405bc446f1edc0bc0","modified":1719479617975},{"_id":"public/image/强化学习/扭曲的曲线.png","hash":"1e785c5e507fcb8999cddd62724b194be6dbbae0","modified":1719479617975},{"_id":"public/image/强化学习/数据加工厂.png","hash":"0f6de0db66dba3926063c5e15801273c016eefe6","modified":1719479617975},{"_id":"public/image/强化学习/由G值算V值.png","hash":"4cd7c7aa68eba7d540f8d6ad3700f913b98b14d0","modified":1719479617975},{"_id":"public/image/强化学习/直观感受PG1.png","hash":"abe569e686536c668a3f038c9a57052c6bcbc9d4","modified":1719479617975},{"_id":"public/image/强化学习/用TD估计Q值.png","hash":"4ae7ab1a840d2f66a6796920a561642608012404","modified":1719479617975},{"_id":"public/image/强化学习/直观感受PG3.png","hash":"76a2980409108c0cb4330cee7d3bf27d0c7ea8b5","modified":1719479617975},{"_id":"public/image/强化学习/直观感受PG2.png","hash":"dc3b790d0138431bd36ca86d9cecb4c3724948d0","modified":1719479617975},{"_id":"public/image/强化学习/策略4.png","hash":"e7bfcbf76f24fe190ab7ed50a0f2085b22496cd6","modified":1719479617975},{"_id":"public/image/强化学习/策略3.png","hash":"07c8459c5961babf996f8b4c16ab17b11c7f4c43","modified":1719479617975},{"_id":"public/image/强化学习/连续型概率分布示意图.png","hash":"b3772e1cf96f08a1e289bc51c9c44750ce3c07ce","modified":1719479617975},{"_id":"public/image/强化学习/策略P和策略B.png","hash":"2ea5ef3287f9d2a216c9d2abf8ddf49bf0ab8989","modified":1719479617975},{"_id":"public/image/强化学习/策略P和策略B更新示意图.png","hash":"61b7166aad0636090777247c4d4cff7d05177234","modified":1719479617975},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_3.png","hash":"3ccf1aae722c09b1b8ab22b5270e33b37eafcb55","modified":1719479617975},{"_id":"public/image/RNN-LSTM-GRU-GCN/img.png","hash":"b5e3b81743830a235f98a3ed98888664ac1b8c01","modified":1719479617975},{"_id":"public/image/MARL/img_1.png","hash":"6d1ebca900fd3c98a7382ea4cc52c9f9fb4bf6d6","modified":1719479617975},{"_id":"public/image/MARL/img.png","hash":"1a15c68b483bbe455c739a3e63d00f9bf517dd8f","modified":1719479617975},{"_id":"public/image/MARL/img_12.png","hash":"04e35d22666436dd7c937da31d6107769694cfe1","modified":1719479617975},{"_id":"public/image/MARL/img_11.png","hash":"99d56908d7c6e6e00ee9cdebe963f253dd55f2c3","modified":1719479617975},{"_id":"public/image/MARL/img_14.png","hash":"a4270b1a9cc1d89e4ef81eb6288306bccd423293","modified":1719479617975},{"_id":"public/image/MARL/img_10.png","hash":"19a0f333d77505aa50e3ce3a4cf8dbdef15a9a08","modified":1719479617975},{"_id":"public/image/MARL/img_22.png","hash":"7ae93ca4e125194633a84b6623e892d306563147","modified":1719479617975},{"_id":"public/image/MARL/img_21.png","hash":"159c9d40e4c3b86ce74dad3627eea0925c05d3d8","modified":1719479617975},{"_id":"public/image/MARL/img_25.png","hash":"780801543fbad5a539da734659da4267e98f6226","modified":1719479617975},{"_id":"public/image/MARL/img_28.png","hash":"3331cbf3b0f5e02aad69ae549a2ca2992e4bc09b","modified":1719479617975},{"_id":"public/image/MARL/img_27.png","hash":"7f45efb57054b5c741adf1338e074b7cb72f4682","modified":1719479617975},{"_id":"public/image/MARL/img_32.png","hash":"d19088279eea2d8be2c91789bed07bb8b9157cf3","modified":1719479617975},{"_id":"public/image/MARL/img_33.png","hash":"1d5a7d97483e1b7f9b15babafa9edaecd16a1ae5","modified":1719479617975},{"_id":"public/image/MARL/img_3.png","hash":"3cd6383d45a693af460d791b6397edadefb54dd7","modified":1719479617975},{"_id":"public/image/MARL/img_34.png","hash":"c40b199cbfa1e48eeb2f48703d97612b10cf8ddd","modified":1719479617975},{"_id":"public/image/MARL/img_35.png","hash":"9c3f707a1e976d26367cef5b697a1e1713e9d30a","modified":1719479617975},{"_id":"public/image/MARL/img_41.png","hash":"dc99ef84a23747bf1df39ffa75f65142833c50f2","modified":1719479617975},{"_id":"public/image/MARL/img_45.png","hash":"653093958a2cd8ec02eb57999be05dae36d22c78","modified":1719479617975},{"_id":"public/image/MARL/img_46.png","hash":"075ab0887e92c81a785a7fd5cc529e02d5b827a2","modified":1719479617975},{"_id":"public/image/MARL/img_47.png","hash":"97bd6ad4c936907889397163b6b82f058bfeb8a5","modified":1719479617975},{"_id":"public/image/MARL/img_48.png","hash":"4a35a0f5f5d3db09ed2ffaed576384bd8b3a5b7f","modified":1719479617975},{"_id":"public/image/MARL/img_50.png","hash":"d2a92cb31f82e75f76a836677ba630056c8a76de","modified":1719479617975},{"_id":"public/image/MARL/img_49.png","hash":"6f42c5de881e8e0e2f9205397492403608d305ea","modified":1719479617975},{"_id":"public/image/MARL/img_53.png","hash":"e77f4991c711db44fc958f9ff5848b3d23fa2155","modified":1719479617975},{"_id":"public/image/MARL/img_6.png","hash":"34f870290763316b68e4b0654992943d463b55ad","modified":1719479617975},{"_id":"public/image/MARL/img_55.png","hash":"2ae039d4635d2584df1aa70813fe0823ba64cd9a","modified":1719479617975},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719479617975},{"_id":"public/css/index.css","hash":"7ec09b47c52077cb7a30b4c07512373d5223cdb9","modified":1719479617975},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1719479617975},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1719479617975},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1719479617975},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1719479617975},{"_id":"public/js/Valine.min.js","hash":"c19fcca376470c5049873475548131c31e8a950b","modified":1719479617975},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1719479617975},{"_id":"public/image/MARL/img_7.png","hash":"069091e238963421f52d381826bea91e89ca7fda","modified":1719479617975},{"_id":"public/image/MARL/img_9.png","hash":"5c9bd19962a9def0dc103325550201d406ebf1f9","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/2.png","hash":"eae90eb1b195c84430fe54a09819862bdd352a2f","modified":1719479617975},{"_id":"public/image/Hand-Torn-Code/20230615085019913.png","hash":"a0a5aab5eeb45e0340de0cb73d1ab5968638209b","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/5.png","hash":"1432b61eb04256e0627913d0e3323eff178626b1","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/backup-desktop.png","hash":"e6ec39385bcd11c4db8a3599509e3fc40f0bce83","modified":1719479617975},{"_id":"public/image/强化学习/A3C.png","hash":"137d1bfc646d4aec2c83a97b339b58bc59ff81fa","modified":1719479617975},{"_id":"public/image/强化学习/Q'估算Q 1.png","hash":"fe5352cc8507ff0748c0e3bb0d90acd8055753e8","modified":1719479617975},{"_id":"public/image/强化学习/Q'估计Q 2.png","hash":"d4b88893a5d0c2d81e9ca846e4129c53ef989d1b","modified":1719479617975},{"_id":"public/image/强化学习/G值的意义.png","hash":"68992cb8a2194c779748e9a34ffccfb4156d25df","modified":1719479617975},{"_id":"public/image/强化学习/Q=S+A表格.png","hash":"8277d01e72f923f488d82cda32befd415d203f40","modified":1719479617975},{"_id":"public/image/强化学习/Q值的定义.png","hash":"969a8e6a7d764e5f3366de0b46fd22d34f6c90a2","modified":1719479617975},{"_id":"public/image/强化学习/Q值转V值1.png","hash":"e168cf4b797ea342ea2cf45a15030424f594c7bf","modified":1719479617975},{"_id":"public/image/强化学习/TD(0).png","hash":"46c1b1d85bc500d3317fc98af24cc00407e4c3a2","modified":1719479617975},{"_id":"public/image/强化学习/TD(N).png","hash":"cf4525e94a10fd8c40d5324f9a616edf0bb5e04d","modified":1719479617975},{"_id":"public/image/强化学习/V值的定义.png","hash":"9a95cb005f86b501901dbe8ecd63f4857ce45857","modified":1719479617975},{"_id":"public/image/强化学习/两种理解方式.png","hash":"8ce85b9a7824394c5ff8eb685af6be073093b9d2","modified":1719479617975},{"_id":"public/image/强化学习/坑的解释.png","hash":"dc5251c2966f88383d3eaa7c92ac1961ab29b739","modified":1719479617975},{"_id":"public/image/强化学习/学习路线.png","hash":"34e7356e916c72ca4c778d116badc860ea1b8146","modified":1719479617975},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_2.png","hash":"0e93fa825353061329cc917c8f98cd30f4591370","modified":1719479617975},{"_id":"public/image/MARL/img_13.png","hash":"439f1936f67cafa07c0e856eb64d49720f67637b","modified":1719479617975},{"_id":"public/image/MARL/img_15.png","hash":"e8f55f26c5bed2b0e1f9926d71fb84480180790b","modified":1719479617975},{"_id":"public/image/MARL/img_16.png","hash":"66909131a240f3e754bc656e4303d21815e7d100","modified":1719479617975},{"_id":"public/image/MARL/img_17.png","hash":"f4a452e9775d395bfa369d54c14fca91c00b7a17","modified":1719479617975},{"_id":"public/image/MARL/img_2.png","hash":"ab12cb07c1c4e44b70dc35a0a925544ac2a6e115","modified":1719479617975},{"_id":"public/image/MARL/img_20.png","hash":"0a3e3919dc0fa73b206df79f1c3c600d92defc2a","modified":1719479617975},{"_id":"public/image/MARL/img_5.png","hash":"fa4cb933ca9f685f35f49d8262b4192a1955968b","modified":1719479617975},{"_id":"public/image/MARL/img_8.png","hash":"803f9cd2e5768da860f76667e589d5b77a201340","modified":1719479617975},{"_id":"public/img/background/樱花2.jpg","hash":"858a926496f17529430ef9c1b56aa3a25abb97af","modified":1719479617975},{"_id":"public/image/Hand-Torn-Code/20230615085001544.png","hash":"c41613a046d173efc1abce08d3dc3074518cd64c","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/3.png","hash":"85cfb5ad615d808491052523c665dd38c152b148","modified":1719479617975},{"_id":"public/image/强化学习/Q值转V值.png","hash":"2aff0b6882884466d6a727e42a9df19c6117b768","modified":1719479617975},{"_id":"public/image/强化学习/V值转Q值.png","hash":"2abc3e4c268f8a277ff1b1596d1fcd2d6f328d0a","modified":1719479617975},{"_id":"public/image/强化学习/理解DDPG1.png","hash":"31f1afbdee99c095a0939941bc0cf2f815c3a2e1","modified":1719479617975},{"_id":"public/image/强化学习/理解DDPG2.png","hash":"d96a5ac6aa63978a4bca742c5c13319cc5acdd8f","modified":1719479617975},{"_id":"public/image/强化学习/马尔科夫树.png","hash":"60c324eaffab2259fbdcb415a356f29088b182bd","modified":1719479617975},{"_id":"public/image/MARL/img_18.png","hash":"98e324069ae326b697ea9fcdec3bfe9c8246ad19","modified":1719479617975},{"_id":"public/image/MARL/img_19.png","hash":"6f2d0f1b01b1e55d1132aba9841ce70c908871ab","modified":1719479617975},{"_id":"public/img/assets/头像.JPG","hash":"2982b004f5f53918d2a6083056455bf3a479d60d","modified":1719479617975},{"_id":"public/image/MARL/img_30.png","hash":"cd0054217d899963732fd6f7f7244fdf8ec27ee5","modified":1719479617975},{"_id":"public/img/background/樱花1.jpg","hash":"ffa38044c2b06e88c45468340c916e862b599b51","modified":1719479617975},{"_id":"public/image/Hand-Torn-Code/20230615083937874.png","hash":"efc34a6ccd222ccb4189275ecfb27013206bdf95","modified":1719479617975},{"_id":"public/image/云笔记系统扩容/pod-deploy.png","hash":"5d7087ce3dfa3e1c38cee56e75eef71845787de5","modified":1719479617975},{"_id":"public/image/MARL/img_24.png","hash":"db26640a9ac6de9c1e6f5a4c436f10a8598ecead","modified":1719479617975},{"_id":"public/image/k8s部署云笔记系统/可莉.png","hash":"19e482e216be26cf376cce9c2f26f95507cc8963","modified":1719479617975}],"Category":[{"name":"面经","_id":"clxx1rq1l0004r7gnam6z9jxa"},{"name":"强化学习","_id":"clxx1rq1o000cr7gner4566tt"},{"name":"算法","_id":"clxx1rq1q000sr7gnb8w41atk"},{"name":"hexo","_id":"clxx1rq1r000xr7gn49y0affa"},{"name":"多智能体强化学习","parent":"clxx1rq1o000cr7gner4566tt","_id":"clxx1rq1r0010r7gn74f98acs"},{"name":"react","_id":"clxx1rq1s0016r7gn1nzx8al7"},{"name":"Kubernetes","_id":"clxx1rq1s001br7gn3t1mhjmr"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"about","type":"about","description":"相册","top_img":null,"abbrlink":0,"date":"2023-08-31T11:46:34.000Z","updated":"2023-10-20T14:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 闲来无事，搭建一个静态博客网站玩一玩。。。\n","source":"about/index.md","raw":"---\ntitle: about\ntype: \"about\"\ndescription: 相册\ntop_img:\nabbrlink: 00000\ndate: 2023-08-31 19:46:34\nupdated: 2023-10-20 22:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 闲来无事，搭建一个静态博客网站玩一玩。。。\n","path":"about/index.html","layout":"page","_id":"clxx1rq1f0000r7gn8jlq4rcr","content":"<blockquote>\n<p>闲来无事，搭建一个静态博客网站玩一玩。。。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>闲来无事，搭建一个静态博客网站玩一玩。。。</p>\n</blockquote>\n"},{"title":"categories","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---\n","updated":"2023-08-31T11:44:33.118Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clxx1rq1k0002r7gn82s92aw6","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2023-08-31T11:44:43.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-08-31 19:44:43\ntype: \"link\"\n---\n","updated":"2023-08-31T11:45:01.378Z","path":"link/index.html","comments":1,"layout":"page","_id":"clxx1rq1m0006r7gn4bir7npg","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"music","date":"2023-08-31T11:48:40.000Z","type":"music","_content":"","source":"music/index.md","raw":"---\ntitle: music\ndate: 2023-08-31 19:48:40\ntype: \"music\"\n---\n","updated":"2023-08-31T11:49:46.718Z","path":"music/index.html","comments":1,"layout":"page","_id":"clxx1rq1n0008r7gn0nin18yi","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"movies","date":"2023-08-31T11:48:52.000Z","type":"movies","_content":"","source":"movies/index.md","raw":"---\ntitle: movies\ndate: 2023-08-31 19:48:52\ntype: \"movies\"\n---\n","updated":"2023-08-31T11:49:46.713Z","path":"movies/index.html","comments":1,"layout":"page","_id":"clxx1rq1n000ar7gn5ebe956s","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"pictures","description":"相册","top_img":null,"abbrlink":0,"date":"2023-09-19T15:55:05.000Z","updated":"2023-10-20T14:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n\n\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '原神' '一些原神图片' '/pictures/gallery_groups/genshin' https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg %}\n{% galleryGroup '英雄联盟KDA' '一些LOL的KDA壁纸' '/pictures/gallery_groups/lol-kda' https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg %}\n\n[//]: # ({% galleryGroup '袜啵啵' '挺喜欢的一家写真摄影集' '/pictures/gallery_groups/wabobo' https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg %})\n</div>\n","source":"pictures/index.md","raw":"---\ntitle: pictures\ndescription: 相册\ntop_img:\nabbrlink: 00000\ndate: 2023-09-19 23:55:05\nupdated: 2023-10-20 22:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n\n\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '原神' '一些原神图片' '/pictures/gallery_groups/genshin' https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg %}\n{% galleryGroup '英雄联盟KDA' '一些LOL的KDA壁纸' '/pictures/gallery_groups/lol-kda' https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg %}\n\n[//]: # ({% galleryGroup '袜啵啵' '挺喜欢的一家写真摄影集' '/pictures/gallery_groups/wabobo' https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg %})\n</div>\n","path":"pictures/index.html","layout":"page","_id":"clxx1rq1o000er7gn607he4ke","content":"<div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">原神</div>\n  <p>一些原神图片</p>\n  <a href='/pictures/gallery_groups/genshin'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">英雄联盟KDA</div>\n  <p>一些LOL的KDA壁纸</p>\n  <a href='/pictures/gallery_groups/lol-kda'></a>\n  </figcaption>\n  </figure>\n  \n\n</div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">原神</div>\n  <p>一些原神图片</p>\n  <a href='/pictures/gallery_groups/genshin'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">英雄联盟KDA</div>\n  <p>一些LOL的KDA壁纸</p>\n  <a href='/pictures/gallery_groups/lol-kda'></a>\n  </figcaption>\n  </figure>\n  \n\n</div>\n"},{"title":"tags","date":"2018-01-04T16:00:00.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2023-09-13T16:03:00.990Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clxx1rq1o000gr7gndfxvhxkq","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"_content":"{% gallery %}\n![pic_11.jpg](https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg)\n![pic_66.jpg](https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png)\n![pic_59.jpg](https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg)\n{% endgallery %}\n","source":"pictures/gallery_groups/genshin.md","raw":"{% gallery %}\n![pic_11.jpg](https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg)\n![pic_66.jpg](https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png)\n![pic_59.jpg](https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg)\n{% endgallery %}\n","date":"2024-02-06T13:21:06.368Z","updated":"2024-02-06T13:21:06.368Z","path":"pictures/gallery_groups/genshin.html","title":"","comments":1,"layout":"page","_id":"clxx1rq1p000lr7gnbwuf38b1","content":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg\",\"alt\":\"pic_11.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png\",\"alt\":\"pic_66.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg\",\"alt\":\"pic_59.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg\",\"alt\":\"pic_11.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png\",\"alt\":\"pic_66.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg\",\"alt\":\"pic_59.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n"},{"_content":"{% gallery %}\n![pic_79.jpg](https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg)\n![pic_37.jpg](https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg)\n![pic_82.jpg](https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg)\n![pic_78.jpg](https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg)\n\n{% endgallery %}\n","source":"pictures/gallery_groups/lol-kda.md","raw":"{% gallery %}\n![pic_79.jpg](https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg)\n![pic_37.jpg](https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg)\n![pic_82.jpg](https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg)\n![pic_78.jpg](https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg)\n\n{% endgallery %}\n","date":"2024-02-06T13:22:38.126Z","updated":"2024-02-06T13:22:38.126Z","path":"pictures/gallery_groups/lol-kda.html","title":"","comments":1,"layout":"page","_id":"clxx1rq1q000pr7gn33k0axkm","content":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg\",\"alt\":\"pic_79.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg\",\"alt\":\"pic_37.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg\",\"alt\":\"pic_82.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg\",\"alt\":\"pic_78.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg\",\"alt\":\"pic_79.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg\",\"alt\":\"pic_37.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg\",\"alt\":\"pic_82.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg\",\"alt\":\"pic_78.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n"},{"_content":"\n[//]: # (# 袜啵啵)\n\n[//]: # ()\n[//]: # (**袜啵啵**是我最喜欢的一家摄影工作室，他们的作品总是能让我感受到一种温暖。最喜欢稚予和小甜豆！！！)\n\n[//]: # ()\n[//]: # (有关的资源我有很多，物恋、誉铭、等，私信我即可，有偿。)\n\n[//]: # ({% gallery %})\n\n[//]: # ()\n[//]: # (![IMG_5152.JPG]&#40;https://s2.loli.net/2023/10/21/5AvpTcn41ukPLDU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5031.jpg]&#40;https://s2.loli.net/2023/10/21/ijo13Vm5dX7lLxc.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5134.JPG]&#40;https://s2.loli.net/2023/10/21/a1hAdBcIJFxNKli.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5151.JPG]&#40;https://s2.loli.net/2023/10/21/lrz6to5fZLdAwFb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5133.JPG]&#40;https://s2.loli.net/2023/10/21/RaQmzlqMrt9bPBG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5132.JPG]&#40;https://s2.loli.net/2023/10/21/AO1RdLJmhlB7WwG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5145.JPG]&#40;https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5126.JPG]&#40;https://s2.loli.net/2023/10/21/J5oYVMza1vjlRbI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5144.JPG]&#40;https://s2.loli.net/2023/10/21/tHjXpwbrl8a1L2M.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5124.JPG]&#40;https://s2.loli.net/2023/10/21/H9mpjRMdNBYFQSx.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5153.JPG]&#40;https://s2.loli.net/2023/10/21/4NEYUnQDgMGp6vk.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5219.JPG]&#40;https://s2.loli.net/2023/10/21/pFEuDlQ7Ay8Vrmi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5218.JPG]&#40;https://s2.loli.net/2023/10/21/mIFGhpzaw24dx7v.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5208.JPG]&#40;https://s2.loli.net/2023/10/21/t5HwUrThulbikBE.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5209.JPG]&#40;https://s2.loli.net/2023/10/21/6rqwmKp3NgW7Dci.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5216.JPG]&#40;https://s2.loli.net/2023/10/21/a7NA6gDBSxXwKpF.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5217.JPG]&#40;https://s2.loli.net/2023/10/21/UAkpsy6Se9r18mq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5229.JPG]&#40;https://s2.loli.net/2023/10/21/K68EUXYpDsvJZzQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5214.JPG]&#40;https://s2.loli.net/2023/10/21/hoVwMp7gCNXzkWP.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5212.JPG]&#40;https://s2.loli.net/2023/10/21/4o5JBygzavUqpDb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5263.JPG]&#40;https://s2.loli.net/2023/10/21/cO3wArBgIkGfVM6.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5265.JPG]&#40;https://s2.loli.net/2023/10/21/exNUZDHMRAPJ8rI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5249.JPG]&#40;https://s2.loli.net/2023/10/21/rtm1NWH6yKC4uYZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5272.JPG]&#40;https://s2.loli.net/2023/10/21/2ERusCdIavwy37L.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5241.JPG]&#40;https://s2.loli.net/2023/10/21/EAi9KQwsSfWRDHU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5243.JPG]&#40;https://s2.loli.net/2023/10/21/nB7iNUWRwQCgvL4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5246.JPG]&#40;https://s2.loli.net/2023/10/21/k4MzjmhYeGNiUrB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5245.JPG]&#40;https://s2.loli.net/2023/10/21/1f4KOGzBJ8Sudsn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5244.JPG]&#40;https://s2.loli.net/2023/10/21/ZJVAi74zM1YK9yC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5242.JPG]&#40;https://s2.loli.net/2023/10/21/a6WtA3s5lBkVFD4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5274.JPG]&#40;https://s2.loli.net/2023/10/21/wsTtBXN6b9Eeif7.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5281.JPG]&#40;https://s2.loli.net/2023/10/21/x8V2sCGL7eg4YPQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5273.JPG]&#40;https://s2.loli.net/2023/10/21/Ee6JFdcbNLBsApU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5286.JPG]&#40;https://s2.loli.net/2023/10/21/sEyijHa32UF7Dgw.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5276.JPG]&#40;https://s2.loli.net/2023/10/21/qmKbR2VSjZErBLX.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5310.JPG]&#40;https://s2.loli.net/2023/10/21/Xn4kBZoM1HDG6W9.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5302.JPG]&#40;https://s2.loli.net/2023/10/21/9eAq4JFMpLSthcu.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5284.JPG]&#40;https://s2.loli.net/2023/10/21/QdfkFYRKrpAU6S5.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5290.JPG]&#40;https://s2.loli.net/2023/10/21/ZLgJnp5NQIYdsVq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5303.JPG]&#40;https://s2.loli.net/2023/10/21/phSsqmxfl67wUyr.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5311.JPG]&#40;https://s2.loli.net/2023/10/21/RkrT9Mzt5Qw8LD3.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5394.JPG]&#40;https://s2.loli.net/2023/10/21/l3StIUqagrdRQDo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5312.JPG]&#40;https://s2.loli.net/2023/10/21/RzbXYaVAdhncpG1.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5350.JPG]&#40;https://s2.loli.net/2023/10/21/FhHV4Bx1JIAicq2.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5378.JPG]&#40;https://s2.loli.net/2023/10/21/9Bf6dhmgkrTpEcN.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5406.JPG]&#40;https://s2.loli.net/2023/10/21/FnWcLjEedV3fRIh.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5351.JPG]&#40;https://s2.loli.net/2023/10/21/H3O8eioK2zL4s1w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5354.JPG]&#40;https://s2.loli.net/2023/10/21/pF1MrHdXqBDRblz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5404.JPG]&#40;https://s2.loli.net/2023/10/21/RtXYhUGq9n7SAya.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5391.JPG]&#40;https://s2.loli.net/2023/10/21/YD2tcOCRXI5Ti8w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5421.JPG]&#40;https://s2.loli.net/2023/10/21/kSZEjvAP7iDhFzo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5435.JPG]&#40;https://s2.loli.net/2023/10/21/BwH7Viabkyr1QPJ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5426.JPG]&#40;https://s2.loli.net/2023/10/21/jcydXw7QmB6faOA.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5436.JPG]&#40;https://s2.loli.net/2023/10/21/oqDMTH8hPnEOIQK.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5469.JPG]&#40;https://s2.loli.net/2023/10/21/D4klmrJ37yFgvCZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5470.JPG]&#40;https://s2.loli.net/2023/10/21/qlJkzIupgt1AmW8.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5424.JPG]&#40;https://s2.loli.net/2023/10/21/ozHLuUc9mPb5Vej.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5430.JPG]&#40;https://s2.loli.net/2023/10/21/OJjqGiA7PMDdtCW.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5482.JPG]&#40;https://s2.loli.net/2023/10/21/gZJLNm8o3a5F9tl.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5756.jpeg]&#40;https://s2.loli.net/2023/10/21/7ABylJru36f4nZz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5783.JPG]&#40;https://s2.loli.net/2023/10/21/tYDnscUrSZ8V5xB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5782.JPG]&#40;https://s2.loli.net/2023/10/21/LDRGosFYtAakxQi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5792.JPG]&#40;https://s2.loli.net/2023/10/21/h9TMpZ3sGxfUvFO.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5794.JPG]&#40;https://s2.loli.net/2023/10/21/qxfHtEjXvlSDy8B.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5757.jpeg]&#40;https://s2.loli.net/2023/10/21/yrwEog9dLOAh1bG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5799.JPG]&#40;https://s2.loli.net/2023/10/21/bnAhag9HpPwWXqC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5800.JPG]&#40;https://s2.loli.net/2023/10/21/xcmua9iPd1WVsnq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_6046.jpg]&#40;https://s2.loli.net/2023/10/21/UVNFMdwjtmb38sC.jpg&#41;)\n\n[//]: # ()\n[//]: # ({% endgallery %})\n","source":"pictures/gallery_groups/wabobo.md","raw":"\n[//]: # (# 袜啵啵)\n\n[//]: # ()\n[//]: # (**袜啵啵**是我最喜欢的一家摄影工作室，他们的作品总是能让我感受到一种温暖。最喜欢稚予和小甜豆！！！)\n\n[//]: # ()\n[//]: # (有关的资源我有很多，物恋、誉铭、等，私信我即可，有偿。)\n\n[//]: # ({% gallery %})\n\n[//]: # ()\n[//]: # (![IMG_5152.JPG]&#40;https://s2.loli.net/2023/10/21/5AvpTcn41ukPLDU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5031.jpg]&#40;https://s2.loli.net/2023/10/21/ijo13Vm5dX7lLxc.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5134.JPG]&#40;https://s2.loli.net/2023/10/21/a1hAdBcIJFxNKli.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5151.JPG]&#40;https://s2.loli.net/2023/10/21/lrz6to5fZLdAwFb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5133.JPG]&#40;https://s2.loli.net/2023/10/21/RaQmzlqMrt9bPBG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5132.JPG]&#40;https://s2.loli.net/2023/10/21/AO1RdLJmhlB7WwG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5145.JPG]&#40;https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5126.JPG]&#40;https://s2.loli.net/2023/10/21/J5oYVMza1vjlRbI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5144.JPG]&#40;https://s2.loli.net/2023/10/21/tHjXpwbrl8a1L2M.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5124.JPG]&#40;https://s2.loli.net/2023/10/21/H9mpjRMdNBYFQSx.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5153.JPG]&#40;https://s2.loli.net/2023/10/21/4NEYUnQDgMGp6vk.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5219.JPG]&#40;https://s2.loli.net/2023/10/21/pFEuDlQ7Ay8Vrmi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5218.JPG]&#40;https://s2.loli.net/2023/10/21/mIFGhpzaw24dx7v.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5208.JPG]&#40;https://s2.loli.net/2023/10/21/t5HwUrThulbikBE.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5209.JPG]&#40;https://s2.loli.net/2023/10/21/6rqwmKp3NgW7Dci.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5216.JPG]&#40;https://s2.loli.net/2023/10/21/a7NA6gDBSxXwKpF.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5217.JPG]&#40;https://s2.loli.net/2023/10/21/UAkpsy6Se9r18mq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5229.JPG]&#40;https://s2.loli.net/2023/10/21/K68EUXYpDsvJZzQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5214.JPG]&#40;https://s2.loli.net/2023/10/21/hoVwMp7gCNXzkWP.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5212.JPG]&#40;https://s2.loli.net/2023/10/21/4o5JBygzavUqpDb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5263.JPG]&#40;https://s2.loli.net/2023/10/21/cO3wArBgIkGfVM6.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5265.JPG]&#40;https://s2.loli.net/2023/10/21/exNUZDHMRAPJ8rI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5249.JPG]&#40;https://s2.loli.net/2023/10/21/rtm1NWH6yKC4uYZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5272.JPG]&#40;https://s2.loli.net/2023/10/21/2ERusCdIavwy37L.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5241.JPG]&#40;https://s2.loli.net/2023/10/21/EAi9KQwsSfWRDHU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5243.JPG]&#40;https://s2.loli.net/2023/10/21/nB7iNUWRwQCgvL4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5246.JPG]&#40;https://s2.loli.net/2023/10/21/k4MzjmhYeGNiUrB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5245.JPG]&#40;https://s2.loli.net/2023/10/21/1f4KOGzBJ8Sudsn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5244.JPG]&#40;https://s2.loli.net/2023/10/21/ZJVAi74zM1YK9yC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5242.JPG]&#40;https://s2.loli.net/2023/10/21/a6WtA3s5lBkVFD4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5274.JPG]&#40;https://s2.loli.net/2023/10/21/wsTtBXN6b9Eeif7.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5281.JPG]&#40;https://s2.loli.net/2023/10/21/x8V2sCGL7eg4YPQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5273.JPG]&#40;https://s2.loli.net/2023/10/21/Ee6JFdcbNLBsApU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5286.JPG]&#40;https://s2.loli.net/2023/10/21/sEyijHa32UF7Dgw.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5276.JPG]&#40;https://s2.loli.net/2023/10/21/qmKbR2VSjZErBLX.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5310.JPG]&#40;https://s2.loli.net/2023/10/21/Xn4kBZoM1HDG6W9.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5302.JPG]&#40;https://s2.loli.net/2023/10/21/9eAq4JFMpLSthcu.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5284.JPG]&#40;https://s2.loli.net/2023/10/21/QdfkFYRKrpAU6S5.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5290.JPG]&#40;https://s2.loli.net/2023/10/21/ZLgJnp5NQIYdsVq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5303.JPG]&#40;https://s2.loli.net/2023/10/21/phSsqmxfl67wUyr.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5311.JPG]&#40;https://s2.loli.net/2023/10/21/RkrT9Mzt5Qw8LD3.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5394.JPG]&#40;https://s2.loli.net/2023/10/21/l3StIUqagrdRQDo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5312.JPG]&#40;https://s2.loli.net/2023/10/21/RzbXYaVAdhncpG1.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5350.JPG]&#40;https://s2.loli.net/2023/10/21/FhHV4Bx1JIAicq2.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5378.JPG]&#40;https://s2.loli.net/2023/10/21/9Bf6dhmgkrTpEcN.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5406.JPG]&#40;https://s2.loli.net/2023/10/21/FnWcLjEedV3fRIh.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5351.JPG]&#40;https://s2.loli.net/2023/10/21/H3O8eioK2zL4s1w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5354.JPG]&#40;https://s2.loli.net/2023/10/21/pF1MrHdXqBDRblz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5404.JPG]&#40;https://s2.loli.net/2023/10/21/RtXYhUGq9n7SAya.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5391.JPG]&#40;https://s2.loli.net/2023/10/21/YD2tcOCRXI5Ti8w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5421.JPG]&#40;https://s2.loli.net/2023/10/21/kSZEjvAP7iDhFzo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5435.JPG]&#40;https://s2.loli.net/2023/10/21/BwH7Viabkyr1QPJ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5426.JPG]&#40;https://s2.loli.net/2023/10/21/jcydXw7QmB6faOA.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5436.JPG]&#40;https://s2.loli.net/2023/10/21/oqDMTH8hPnEOIQK.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5469.JPG]&#40;https://s2.loli.net/2023/10/21/D4klmrJ37yFgvCZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5470.JPG]&#40;https://s2.loli.net/2023/10/21/qlJkzIupgt1AmW8.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5424.JPG]&#40;https://s2.loli.net/2023/10/21/ozHLuUc9mPb5Vej.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5430.JPG]&#40;https://s2.loli.net/2023/10/21/OJjqGiA7PMDdtCW.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5482.JPG]&#40;https://s2.loli.net/2023/10/21/gZJLNm8o3a5F9tl.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5756.jpeg]&#40;https://s2.loli.net/2023/10/21/7ABylJru36f4nZz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5783.JPG]&#40;https://s2.loli.net/2023/10/21/tYDnscUrSZ8V5xB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5782.JPG]&#40;https://s2.loli.net/2023/10/21/LDRGosFYtAakxQi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5792.JPG]&#40;https://s2.loli.net/2023/10/21/h9TMpZ3sGxfUvFO.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5794.JPG]&#40;https://s2.loli.net/2023/10/21/qxfHtEjXvlSDy8B.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5757.jpeg]&#40;https://s2.loli.net/2023/10/21/yrwEog9dLOAh1bG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5799.JPG]&#40;https://s2.loli.net/2023/10/21/bnAhag9HpPwWXqC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5800.JPG]&#40;https://s2.loli.net/2023/10/21/xcmua9iPd1WVsnq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_6046.jpg]&#40;https://s2.loli.net/2023/10/21/UVNFMdwjtmb38sC.jpg&#41;)\n\n[//]: # ()\n[//]: # ({% endgallery %})\n","date":"2023-12-26T08:53:22.200Z","updated":"2023-12-26T08:53:22.200Z","path":"pictures/gallery_groups/wabobo.html","title":"","comments":1,"layout":"page","_id":"clxx1rq1r000ur7gn67e81ffh","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"C++知识点","keywords":["面经"],"description":"C++知识点","abbrlink":17775,"date":"2024-06-27T08:31:43.000Z","updated":"2024-06-26T08:15:15.000Z","top_img":"https://s2.loli.net/2024/06/27/l3jdeWMqxY9Hf5h.png","comments":1,"cover":"https://s2.loli.net/2024/06/27/xvtGedjogpz15iE.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"","source":"_posts/C-知识点.md","raw":"---\ntitle: C++知识点\ntags:\n  - C++\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: C++知识点\nabbrlink: 17775\ndate: 2024-06-27 16:31:43\nupdated: 2024-06-26 16:15:15\ntop_img: https://s2.loli.net/2024/06/27/l3jdeWMqxY9Hf5h.png\ncomments:\ncover: https://s2.loli.net/2024/06/27/xvtGedjogpz15iE.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n","slug":"C-知识点","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1h0001r7gneas9hdmy","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":""},{"title":"MARL","keywords":["多智能体强化学习"],"description":"多智能体强化学习的算法和思路总结","abbrlink":17763,"date":"2023-10-30T09:04:41.000Z","updated":"2023-11-09T09:37:56.000Z","top_img":"https://s2.loli.net/2024/06/27/qCnl54QgsXFyv8j.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/FCKdzqG2wJ8RmcS.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 由于我的科研方向是`多智能体强化学习`，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。\n\n> 在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。\n\n知乎专栏：https://www.zhihu.com/column/c_1061939147282915328\n\n## 基础知识与博弈\n\n### 引言\n在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。\n\n在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。\n\n1. 维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。\n2. 目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。\n3. 不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。\n4. 探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。\n\n多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。\n\n### 纳什均衡\n\n![img_1.png](..%2Fimage%2FMARL%2Fimg_1.png)\n\n### 完全混合策略\n若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。\n\n### 纯策略\n\n若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。\n\n### 零和博弈\n零和博弈中，两个智能体是完全竞争对抗关系，则 `R1 = - R2` 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。\n\n### 一般和博弈\n一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。\n\n> 矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：https://zhuanlan.zhihu.com/p/53474965\n\n## Minimax-Q\n论文：[Markov games as a framework for multi-agent reinforcement learning](https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf)\n\nMinimax-Q算法应用于`两个玩家的零和随机博弈中`。`Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。`\n\n在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，`每个智能体最大化在与对手博弈中最差情况下的期望奖励值`。\n\n![img_2.png](..%2Fimage%2FMARL%2Fimg_2.png)\n\n理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：\n\n1. 在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。\n2. 为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。\n3. 只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。\n\n## Nash Q-Learning\n论文：[Nash Q-learning for general-sum stochastic games](https://www.jmlr.org/papers/volume4/temp/hu03a.pdf)\n\nNash Q-Learning算法是将Minimax-Q算法`从零和博弈扩展到多人一般和博弈`的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到`Nash Q-Learning算法就是使用二次规划求解纳什均衡点`。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。\n\n其算法流程如下：\n\n![img_3.png](..%2Fimage%2FMARL%2Fimg_3.png)\n\n该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。\n\n## Friend-or-Foe Q-Learning\n论文：[Friend-or-foe Q-learning in general-sum games](https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf)\n\nFriend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。\n\n其纳什均衡策略求解方法如下所示：\n\n![img_4.png](..%2Fimage%2FMARL%2Fimg_4.png)\n\n算法流程如下：\n\n![img_5.png](..%2Fimage%2FMARL%2Fimg_5.png)\n\n有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。\n\nFFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。\n\nFFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。\n\n## WoLF Policy Hill-Climbing\n论文：[Multiagent learning using a variable learning rate](https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK%2Bil2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV%2Bk4Sy0RKqs%2FFblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL%2FzjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t%2F2bnTZ7qTDIfyIUlvNHlEKL%2F9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv%2BcEGunXeil0OTm%2FSRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz%2BTVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt%2Bupsy1T6e%2Bt1k0PCXzBrMR4xqRuv006eN8HG7%2FOHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN%2F%2Bt8okdIhgmNbKIikDVOUqNwejq1Mnka%2B0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8%2B1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J%2F3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb%2B2%2BMdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH%2BOpYXYXQA%2BusAbQ%2FJLnUibNKgBd8Ssk2Fj7%2BAj1H1%2B7hEDC%2BKVib31jzGP9aBwfa76WjOdwk%2B%2FVtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb%2FyzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr%2BMh%2F%2F5bt5%2FspmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT%2BQiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr%2Fop8JfLOur2Kx4cAbHsxPmwrtlKhbwv%2FByOhbxlQf%2BUKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t%2Fp1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR%2F20231107%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk)\n\n![img_6.png](..%2Fimage%2FMARL%2Fimg_6.png)\n\nWolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。\n\nPHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。\n\n其算法流程如下：\n\n![img_7.png](..%2Fimage%2FMARL%2Fimg_7.png)\n\n为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 `δ` 来实现WoLF效果，当策略效果较差时使用 `δl` ，策略效果较好时使用 `δw` ，并且满足 `δl > δw` 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。\n\n其算法流程如下所示：\n\n![img_8.png](..%2Fimage%2FMARL%2Fimg_8.png)\n\n> 关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：https://www.cnblogs.com/zuti666/p/16909220.html 和 https://zhuanlan.zhihu.com/p/53563792\n\n\n## MADDPG\n论文：[Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments](https://arxiv.org/abs/1706.02275)\n\nOpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。\n\n传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。\n\nMADDPG算法具有以下三点特征： \n1. 通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 \n2. 不需要知道环境的动力学模型以及特殊的通信需求。 \n3. 该算法不仅能用于合作环境，也能用于竞争环境。\n\nMADDPG算法具有以下三点技巧：\n1. 集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。\n2. 改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x', a1,..., an, r1,..., rn)组成，X = (o1,..., on)。表示每个智能体的观测。\n3. 利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。\n\n### 背景知识\n\n#### DQN\n深度Q网络（deep Q-network）\n![img_9.png](..%2Fimage%2FMARL%2Fimg_9.png)\n\n#### SPG\n随机策略梯度（stochastic policy gradient）\n\n![img_10.png](..%2Fimage%2FMARL%2Fimg_10.png)\n\n#### DPG\n确定性策略梯度（deterministic policy gradient）\n\n![img_11.png](..%2Fimage%2FMARL%2Fimg_11.png)\n\n### MADDPG\n\n#### 多智能体AC设计\n\nMADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。\n![img_12.png](..%2Fimage%2FMARL%2Fimg_12.png)\n![img_13.png](..%2Fimage%2FMARL%2Fimg_13.png)\n\n#### 估计其他智能体策略\n\n![img_14.png](..%2Fimage%2FMARL%2Fimg_14.png)\n\n#### 策略集合优化\n\n![img_15.png](..%2Fimage%2FMARL%2Fimg_15.png)\n\n### 相关PPT\n\n![img_16.png](..%2Fimage%2FMARL%2Fimg_16.png)\n![img_17.png](..%2Fimage%2FMARL%2Fimg_17.png)\n![img_18.png](..%2Fimage%2FMARL%2Fimg_18.png)\n![img_19.png](..%2Fimage%2FMARL%2Fimg_19.png)\n![img_20.png](..%2Fimage%2FMARL%2Fimg_20.png)\n\n\n## IQL\n论文：[Multiagent Cooperation and Competition with Deep Reinforcement Learning](https://arxiv.org/abs/1511.08779)\n\nIndependent Q-Learning\n\n本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。\n\nIQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。\n\nIQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。`这是此类算法的一个极端。`\n\n其他没啥要讲的。。。\n\n![img_21.png](..%2Fimage%2FMARL%2Fimg_21.png)\n\n## COMA\n论文：[Counterfactual Multi-Agent Policy Gradients](https://arxiv.org/abs/1705.08926)\n\nCOMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。`这是此类算法的另一个极端。`\n![img_23.png](..%2Fimage%2FMARL%2Fimg_23.png)\n\n多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。\n\n那么这些算法都在解决什么问题呢？\n\n只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。\n\n在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。\n\n![img_24.png](..%2Fimage%2FMARL%2Fimg_24.png)\n\n这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。\n\n![img_25.png](..%2Fimage%2FMARL%2Fimg_25.png)\n\nCOMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。\n\nCOMA算法具体框架如下图所示：\n![img_22.png](..%2Fimage%2FMARL%2Fimg_22.png)\n\n网络架构：\n![img_26.png](..%2Fimage%2FMARL%2Fimg_26.png)\n\n\n## VDN\n论文：[Value-Decomposition Networks For Cooperative Multi-Agent Learning](https://arxiv.org/abs/1706.05296)\n\nVDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。\n\nVDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：`Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。`如下图：\n左边是IQL，右边是VDN\n![img_27.png](..%2Fimage%2FMARL%2Fimg_27.png)\n\n作者假定如下等式成立：\n![img_29.png](..%2Fimage%2FMARL%2Fimg_29.png)\n\nh表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。\n\n推导上式：\n假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：\n![img_30.png](..%2Fimage%2FMARL%2Fimg_30.png)\n这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：\n![img_31.png](..%2Fimage%2FMARL%2Fimg_31.png)\n\n网络架构：\n![img_28.png](..%2Fimage%2FMARL%2Fimg_28.png)\n\n\nVDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。\n\n## QMIX\n论文：[QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1803.11485)\n\n深度多智能体强化学习的单调值函数分解\n\nQMIX是一个多智能体强化学习算法，具有如下特点： \n1. 学习得到分布式策略。 \n2. 本质是一个值函数逼近算法。 \n3. 由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 \n4. QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 \n5. 训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 \n6. 接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 \n7. 每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 \n8. 算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 \n9. 算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。\n\n### 背景知识\n\n#### MARL核心问题\n\n在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，`如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数`。另一个问题就是学得了联合动作值函数后，`如何通过联合值函数提取出一个优秀的分布式的策略`。这其实是单智能体强化学习拓展到MARL的核心问题。\n\n#### Dec-POMDP\nDec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。\n![img_32.png](..%2Fimage%2FMARL%2Fimg_32.png)\n\n#### IQL\n\nIQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。\n\n#### VDN\n\n如前介绍：\n![img_33.png](..%2Fimage%2FMARL%2Fimg_33.png)\n\n#### DRQN\n\nDRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。\n\n\n### QMIX\n\nQMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。\n\nQMIX约束条件：\n![img_34.png](..%2Fimage%2FMARL%2Fimg_34.png)\n也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。\n\n具体网络结构如下：\n![img_35.png](..%2Fimage%2FMARL%2Fimg_35.png)\n\n图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。\n\n图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。\n\n为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。\n\nQMIX的Loss：\n![img_36.png](..%2Fimage%2FMARL%2Fimg_36.png)\n\n更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，\n![img_37.png](..%2Fimage%2FMARL%2Fimg_37.png)\n\n由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。\n\n\n## QTRAN\n论文：[QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1905.05408)\n\n学习因式分解以实现协作多智能体强化学习 Q-Tran\n\nQMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。\n\nQTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。\n\n![img_38.png](..%2Fimage%2FMARL%2Fimg_38.png)\n\n这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。\n\n为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:\n![img_41.png](..%2Fimage%2FMARL%2Fimg_41.png)\n\n### TRAN-base\n分为三部分：\n1. 独立 Q 网络\n2. 联合 Q 网络\n3. 联合 V 网络\n\n整体的Loss如下：\n![img_39.png](..%2Fimage%2FMARL%2Fimg_39.png)\n![img_40.png](..%2Fimage%2FMARL%2Fimg_40.png)\n\n### TRAN-alt\nQTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。\n\n作者认为约束：\n![img_42.png](..%2Fimage%2FMARL%2Fimg_42.png)\n\n在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。\n\n为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。\n![img_43.png](..%2Fimage%2FMARL%2Fimg_43.png)\n这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：\n\n![img_44.png](..%2Fimage%2FMARL%2Fimg_44.png)\n\n具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。\n\n算法流程：\n![img.png](..%2Fimage%2FMARL%2Fimg.png)\n\n## MFMARL\n论文：[Mean Field Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1802.05438v4)\n\n平均场多智能体强化学习\n\n`MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。`由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。\n\nMFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。\n\n下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。\n\n### 背景知识\n\n#### 随机博弈\n\n![img_45.png](..%2Fimage%2FMARL%2Fimg_45.png)\n\n#### Nash-Q\n\n![img_46.png](..%2Fimage%2FMARL%2Fimg_46.png)\n\n### Mean Field MARL\n\n\n![img_50.png](..%2Fimage%2FMARL%2Fimg_50.png)\n#### 平均场近似\n\n![img_47.png](..%2Fimage%2FMARL%2Fimg_47.png)\n\n![img_48.png](..%2Fimage%2FMARL%2Fimg_48.png)\n\n![img_49.png](..%2Fimage%2FMARL%2Fimg_49.png)\n\n### 算法设计\n\n原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。\n\n#### MF-Q\n\n通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差\n![img_51.png](..%2Fimage%2FMARL%2Fimg_51.png)\n\n对上式求导可以得出参数梯度方向如下:\n![img_52.png](..%2Fimage%2FMARL%2Fimg_52.png)\n\n通过梯度下降法可以得到参数更新公式。\n\n算法流程：\n![img_53.png](..%2Fimage%2FMARL%2Fimg_53.png)\n\n#### MF-AC\n\n类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。\n\n类似SPG，actor策略梯度公式可以写为：\n![img_54.png](..%2Fimage%2FMARL%2Fimg_54.png)\n\ncritic类似于MF-Q的更新方式(9)\n\n![img_55.png](..%2Fimage%2FMARL%2Fimg_55.png)\n\n### 总结\n\n![img_56.png](..%2Fimage%2FMARL%2Fimg_56.png)\n\n> 至此，MARL的入门已结束，后面会结合科研方向看论文想点子。\n\n\n\n\n\n","source":"_posts/MARL.md","raw":"---\ntitle: MARL\ntags:\n    - 强化学习\n    - 多智能体强化学习\n    - 算法\ncategories:\n    - 强化学习\n    - 多智能体强化学习\nkeywords:\n    - 多智能体强化学习\ndescription: 多智能体强化学习的算法和思路总结\nabbrlink: 17763\ndate: 2023-10-30 17:04:41\nupdated: 2023-11-09 17:37:56\ntop_img: https://s2.loli.net/2024/06/27/qCnl54QgsXFyv8j.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/FCKdzqG2wJ8RmcS.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 由于我的科研方向是`多智能体强化学习`，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。\n\n> 在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。\n\n知乎专栏：https://www.zhihu.com/column/c_1061939147282915328\n\n## 基础知识与博弈\n\n### 引言\n在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。\n\n在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。\n\n1. 维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。\n2. 目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。\n3. 不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。\n4. 探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。\n\n多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。\n\n### 纳什均衡\n\n![img_1.png](..%2Fimage%2FMARL%2Fimg_1.png)\n\n### 完全混合策略\n若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。\n\n### 纯策略\n\n若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。\n\n### 零和博弈\n零和博弈中，两个智能体是完全竞争对抗关系，则 `R1 = - R2` 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。\n\n### 一般和博弈\n一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。\n\n> 矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：https://zhuanlan.zhihu.com/p/53474965\n\n## Minimax-Q\n论文：[Markov games as a framework for multi-agent reinforcement learning](https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf)\n\nMinimax-Q算法应用于`两个玩家的零和随机博弈中`。`Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。`\n\n在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，`每个智能体最大化在与对手博弈中最差情况下的期望奖励值`。\n\n![img_2.png](..%2Fimage%2FMARL%2Fimg_2.png)\n\n理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：\n\n1. 在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。\n2. 为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。\n3. 只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。\n\n## Nash Q-Learning\n论文：[Nash Q-learning for general-sum stochastic games](https://www.jmlr.org/papers/volume4/temp/hu03a.pdf)\n\nNash Q-Learning算法是将Minimax-Q算法`从零和博弈扩展到多人一般和博弈`的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到`Nash Q-Learning算法就是使用二次规划求解纳什均衡点`。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。\n\n其算法流程如下：\n\n![img_3.png](..%2Fimage%2FMARL%2Fimg_3.png)\n\n该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。\n\n## Friend-or-Foe Q-Learning\n论文：[Friend-or-foe Q-learning in general-sum games](https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf)\n\nFriend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。\n\n其纳什均衡策略求解方法如下所示：\n\n![img_4.png](..%2Fimage%2FMARL%2Fimg_4.png)\n\n算法流程如下：\n\n![img_5.png](..%2Fimage%2FMARL%2Fimg_5.png)\n\n有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。\n\nFFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。\n\nFFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。\n\n## WoLF Policy Hill-Climbing\n论文：[Multiagent learning using a variable learning rate](https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK%2Bil2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV%2Bk4Sy0RKqs%2FFblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL%2FzjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t%2F2bnTZ7qTDIfyIUlvNHlEKL%2F9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv%2BcEGunXeil0OTm%2FSRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz%2BTVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt%2Bupsy1T6e%2Bt1k0PCXzBrMR4xqRuv006eN8HG7%2FOHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN%2F%2Bt8okdIhgmNbKIikDVOUqNwejq1Mnka%2B0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8%2B1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J%2F3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb%2B2%2BMdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH%2BOpYXYXQA%2BusAbQ%2FJLnUibNKgBd8Ssk2Fj7%2BAj1H1%2B7hEDC%2BKVib31jzGP9aBwfa76WjOdwk%2B%2FVtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb%2FyzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr%2BMh%2F%2F5bt5%2FspmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT%2BQiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr%2Fop8JfLOur2Kx4cAbHsxPmwrtlKhbwv%2FByOhbxlQf%2BUKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t%2Fp1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR%2F20231107%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk)\n\n![img_6.png](..%2Fimage%2FMARL%2Fimg_6.png)\n\nWolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。\n\nPHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。\n\n其算法流程如下：\n\n![img_7.png](..%2Fimage%2FMARL%2Fimg_7.png)\n\n为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 `δ` 来实现WoLF效果，当策略效果较差时使用 `δl` ，策略效果较好时使用 `δw` ，并且满足 `δl > δw` 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。\n\n其算法流程如下所示：\n\n![img_8.png](..%2Fimage%2FMARL%2Fimg_8.png)\n\n> 关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：https://www.cnblogs.com/zuti666/p/16909220.html 和 https://zhuanlan.zhihu.com/p/53563792\n\n\n## MADDPG\n论文：[Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments](https://arxiv.org/abs/1706.02275)\n\nOpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。\n\n传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。\n\nMADDPG算法具有以下三点特征： \n1. 通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 \n2. 不需要知道环境的动力学模型以及特殊的通信需求。 \n3. 该算法不仅能用于合作环境，也能用于竞争环境。\n\nMADDPG算法具有以下三点技巧：\n1. 集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。\n2. 改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x', a1,..., an, r1,..., rn)组成，X = (o1,..., on)。表示每个智能体的观测。\n3. 利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。\n\n### 背景知识\n\n#### DQN\n深度Q网络（deep Q-network）\n![img_9.png](..%2Fimage%2FMARL%2Fimg_9.png)\n\n#### SPG\n随机策略梯度（stochastic policy gradient）\n\n![img_10.png](..%2Fimage%2FMARL%2Fimg_10.png)\n\n#### DPG\n确定性策略梯度（deterministic policy gradient）\n\n![img_11.png](..%2Fimage%2FMARL%2Fimg_11.png)\n\n### MADDPG\n\n#### 多智能体AC设计\n\nMADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。\n![img_12.png](..%2Fimage%2FMARL%2Fimg_12.png)\n![img_13.png](..%2Fimage%2FMARL%2Fimg_13.png)\n\n#### 估计其他智能体策略\n\n![img_14.png](..%2Fimage%2FMARL%2Fimg_14.png)\n\n#### 策略集合优化\n\n![img_15.png](..%2Fimage%2FMARL%2Fimg_15.png)\n\n### 相关PPT\n\n![img_16.png](..%2Fimage%2FMARL%2Fimg_16.png)\n![img_17.png](..%2Fimage%2FMARL%2Fimg_17.png)\n![img_18.png](..%2Fimage%2FMARL%2Fimg_18.png)\n![img_19.png](..%2Fimage%2FMARL%2Fimg_19.png)\n![img_20.png](..%2Fimage%2FMARL%2Fimg_20.png)\n\n\n## IQL\n论文：[Multiagent Cooperation and Competition with Deep Reinforcement Learning](https://arxiv.org/abs/1511.08779)\n\nIndependent Q-Learning\n\n本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。\n\nIQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。\n\nIQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。`这是此类算法的一个极端。`\n\n其他没啥要讲的。。。\n\n![img_21.png](..%2Fimage%2FMARL%2Fimg_21.png)\n\n## COMA\n论文：[Counterfactual Multi-Agent Policy Gradients](https://arxiv.org/abs/1705.08926)\n\nCOMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。`这是此类算法的另一个极端。`\n![img_23.png](..%2Fimage%2FMARL%2Fimg_23.png)\n\n多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。\n\n那么这些算法都在解决什么问题呢？\n\n只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。\n\n在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。\n\n![img_24.png](..%2Fimage%2FMARL%2Fimg_24.png)\n\n这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。\n\n![img_25.png](..%2Fimage%2FMARL%2Fimg_25.png)\n\nCOMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。\n\nCOMA算法具体框架如下图所示：\n![img_22.png](..%2Fimage%2FMARL%2Fimg_22.png)\n\n网络架构：\n![img_26.png](..%2Fimage%2FMARL%2Fimg_26.png)\n\n\n## VDN\n论文：[Value-Decomposition Networks For Cooperative Multi-Agent Learning](https://arxiv.org/abs/1706.05296)\n\nVDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。\n\nVDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：`Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。`如下图：\n左边是IQL，右边是VDN\n![img_27.png](..%2Fimage%2FMARL%2Fimg_27.png)\n\n作者假定如下等式成立：\n![img_29.png](..%2Fimage%2FMARL%2Fimg_29.png)\n\nh表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。\n\n推导上式：\n假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：\n![img_30.png](..%2Fimage%2FMARL%2Fimg_30.png)\n这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：\n![img_31.png](..%2Fimage%2FMARL%2Fimg_31.png)\n\n网络架构：\n![img_28.png](..%2Fimage%2FMARL%2Fimg_28.png)\n\n\nVDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。\n\n## QMIX\n论文：[QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1803.11485)\n\n深度多智能体强化学习的单调值函数分解\n\nQMIX是一个多智能体强化学习算法，具有如下特点： \n1. 学习得到分布式策略。 \n2. 本质是一个值函数逼近算法。 \n3. 由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 \n4. QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 \n5. 训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 \n6. 接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 \n7. 每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 \n8. 算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 \n9. 算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。\n\n### 背景知识\n\n#### MARL核心问题\n\n在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，`如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数`。另一个问题就是学得了联合动作值函数后，`如何通过联合值函数提取出一个优秀的分布式的策略`。这其实是单智能体强化学习拓展到MARL的核心问题。\n\n#### Dec-POMDP\nDec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。\n![img_32.png](..%2Fimage%2FMARL%2Fimg_32.png)\n\n#### IQL\n\nIQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。\n\n#### VDN\n\n如前介绍：\n![img_33.png](..%2Fimage%2FMARL%2Fimg_33.png)\n\n#### DRQN\n\nDRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。\n\n\n### QMIX\n\nQMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。\n\nQMIX约束条件：\n![img_34.png](..%2Fimage%2FMARL%2Fimg_34.png)\n也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。\n\n具体网络结构如下：\n![img_35.png](..%2Fimage%2FMARL%2Fimg_35.png)\n\n图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。\n\n图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。\n\n为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。\n\nQMIX的Loss：\n![img_36.png](..%2Fimage%2FMARL%2Fimg_36.png)\n\n更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，\n![img_37.png](..%2Fimage%2FMARL%2Fimg_37.png)\n\n由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。\n\n\n## QTRAN\n论文：[QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1905.05408)\n\n学习因式分解以实现协作多智能体强化学习 Q-Tran\n\nQMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。\n\nQTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。\n\n![img_38.png](..%2Fimage%2FMARL%2Fimg_38.png)\n\n这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。\n\n为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:\n![img_41.png](..%2Fimage%2FMARL%2Fimg_41.png)\n\n### TRAN-base\n分为三部分：\n1. 独立 Q 网络\n2. 联合 Q 网络\n3. 联合 V 网络\n\n整体的Loss如下：\n![img_39.png](..%2Fimage%2FMARL%2Fimg_39.png)\n![img_40.png](..%2Fimage%2FMARL%2Fimg_40.png)\n\n### TRAN-alt\nQTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。\n\n作者认为约束：\n![img_42.png](..%2Fimage%2FMARL%2Fimg_42.png)\n\n在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。\n\n为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。\n![img_43.png](..%2Fimage%2FMARL%2Fimg_43.png)\n这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：\n\n![img_44.png](..%2Fimage%2FMARL%2Fimg_44.png)\n\n具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。\n\n算法流程：\n![img.png](..%2Fimage%2FMARL%2Fimg.png)\n\n## MFMARL\n论文：[Mean Field Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1802.05438v4)\n\n平均场多智能体强化学习\n\n`MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。`由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。\n\nMFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。\n\n下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。\n\n### 背景知识\n\n#### 随机博弈\n\n![img_45.png](..%2Fimage%2FMARL%2Fimg_45.png)\n\n#### Nash-Q\n\n![img_46.png](..%2Fimage%2FMARL%2Fimg_46.png)\n\n### Mean Field MARL\n\n\n![img_50.png](..%2Fimage%2FMARL%2Fimg_50.png)\n#### 平均场近似\n\n![img_47.png](..%2Fimage%2FMARL%2Fimg_47.png)\n\n![img_48.png](..%2Fimage%2FMARL%2Fimg_48.png)\n\n![img_49.png](..%2Fimage%2FMARL%2Fimg_49.png)\n\n### 算法设计\n\n原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。\n\n#### MF-Q\n\n通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差\n![img_51.png](..%2Fimage%2FMARL%2Fimg_51.png)\n\n对上式求导可以得出参数梯度方向如下:\n![img_52.png](..%2Fimage%2FMARL%2Fimg_52.png)\n\n通过梯度下降法可以得到参数更新公式。\n\n算法流程：\n![img_53.png](..%2Fimage%2FMARL%2Fimg_53.png)\n\n#### MF-AC\n\n类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。\n\n类似SPG，actor策略梯度公式可以写为：\n![img_54.png](..%2Fimage%2FMARL%2Fimg_54.png)\n\ncritic类似于MF-Q的更新方式(9)\n\n![img_55.png](..%2Fimage%2FMARL%2Fimg_55.png)\n\n### 总结\n\n![img_56.png](..%2Fimage%2FMARL%2Fimg_56.png)\n\n> 至此，MARL的入门已结束，后面会结合科研方向看论文想点子。\n\n\n\n\n\n","slug":"MARL","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1k0003r7gn8hpx4mlw","content":"<blockquote>\n<p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p>\n</blockquote>\n<blockquote>\n<p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p>\n</blockquote>\n<p>知乎专栏：<a href=\"https://www.zhihu.com/column/c_1061939147282915328\">https://www.zhihu.com/column/c_1061939147282915328</a></p>\n<h2 id=\"基础知识与博弈\"><a href=\"#基础知识与博弈\" class=\"headerlink\" title=\"基础知识与博弈\"></a>基础知识与博弈</h2><h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p>\n<p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p>\n<ol>\n<li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li>\n<li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li>\n<li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li>\n<li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li>\n</ol>\n<p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p>\n<h3 id=\"纳什均衡\"><a href=\"#纳什均衡\" class=\"headerlink\" title=\"纳什均衡\"></a>纳什均衡</h3><p><img src=\"/../image/MARL/img_1.png\" alt=\"img_1.png\"></p>\n<h3 id=\"完全混合策略\"><a href=\"#完全混合策略\" class=\"headerlink\" title=\"完全混合策略\"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p>\n<h3 id=\"纯策略\"><a href=\"#纯策略\" class=\"headerlink\" title=\"纯策略\"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p>\n<h3 id=\"零和博弈\"><a href=\"#零和博弈\" class=\"headerlink\" title=\"零和博弈\"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p>\n<h3 id=\"一般和博弈\"><a href=\"#一般和博弈\" class=\"headerlink\" title=\"一般和博弈\"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p>\n<blockquote>\n<p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href=\"https://zhuanlan.zhihu.com/p/53474965\">https://zhuanlan.zhihu.com/p/53474965</a></p>\n</blockquote>\n<h2 id=\"Minimax-Q\"><a href=\"#Minimax-Q\" class=\"headerlink\" title=\"Minimax-Q\"></a>Minimax-Q</h2><p>论文：<a href=\"https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf\">Markov games as a framework for multi-agent reinforcement learning</a></p>\n<p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p>\n<p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p>\n<p><img src=\"/../image/MARL/img_2.png\" alt=\"img_2.png\"></p>\n<p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p>\n<ol>\n<li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li>\n<li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li>\n<li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li>\n</ol>\n<h2 id=\"Nash-Q-Learning\"><a href=\"#Nash-Q-Learning\" class=\"headerlink\" title=\"Nash Q-Learning\"></a>Nash Q-Learning</h2><p>论文：<a href=\"https://www.jmlr.org/papers/volume4/temp/hu03a.pdf\">Nash Q-learning for general-sum stochastic games</a></p>\n<p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_3.png\" alt=\"img_3.png\"></p>\n<p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p>\n<h2 id=\"Friend-or-Foe-Q-Learning\"><a href=\"#Friend-or-Foe-Q-Learning\" class=\"headerlink\" title=\"Friend-or-Foe Q-Learning\"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href=\"https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf\">Friend-or-foe Q-learning in general-sum games</a></p>\n<p>Friend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p>\n<p>其纳什均衡策略求解方法如下所示：</p>\n<p><img src=\"/../image/MARL/img_4.png\" alt=\"img_4.png\"></p>\n<p>算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_5.png\" alt=\"img_5.png\"></p>\n<p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p>\n<p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p>\n<p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p>\n<h2 id=\"WoLF-Policy-Hill-Climbing\"><a href=\"#WoLF-Policy-Hill-Climbing\" class=\"headerlink\" title=\"WoLF Policy Hill-Climbing\"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href=\"https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk\">Multiagent learning using a variable learning rate</a></p>\n<p><img src=\"/../image/MARL/img_6.png\" alt=\"img_6.png\"></p>\n<p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p>\n<p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_7.png\" alt=\"img_7.png\"></p>\n<p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p>\n<p>其算法流程如下所示：</p>\n<p><img src=\"/../image/MARL/img_8.png\" alt=\"img_8.png\"></p>\n<blockquote>\n<p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href=\"https://www.cnblogs.com/zuti666/p/16909220.html\">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/53563792\">https://zhuanlan.zhihu.com/p/53563792</a></p>\n</blockquote>\n<h2 id=\"MADDPG\"><a href=\"#MADDPG\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.02275\">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p>\n<p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p>\n<p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p>\n<p>MADDPG算法具有以下三点特征： </p>\n<ol>\n<li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li>\n<li>不需要知道环境的动力学模型以及特殊的通信需求。 </li>\n<li>该算法不仅能用于合作环境，也能用于竞争环境。</li>\n</ol>\n<p>MADDPG算法具有以下三点技巧：</p>\n<ol>\n<li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li>\n<li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li>\n<li>利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li>\n</ol>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4><p>深度Q网络（deep Q-network）<br><img src=\"/../image/MARL/img_9.png\" alt=\"img_9.png\"></p>\n<h4 id=\"SPG\"><a href=\"#SPG\" class=\"headerlink\" title=\"SPG\"></a>SPG</h4><p>随机策略梯度（stochastic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_10.png\" alt=\"img_10.png\"></p>\n<h4 id=\"DPG\"><a href=\"#DPG\" class=\"headerlink\" title=\"DPG\"></a>DPG</h4><p>确定性策略梯度（deterministic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_11.png\" alt=\"img_11.png\"></p>\n<h3 id=\"MADDPG-1\"><a href=\"#MADDPG-1\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h3><h4 id=\"多智能体AC设计\"><a href=\"#多智能体AC设计\" class=\"headerlink\" title=\"多智能体AC设计\"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src=\"/../image/MARL/img_12.png\" alt=\"img_12.png\"><br><img src=\"/../image/MARL/img_13.png\" alt=\"img_13.png\"></p>\n<h4 id=\"估计其他智能体策略\"><a href=\"#估计其他智能体策略\" class=\"headerlink\" title=\"估计其他智能体策略\"></a>估计其他智能体策略</h4><p><img src=\"/../image/MARL/img_14.png\" alt=\"img_14.png\"></p>\n<h4 id=\"策略集合优化\"><a href=\"#策略集合优化\" class=\"headerlink\" title=\"策略集合优化\"></a>策略集合优化</h4><p><img src=\"/../image/MARL/img_15.png\" alt=\"img_15.png\"></p>\n<h3 id=\"相关PPT\"><a href=\"#相关PPT\" class=\"headerlink\" title=\"相关PPT\"></a>相关PPT</h3><p><img src=\"/../image/MARL/img_16.png\" alt=\"img_16.png\"><br><img src=\"/../image/MARL/img_17.png\" alt=\"img_17.png\"><br><img src=\"/../image/MARL/img_18.png\" alt=\"img_18.png\"><br><img src=\"/../image/MARL/img_19.png\" alt=\"img_19.png\"><br><img src=\"/../image/MARL/img_20.png\" alt=\"img_20.png\"></p>\n<h2 id=\"IQL\"><a href=\"#IQL\" class=\"headerlink\" title=\"IQL\"></a>IQL</h2><p>论文：<a href=\"https://arxiv.org/abs/1511.08779\">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p>\n<p>Independent Q-Learning</p>\n<p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。</p>\n<p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p>\n<p>IQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p>\n<p>其他没啥要讲的。。。</p>\n<p><img src=\"/../image/MARL/img_21.png\" alt=\"img_21.png\"></p>\n<h2 id=\"COMA\"><a href=\"#COMA\" class=\"headerlink\" title=\"COMA\"></a>COMA</h2><p>论文：<a href=\"https://arxiv.org/abs/1705.08926\">Counterfactual Multi-Agent Policy Gradients</a></p>\n<p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src=\"/../image/MARL/img_23.png\" alt=\"img_23.png\"></p>\n<p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p>\n<p>那么这些算法都在解决什么问题呢？</p>\n<p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。</p>\n<p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。</p>\n<p><img src=\"/../image/MARL/img_24.png\" alt=\"img_24.png\"></p>\n<p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p>\n<p><img src=\"/../image/MARL/img_25.png\" alt=\"img_25.png\"></p>\n<p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p>\n<p>COMA算法具体框架如下图所示：<br><img src=\"/../image/MARL/img_22.png\" alt=\"img_22.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_26.png\" alt=\"img_26.png\"></p>\n<h2 id=\"VDN\"><a href=\"#VDN\" class=\"headerlink\" title=\"VDN\"></a>VDN</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.05296\">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p>\n<p>VDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p>\n<p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src=\"/../image/MARL/img_27.png\" alt=\"img_27.png\"></p>\n<p>作者假定如下等式成立：<br><img src=\"/../image/MARL/img_29.png\" alt=\"img_29.png\"></p>\n<p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p>\n<p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src=\"/../image/MARL/img_30.png\" alt=\"img_30.png\"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src=\"/../image/MARL/img_31.png\" alt=\"img_31.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_28.png\" alt=\"img_28.png\"></p>\n<p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p>\n<h2 id=\"QMIX\"><a href=\"#QMIX\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h2><p>论文：<a href=\"https://arxiv.org/abs/1803.11485\">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p>\n<p>深度多智能体强化学习的单调值函数分解</p>\n<p>QMIX是一个多智能体强化学习算法，具有如下特点： </p>\n<ol>\n<li>学习得到分布式策略。 </li>\n<li>本质是一个值函数逼近算法。 </li>\n<li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li>\n<li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li>\n<li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li>\n<li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li>\n<li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li>\n<li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li>\n<li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。</li>\n</ol>\n<h3 id=\"背景知识-1\"><a href=\"#背景知识-1\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"MARL核心问题\"><a href=\"#MARL核心问题\" class=\"headerlink\" title=\"MARL核心问题\"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p>\n<h4 id=\"Dec-POMDP\"><a href=\"#Dec-POMDP\" class=\"headerlink\" title=\"Dec-POMDP\"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src=\"/../image/MARL/img_32.png\" alt=\"img_32.png\"></p>\n<h4 id=\"IQL-1\"><a href=\"#IQL-1\" class=\"headerlink\" title=\"IQL\"></a>IQL</h4><p>IQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p>\n<h4 id=\"VDN-1\"><a href=\"#VDN-1\" class=\"headerlink\" title=\"VDN\"></a>VDN</h4><p>如前介绍：<br><img src=\"/../image/MARL/img_33.png\" alt=\"img_33.png\"></p>\n<h4 id=\"DRQN\"><a href=\"#DRQN\" class=\"headerlink\" title=\"DRQN\"></a>DRQN</h4><p>DRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p>\n<h3 id=\"QMIX-1\"><a href=\"#QMIX-1\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p>\n<p>QMIX约束条件：<br><img src=\"/../image/MARL/img_34.png\" alt=\"img_34.png\"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。</p>\n<p>具体网络结构如下：<br><img src=\"/../image/MARL/img_35.png\" alt=\"img_35.png\"></p>\n<p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p>\n<p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p>\n<p>为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p>\n<p>QMIX的Loss：<br><img src=\"/../image/MARL/img_36.png\" alt=\"img_36.png\"></p>\n<p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src=\"/../image/MARL/img_37.png\" alt=\"img_37.png\"></p>\n<p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p>\n<h2 id=\"QTRAN\"><a href=\"#QTRAN\" class=\"headerlink\" title=\"QTRAN\"></a>QTRAN</h2><p>论文：<a href=\"https://arxiv.org/abs/1905.05408\">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p>\n<p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p>\n<p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p>\n<p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p>\n<p><img src=\"/../image/MARL/img_38.png\" alt=\"img_38.png\"></p>\n<p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p>\n<p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src=\"/../image/MARL/img_41.png\" alt=\"img_41.png\"></p>\n<h3 id=\"TRAN-base\"><a href=\"#TRAN-base\" class=\"headerlink\" title=\"TRAN-base\"></a>TRAN-base</h3><p>分为三部分：</p>\n<ol>\n<li>独立 Q 网络</li>\n<li>联合 Q 网络</li>\n<li>联合 V 网络</li>\n</ol>\n<p>整体的Loss如下：<br><img src=\"/../image/MARL/img_39.png\" alt=\"img_39.png\"><br><img src=\"/../image/MARL/img_40.png\" alt=\"img_40.png\"></p>\n<h3 id=\"TRAN-alt\"><a href=\"#TRAN-alt\" class=\"headerlink\" title=\"TRAN-alt\"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p>\n<p>作者认为约束：<br><img src=\"/../image/MARL/img_42.png\" alt=\"img_42.png\"></p>\n<p>在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p>\n<p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src=\"/../image/MARL/img_43.png\" alt=\"img_43.png\"><br>这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p>\n<p><img src=\"/../image/MARL/img_44.png\" alt=\"img_44.png\"></p>\n<p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img.png\" alt=\"img.png\"></p>\n<h2 id=\"MFMARL\"><a href=\"#MFMARL\" class=\"headerlink\" title=\"MFMARL\"></a>MFMARL</h2><p>论文：<a href=\"https://arxiv.org/abs/1802.05438v4\">Mean Field Multi-Agent Reinforcement Learning</a></p>\n<p>平均场多智能体强化学习</p>\n<p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p>\n<p>MFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p>\n<p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p>\n<h3 id=\"背景知识-2\"><a href=\"#背景知识-2\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"随机博弈\"><a href=\"#随机博弈\" class=\"headerlink\" title=\"随机博弈\"></a>随机博弈</h4><p><img src=\"/../image/MARL/img_45.png\" alt=\"img_45.png\"></p>\n<h4 id=\"Nash-Q\"><a href=\"#Nash-Q\" class=\"headerlink\" title=\"Nash-Q\"></a>Nash-Q</h4><p><img src=\"/../image/MARL/img_46.png\" alt=\"img_46.png\"></p>\n<h3 id=\"Mean-Field-MARL\"><a href=\"#Mean-Field-MARL\" class=\"headerlink\" title=\"Mean Field MARL\"></a>Mean Field MARL</h3><p><img src=\"/../image/MARL/img_50.png\" alt=\"img_50.png\"></p>\n<h4 id=\"平均场近似\"><a href=\"#平均场近似\" class=\"headerlink\" title=\"平均场近似\"></a>平均场近似</h4><p><img src=\"/../image/MARL/img_47.png\" alt=\"img_47.png\"></p>\n<p><img src=\"/../image/MARL/img_48.png\" alt=\"img_48.png\"></p>\n<p><img src=\"/../image/MARL/img_49.png\" alt=\"img_49.png\"></p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p>\n<h4 id=\"MF-Q\"><a href=\"#MF-Q\" class=\"headerlink\" title=\"MF-Q\"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src=\"/../image/MARL/img_51.png\" alt=\"img_51.png\"></p>\n<p>对上式求导可以得出参数梯度方向如下:<br><img src=\"/../image/MARL/img_52.png\" alt=\"img_52.png\"></p>\n<p>通过梯度下降法可以得到参数更新公式。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img_53.png\" alt=\"img_53.png\"></p>\n<h4 id=\"MF-AC\"><a href=\"#MF-AC\" class=\"headerlink\" title=\"MF-AC\"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p>\n<p>类似SPG，actor策略梯度公式可以写为：<br><img src=\"/../image/MARL/img_54.png\" alt=\"img_54.png\"></p>\n<p>critic类似于MF-Q的更新方式(9)</p>\n<p><img src=\"/../image/MARL/img_55.png\" alt=\"img_55.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"/../image/MARL/img_56.png\" alt=\"img_56.png\"></p>\n<blockquote>\n<p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p>\n</blockquote>\n<blockquote>\n<p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p>\n</blockquote>\n<p>知乎专栏：<a href=\"https://www.zhihu.com/column/c_1061939147282915328\">https://www.zhihu.com/column/c_1061939147282915328</a></p>\n<h2 id=\"基础知识与博弈\"><a href=\"#基础知识与博弈\" class=\"headerlink\" title=\"基础知识与博弈\"></a>基础知识与博弈</h2><h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p>\n<p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p>\n<ol>\n<li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li>\n<li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li>\n<li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li>\n<li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li>\n</ol>\n<p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p>\n<h3 id=\"纳什均衡\"><a href=\"#纳什均衡\" class=\"headerlink\" title=\"纳什均衡\"></a>纳什均衡</h3><p><img src=\"/../image/MARL/img_1.png\" alt=\"img_1.png\"></p>\n<h3 id=\"完全混合策略\"><a href=\"#完全混合策略\" class=\"headerlink\" title=\"完全混合策略\"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p>\n<h3 id=\"纯策略\"><a href=\"#纯策略\" class=\"headerlink\" title=\"纯策略\"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p>\n<h3 id=\"零和博弈\"><a href=\"#零和博弈\" class=\"headerlink\" title=\"零和博弈\"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p>\n<h3 id=\"一般和博弈\"><a href=\"#一般和博弈\" class=\"headerlink\" title=\"一般和博弈\"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p>\n<blockquote>\n<p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href=\"https://zhuanlan.zhihu.com/p/53474965\">https://zhuanlan.zhihu.com/p/53474965</a></p>\n</blockquote>\n<h2 id=\"Minimax-Q\"><a href=\"#Minimax-Q\" class=\"headerlink\" title=\"Minimax-Q\"></a>Minimax-Q</h2><p>论文：<a href=\"https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf\">Markov games as a framework for multi-agent reinforcement learning</a></p>\n<p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p>\n<p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p>\n<p><img src=\"/../image/MARL/img_2.png\" alt=\"img_2.png\"></p>\n<p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p>\n<ol>\n<li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li>\n<li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li>\n<li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li>\n</ol>\n<h2 id=\"Nash-Q-Learning\"><a href=\"#Nash-Q-Learning\" class=\"headerlink\" title=\"Nash Q-Learning\"></a>Nash Q-Learning</h2><p>论文：<a href=\"https://www.jmlr.org/papers/volume4/temp/hu03a.pdf\">Nash Q-learning for general-sum stochastic games</a></p>\n<p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_3.png\" alt=\"img_3.png\"></p>\n<p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p>\n<h2 id=\"Friend-or-Foe-Q-Learning\"><a href=\"#Friend-or-Foe-Q-Learning\" class=\"headerlink\" title=\"Friend-or-Foe Q-Learning\"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href=\"https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf\">Friend-or-foe Q-learning in general-sum games</a></p>\n<p>Friend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p>\n<p>其纳什均衡策略求解方法如下所示：</p>\n<p><img src=\"/../image/MARL/img_4.png\" alt=\"img_4.png\"></p>\n<p>算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_5.png\" alt=\"img_5.png\"></p>\n<p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p>\n<p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p>\n<p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p>\n<h2 id=\"WoLF-Policy-Hill-Climbing\"><a href=\"#WoLF-Policy-Hill-Climbing\" class=\"headerlink\" title=\"WoLF Policy Hill-Climbing\"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href=\"https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk\">Multiagent learning using a variable learning rate</a></p>\n<p><img src=\"/../image/MARL/img_6.png\" alt=\"img_6.png\"></p>\n<p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p>\n<p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_7.png\" alt=\"img_7.png\"></p>\n<p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p>\n<p>其算法流程如下所示：</p>\n<p><img src=\"/../image/MARL/img_8.png\" alt=\"img_8.png\"></p>\n<blockquote>\n<p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href=\"https://www.cnblogs.com/zuti666/p/16909220.html\">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/53563792\">https://zhuanlan.zhihu.com/p/53563792</a></p>\n</blockquote>\n<h2 id=\"MADDPG\"><a href=\"#MADDPG\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.02275\">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p>\n<p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p>\n<p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p>\n<p>MADDPG算法具有以下三点特征： </p>\n<ol>\n<li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li>\n<li>不需要知道环境的动力学模型以及特殊的通信需求。 </li>\n<li>该算法不仅能用于合作环境，也能用于竞争环境。</li>\n</ol>\n<p>MADDPG算法具有以下三点技巧：</p>\n<ol>\n<li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li>\n<li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li>\n<li>利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li>\n</ol>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4><p>深度Q网络（deep Q-network）<br><img src=\"/../image/MARL/img_9.png\" alt=\"img_9.png\"></p>\n<h4 id=\"SPG\"><a href=\"#SPG\" class=\"headerlink\" title=\"SPG\"></a>SPG</h4><p>随机策略梯度（stochastic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_10.png\" alt=\"img_10.png\"></p>\n<h4 id=\"DPG\"><a href=\"#DPG\" class=\"headerlink\" title=\"DPG\"></a>DPG</h4><p>确定性策略梯度（deterministic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_11.png\" alt=\"img_11.png\"></p>\n<h3 id=\"MADDPG-1\"><a href=\"#MADDPG-1\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h3><h4 id=\"多智能体AC设计\"><a href=\"#多智能体AC设计\" class=\"headerlink\" title=\"多智能体AC设计\"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src=\"/../image/MARL/img_12.png\" alt=\"img_12.png\"><br><img src=\"/../image/MARL/img_13.png\" alt=\"img_13.png\"></p>\n<h4 id=\"估计其他智能体策略\"><a href=\"#估计其他智能体策略\" class=\"headerlink\" title=\"估计其他智能体策略\"></a>估计其他智能体策略</h4><p><img src=\"/../image/MARL/img_14.png\" alt=\"img_14.png\"></p>\n<h4 id=\"策略集合优化\"><a href=\"#策略集合优化\" class=\"headerlink\" title=\"策略集合优化\"></a>策略集合优化</h4><p><img src=\"/../image/MARL/img_15.png\" alt=\"img_15.png\"></p>\n<h3 id=\"相关PPT\"><a href=\"#相关PPT\" class=\"headerlink\" title=\"相关PPT\"></a>相关PPT</h3><p><img src=\"/../image/MARL/img_16.png\" alt=\"img_16.png\"><br><img src=\"/../image/MARL/img_17.png\" alt=\"img_17.png\"><br><img src=\"/../image/MARL/img_18.png\" alt=\"img_18.png\"><br><img src=\"/../image/MARL/img_19.png\" alt=\"img_19.png\"><br><img src=\"/../image/MARL/img_20.png\" alt=\"img_20.png\"></p>\n<h2 id=\"IQL\"><a href=\"#IQL\" class=\"headerlink\" title=\"IQL\"></a>IQL</h2><p>论文：<a href=\"https://arxiv.org/abs/1511.08779\">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p>\n<p>Independent Q-Learning</p>\n<p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。</p>\n<p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p>\n<p>IQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p>\n<p>其他没啥要讲的。。。</p>\n<p><img src=\"/../image/MARL/img_21.png\" alt=\"img_21.png\"></p>\n<h2 id=\"COMA\"><a href=\"#COMA\" class=\"headerlink\" title=\"COMA\"></a>COMA</h2><p>论文：<a href=\"https://arxiv.org/abs/1705.08926\">Counterfactual Multi-Agent Policy Gradients</a></p>\n<p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src=\"/../image/MARL/img_23.png\" alt=\"img_23.png\"></p>\n<p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p>\n<p>那么这些算法都在解决什么问题呢？</p>\n<p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。</p>\n<p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。</p>\n<p><img src=\"/../image/MARL/img_24.png\" alt=\"img_24.png\"></p>\n<p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p>\n<p><img src=\"/../image/MARL/img_25.png\" alt=\"img_25.png\"></p>\n<p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p>\n<p>COMA算法具体框架如下图所示：<br><img src=\"/../image/MARL/img_22.png\" alt=\"img_22.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_26.png\" alt=\"img_26.png\"></p>\n<h2 id=\"VDN\"><a href=\"#VDN\" class=\"headerlink\" title=\"VDN\"></a>VDN</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.05296\">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p>\n<p>VDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p>\n<p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src=\"/../image/MARL/img_27.png\" alt=\"img_27.png\"></p>\n<p>作者假定如下等式成立：<br><img src=\"/../image/MARL/img_29.png\" alt=\"img_29.png\"></p>\n<p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p>\n<p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src=\"/../image/MARL/img_30.png\" alt=\"img_30.png\"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src=\"/../image/MARL/img_31.png\" alt=\"img_31.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_28.png\" alt=\"img_28.png\"></p>\n<p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p>\n<h2 id=\"QMIX\"><a href=\"#QMIX\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h2><p>论文：<a href=\"https://arxiv.org/abs/1803.11485\">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p>\n<p>深度多智能体强化学习的单调值函数分解</p>\n<p>QMIX是一个多智能体强化学习算法，具有如下特点： </p>\n<ol>\n<li>学习得到分布式策略。 </li>\n<li>本质是一个值函数逼近算法。 </li>\n<li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li>\n<li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li>\n<li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li>\n<li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li>\n<li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li>\n<li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li>\n<li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。</li>\n</ol>\n<h3 id=\"背景知识-1\"><a href=\"#背景知识-1\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"MARL核心问题\"><a href=\"#MARL核心问题\" class=\"headerlink\" title=\"MARL核心问题\"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p>\n<h4 id=\"Dec-POMDP\"><a href=\"#Dec-POMDP\" class=\"headerlink\" title=\"Dec-POMDP\"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src=\"/../image/MARL/img_32.png\" alt=\"img_32.png\"></p>\n<h4 id=\"IQL-1\"><a href=\"#IQL-1\" class=\"headerlink\" title=\"IQL\"></a>IQL</h4><p>IQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p>\n<h4 id=\"VDN-1\"><a href=\"#VDN-1\" class=\"headerlink\" title=\"VDN\"></a>VDN</h4><p>如前介绍：<br><img src=\"/../image/MARL/img_33.png\" alt=\"img_33.png\"></p>\n<h4 id=\"DRQN\"><a href=\"#DRQN\" class=\"headerlink\" title=\"DRQN\"></a>DRQN</h4><p>DRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p>\n<h3 id=\"QMIX-1\"><a href=\"#QMIX-1\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p>\n<p>QMIX约束条件：<br><img src=\"/../image/MARL/img_34.png\" alt=\"img_34.png\"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。</p>\n<p>具体网络结构如下：<br><img src=\"/../image/MARL/img_35.png\" alt=\"img_35.png\"></p>\n<p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p>\n<p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p>\n<p>为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p>\n<p>QMIX的Loss：<br><img src=\"/../image/MARL/img_36.png\" alt=\"img_36.png\"></p>\n<p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src=\"/../image/MARL/img_37.png\" alt=\"img_37.png\"></p>\n<p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p>\n<h2 id=\"QTRAN\"><a href=\"#QTRAN\" class=\"headerlink\" title=\"QTRAN\"></a>QTRAN</h2><p>论文：<a href=\"https://arxiv.org/abs/1905.05408\">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p>\n<p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p>\n<p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p>\n<p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p>\n<p><img src=\"/../image/MARL/img_38.png\" alt=\"img_38.png\"></p>\n<p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p>\n<p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src=\"/../image/MARL/img_41.png\" alt=\"img_41.png\"></p>\n<h3 id=\"TRAN-base\"><a href=\"#TRAN-base\" class=\"headerlink\" title=\"TRAN-base\"></a>TRAN-base</h3><p>分为三部分：</p>\n<ol>\n<li>独立 Q 网络</li>\n<li>联合 Q 网络</li>\n<li>联合 V 网络</li>\n</ol>\n<p>整体的Loss如下：<br><img src=\"/../image/MARL/img_39.png\" alt=\"img_39.png\"><br><img src=\"/../image/MARL/img_40.png\" alt=\"img_40.png\"></p>\n<h3 id=\"TRAN-alt\"><a href=\"#TRAN-alt\" class=\"headerlink\" title=\"TRAN-alt\"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p>\n<p>作者认为约束：<br><img src=\"/../image/MARL/img_42.png\" alt=\"img_42.png\"></p>\n<p>在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p>\n<p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src=\"/../image/MARL/img_43.png\" alt=\"img_43.png\"><br>这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p>\n<p><img src=\"/../image/MARL/img_44.png\" alt=\"img_44.png\"></p>\n<p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img.png\" alt=\"img.png\"></p>\n<h2 id=\"MFMARL\"><a href=\"#MFMARL\" class=\"headerlink\" title=\"MFMARL\"></a>MFMARL</h2><p>论文：<a href=\"https://arxiv.org/abs/1802.05438v4\">Mean Field Multi-Agent Reinforcement Learning</a></p>\n<p>平均场多智能体强化学习</p>\n<p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p>\n<p>MFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p>\n<p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p>\n<h3 id=\"背景知识-2\"><a href=\"#背景知识-2\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"随机博弈\"><a href=\"#随机博弈\" class=\"headerlink\" title=\"随机博弈\"></a>随机博弈</h4><p><img src=\"/../image/MARL/img_45.png\" alt=\"img_45.png\"></p>\n<h4 id=\"Nash-Q\"><a href=\"#Nash-Q\" class=\"headerlink\" title=\"Nash-Q\"></a>Nash-Q</h4><p><img src=\"/../image/MARL/img_46.png\" alt=\"img_46.png\"></p>\n<h3 id=\"Mean-Field-MARL\"><a href=\"#Mean-Field-MARL\" class=\"headerlink\" title=\"Mean Field MARL\"></a>Mean Field MARL</h3><p><img src=\"/../image/MARL/img_50.png\" alt=\"img_50.png\"></p>\n<h4 id=\"平均场近似\"><a href=\"#平均场近似\" class=\"headerlink\" title=\"平均场近似\"></a>平均场近似</h4><p><img src=\"/../image/MARL/img_47.png\" alt=\"img_47.png\"></p>\n<p><img src=\"/../image/MARL/img_48.png\" alt=\"img_48.png\"></p>\n<p><img src=\"/../image/MARL/img_49.png\" alt=\"img_49.png\"></p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p>\n<h4 id=\"MF-Q\"><a href=\"#MF-Q\" class=\"headerlink\" title=\"MF-Q\"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src=\"/../image/MARL/img_51.png\" alt=\"img_51.png\"></p>\n<p>对上式求导可以得出参数梯度方向如下:<br><img src=\"/../image/MARL/img_52.png\" alt=\"img_52.png\"></p>\n<p>通过梯度下降法可以得到参数更新公式。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img_53.png\" alt=\"img_53.png\"></p>\n<h4 id=\"MF-AC\"><a href=\"#MF-AC\" class=\"headerlink\" title=\"MF-AC\"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p>\n<p>类似SPG，actor策略梯度公式可以写为：<br><img src=\"/../image/MARL/img_54.png\" alt=\"img_54.png\"></p>\n<p>critic类似于MF-Q的更新方式(9)</p>\n<p><img src=\"/../image/MARL/img_55.png\" alt=\"img_55.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"/../image/MARL/img_56.png\" alt=\"img_56.png\"></p>\n<blockquote>\n<p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p>\n</blockquote>\n"},{"title":"Python知识点","keywords":["面经"],"description":"Python知识点","abbrlink":17776,"date":"2024-06-27T08:32:01.000Z","updated":"2024-06-26T08:15:15.000Z","top_img":"https://s2.loli.net/2024/06/27/2XLqopQdfBKZ5s3.png","comments":1,"cover":"https://s2.loli.net/2024/06/27/RATGUg5c6FXC7mH.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n\n\n","source":"_posts/Python知识点.md","raw":"---\ntitle: Python知识点\ntags:\n  - C++\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: Python知识点\nabbrlink: 17776\ndate: 2024-06-27 16:32:01\nupdated: 2024-06-26 16:15:15\ntop_img: https://s2.loli.net/2024/06/27/2XLqopQdfBKZ5s3.png\ncomments:\ncover: https://s2.loli.net/2024/06/27/RATGUg5c6FXC7mH.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n\n\n","slug":"Python知识点","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1m0007r7gn9opmgl73","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":""},{"title":"Java后端面经","keywords":["面经"],"description":"Java后端面经","abbrlink":17766,"date":"2024-05-27T11:58:53.000Z","updated":"2024-06-25T08:46:23.000Z","top_img":"https://s2.loli.net/2024/05/27/ytcdAHzliRquNM2.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## 简历相关\n\n### 自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！\n\n### Casbin明日之星实习\n\n1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。\n\n2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。\n\n3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。\n\n### 中科院开源之夏项目\n\n**简介**\nCasdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。\n\n**项目诉求**\n1. 对微信第三方登录的移动端支持\n    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。\n\n2. 对flutter、react-native、unity等sdk的开发及功能的增强\n    - 对flutter-sdk的增强如第一点\n\n3. 临时加上的开发casdoor-app诉求，对标Google Authenticator\n\n**技术细节**\n1. 在flutter-sdk中通过截取`session`中的`url`和`callbackURLscheme`判断其中是否有\"weixin\"字段，如果有，则进行微信第三方原生授权登录；\n    - 使用`WKWebView`替换原本的`ASWebAuthenticationSession`，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；\n    - 使用rb脚本文件自动化配置微信SDK导入后xcode中`xcodeproj`文件的相关配置；\n    - 接入`xcframework`的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；\n\n    接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置`universal Link`，需付费几百美元，所以最终代码并未实际测试。\n2. 分为两部分\n    1. casdoor-unity-example\n        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；\n        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；\n        - 在casdoor服务端配置好应用的`clientCode`和`clientSecret`后，在Unity3D中向服务端发送认证请求(`cilentCode`等)，解析返回的`token`，就可以得到用户信息，也可以使用`session`保存`token`等信息。\n        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。\n    2. casdoor-react-native-sdk、example\n        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；\n        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。\n        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 `code_challenge` 和 `code_verifier` 。\n3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。\n    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。\n    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。\n\n> SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。\n\n**总结**\n参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。\n\n### 单点登录SSO原理\n单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。\n\n在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。\n\n流程：\n1. 用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的`session`里面，浏览器也会写入SSO域下的`cookie`。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到`session`中，并设置app域下的`cookie`，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。\n2. 此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到`session`，并在app2的域下写入一个`cookie`。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的`session`不共享，也没有任何问题。\n\nSSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，\n\n### OAuth 2.0原理\nhttps://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\n\nOAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。\n\n定义了4种角色：\n\n- 用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。\n- 应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。\n- 资源服务器：资源服务器托管受保护的用户帐户的资源。\n- 授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。\n\n步骤：\n1. 应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。\n2. 如果用户授权该请求，应用程序会收到授权准许(`Authorization Grant`)。\n3. 应用程序通过提供其自身的身份验证和授权准许(`Authorization Grant`)来向授权服务器 (API) 请求访问令牌(`access_token`)。\n4. 如果应用程序身份通过验证且授权准许(`Authorization Grant`)有效，则授权服务器(API)向应用程序颁发访问令牌(`access_token`)。授权完成。\n5. 应用程序从资源服务器(API)请求资源并提供访问令牌(`access_token`)进行身份验证。\n6. 如果访问令牌(`access_token`)有效，则资源服务器 (API) 向应用程序提供资源。\n\n授权准许(`Authorization Grant`)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：\n\n1. 授权码(`Authorization Code`)：与服务器端应用程序一起使用。\n2. 客户端凭证(`Client Credentials`)：与具有 API 访问权限的应用程序一起使用。\n3. 设备代码(`Device Code`)：用于缺少浏览器或有输入限制的设备。\n\n### 2FA\n两因素认证(`Two-Factor Authentication, 2FA)`是一种安全系统，用于确保用户登录到账户或访问资源时，需要通过两种不同类型的验证方式。这种方法比仅依靠密码更安全，因为它增加了额外的验证层，使得即使密码被泄露，攻击者仍然难以访问用户账户。\n\n身份验证因素：2FA通常结合两种不同的验证因素，分三类：\n- 知识因素(Something you know)：用户知道的东西，例如密码、PIN码、回答安全问题等。\n- 持有因素(Something you have)：用户拥有的物品，例如手机、硬件令牌、智能卡等。\n- 固有因素(Something you are)：用户自身的特征，例如指纹、面部识别、声音识别等生物特征。\n\n验证过程：\n- 第一步：输入用户名和密码：用户首先输入他们的用户名和密码(知识因素)。\n- 第二步：额外验证：系统会要求用户进行第二步验证。这可以是：  \n  - 一次性密码(OTP)：通过短信、电子邮件或专用应用程序(如Google Authenticator、Authy)生成并发送给用户的随机密码。\n  - 硬件令牌：用户插入或展示硬件令牌生成的代码。\n  - 生物特征识别：用户通过指纹、面部识别等方式进行验证。\n\n验证成功：如果两步验证都通过，用户将获得访问权限。\n验证失败：如果任何一步失败，访问将被拒绝。\n\n### PKCE\nPKCE(`Proof Key for Code Exchange, PKCE`)是一种用于保护OAuth 2.0授权码授权流程的机制，主要目的是防止授权码拦截攻击(Authorization Code Interception Attack)。\n\n原理：\nPKCE通过在OAuth 2.0授权码请求和令牌交换过程中引入一个随机生成的`code_challenge`和`code_verifier`来增强安全性。具体来说，PKCE引入了两个新参数：\n- `code_verifier`：一个高熵的随机字符串，客户端在请求`code`(授权码)时生成并保存。\n- `code_challenge`：由`code_verifier`生成的一个变体，发送给授权服务器。可以是`code_verifier`本身，或者是`code_verifier`的SHA256哈希值。\n\n流程：\n1. 客户端生成一个随机的`code_challenge`和`code_verifier`，`code_verifier`可以是明文(`plain`)SHA256哈希值(`s256`)。\n2. 客户端将`code_challenge`和`code_challenge_method`(`plain`或`s256`)发送给授权服务器。\n   - 如：`GET /authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=SCOPE&state=STATE&code_challenge=CODE_CHALLENGE&code_challenge_method=S256`\n3. 用户在授权服务器进行身份验证，同意授权，授权服务器通过重定向URI将`code`(授权码)返回给客户端。\n4. 客户端将`code`(授权码)和`code_verifier`发送给授权服务器，以获取`access_token`(访问令牌)。\n   - 如：`POST /token?grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=REDIRECT_URI&client_id=CLIENT_ID&code_verifier=CODE_VERIFIER`\n5. 授权服务器收到客户端发送的`code`(授权码)和`code_verifier`后，使用之前保存的`code_challenge`进行验证。\n   - 如果`code_challenge_method`是`plain`，则直接比较`code_verifier`和`code_challenge`。\n   - 如果`code_challenge_method`是`s256`，则比较`code_verifier`的SHA256哈希值和`code_challenge`。\n6. 如果验证通过，授权服务器返回`access_token`(访问令牌)给客户端。\n\n这样，即使`code`(授权码)在传输过程中被拦截，攻击者也无法使用该`code`(授权码)，因为缺少正确的`code_verifier`。\n\n### OTP/TOTP/HOTP\nOTP (One-Time Password) 是一种一次性有效的密码，通常用于两因素身份验证(2FA)。每次使用 OTP 进行身份验证后，这个密码便失效，无法再使用。OTP 提高了安全性，因为即使密码被截获或暴力破解，也不能再次使用。OTP 生成和使用的方式有很多种，包括基于时间的(TOTP)和基于事件的(HOTP)。\n\n**TOTP(基于时间的一次性密码)**\nTOTP (Time-Based One-Time Password) 是 OTP 的一种，它基于当前时间生成密码。TOTP 是 HOTP 的扩展，结合了时间元素来提高安全性。TOTP 的工作原理如下：\n1. 共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 TOTP。\n2. 时间段：TOTP 使用当前时间的一个窗口(通常是 30 秒)来生成密码。每个时间段内生成的密码是唯一的。\n3. 算法：TOTP 使用 HMAC-SHA1 算法和共享密钥以及当前时间戳来生成密码。\n\n**生成和验证**\n- 生成 TOTP：用户的设备(如手机上的 Google Authenticator 应用)使用共享密钥和当前时间生成 TOTP。\n- 验证 TOTP：服务器使用同样的共享密钥和当前时间计算 TOTP，并与用户提供的 TOTP 进行对比。如果匹配，则验证成功。\n\n**优点**\n- 安全性高：每个密码只能使用一次，有效时间短，降低了被攻击的风险。\n- 易于使用：用户只需要输入一次性密码，而不需要记住复杂的密码。\n- 灵活性：适用于各种应用场景，如登录、交易验证等。\n\n**缺点**\n- 时间同步：TOTP 依赖于设备和服务器时间的同步，如果时间不同步，可能会导致验证失败。\n- 设备依赖：需要用户拥有生成 OTP 或 TOTP 的设备，如智能手机。\n\n**HOTP(基于事件的一次性密码)**\nHOTP (HMAC-Based One-Time Password) 是一种基于事件的 OTP(一次性密码)生成方法。HOTP 的生成与验证基于 HMAC-SHA1 算法及一个计数器，确保每次生成的密码都是唯一的。HOTP 的工作原理如下：\n1. 共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 HOTP。\n2. 计数器：用户和服务器都维护一个计数器，计数器初始值相同，每次生成或验证 OTP 时都会增加计数器的值。\n3. HMAC-SHA1 算法：HOTP 使用 HMAC-SHA1 算法，将共享密钥和计数器作为输入，生成一个哈希值。\n4. 生成 OTP：从哈希值中提取部分数据(通常是取哈希值的后几位)，将其转换为一个短数字串，即 OTP。\n\n**生成和验证**\n- 生成 HOTP：用户的设备使用共享密钥和计数器生成 HOTP。\n- 验证 HOTP：服务器使用同样的共享密钥和计数器计算 HOTP，并与用户提供的 OTP 进行对比。如果匹配，则验证成功，并增加计数器的值。\n\n**优点**\n- 无时间依赖：HOTP 不依赖于设备和服务器时间的同步，避免了时间不同步带来的问题。\n- 安全性高：每个密码只能使用一次，降低了密码被截获或重复使用的风险。\n- 灵活性：适用于各种应用场景，如登录、交易验证等。\n\n**缺点**\n- 计数器同步：用户和服务器必须保持计数器的同步，否则会导致验证失败。如果计数器不同步，需要有机制进行重新同步。\n- 复杂性：相较于静态密码，HOTP 的实现和维护相对复杂。\n\n**使用场景**\n- 银行和金融服务：TOTP/HOTP 经常用于网上银行和金融交易中，以确保只有授权用户才能进行操作。\n- 企业安全：企业系统常使用 TOTP/HOTP 进行多因素身份验证，以保护敏感数据和资源。\n- 社交媒体和电子邮件：为了防止账户被黑客入侵，许多社交媒体和电子邮件服务提供商都提供 TOTP/HOTP 作为额外的安全措施。\n\n### Casbin Casdoor 介绍\n> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 \n> Casbin 的主要特点包括：\n> 1. 多种访问控制模型支持：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。\n> 2. 灵活的策略管理：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。\n> 3. 细粒度的权限控制：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。\n> 4. 跨语言支持：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。\n\n> Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。\n> 1. 单点登录(SSO)：支持统一身份验证，用户只需登录一次即可访问多个应用系统。\n> 2. 用户管理：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。\n> 3. 权限控制：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。\n> 4. 开源社区：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。\n\n### RESTful API\n> RESTful API(`Representational State Transfer API`)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。\n> REST架构原则：\n> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。\n> - 统一接口： 资源：通过URL定位资源(通常是名词，如 `/users` 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： `GET`：获取资源 `POST`：创建资源 `PUT`：更新资源 `DELETE`：删除资源\n> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。\n> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。\n> - 按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。\n>\n> 特点：\n> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 \n> - 标准化操作：利用HTTP动词来描述对资源的操作。 \n> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 \n> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 \n> - 无状态交互：每个请求独立，不依赖于之前的请求。\n> \n> 优点 \n> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 \n> - 性能高：无状态和可缓存性提高了性能。 \n> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 \n> - 灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。\n> \n> 缺点 \n> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。\n> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 \n> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。\n> \n> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。\n\n### 国家电网项目\n\n**简介**\n\n自己导师接的项目，江苏省国家电网智能诊断数据分析平台\n\n**项目诉求**\n- 对相应指标进行增删改查\n- 可以导入、导出一些excel表格\n- 对数据进行智能诊断分析\n\n**技术细节**\nreact、Antd、Flask、mongodb\n\n**我的职责**\n在项目中，负责实现各项重要指标的计算、以及对各指标进行灵活的增删改查，实现数据的存取以及前端展示等功能。\n\n### 为什么使用mongodb\nmongodb是一个非关系型数据库，采用文档存储模型，数据以BSON格式存储。项目中，需要导入或者导出 Excel 表格，一个 Excel文件正好可以对应mongodb中的一个文档，这样可以方便地将 Excel 中的数据导入到 mongodb 中。\n\n### 江南布衣实习\n在公司实习期间，我担任网络工程师实习生，主要负责以下工作：\n\n1. 新入职员工设备管理：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。\n\n2. 离职员工设备回收和资料销毁：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>\n\n3. 订货会期间设备组装和网络连接：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。\n\n4. 员工设备报修响应与问题解决：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。\n\n通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。\n\n> **公司内网**：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。\n> 要使一台电脑接入公司内网，经过以下步骤：\n> \n> 1. 网络配置：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。\n> 2. 身份验证：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。\n> 3. 访问内部资源：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。\n\n### 印象最深的一个项目\n之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。\n\n**亮点**\n1. **异步支持**：\n    - 亮点：代码中使用了 `AsyncSession` 和 `async with` 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。\n    - 回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。\n2. **灵活的过滤机制**：\n    - 亮点：通过 `Filter` 类和 `filter_query` 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。\n    - 回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。\n3. **可扩展性**：\n    - 亮点：支持自定义 `db_class`，可以根据不同的需求定制存储策略。同时，默认的 `CasbinRule` 类提供了一个通用的实现。\n    - 回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。\n4. **事务处理**：\n    - 亮点：使用了 `_session_scope` 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。\n    - 回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。\n\n**难点**\n1. **异步编程的复杂性**：\n    - 难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。\n    - 回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。\n2. **数据库模型的灵活性与一致性**：\n    - 难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。\n    - 回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。\n3. **复杂的策略更新逻辑**：\n    - 难点：如 `update_policy` 和 `update_policies` 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。\n    - 回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。\n4. **高效的批量操作**：\n    - 难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。\n    - 回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。\n\n测试方面\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：说明使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。\n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n    - 测试添加一个策略，添加多个策略\n    - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n    - 测试更新一个策略，测试更新多个策略。\n\n通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。\n\n### 学生生涯遇到的挫折和应对策略\n高一升高二的时候，当时是从一个普通班进入全校最好的英才班嘛。然后第一次考试，我考了全班倒数第三，当时从普通班的前几名到倒数第三，可谓是很大的打击，我从小到大就没考过这么差的名词，当时很伤心沮丧吧，回家在房间偷偷哭。\n\n但我也知道，哭是没有用的，我跟别人的差距是确实存在的，从那次后，我比别人更加努力，我花别人更多的时间去学习，去做题，去复习。不会的知识点也请教老师和同学，他们也都很乐意帮助我，我很感谢他们。争取把遇到的每个不会的知识点攻克，我也慢慢的感觉到自己的进步，从才开始的在英才班倒数，到中游 10-20名这样子，到最后高考的时候，考了英才班第四名。\n\n我觉得吧，从这个经历中，我学到了很多，比如说遇到困难要找对方法才行，其次就是要有毅力，不要轻易放弃，最后就是要有信心，相信自己可以做到。\n\n最让我有感触的是，让我学会了 任何时候，都要对自己有信心，不要怀疑自己的能力，相信自己可以做到。这点在我后面的大学学习、跨专业保研中起到了很重要的作用。\n\n## Java基础\n\n### Java和C++的区别\nJava 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：\n- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；\n- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；\n- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；\n- C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。\n\n> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。\n\n### 移位运算符\n`<<`：左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。\n`>>`：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。\n`>>>`：无符号右移，忽略符号位，空位都以 0 补齐。\n\n使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。\n\n如果移位的位数超过数值所占有的位数会怎样？\n当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余(%)** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作(32%32=0)，左移/右移 42 位相当于左移/右移 10 位(42%32=10)。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。\n\n### 基本数据类型/包装类型 及区别\n**8种基本数据类型**\n- 6 种数字类型： \n  - 4 种整数型：`byte`、`short`、`int`、`long`\n  - 2 种浮点型：`float`、`double`\n- 1 种字符类型：`char`\n- 1 种布尔型：`boolean`\n\n> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 \n> `char a = 'h'`，`char`： 单引号，`String a = \"hello\"`，`String`： 双引号。\n\n**8种包装类型** \n`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n**区别**\n- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。\n- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 `static` 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。\n- 占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。\n- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。\n- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。\n\n### 包装类的缓存机制\nJava 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。\n\n### 什么是自动拆装箱\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n- 装箱：将基本类型用它们对应的引用类型包装起来；\n- 拆箱：将包装类型转换为基本数据类型；\n\n从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。\n\n### 如何解决浮点数运算的精度丢失问题\n\n无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 `BigDecimal` 来做的。\n\n### 局部变量/成员变量/静态变量\n\n- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\n- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\n- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 `final` 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。\n\n静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。\n\n### 重载和重写\n- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\n  - 构造方法无法被重写\n\n### 面向对象和面向过程区别\n两者的主要区别在于解决问题的方式不同：\n- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\n- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\n\n另外，面向对象开发的程序一般更易维护、易复用、易扩展。\n\n### 接口和抽象类区别\n共同点： 都不能被实例化\nhttps://learn.skyofit.com/archives/351\n**区别**\n- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。\n- 抽象类可以有构造方法，接口不能有构造方法。\n- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。\n- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。\n- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。\n- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。\n\n### 堆和栈的区别\nhttps://blog.csdn.net/qq_44944221/article/details/126692973\n- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；\n- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；\n\n区别：\n- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；\n- 共享性不同：栈是线程私有，而堆是线程共享；\n- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；\n- 空间大小不同：堆空间大小远远大于栈的内存空间。\n\n### 深拷贝/浅拷贝/引用拷贝\n- 深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。\n- 浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n- 引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？\n\n### Object 类\nObject 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：\n```java\n//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\npublic final native Class<?> getClass()\n\n//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\npublic native int hashCode()\n\n//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\npublic boolean equals(Object obj)\n\n//native 方法，用于创建并返回当前对象的一份拷贝。\nprotected native Object clone() throws CloneNotSupportedException\n\n//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\npublic String toString()\n\n//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable { }\n```\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n  - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n  - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 形参&实参\n- 形参(形式参数，Parameters)：用于定义函数/方法，接收实参，不需要有确定的值。\n- 实参(实际参数，Arguments)：用于传递给函数/方法的参数，必须有确定的值。\n\n### 值传递&引用传递\n- 值传递：方法接收的是实参值的拷贝，会创建副本。\n- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。\n\nJava 中只有值传递，C++ 中有值传递和引用传递。\n\n### ==和equals()区别\n- `==` 可以用来比较基本数据类型和引用数据类型\n  - 基本数据类型：比较的是值是否相等\n  - 引用数据类型：比较的是引用地址是否相等\n  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。\n- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。\n  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。\n  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。\n\n### hashCode()和equal()\n`hashCode()` 的作用是获取哈希码(`int` 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n\n`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。\n- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等(**哈希碰撞**)。\n- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。\n- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。\n\n**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**\n因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。\n\n### String/StringBuffer/StringBuilder\n- `String` ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。\n- `StringBuffer` ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。\n- `StringBuilder` ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。\n\n- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。\n- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。\n- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n** `String` 为什么不可变？**\n- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。\n- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。\n\n### 字符串拼接使用+还是StringBuilder？\nJava中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。\n\n### String.equals()/Object.equals()\n`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。\n\n### 字符串常量池\n**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n\n### 异常\n异常的共同祖先是 `Throwable` 类，其有两个重要的子类：\n`Error`： 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。\n`Exception`： 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。\n\n### Checked/Unchecked Exception\n- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。\n  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。\n- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。\n  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。\n\n### try-catch-finally\n`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。\n`catch`：用于处理 `try` 捕获到的异常。\n`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。\n\n> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。\n\n### 泛型\n- 使用泛型参数，可以增强代码的可读性以及稳定性。\n- 泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。\n\n### 反射\n反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。\n\n- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n\n### 注解\n注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。\n\n### 序列化/反序列化\n如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n- 序列化：将数据结构或对象转换成二进制字节流的过程\n- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\n\n序列化和反序列化常见应用场景：\n- 对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；\n- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；\n- 将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；\n- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。\n\n### 语法糖\n语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。\n\nJava 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。\n\n## Java集合\n\n### List/Set/Queue/Map区别\n- List： 存储的元素是有序的、可重复的。\n- Set： 存储的元素不可重复的。\n- Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\n- Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n### 如何选用集合?\n主要根据集合的特点来选择合适的集合。如：\n- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。\n- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。\n\n### 为什么要使用集合？\n在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\n\n### ArrayList和Array区别\n`ArrayList` 内部基于动态数组实现，比 `Array`(静态数组) 更加灵活：\n- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。\n- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。\n- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。\n- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。\n- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。\n\n> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。\n\n### ArrayList和LinkedList区别\n- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。\n  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。\n  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。\n- 二者都是线程不安全的。\n- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。\n- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。\n\n> 项目中一般不会使用 `LinkedList`。\n\n### ArrayList和LinkedList插入/删除效率\n`ArrayList`\n- 头部插入/删除：O(n), 需要移动元素。\n- 指定位置插入/删除：O(n), 需要移动元素。\n- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\n`LinkedList`\n- 头部插入/删除：O(1), 只需改变指针指向。\n- 尾部插入/删除：O(1), 只需改变指针指向。\n- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。\n\n### CopyOnWriteArrayList\n`CopyOnWriteArrayList` 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 `Copy-On-Write(COW)`的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：\n- 读多写少：大部分操作都是读取数据，写操作相对较少。\n- 不要求实时性：因为写操作需要创建数组副本，可能会有短暂的延迟。\n\n`ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。\n\n**优点**\n- 线程安全：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。\n- 简化并发控制：不需要显式的同步块或锁定机制。\n- 迭代器安全：迭代器不会抛出 `ConcurrentModificationException`，因为迭代时是基于快照的。\n\n**缺点**\n- 内存开销大：每次写操作都会创建数组副本，可能会占用较多的内存。\n- 写操作开销大：由于需要复制整个数组，写操作的时间复杂度为 O(n)。\n- 读取旧数据：在高并发场景下，可能会读取到旧的数据。\n\n**适用场景**\n- 配置类数据：如系统配置参数、常量集合等。\n- 事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。\n\n**不适用场景**\n- 高并发写操作：如果有大量的写操作，那么 `CopyOnWriteArrayList` 的性能会变差。\n- 实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。\n\n**结论**\n`CopyOnWriteArrayList` 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 `ConcurrentHashMap` 或 `ConcurrentLinkedQueue`。\n\n### HashSet/LinkedHashSet/TreeSet\n- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。\n- 主要区别在于底层数据结构不同。\n  - `HashSet` 底层是哈希表(`HashMap`)。\n  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。\n  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。\n\n### Map(重要)\n### HashMap/HashTable区别\n- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。\n- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。\n- `HashTable`中有锁，所以效率比 `HashMap` 低。\n- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。\n- 初始容量大小和每次扩充容量大小的不同： \n  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。\n  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\n  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。\n\n> `HashTable` 已经被淘汰，不建议使用。\n> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`\n\n### HashMap长度为什么是2的幂次方\nkey经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。\n\n“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作(也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。\n\n### HashMap/TreeMap区别\n- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。\n- `HashMap` 是无序的，`TreeMap` 是有序的。\n- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。\n- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。\n\n相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\n\n### HashSet如何检查重复\n把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。\n\n在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。\n\n### HashMap底层实现\n**JDK1.8 之前**\n底层是数组和链表。哈希冲突使用“拉链法”解决。\n\n`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。\n\n- 扰动函数 `hash()` 可以减少碰撞。\n- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。\n\n**JDK1.8 之后**\n底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。\n\n- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。\n- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。\n\n### HashMap多线程扩容死循环问题\nJDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\n\n为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。\n\n> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。\n\n### HashMap为什么不支持高并发\n### HashMap为什么线程不安全\n- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。\n- JDK1.7 和 JDK 1.8 都存在数据丢失问题。如下：\n\n**数据丢失**\n在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。\n> 例子：\n> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。\n> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\n> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\n\n### 遍历HashMap\n七种\n```java\nHashMap<Integer, String> map = new HashMap<>();\n// ForEach EntrySet\nfor (Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// ForEach KeySet\nfor (Integer key : map.keySet()) {\n    System.out.println(key + \":\" + map.get(key));\n}\n// 迭代器EntrySet\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry<Integer, String> entry = iterator.next();\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// 迭代器KeySet\nIterator<Integer> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    Integer key = iterator.next();\n    System.out.println(key + \":\" + map.get(key));\n}\n// Lambda\nmap.forEach((key, value) -> {\n    System.out.println(key);\n    System.out.println(value);\n});\n// Streams API 单线程\nmap.entrySet().stream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n// Streams API 多线程\nmap.entrySet().parallelStream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n```\n\n### ConcurrentHashMap/Hashtable区别\n- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。\n- 实现线程安全的方式：\n  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。\n  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - `Hashtable`(同一把锁) ：使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。\n\n### ConcurrentHashMap底层\n\nJDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。\n\n`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。\n\nJDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。\n\n\n### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\n- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。\n- Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。\n- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。\n\n### ConcurrentHashMap能保证复合操作的原子性吗？\n- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。\n- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。\n\n### 什么是LinkedHashMap\n继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性：\n- 支持遍历时会按照插入顺序有序进行迭代\n- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。\n\n> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。\n\n### LinkedHashMap如何按照访问顺序迭代元素？\n`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。\n\n### 如何实现LRU缓存\n- `accessOrder` = `true` \n- 继承`LinkedHashMap`\n- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。\n```java\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n```\n### LinkedHashMap和HashMap的区别\n- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。\n- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。\n\n### Queue/Deque区别\n- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。\n- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。\n\n### ArrayDeque/LinkedList区别\n- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。\n- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。\n- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。\n\n从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。\n\n### PriorityQueue\nPriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\n- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\n- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。\n- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。\n\n> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。\n\n### BlockingQueue及其实现类\n`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。\n\n**实现类**\n- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。\n- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。\n- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。\n- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。\n- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n### ArrayBlockingQueue\n- `put()`、`take()`：插入和删除元素时，如果队列已满或者为空，会阻塞等待。\n- `offer()`、`poll()`：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 `false` 或者 `null`。\n- 并发控制采用可重入锁 `ReentrantLock` 保证线程安全，插入/读取操作都需获取到锁才能进行，且支持公平/非公平两种方式的锁访问机制，默认是非公平锁。\n\n### ArrayBlockingQueue实现原理\n- `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。\n- 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。\n- 通过 `Condition` 接口实现线程间的等待和唤醒操作。\n\n线程间的等待和唤醒具体的实现：\n- 当队列已满时，生产者线程会调用 `notFull.await()` 方法让生产者进行等待，等待队列非满时插入(非满条件)。\n- 当队列为空时，消费者线程会调用 `notEmpty.await()`方法让消费者进行等待，等待队列非空时消费(非空条件)。\n- 当有新的元素被添加时，生产者线程会调用 `notEmpty.signal()`方法唤醒正在等待消费的消费者线程。\n- 当队列中有元素被取出时，消费者线程会调用 `notFull.signal()`方法唤醒正在等待插入元素的生产者线程。\n\n### ArrayBlockingQueue/LinkedBlockingQueue区别\n二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：\n- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。\n- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。\n- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。\n- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。\n\n### DelayQueue底层\n是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n**底层**\n`DelayQueue` 底层用 `PriorityQueue` 存储元素，`PriorityQueue` 采用**二叉小顶堆**的思想确保值小的元素排在最前面，使得 `DelayQueue` 对于延迟任务优先级的管理非常方便。同时 `DelayQueue` 为了保证线程安全还用到了可重入锁 `ReentrantLock`,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 `Condition`接口，通过 `Condition` 的 `await` 和 `signal` 方法完成多线程之间的等待唤醒。\n\n> ```java\n> //可重入锁，实现线程安全的关键\n> private final transient ReentrantLock lock = new ReentrantLock();\n> //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列\n> private final PriorityQueue<E> q = new PriorityQueue<E>();\n> //指向准备执行优先级最高的线程\n> private Thread leader = null;\n> //实现多线程之间等待唤醒的交互\n> private final Condition available = lock.newCondition();\n> ```\n> `leader` ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 `leader` 来管理延迟任务，只有 `leader` 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 `leader` 线程执行完手头的延迟任务后唤醒它。\n> `available` ： 等待唤醒操作的交互是通过 `available` 实现的，假如一个线程尝试在空的 `DelayQueue` 获取任务时，`available` 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 `available` 的 `signal` 方法将其唤醒。\n\n\n### DelayQueue是否线程安全？\n`DelayQueue`是线程安全的，它通过 `ReentrantLock` 实现了互斥访问和 `Condition` 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。\n\n### DelayQueue使用场景\n通常用于实现定时任务调度和缓存过期删除等场景。\n- 在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 `DelayQueue` 中，`DelayQueue` 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。\n- 缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 `key` 封装成一个延迟的删除任务，并将其添加到 `DelayQueue` 中，当数据过期时，拿到这个任务的 `key`，将这个 `key` 从内存中移除。\n\n### DelayQueue中Delayed接口的作用是什么？\n`DelayQueue` 中存放的元素必须实现 `Delayed` 接口，并且需要重写 `getDelay()`方法。`Delayed`接口定义了元素的剩余延迟时间(`getDelay()`)和元素之间的比较规则(继承 `Comparable` 接口),否则 `DelayQueue` 无法得知当前任务剩余时长和任务优先级的比较。\n\n### DelayQueue/Timer/TimerTask区别\n都可以用于实现定时任务调度，但实现方式不同。\n- `DelayQueue` 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；\n- `Timer/TimerTask` 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。\n- `DelayQueue` 支持动态添加/移除任务，`Timer/TimerTask` 只能在创建时指定任务。\n\n\n## Java并发\n\n### 进程/线程/协程\nhttps://blog.csdn.net/m0_60505735/article/details/131047046\nhttps://blog.csdn.net/weixin_49199646/article/details/109210547\n- 进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。\n- 线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n- 协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。\n\n**进程与线程的区别**\n- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。\n- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。\n- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。\n\n**进程与线程的联系**\n一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。\n\n*进程与线程的选择**\n- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；\n- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；\n- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程\n- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。\n\n综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。\n\n### Java线程和操作系统线程有何区别\n现在的 Java 线程的本质其实就是操作系统的线程。\n\n- JDK1.2之前Java线程基于绿色线程(`Green Threads`)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。\n- JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n\n线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。\n\n在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。\n\n### 程序计数器为啥是私有的\n程序计数器主要有下面两个作用：\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n- 如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n\n### 虚拟机栈和本地方法栈为啥是私有的\n- 虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n\n### 一句话简单了解堆和方法区\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n### 如何创建线程\n- 继承`Thread`类并重写`run()`方法\n- 实现`Runnable`接口并重写`run()`方法\n- 实现`Callable`接口并重写`call()`方法\n- 使用线程池`ThreadPoolExecutor`创建线程\n- 等等......\n\n其实只有一种方式可以创建线程，那就是通过 `new Thread().start()` 创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。\n\n### 线程的生命周期和状态\nJava 线程 6 种状态：\n`NEW`： 初始状态，线程被创建出来但没有被调用 `start()` 。\n`RUNNABLE`： 运行状态，线程被调用了 `start()`等待运行的状态。\n`BLOCKED`：阻塞状态，需要等待锁释放。\n`WAITING`：线程执行`wait()`方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。\n`TIME_WAITING`：超时等待状态，调用`sleep(long millis)`可以在指定的时间后自行返回而不是像 `WAITING` 那样一直等待。\n`TERMINATED`：执行完`run()`方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n### 线程上下文切换开销\n线程在执行过程中会有自己的运行条件和状态(也称**上下文**)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。\n- 时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。\n- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\n\n线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\n\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\n\n### Thread.sleep()方法和Object.wait()方法对比\n共同点：两者都可以暂停线程的执行。\n区别：\n- `sleep()` 方法没有释放锁，`wait()` 方法释放锁 。\n- `sleep()`通常被用于暂停执行，`wait()` 通常被用于线程间交互/通信。\n- `wait()`方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()`方法。`sleep()`方法执行完成后，线程会自动苏醒(或者也可以使用`wait(long timeout)`超时后线程会自动苏醒)。\n- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。\n\n### 锁的基本概念\nJava 中，每个对象都有一个与之关联的监视器(`monitor`)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。\n\n### Java中有哪些锁\n- `synchronized`关键字\n  - 用于同步方法或同步代码块。\n  - 基于对象锁，每个对象都有一个监视器锁。\n- `ReentrantLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供更灵活的锁机制，相比`synchronized`，支持公平锁、非公平锁等特性。\n  - 支持可重入锁，即同一个线程可以多次获取同一个锁。\n- `ReentrantReadWriteLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供读写锁的实现，读锁共享，写锁独占。\n  - 适用于读多写少的场景，提升并发性能。 \n- `StampedLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供三种锁模式：写锁、悲观读锁和乐观读锁。\n  - 乐观读锁在某些情况下可以避免加锁操作，提升性能。\n- `LockSupport`\n  - 提供基本的线程阻塞和唤醒机制。\n  - 通常用于构建更高级的同步器，如`Semaphore`、`CountDownLatch`等。\n- `Semaphore`\n  - 在`java.util.concurrent`包中提供。\n  - 用于控制同时访问特定资源的线程数量。\n- `CountDownLatch`\n  - 在`java.util.concurrent`包中提供。\n  - 允许一个或多个线程等待一组操作完成。 \n- `CyclicBarrier`\n  - 在`java.util.concurrent`包中提供。\n  - 使一组线程在到达一个共同的屏障点时被阻塞，直到所有线程都到达该点。\n- Phaser\n  - 在`java.util.concurrent`包中提供。\n  - 允许多阶段的线程协作，每个阶段完成后继续下一阶段。 \n- `Atomic`变量\n  - 在`java.util.concurrent.atomic`包中提供。\n  - 提供了一些基本类型(如`AtomicInteger`、`AtomicLong`)的原子操作，实现了无锁的线程安全。\n\n这些锁机制可以根据具体的应用场景选择，以实现高效、安全的并发控制。\n\n### 为什么wait()方法不定义在Thread中\n- 锁是对象级别的，每个对象都有一把锁。\n- `wait()` 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。\n\n### 为什么sleep()方法定义在Thread中\n- `sleep()` 是线程控制方法，作用对象是线程本身。\n- 线程暂停执行，不涉及到对象类，也不需要获得对象锁。\n\n### sleep()如何控制当前线程沉睡\n调用 `Thread.sleep()` 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。\n\n### 可以直接调用Thread类的run方法吗\n可以但不建议。`new` 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 `main` 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。\n\n### 并发/并行区别\n- 并发：两个及两个以上的作业在同一 **时间段** 内执行。\n- 并行：两个及两个以上的作业在同一 **时刻** 执行。\n\n### 同步/异步区别\n- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。\n- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。\n\n### 为什么要使用多线程\n- 线程切换和调度的成本远远小于进程。\n- 单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。\n- 多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。\n- 并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。\n\n### 使用多线程风险\n- 线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。\n- 死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。\n- 内存泄漏：线程未正确释放资源，导致内存泄漏。\n- 上下文切换：线程频繁切换，会增加系统开销。\n- ...\n\n### 如何理解线程安全和不安全\n线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性** 和**一致性** 的描述。\n- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。\n- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。\n\n### 高并发存在什么问题,Java如何解决的\n**高并发问题**\n- 资源竞争：多个线程竞争同一资源(如内存、文件、数据库连接等)，可能导致数据不一致、死锁等问题。\n- 死锁：多个线程在等待对方释放资源，从而相互阻塞，导致程序无法继续执行。\n- 上下文切换开销：线程之间的切换会消耗系统资源，频繁的上下文切换会降低系统性能。\n- 线程安全：确保多个线程对共享资源的操作不会导致数据不一致的问题。\n- 内存泄漏：大量创建和销毁线程，如果不合理管理，会导致内存泄漏。\n- 饥饿和公平性：某些线程可能长期得不到资源，导致饥饿问题。如何确保线程公平地获取资源也是一个挑战。\n- 负载均衡：在分布式系统中，如何将请求均衡地分配到不同的服务器，以避免某些服务器过载。\n\n**Java解决高并发问题**\n- 线程池(Thread Pool)：通过线程池管理线程的创建和销毁，减少资源消耗，提高系统性能。\n- 同步机制(Synchronization)：使用 `synchronized`关键字或显示锁(如`ReentrantLock`)来确保线程安全，避免资源竞争。\n- 并发工具类：如`ConcurrentHashMap`、`CopyOnWriteArrayList`等，这些工具类可以帮助开发者更方便地实现线程间的协调和资源共享。\n- 无锁算法(Lock-Free Algorithms)：使用原子变量类(如`AtomicInteger`、`AtomicLong`)来实现无锁并发，减少上下文切换开销，提高性能。\n- CAS操作(Compare-And-Swap)：CAS是一种无锁算法，通过比较和交换操作来实现原子性。Java中的`Unsafe`类和`Atomic`包使用了CAS操作来实现无锁算法。\n- Fork/Join框架：用于任务拆分和并行处理，适用于大规模数据并行处理。Java 7引入了`ForkJoinPool`来支持这一框架。\n- 异步编程(Asynchronous Programming)：通过`CompletableFuture`和异步方法调用，实现非阻塞的并发编程模型。\n\n### Java如何实现高并发\n**使用线程池**\n线程池可以有效管理线程的创建和销毁，减少资源消耗和上下文切换开销。Java中的`ExecutorService`和`Executors`类提供了便捷的线程池实现。\n```java\nExecutorService executor = Executors.newFixedThreadPool(10);\nfor (int i = 0; i < 100; i++) {\n    executor.submit(new Task());\n}\nexecutor.shutdown();\n```\n**同步机制**\n使用`synchronized`关键字或者显式锁(如`ReentrantLock`)来确保线程安全，避免资源竞争和数据不一致问题。\n```java\npublic synchronized void safeMethod() {\n    // Critical section\n}\n\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n```\n**并发集合类**\nJava提供了线程安全的并发集合类，如`ConcurrentHashMap`、`CopyOnWriteArrayList`、`BlockingQueue`等，这些集合类可以简化多线程编程。\n\n**原子变量类**\n使用原子变量类(如`AtomicInteger`、`AtomicLong`)来实现无锁并发，减少上下文切换，提高性能。\n\n**CAS操作**\nJava的`Atomic`包和`Unsafe`类使用了CAS(Compare-And-Swap)操作来实现无锁算法，从而提高并发性能。\n```java\nAtomicInteger count = new AtomicInteger(0);\nboolean updated = count.compareAndSet(0, 1);\n```\n**Fork/Join框架**\n`ForkJoinPool`用于任务拆分和并行处理，适用于大规模数据的并行计算。\n```java\nForkJoinPool pool = new ForkJoinPool();\npool.invoke(new RecursiveTask<Void>() {\n    @Override\n    protected Void compute() {\n        // Task implementation\n        return null;\n    }\n});\n```\n**异步编程**\n使用`CompletableFuture`和异步方法调用，实现非阻塞的并发编程模型。\n```java\nCompletableFuture.supplyAsync(() -> {\n    // Async task\n    return \"result\";\n}).thenAccept(result -> {\n    // Process result\n});\n```\n**使用非阻塞I/O**\n在网络编程中，使用NIO(Non-blocking I/O)实现高并发。NIO提供了选择器(`Selector`)、通道(`Channel`)和缓冲区(`Buffer`)等工具，可以实现高效的非阻塞I/O操作。\n\n**使用第三方并发框架**\n如Akka、RxJava、Vert.x等，它们提供了更加高级的并发和反应式编程模型。\n\n### 单核CPU上运行多个线程效率一定会高吗\n如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。\n如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。\n\n### 死锁\n死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\n> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n产生死锁的四个必要条件：\n- 互斥条件：该资源任意一个时刻只由一个线程占用。\n- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n- 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n### 如何检测死锁\n- 一般死锁可能会导致 CPU 使用率飙升，线程处于 `BLOCKED` 状态，可以通过监控工具查看。\n- jConsole： 可以检测死锁，查看线程的状态。\n- jstack： 如有死锁，会输出`Found one Java-level deadlock: `线程的状态信息\n\n### 如何预防和避免死锁\n破坏死锁的产生的必要条件：\n- 破坏请求与保持条件：一次性申请所有的资源。\n- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n避免死锁就是在资源分配时，借助于算法(比如**银行家算法** )对资源分配进行计算评估，使其进入安全状态。\n\n> 安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\n\n### Java内存模型JMM\nJMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。\n\n### 为什么需要Java内存模型\n- Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\n- JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。\n- 对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 `volatile`、`synchronized`、各种 `Lock`)即可开发出并发安全的程序。\n\n### Java内存区域和Java内存模型有什么区别\n- Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。\n- Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。\n\n### JMM是如何抽象线程和主内存之间的关系\nJava内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。\n\n### 主内存与工作内存\n- 主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。\n- 工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。\n\n### 并发编程三大特性\n可见性、原子性和有序性\n- 可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、`volatile`关键字、`synchronized`块等手段来实现可见性。\n- 原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。\n- 有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的`happens-before`规则，确保代码的执行顺序对多线程环境是可预测的。\n\nJMM通过上面三种属性来确保线程之间的内存一致性。\n\n### 如何保证变量的可见性(volatile)\n`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n### 如何禁止指令重排序\n`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 `volatile` ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\n\n### volatile可以保证原子性\n`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。\n\n### 乐观锁/悲观锁\n- 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n  - `synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n  - 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。\n  - 悲观锁可能会存在死锁问题。\n  - 通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。\n- 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。\n  - 具体方法可以使用版本号机制或 CAS 算法，`AtomicInteger`、`LongAdder`等都是乐观锁的实现。\n  - 高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。\n  - 如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n    - `LongAdder`以空间换时间的方式就解决了大量重试问题。\n  - 通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。\n\n### 如何实现乐观锁\n- 版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。\n- CAS算法：`compare and swap`，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。\n  - V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n\n> 举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V = 1，E=1，N=6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\n\n### CAS算法存在问题\n\n### ABA问题\n变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \"ABA\"问题。\n\nABA问题的解决思路是在变量前面追加上版本号或者时间戳。\n\n**循环时间长开销大**\nCAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。\n\n**只能保证一个共享变量的原子操作**\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用`AtomicReference`。\n\n### synchronized关键字\n`synchronized` 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n### JDK1.6之后synchronized的优化\n在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，`synchronized`引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。\n\n### 锁升级原理了解吗\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n### 如何使用synchronized\n- 修饰实例方法：锁住当前实例对象。\n```java\nsynchronized void method() {\n    //业务代码\n}\n```\n- 修饰静态方法：锁住当前类的 Class 对象。\n```java\nsynchronized static void method() {\n    //业务代码\n}\n```\n- 修饰代码块：锁住括号里面的对象。\n  - `synchronized(object)` 表示进入同步代码库前要获得 给定对象的锁。\n  - `synchronized(类.class)` 表示进入同步代码前要获得 给定 `Class` 的锁\n\n```\nsynchronized(对象) {\n    //业务代码\n}\nsynchronized(类.class) {\n    //业务代码\n}\n```\n\n### synchronized底层原理\n`synchronized` 关键字是通过对象内部的一个叫做监视器锁(`monitor`)来实现的。\n\n- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。\n- `synchronized` 修饰的方法使用 `ACC_SYNCHRONIZED` 标识，JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n两者的本质都是对对象监视器 `monitor` 的获取。\n\n### ReentrantLock\n`ReentrantLock` 是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\n\n`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承抽象类 `AQS(AbstractQueuedSynchronizer，抽象队列同步器)`，添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。\n\n### AQS核心思想\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于`CLH`锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。\n\n以可重入互斥锁 `ReentrantLock` 为例，其内部维护了一个使用`volatile`修饰(保证线程可见性)的`state`变量，用来表示锁的占用状态。`state` 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 `lock()` 方法时，会尝试通过 `tryAcquire()` 方法独占该锁，并让 `state` 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(`CLH` 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(`state` 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 `state` 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\n\n> `CLH`锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 `CLH` 队列锁的一个结点(`Node`)来实现锁的分配。在 `CLH` 队列锁中，一个节点表示一个线程，它保存着线程的引用(`thread`)、 当前节点在队列中的状态(`waitStatus`)、前驱节点(`prev`)、后继节点(`next`)。\n\n### AQS资源共享模式\nAQS 支持两种资源共享方式：独占和共享。\n- `Exclusive`(独占，只有一个线程能执行，如`ReentrantLock`)\n- `Share`(共享，多个线程可同时执行，如`Semaphore/CountDownLatch`)\n\n> 也可以自定义同步器同时实现独占和共享，如`ReentrantReadWriteLock`，读操作时多个线程可以同时进行，写操作时只能一个线程进行。\n\n### Semaphore\n`Semaphore` 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的`state`表示许可数(>=1)，当一个线程调用 `acquire()` 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 `release()` 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。\n\n### 公平锁/非公平锁\n- 公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n- 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n\n### synchronized和ReentrantLock有什么区别？\n两者都是可重入锁\n- `synchronized` 是关键字，是内置的语言实现，`ReentrantLock` 是一个类。\n- `synchronized` 是 JVM 实现的，`ReentrantLock` 是 JDK 实现的(也就是 API 层面，需要 `lock()` 和 `unlock()` 方法配合 `try/finally` 语句块来完成)\n- `ReentrantLock` 比 `synchronized` 增加了一些高级功能：\n  - 等待可中断 ： `ReentrantLock`提供一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()`实现。\n  - 可实现公平锁： `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。通过`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。\n  - 可实现选择性通知(锁可以绑定多个条件)： `synchronized`关键字与`wait()`和`notify()/notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以，但需借助`Condition`接口与`newCondition()`方法。\n\n> 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个`synchronized`修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\n\n### 可中断锁/不可中断锁\n- 可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。`ReentrantLock` 是可中断锁。\n- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 是不可中断锁。\n\n### ReentrantReadWriteLock\n是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n`ReentrantReadWriteLock` 其实是两把锁，一把是 `WriteLock` (写锁)，一把是 `ReadLock`(读锁) 。读锁是**共享锁**，写锁是**独占锁**。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n> 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\n> 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。\n\n### 共享锁/独占锁\n- 共享锁：一把锁可以被多个线程同时获得。\n- 独占锁：一把锁只能被一个线程获得。\n\n### 线程持有读锁还能获取写锁吗\n- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\n- 在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。\n\n### 读锁为什么不能升级为写锁\n- 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。\n- 可能会有死锁问题发生。\n\n### StampedLock\n`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，没有实现 `Lock`或 `ReadWriteLock`接口，而是基于 `CLH` 锁独立实现的。\n\n提供三种访问模式：\n- 写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。\n- 读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。\n- 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比`ReadWriteLock`更好的原因)\n\n### ThreadLocal\n`ThreadLocal` 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n### ThreadLocal原理\n`ThreadLocal` 通过 `ThreadLocalMap` 来实现线程内部的数据存储。`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，每个线程中都有一个 `ThreadLocalMap`，`ThreadLocal` 通过 `get()`、`set()` 方法访问 `ThreadLocalMap`。在一个线程中创造多个`ThreadLocal`对象，这个许多个`ThreadLocal`对象会被放到一个`ThreadLocalMap`中。\n\n> `ThreadLocalMap`可以理解为一个定制化的 `HashMap`，`key` 是 `ThreadLocal` 对象，`value` 是存储的值。\n> 可以存在这种情况： 在线程 1 中创建了两个 `ThreadLocal` 对象，在线程 1 中只有一个 `ThreadLocal` 对象。\n\n### ThreadLocal内存泄漏\n`ThreadLocalMap` 中使用的 `key` 为 `ThreadLocal` 的弱引用，而 `value` 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，`key` 会被清理掉，而 `value` 不会被清理掉。这样一来就会出现 `key` 为 `null` 的 键值对。如果不做任何措施的话，`value` 永远无法被 GC 回收，这个时候就可能会产生内存泄露。\n\n其实`ThreadLocalMap`实现中已经考虑了内存泄漏问题，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 `key` 为 `null` 的记录。不过使用完 `ThreadLocal`方法后最好手动调用`remove()`方法。\n\n> `HashMap` 的 `key` 和 `value` 都是强引用，因此不会存在弱引用导致的内存泄漏问题。\n\n### 线程池\n线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n### 为什么用线程池\n- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n> 在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n### 创建线程池的方式\n- 通过`ThreadPoolExecutor`构造函数来创建 _**(推荐)**_ 。\n- 通过`Executors`工具类来创建 _**(不推荐)**_ 。通过这种方式可以创建出多种类型的线程池\n  - `FixedThreadPool`：固定大小的线程池。\n  - `SingleThreadPool`：只有一个线程的线程池。\n  - `CachedThreadPool`：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。\n  - `ScheduledThreadPool`：定时任务的线程池。\n\n### 为什么不推荐使用内置线程池\n- `FixedThreadPool`，`SingleThreadPool`，`ScheduledThreadPool`：使用的是无界的 `LinkedBlockingQueue`，允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。\n- `CachedThreadPool`：使用同步队列`SynchronousQueue`，允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。\n\n### ThreadPoolExecutor参数\n3 个最重要的参数：\n- `corePoolSize` ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n- `maximumPoolSize` ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n- `workQueue`： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\n其他常见参数 ：\n- `keepAliveTime`：线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。\n- `unit` ： `keepAliveTime` 参数的时间单位。\n- `threadFactory` ：`executor` 创建新线程的时候会用到。\n- `handler` ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。\n\n### 线程池的拒绝策略\n- `AbortPolicy`：直接抛出异常，阻止系统正常工作。\n- `CallerRunsPolicy`：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。\n- `DiscardOldestPolicy`：丢弃最早的未处理的任务请求。\n- `DiscardPolicy`：不处理新任务，直接丢弃掉。\n\n### CallerRunsPolicy策略风险及解决方案\n**风险**\n`CallerRunsPolicy` 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n\n**解决方案**\n1. 使用`CallerRunsPolicy`是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列`BlockingQueue`中，这样在内存允许的情况下，可以增加阻塞队列`BlockingQueue`的大小以容纳更多的任务，同时调整线程池的`maximumPoolSize` (最大线程数)参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。\n2. 使用`ThreadPoolExecutor`的`setRejectedExecutionHandler`方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 `Redis`缓存任务。\n\n### 线程池常用阻塞队列\n- `LinkedBlockingQueue`：基于链表的阻塞队列，大小默认为 `Integer.MAX_VALUE`，即任务队列永远不会放满。`FixedThreadPool` 和 `SingleThreadExector`使用，前者只能创建核心线程数的线程，后者只能创建一个线程。\n- `SyncronousQueue`：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\n- `DelayedWorkQueue`：延迟阻塞队列，`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。\n\n### 线程池处理任务流程\n1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。\n3. 如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。\n\n### 线程池中线程异常后销毁还是复用？\n两种情况：\n- 使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；\n- 使用`ExecutorService.submit()`时，异常被封装在`Future`中，线程继续复用。\n\n### 如何设定线程池大小\n- CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。\n- I/O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I/O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。\n\n### 如何设计一个根据任务优先级执行的线程池\n- 使用`PriorityBlockingQueue`作为任务队列，队列中的任务按照优先级顺序执行。\n- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。\n\n这样还存在一些问题：\n- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。\n  - 解决方法：继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 `false 。\n- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。\n  - 解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。\n\n### 异步调用Future类\n\n`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n`Future`类是一个泛型接口，主要包含下面几个方法：\n```\n// V 代表了Future执行的任务返回值的类型\npublic interface Future<V> {\n    // 取消任务执行，成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 判断任务是否被取消\n    boolean isCancelled();\n    // 判断任务是否已经执行完成\n    boolean isDone();\n    // 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n}\n```\n\n### Callable和Future关系\n`Callable` 用于定义可以返回结果的任务，`Future` 用于获取 `Callable` 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。\n- 任务提交与执行：通常通过 `ExecutorService` 提交 `Callable` 任务，`submit` 方法返回一个 `Future` 对象。\n- 异步结果获取：`Future` 对象可以用来获取 `Callable` 任务的返回结果或处理异常。\n\n### CompletableFuture类有什么用？\n`CompletableFuture` 类是 Java 8 中引入的一个增强版 `Future`，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 `Future` 相比，`CompletableFuture` 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。\n\n### CompletableFuture类异步调用实现\n```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // 创建一个CompletableFuture来执行异步任务\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            // 模拟一个长时间运行的任务\n            try {\n                Thread.sleep(2000); // 休眠2秒\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"任务完成\";\n        });\n        // 注册一个回调函数，当任务完成时获取结果\n        future.thenAccept(result -> {\n            System.out.println(\"异步任务结果: \" + result);\n        });\n        // 主线程继续执行其他操作\n        System.out.println(\"主线程继续执行...\");\n        // 阻塞主线程，直到异步任务完成（可选）\n        try {\n            // 这一步会阻塞主线程，直到异步任务完成\n            String result = future.get();\n            System.out.println(\"异步任务完成后获取的结果: \" + result);\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n### 虚拟线程\n虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\n\n虚拟线程(`Virtual Thread`)是 JDK 而不是操作系统实现的轻量级线程(`Lightweight Process，LWP`)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n\n在没有虚拟线程之前，JVM使用的是**平台线程**，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。\n\nJVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。\n\n**优点**\n- 非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。\n- 简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。\n- 减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。\n\n**缺点**\n不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。\n依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。\n\n## IO\n\nIO(`Input/Output`)即输入/输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。\n\nIO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\n- `InputStream/Reader`： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- `OutputStream/Writer`： 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n### Java为什么要分字节流和字符流\nJava 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。\n- 字符流自动处理字符编码问题，非常适合文本数据；\n- 字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。\n\n### 字节流和字符流区别\n- 字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。\n- 字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。\n- 字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。\n\n### IO设计模式总结\n- 装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。\n- 适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\n- 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n- 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。\n\n### 装饰器模式和适配器模式区别\n- 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n- 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n\n### 3种常见的IO模型\n- BIO(`Blocking IO`)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n  - 优点：编程简单，代码易于理解。\n  - 缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。\n- NIO(`Non-blocking IO`)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。\n  - 优点：单线程可以处理多个连接，提高并发性能。\n  - 缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n- AIO(`Asynchronous IO`)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。\n  - 优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。\n  - 缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。\n\n\n\n\n## JVM\n### 内存区域\nJava内存区域/Java虚拟机内存 通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。\n\n线程私有的内存区域包括：\n- **程序计数器**：\n  - 这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。\n  - 如果正在执行的是本地方法，这个计数器是未指定值(undefined)。\n- **Java虚拟机栈**：\n  - Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。\n  - 栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。\n- **本地方法栈**：\n  - 本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。\n  - 一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。\n\n线程共享的内存区域包括：\n- **堆**：\n  - Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。\n  - 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。\n  - 堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。\n    - JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。\n- **方法区**：\n  - 方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n  - 方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。\n- **运行时常量池**：\n  - 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。\n  - JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。\n\n本地内存：\n- 直接内存：\n  - 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。\n  - JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。\n  - JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。\n\n\n**内存模型与内存管理**\n- **内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。\n- **垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。\n\n**总结**\nJava内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。\n\n### 成员变量/全局变量/局部变量存放在哪里\n- 成员变量(实例变量)存储在堆内存中，每个对象都有自己的一份成员变量。\n- 静态变量(类变量)存储在方法区(或元空间)中，是类级别的变量，共享给所有实例。\n- 局部变量存储在栈内存中，属于方法调用帧的一部分。\n\n### 对象的创建过程(5步)\n1. 类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n2. 分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n3. 初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n5. 执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 对象的内存布局\n对象在内存中的布局可以分为 3 块区域： \n- 对象头(`Header`)： \n  - 标记字段(`Mark Word`)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。\n  - 类型指针(`Klass Word`)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n- 实例数据(`Instance Data`)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n- 对齐填充(`Padding`)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。\n\n### 对象的访问定位\n建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。\n- 句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n- 直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n### 垃圾回收机制✅\n**垃圾回收机制定义**\n垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。\n\n**堆空间结构**\n堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。\n\n**内存分配和回收原则**\n- 对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。\n- 大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。\n- 长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。\n\n垃圾回收的基本步骤分两步：\n- 查找内存中不再使用的对象(GC判断策略)\n- 释放这些对象占用的内存(GC收集算法)\n\n**死亡对象/GC判断策略**\n- 引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。\n    - 循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n- 可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。\n    - 这些对象可以用作 GC Roots： \n      - 虚拟机栈(栈帧中的局部变量表)中引用的对象\n      - 本地方法栈(Native 方法)中引用的对象\n      - 方法区中类静态属性引用的对象\n      - 方法区中常量引用的对象\n      - 所有被同步锁持有的对象\n      - JNI(Java Native Interface)引用的对象\n\n> 对象被标记为不可达，就代表一定会被回收吗？\n> 不一定。真正宣告一个对象死亡至少要经过两次标记过程。\n\n**垃圾回收算法**\n- 标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。\n  - 存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。\n- 复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。\n  - 存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。\n- 标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。\n  - 问题：整理的过程效率也不高。\n- 分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。\n\n**垃圾回收器**\n默认收集器：\nJDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)\nJDK 9 ~ JDK20： G1(Garbage-First)收集器\n\n- Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( \"Stop The World\" )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。\n- ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。\n- Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。\n- Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。\n- Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。\n- CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。\n- G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。\n- ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。\n\n\n> HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\n> - 部分收集 (`Partial GC`)：\n>     - 新生代收集(Minor GC / Young GC)：只对新生代进行垃圾收集；\n>     - 老年代收集(Major GC / Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\n>     - 混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。\n> - 整堆收集 (Full GC)：收集整个 Java 堆和方法区。\n\n### 为什么要进行垃圾回收\n- **防止内存泄漏**：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。\n- **提高开发效率**：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。\n- **系统性能和稳定性**：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。\n\n### 强引用/软引用/弱引用/虚引用✅\nhttps://blog.csdn.net/u013718071/article/details/134789666\nJava中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。\n- 强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。\n- 软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。\n- 弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。\n- 虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(`ReferenceQueue`)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。\n\n以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。\n\n### 如何判断一个类是无用的\n类需要同时满足下面 3 个条件才能算是 “无用的类”：\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收\n\n### 类的生命周期\n加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。\n\n其中验证、准备、解析 3 部分统称为连接。\n\n### 类加载过程\n分三步：加载、连接(验证、准备、解析)、初始化。\n\n**加载**\n加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。加载主要分下面三步：\n1. 通过全类名获取定义此类的二进制字节流。\n2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。\n\n> 加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。\n\n**验证**\n连接的第一步，确保 `Class` 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：\n1. 文件格式验证：验证字节流是否符合 Class 文件格式规范。\n2. 元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。\n   - 如验证类是否有父类\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n   - 如验证函数的参数是否正确\n4. 符号引用验证：确保解析动作能正确执行。\n   - 如验证该类要使用的其他类、方法是否存在。\n\n**准备**\n连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。\n- 进行内存分配的仅包括类变量(被`static`修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\n- 初始值是数据类型的默认值，如 0、null 等。\n\n**解析**\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。\n\n**初始化**\n初始化阶段是执行初始化方法 `<clinit>()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\n\n### 类卸载\n卸载类即该类的 `Class` 对象被 GC。\n\n卸载类需要满足 3 个要求：\n- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。\n- 该类没有在其他任何地方被引用\n- 该类的类加载器的实例已被 GC\n\n在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如`BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。\n\n### 类加载器\n类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 `ClassLoader`。数组类不是通过 `ClassLoader` 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。\n\n> 类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。\n\nJVM内置三个重要的类加载器：\n`BootstrapClassLoader`(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 `null`，并且没有父级，主要用来加载 JDK 内部的核心类库。\n`ExtensionClassLoader`(扩展类加载器)：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。\n`AppClassLoader`(应用程序类加载器)：面向用户的加载器，负责加载当前应用 `classpath` 下的所有 jar 包和类。\n\n### 双亲委派模型\n双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。\n\n**优点**\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。\n\n如果需要打破双亲委派模型，需要自定义类加载器，并重写 `loadClass` 方法。\n\n\n\n","source":"_posts/Java后端面经.md","raw":"---\ntitle: Java后端面经\ntags:\n  - Java\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: Java后端面经\nabbrlink: 17766\ndate: 2024-05-27 19:58:53\nupdated: 2024-06-25 16:46:23\ntop_img: https://s2.loli.net/2024/05/27/ytcdAHzliRquNM2.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## 简历相关\n\n### 自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！\n\n### Casbin明日之星实习\n\n1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。\n\n2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。\n\n3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。\n\n### 中科院开源之夏项目\n\n**简介**\nCasdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。\n\n**项目诉求**\n1. 对微信第三方登录的移动端支持\n    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。\n\n2. 对flutter、react-native、unity等sdk的开发及功能的增强\n    - 对flutter-sdk的增强如第一点\n\n3. 临时加上的开发casdoor-app诉求，对标Google Authenticator\n\n**技术细节**\n1. 在flutter-sdk中通过截取`session`中的`url`和`callbackURLscheme`判断其中是否有\"weixin\"字段，如果有，则进行微信第三方原生授权登录；\n    - 使用`WKWebView`替换原本的`ASWebAuthenticationSession`，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；\n    - 使用rb脚本文件自动化配置微信SDK导入后xcode中`xcodeproj`文件的相关配置；\n    - 接入`xcframework`的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；\n\n    接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置`universal Link`，需付费几百美元，所以最终代码并未实际测试。\n2. 分为两部分\n    1. casdoor-unity-example\n        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；\n        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；\n        - 在casdoor服务端配置好应用的`clientCode`和`clientSecret`后，在Unity3D中向服务端发送认证请求(`cilentCode`等)，解析返回的`token`，就可以得到用户信息，也可以使用`session`保存`token`等信息。\n        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。\n    2. casdoor-react-native-sdk、example\n        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；\n        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。\n        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 `code_challenge` 和 `code_verifier` 。\n3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。\n    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。\n    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。\n\n> SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。\n\n**总结**\n参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。\n\n### 单点登录SSO原理\n单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。\n\n在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。\n\n流程：\n1. 用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的`session`里面，浏览器也会写入SSO域下的`cookie`。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到`session`中，并设置app域下的`cookie`，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。\n2. 此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到`session`，并在app2的域下写入一个`cookie`。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的`session`不共享，也没有任何问题。\n\nSSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，\n\n### OAuth 2.0原理\nhttps://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\n\nOAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。\n\n定义了4种角色：\n\n- 用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。\n- 应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。\n- 资源服务器：资源服务器托管受保护的用户帐户的资源。\n- 授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。\n\n步骤：\n1. 应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。\n2. 如果用户授权该请求，应用程序会收到授权准许(`Authorization Grant`)。\n3. 应用程序通过提供其自身的身份验证和授权准许(`Authorization Grant`)来向授权服务器 (API) 请求访问令牌(`access_token`)。\n4. 如果应用程序身份通过验证且授权准许(`Authorization Grant`)有效，则授权服务器(API)向应用程序颁发访问令牌(`access_token`)。授权完成。\n5. 应用程序从资源服务器(API)请求资源并提供访问令牌(`access_token`)进行身份验证。\n6. 如果访问令牌(`access_token`)有效，则资源服务器 (API) 向应用程序提供资源。\n\n授权准许(`Authorization Grant`)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：\n\n1. 授权码(`Authorization Code`)：与服务器端应用程序一起使用。\n2. 客户端凭证(`Client Credentials`)：与具有 API 访问权限的应用程序一起使用。\n3. 设备代码(`Device Code`)：用于缺少浏览器或有输入限制的设备。\n\n### 2FA\n两因素认证(`Two-Factor Authentication, 2FA)`是一种安全系统，用于确保用户登录到账户或访问资源时，需要通过两种不同类型的验证方式。这种方法比仅依靠密码更安全，因为它增加了额外的验证层，使得即使密码被泄露，攻击者仍然难以访问用户账户。\n\n身份验证因素：2FA通常结合两种不同的验证因素，分三类：\n- 知识因素(Something you know)：用户知道的东西，例如密码、PIN码、回答安全问题等。\n- 持有因素(Something you have)：用户拥有的物品，例如手机、硬件令牌、智能卡等。\n- 固有因素(Something you are)：用户自身的特征，例如指纹、面部识别、声音识别等生物特征。\n\n验证过程：\n- 第一步：输入用户名和密码：用户首先输入他们的用户名和密码(知识因素)。\n- 第二步：额外验证：系统会要求用户进行第二步验证。这可以是：  \n  - 一次性密码(OTP)：通过短信、电子邮件或专用应用程序(如Google Authenticator、Authy)生成并发送给用户的随机密码。\n  - 硬件令牌：用户插入或展示硬件令牌生成的代码。\n  - 生物特征识别：用户通过指纹、面部识别等方式进行验证。\n\n验证成功：如果两步验证都通过，用户将获得访问权限。\n验证失败：如果任何一步失败，访问将被拒绝。\n\n### PKCE\nPKCE(`Proof Key for Code Exchange, PKCE`)是一种用于保护OAuth 2.0授权码授权流程的机制，主要目的是防止授权码拦截攻击(Authorization Code Interception Attack)。\n\n原理：\nPKCE通过在OAuth 2.0授权码请求和令牌交换过程中引入一个随机生成的`code_challenge`和`code_verifier`来增强安全性。具体来说，PKCE引入了两个新参数：\n- `code_verifier`：一个高熵的随机字符串，客户端在请求`code`(授权码)时生成并保存。\n- `code_challenge`：由`code_verifier`生成的一个变体，发送给授权服务器。可以是`code_verifier`本身，或者是`code_verifier`的SHA256哈希值。\n\n流程：\n1. 客户端生成一个随机的`code_challenge`和`code_verifier`，`code_verifier`可以是明文(`plain`)SHA256哈希值(`s256`)。\n2. 客户端将`code_challenge`和`code_challenge_method`(`plain`或`s256`)发送给授权服务器。\n   - 如：`GET /authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=SCOPE&state=STATE&code_challenge=CODE_CHALLENGE&code_challenge_method=S256`\n3. 用户在授权服务器进行身份验证，同意授权，授权服务器通过重定向URI将`code`(授权码)返回给客户端。\n4. 客户端将`code`(授权码)和`code_verifier`发送给授权服务器，以获取`access_token`(访问令牌)。\n   - 如：`POST /token?grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=REDIRECT_URI&client_id=CLIENT_ID&code_verifier=CODE_VERIFIER`\n5. 授权服务器收到客户端发送的`code`(授权码)和`code_verifier`后，使用之前保存的`code_challenge`进行验证。\n   - 如果`code_challenge_method`是`plain`，则直接比较`code_verifier`和`code_challenge`。\n   - 如果`code_challenge_method`是`s256`，则比较`code_verifier`的SHA256哈希值和`code_challenge`。\n6. 如果验证通过，授权服务器返回`access_token`(访问令牌)给客户端。\n\n这样，即使`code`(授权码)在传输过程中被拦截，攻击者也无法使用该`code`(授权码)，因为缺少正确的`code_verifier`。\n\n### OTP/TOTP/HOTP\nOTP (One-Time Password) 是一种一次性有效的密码，通常用于两因素身份验证(2FA)。每次使用 OTP 进行身份验证后，这个密码便失效，无法再使用。OTP 提高了安全性，因为即使密码被截获或暴力破解，也不能再次使用。OTP 生成和使用的方式有很多种，包括基于时间的(TOTP)和基于事件的(HOTP)。\n\n**TOTP(基于时间的一次性密码)**\nTOTP (Time-Based One-Time Password) 是 OTP 的一种，它基于当前时间生成密码。TOTP 是 HOTP 的扩展，结合了时间元素来提高安全性。TOTP 的工作原理如下：\n1. 共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 TOTP。\n2. 时间段：TOTP 使用当前时间的一个窗口(通常是 30 秒)来生成密码。每个时间段内生成的密码是唯一的。\n3. 算法：TOTP 使用 HMAC-SHA1 算法和共享密钥以及当前时间戳来生成密码。\n\n**生成和验证**\n- 生成 TOTP：用户的设备(如手机上的 Google Authenticator 应用)使用共享密钥和当前时间生成 TOTP。\n- 验证 TOTP：服务器使用同样的共享密钥和当前时间计算 TOTP，并与用户提供的 TOTP 进行对比。如果匹配，则验证成功。\n\n**优点**\n- 安全性高：每个密码只能使用一次，有效时间短，降低了被攻击的风险。\n- 易于使用：用户只需要输入一次性密码，而不需要记住复杂的密码。\n- 灵活性：适用于各种应用场景，如登录、交易验证等。\n\n**缺点**\n- 时间同步：TOTP 依赖于设备和服务器时间的同步，如果时间不同步，可能会导致验证失败。\n- 设备依赖：需要用户拥有生成 OTP 或 TOTP 的设备，如智能手机。\n\n**HOTP(基于事件的一次性密码)**\nHOTP (HMAC-Based One-Time Password) 是一种基于事件的 OTP(一次性密码)生成方法。HOTP 的生成与验证基于 HMAC-SHA1 算法及一个计数器，确保每次生成的密码都是唯一的。HOTP 的工作原理如下：\n1. 共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 HOTP。\n2. 计数器：用户和服务器都维护一个计数器，计数器初始值相同，每次生成或验证 OTP 时都会增加计数器的值。\n3. HMAC-SHA1 算法：HOTP 使用 HMAC-SHA1 算法，将共享密钥和计数器作为输入，生成一个哈希值。\n4. 生成 OTP：从哈希值中提取部分数据(通常是取哈希值的后几位)，将其转换为一个短数字串，即 OTP。\n\n**生成和验证**\n- 生成 HOTP：用户的设备使用共享密钥和计数器生成 HOTP。\n- 验证 HOTP：服务器使用同样的共享密钥和计数器计算 HOTP，并与用户提供的 OTP 进行对比。如果匹配，则验证成功，并增加计数器的值。\n\n**优点**\n- 无时间依赖：HOTP 不依赖于设备和服务器时间的同步，避免了时间不同步带来的问题。\n- 安全性高：每个密码只能使用一次，降低了密码被截获或重复使用的风险。\n- 灵活性：适用于各种应用场景，如登录、交易验证等。\n\n**缺点**\n- 计数器同步：用户和服务器必须保持计数器的同步，否则会导致验证失败。如果计数器不同步，需要有机制进行重新同步。\n- 复杂性：相较于静态密码，HOTP 的实现和维护相对复杂。\n\n**使用场景**\n- 银行和金融服务：TOTP/HOTP 经常用于网上银行和金融交易中，以确保只有授权用户才能进行操作。\n- 企业安全：企业系统常使用 TOTP/HOTP 进行多因素身份验证，以保护敏感数据和资源。\n- 社交媒体和电子邮件：为了防止账户被黑客入侵，许多社交媒体和电子邮件服务提供商都提供 TOTP/HOTP 作为额外的安全措施。\n\n### Casbin Casdoor 介绍\n> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 \n> Casbin 的主要特点包括：\n> 1. 多种访问控制模型支持：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。\n> 2. 灵活的策略管理：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。\n> 3. 细粒度的权限控制：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。\n> 4. 跨语言支持：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。\n\n> Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。\n> 1. 单点登录(SSO)：支持统一身份验证，用户只需登录一次即可访问多个应用系统。\n> 2. 用户管理：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。\n> 3. 权限控制：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。\n> 4. 开源社区：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。\n\n### RESTful API\n> RESTful API(`Representational State Transfer API`)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。\n> REST架构原则：\n> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。\n> - 统一接口： 资源：通过URL定位资源(通常是名词，如 `/users` 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： `GET`：获取资源 `POST`：创建资源 `PUT`：更新资源 `DELETE`：删除资源\n> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。\n> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。\n> - 按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。\n>\n> 特点：\n> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 \n> - 标准化操作：利用HTTP动词来描述对资源的操作。 \n> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 \n> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 \n> - 无状态交互：每个请求独立，不依赖于之前的请求。\n> \n> 优点 \n> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 \n> - 性能高：无状态和可缓存性提高了性能。 \n> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 \n> - 灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。\n> \n> 缺点 \n> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。\n> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 \n> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。\n> \n> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。\n\n### 国家电网项目\n\n**简介**\n\n自己导师接的项目，江苏省国家电网智能诊断数据分析平台\n\n**项目诉求**\n- 对相应指标进行增删改查\n- 可以导入、导出一些excel表格\n- 对数据进行智能诊断分析\n\n**技术细节**\nreact、Antd、Flask、mongodb\n\n**我的职责**\n在项目中，负责实现各项重要指标的计算、以及对各指标进行灵活的增删改查，实现数据的存取以及前端展示等功能。\n\n### 为什么使用mongodb\nmongodb是一个非关系型数据库，采用文档存储模型，数据以BSON格式存储。项目中，需要导入或者导出 Excel 表格，一个 Excel文件正好可以对应mongodb中的一个文档，这样可以方便地将 Excel 中的数据导入到 mongodb 中。\n\n### 江南布衣实习\n在公司实习期间，我担任网络工程师实习生，主要负责以下工作：\n\n1. 新入职员工设备管理：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。\n\n2. 离职员工设备回收和资料销毁：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>\n\n3. 订货会期间设备组装和网络连接：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。\n\n4. 员工设备报修响应与问题解决：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。\n\n通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。\n\n> **公司内网**：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。\n> 要使一台电脑接入公司内网，经过以下步骤：\n> \n> 1. 网络配置：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。\n> 2. 身份验证：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。\n> 3. 访问内部资源：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。\n\n### 印象最深的一个项目\n之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。\n\n**亮点**\n1. **异步支持**：\n    - 亮点：代码中使用了 `AsyncSession` 和 `async with` 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。\n    - 回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。\n2. **灵活的过滤机制**：\n    - 亮点：通过 `Filter` 类和 `filter_query` 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。\n    - 回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。\n3. **可扩展性**：\n    - 亮点：支持自定义 `db_class`，可以根据不同的需求定制存储策略。同时，默认的 `CasbinRule` 类提供了一个通用的实现。\n    - 回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。\n4. **事务处理**：\n    - 亮点：使用了 `_session_scope` 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。\n    - 回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。\n\n**难点**\n1. **异步编程的复杂性**：\n    - 难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。\n    - 回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。\n2. **数据库模型的灵活性与一致性**：\n    - 难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。\n    - 回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。\n3. **复杂的策略更新逻辑**：\n    - 难点：如 `update_policy` 和 `update_policies` 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。\n    - 回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。\n4. **高效的批量操作**：\n    - 难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。\n    - 回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。\n\n测试方面\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：说明使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。\n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n    - 测试添加一个策略，添加多个策略\n    - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n    - 测试更新一个策略，测试更新多个策略。\n\n通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。\n\n### 学生生涯遇到的挫折和应对策略\n高一升高二的时候，当时是从一个普通班进入全校最好的英才班嘛。然后第一次考试，我考了全班倒数第三，当时从普通班的前几名到倒数第三，可谓是很大的打击，我从小到大就没考过这么差的名词，当时很伤心沮丧吧，回家在房间偷偷哭。\n\n但我也知道，哭是没有用的，我跟别人的差距是确实存在的，从那次后，我比别人更加努力，我花别人更多的时间去学习，去做题，去复习。不会的知识点也请教老师和同学，他们也都很乐意帮助我，我很感谢他们。争取把遇到的每个不会的知识点攻克，我也慢慢的感觉到自己的进步，从才开始的在英才班倒数，到中游 10-20名这样子，到最后高考的时候，考了英才班第四名。\n\n我觉得吧，从这个经历中，我学到了很多，比如说遇到困难要找对方法才行，其次就是要有毅力，不要轻易放弃，最后就是要有信心，相信自己可以做到。\n\n最让我有感触的是，让我学会了 任何时候，都要对自己有信心，不要怀疑自己的能力，相信自己可以做到。这点在我后面的大学学习、跨专业保研中起到了很重要的作用。\n\n## Java基础\n\n### Java和C++的区别\nJava 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：\n- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；\n- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；\n- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；\n- C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。\n\n> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。\n\n### 移位运算符\n`<<`：左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。\n`>>`：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。\n`>>>`：无符号右移，忽略符号位，空位都以 0 补齐。\n\n使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。\n\n如果移位的位数超过数值所占有的位数会怎样？\n当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余(%)** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作(32%32=0)，左移/右移 42 位相当于左移/右移 10 位(42%32=10)。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。\n\n### 基本数据类型/包装类型 及区别\n**8种基本数据类型**\n- 6 种数字类型： \n  - 4 种整数型：`byte`、`short`、`int`、`long`\n  - 2 种浮点型：`float`、`double`\n- 1 种字符类型：`char`\n- 1 种布尔型：`boolean`\n\n> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 \n> `char a = 'h'`，`char`： 单引号，`String a = \"hello\"`，`String`： 双引号。\n\n**8种包装类型** \n`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n**区别**\n- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。\n- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 `static` 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。\n- 占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。\n- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。\n- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。\n\n### 包装类的缓存机制\nJava 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。\n\n### 什么是自动拆装箱\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n- 装箱：将基本类型用它们对应的引用类型包装起来；\n- 拆箱：将包装类型转换为基本数据类型；\n\n从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。\n\n### 如何解决浮点数运算的精度丢失问题\n\n无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 `BigDecimal` 来做的。\n\n### 局部变量/成员变量/静态变量\n\n- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\n- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\n- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 `final` 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。\n\n静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。\n\n### 重载和重写\n- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\n  - 构造方法无法被重写\n\n### 面向对象和面向过程区别\n两者的主要区别在于解决问题的方式不同：\n- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\n- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\n\n另外，面向对象开发的程序一般更易维护、易复用、易扩展。\n\n### 接口和抽象类区别\n共同点： 都不能被实例化\nhttps://learn.skyofit.com/archives/351\n**区别**\n- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。\n- 抽象类可以有构造方法，接口不能有构造方法。\n- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。\n- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。\n- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。\n- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。\n\n### 堆和栈的区别\nhttps://blog.csdn.net/qq_44944221/article/details/126692973\n- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；\n- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；\n\n区别：\n- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；\n- 共享性不同：栈是线程私有，而堆是线程共享；\n- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；\n- 空间大小不同：堆空间大小远远大于栈的内存空间。\n\n### 深拷贝/浅拷贝/引用拷贝\n- 深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。\n- 浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n- 引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？\n\n### Object 类\nObject 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：\n```java\n//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\npublic final native Class<?> getClass()\n\n//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\npublic native int hashCode()\n\n//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\npublic boolean equals(Object obj)\n\n//native 方法，用于创建并返回当前对象的一份拷贝。\nprotected native Object clone() throws CloneNotSupportedException\n\n//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\npublic String toString()\n\n//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable { }\n```\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n  - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n  - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 形参&实参\n- 形参(形式参数，Parameters)：用于定义函数/方法，接收实参，不需要有确定的值。\n- 实参(实际参数，Arguments)：用于传递给函数/方法的参数，必须有确定的值。\n\n### 值传递&引用传递\n- 值传递：方法接收的是实参值的拷贝，会创建副本。\n- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。\n\nJava 中只有值传递，C++ 中有值传递和引用传递。\n\n### ==和equals()区别\n- `==` 可以用来比较基本数据类型和引用数据类型\n  - 基本数据类型：比较的是值是否相等\n  - 引用数据类型：比较的是引用地址是否相等\n  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。\n- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。\n  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。\n  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。\n\n### hashCode()和equal()\n`hashCode()` 的作用是获取哈希码(`int` 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n\n`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。\n- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等(**哈希碰撞**)。\n- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。\n- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。\n\n**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**\n因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。\n\n### String/StringBuffer/StringBuilder\n- `String` ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。\n- `StringBuffer` ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。\n- `StringBuilder` ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。\n\n- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。\n- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。\n- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n** `String` 为什么不可变？**\n- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。\n- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。\n\n### 字符串拼接使用+还是StringBuilder？\nJava中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。\n\n### String.equals()/Object.equals()\n`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。\n\n### 字符串常量池\n**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n\n### 异常\n异常的共同祖先是 `Throwable` 类，其有两个重要的子类：\n`Error`： 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。\n`Exception`： 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。\n\n### Checked/Unchecked Exception\n- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。\n  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。\n- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。\n  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。\n\n### try-catch-finally\n`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。\n`catch`：用于处理 `try` 捕获到的异常。\n`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。\n\n> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。\n\n### 泛型\n- 使用泛型参数，可以增强代码的可读性以及稳定性。\n- 泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。\n\n### 反射\n反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。\n\n- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n\n### 注解\n注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。\n\n### 序列化/反序列化\n如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n- 序列化：将数据结构或对象转换成二进制字节流的过程\n- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\n\n序列化和反序列化常见应用场景：\n- 对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；\n- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；\n- 将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；\n- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。\n\n### 语法糖\n语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。\n\nJava 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。\n\n## Java集合\n\n### List/Set/Queue/Map区别\n- List： 存储的元素是有序的、可重复的。\n- Set： 存储的元素不可重复的。\n- Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\n- Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n### 如何选用集合?\n主要根据集合的特点来选择合适的集合。如：\n- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。\n- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。\n\n### 为什么要使用集合？\n在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\n\n### ArrayList和Array区别\n`ArrayList` 内部基于动态数组实现，比 `Array`(静态数组) 更加灵活：\n- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。\n- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。\n- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。\n- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。\n- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。\n\n> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。\n\n### ArrayList和LinkedList区别\n- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。\n  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。\n  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。\n- 二者都是线程不安全的。\n- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。\n- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。\n\n> 项目中一般不会使用 `LinkedList`。\n\n### ArrayList和LinkedList插入/删除效率\n`ArrayList`\n- 头部插入/删除：O(n), 需要移动元素。\n- 指定位置插入/删除：O(n), 需要移动元素。\n- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\n`LinkedList`\n- 头部插入/删除：O(1), 只需改变指针指向。\n- 尾部插入/删除：O(1), 只需改变指针指向。\n- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。\n\n### CopyOnWriteArrayList\n`CopyOnWriteArrayList` 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 `Copy-On-Write(COW)`的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：\n- 读多写少：大部分操作都是读取数据，写操作相对较少。\n- 不要求实时性：因为写操作需要创建数组副本，可能会有短暂的延迟。\n\n`ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。\n\n**优点**\n- 线程安全：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。\n- 简化并发控制：不需要显式的同步块或锁定机制。\n- 迭代器安全：迭代器不会抛出 `ConcurrentModificationException`，因为迭代时是基于快照的。\n\n**缺点**\n- 内存开销大：每次写操作都会创建数组副本，可能会占用较多的内存。\n- 写操作开销大：由于需要复制整个数组，写操作的时间复杂度为 O(n)。\n- 读取旧数据：在高并发场景下，可能会读取到旧的数据。\n\n**适用场景**\n- 配置类数据：如系统配置参数、常量集合等。\n- 事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。\n\n**不适用场景**\n- 高并发写操作：如果有大量的写操作，那么 `CopyOnWriteArrayList` 的性能会变差。\n- 实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。\n\n**结论**\n`CopyOnWriteArrayList` 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 `ConcurrentHashMap` 或 `ConcurrentLinkedQueue`。\n\n### HashSet/LinkedHashSet/TreeSet\n- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。\n- 主要区别在于底层数据结构不同。\n  - `HashSet` 底层是哈希表(`HashMap`)。\n  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。\n  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。\n\n### Map(重要)\n### HashMap/HashTable区别\n- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。\n- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。\n- `HashTable`中有锁，所以效率比 `HashMap` 低。\n- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。\n- 初始容量大小和每次扩充容量大小的不同： \n  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。\n  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\n  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。\n\n> `HashTable` 已经被淘汰，不建议使用。\n> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`\n\n### HashMap长度为什么是2的幂次方\nkey经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。\n\n“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作(也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。\n\n### HashMap/TreeMap区别\n- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。\n- `HashMap` 是无序的，`TreeMap` 是有序的。\n- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。\n- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。\n\n相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\n\n### HashSet如何检查重复\n把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。\n\n在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。\n\n### HashMap底层实现\n**JDK1.8 之前**\n底层是数组和链表。哈希冲突使用“拉链法”解决。\n\n`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。\n\n- 扰动函数 `hash()` 可以减少碰撞。\n- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。\n\n**JDK1.8 之后**\n底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。\n\n- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。\n- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。\n\n### HashMap多线程扩容死循环问题\nJDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\n\n为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。\n\n> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。\n\n### HashMap为什么不支持高并发\n### HashMap为什么线程不安全\n- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。\n- JDK1.7 和 JDK 1.8 都存在数据丢失问题。如下：\n\n**数据丢失**\n在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。\n> 例子：\n> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。\n> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\n> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\n\n### 遍历HashMap\n七种\n```java\nHashMap<Integer, String> map = new HashMap<>();\n// ForEach EntrySet\nfor (Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// ForEach KeySet\nfor (Integer key : map.keySet()) {\n    System.out.println(key + \":\" + map.get(key));\n}\n// 迭代器EntrySet\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry<Integer, String> entry = iterator.next();\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// 迭代器KeySet\nIterator<Integer> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    Integer key = iterator.next();\n    System.out.println(key + \":\" + map.get(key));\n}\n// Lambda\nmap.forEach((key, value) -> {\n    System.out.println(key);\n    System.out.println(value);\n});\n// Streams API 单线程\nmap.entrySet().stream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n// Streams API 多线程\nmap.entrySet().parallelStream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n```\n\n### ConcurrentHashMap/Hashtable区别\n- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。\n- 实现线程安全的方式：\n  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。\n  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - `Hashtable`(同一把锁) ：使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。\n\n### ConcurrentHashMap底层\n\nJDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。\n\n`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。\n\nJDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。\n\n\n### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\n- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。\n- Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。\n- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。\n\n### ConcurrentHashMap能保证复合操作的原子性吗？\n- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。\n- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。\n\n### 什么是LinkedHashMap\n继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性：\n- 支持遍历时会按照插入顺序有序进行迭代\n- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。\n\n> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。\n\n### LinkedHashMap如何按照访问顺序迭代元素？\n`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。\n\n### 如何实现LRU缓存\n- `accessOrder` = `true` \n- 继承`LinkedHashMap`\n- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。\n```java\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n```\n### LinkedHashMap和HashMap的区别\n- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。\n- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。\n\n### Queue/Deque区别\n- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。\n- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。\n\n### ArrayDeque/LinkedList区别\n- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。\n- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。\n- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。\n\n从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。\n\n### PriorityQueue\nPriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\n- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\n- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。\n- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。\n\n> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。\n\n### BlockingQueue及其实现类\n`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。\n\n**实现类**\n- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。\n- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。\n- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。\n- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。\n- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n### ArrayBlockingQueue\n- `put()`、`take()`：插入和删除元素时，如果队列已满或者为空，会阻塞等待。\n- `offer()`、`poll()`：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 `false` 或者 `null`。\n- 并发控制采用可重入锁 `ReentrantLock` 保证线程安全，插入/读取操作都需获取到锁才能进行，且支持公平/非公平两种方式的锁访问机制，默认是非公平锁。\n\n### ArrayBlockingQueue实现原理\n- `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。\n- 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。\n- 通过 `Condition` 接口实现线程间的等待和唤醒操作。\n\n线程间的等待和唤醒具体的实现：\n- 当队列已满时，生产者线程会调用 `notFull.await()` 方法让生产者进行等待，等待队列非满时插入(非满条件)。\n- 当队列为空时，消费者线程会调用 `notEmpty.await()`方法让消费者进行等待，等待队列非空时消费(非空条件)。\n- 当有新的元素被添加时，生产者线程会调用 `notEmpty.signal()`方法唤醒正在等待消费的消费者线程。\n- 当队列中有元素被取出时，消费者线程会调用 `notFull.signal()`方法唤醒正在等待插入元素的生产者线程。\n\n### ArrayBlockingQueue/LinkedBlockingQueue区别\n二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：\n- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。\n- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。\n- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。\n- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。\n\n### DelayQueue底层\n是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n**底层**\n`DelayQueue` 底层用 `PriorityQueue` 存储元素，`PriorityQueue` 采用**二叉小顶堆**的思想确保值小的元素排在最前面，使得 `DelayQueue` 对于延迟任务优先级的管理非常方便。同时 `DelayQueue` 为了保证线程安全还用到了可重入锁 `ReentrantLock`,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 `Condition`接口，通过 `Condition` 的 `await` 和 `signal` 方法完成多线程之间的等待唤醒。\n\n> ```java\n> //可重入锁，实现线程安全的关键\n> private final transient ReentrantLock lock = new ReentrantLock();\n> //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列\n> private final PriorityQueue<E> q = new PriorityQueue<E>();\n> //指向准备执行优先级最高的线程\n> private Thread leader = null;\n> //实现多线程之间等待唤醒的交互\n> private final Condition available = lock.newCondition();\n> ```\n> `leader` ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 `leader` 来管理延迟任务，只有 `leader` 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 `leader` 线程执行完手头的延迟任务后唤醒它。\n> `available` ： 等待唤醒操作的交互是通过 `available` 实现的，假如一个线程尝试在空的 `DelayQueue` 获取任务时，`available` 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 `available` 的 `signal` 方法将其唤醒。\n\n\n### DelayQueue是否线程安全？\n`DelayQueue`是线程安全的，它通过 `ReentrantLock` 实现了互斥访问和 `Condition` 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。\n\n### DelayQueue使用场景\n通常用于实现定时任务调度和缓存过期删除等场景。\n- 在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 `DelayQueue` 中，`DelayQueue` 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。\n- 缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 `key` 封装成一个延迟的删除任务，并将其添加到 `DelayQueue` 中，当数据过期时，拿到这个任务的 `key`，将这个 `key` 从内存中移除。\n\n### DelayQueue中Delayed接口的作用是什么？\n`DelayQueue` 中存放的元素必须实现 `Delayed` 接口，并且需要重写 `getDelay()`方法。`Delayed`接口定义了元素的剩余延迟时间(`getDelay()`)和元素之间的比较规则(继承 `Comparable` 接口),否则 `DelayQueue` 无法得知当前任务剩余时长和任务优先级的比较。\n\n### DelayQueue/Timer/TimerTask区别\n都可以用于实现定时任务调度，但实现方式不同。\n- `DelayQueue` 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；\n- `Timer/TimerTask` 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。\n- `DelayQueue` 支持动态添加/移除任务，`Timer/TimerTask` 只能在创建时指定任务。\n\n\n## Java并发\n\n### 进程/线程/协程\nhttps://blog.csdn.net/m0_60505735/article/details/131047046\nhttps://blog.csdn.net/weixin_49199646/article/details/109210547\n- 进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。\n- 线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n- 协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。\n\n**进程与线程的区别**\n- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。\n- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。\n- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。\n\n**进程与线程的联系**\n一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。\n\n*进程与线程的选择**\n- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；\n- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；\n- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程\n- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。\n\n综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。\n\n### Java线程和操作系统线程有何区别\n现在的 Java 线程的本质其实就是操作系统的线程。\n\n- JDK1.2之前Java线程基于绿色线程(`Green Threads`)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。\n- JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n\n线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。\n\n在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。\n\n### 程序计数器为啥是私有的\n程序计数器主要有下面两个作用：\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n- 如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n\n### 虚拟机栈和本地方法栈为啥是私有的\n- 虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n\n### 一句话简单了解堆和方法区\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n### 如何创建线程\n- 继承`Thread`类并重写`run()`方法\n- 实现`Runnable`接口并重写`run()`方法\n- 实现`Callable`接口并重写`call()`方法\n- 使用线程池`ThreadPoolExecutor`创建线程\n- 等等......\n\n其实只有一种方式可以创建线程，那就是通过 `new Thread().start()` 创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。\n\n### 线程的生命周期和状态\nJava 线程 6 种状态：\n`NEW`： 初始状态，线程被创建出来但没有被调用 `start()` 。\n`RUNNABLE`： 运行状态，线程被调用了 `start()`等待运行的状态。\n`BLOCKED`：阻塞状态，需要等待锁释放。\n`WAITING`：线程执行`wait()`方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。\n`TIME_WAITING`：超时等待状态，调用`sleep(long millis)`可以在指定的时间后自行返回而不是像 `WAITING` 那样一直等待。\n`TERMINATED`：执行完`run()`方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n### 线程上下文切换开销\n线程在执行过程中会有自己的运行条件和状态(也称**上下文**)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。\n- 时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。\n- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\n\n线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\n\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\n\n### Thread.sleep()方法和Object.wait()方法对比\n共同点：两者都可以暂停线程的执行。\n区别：\n- `sleep()` 方法没有释放锁，`wait()` 方法释放锁 。\n- `sleep()`通常被用于暂停执行，`wait()` 通常被用于线程间交互/通信。\n- `wait()`方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()`方法。`sleep()`方法执行完成后，线程会自动苏醒(或者也可以使用`wait(long timeout)`超时后线程会自动苏醒)。\n- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。\n\n### 锁的基本概念\nJava 中，每个对象都有一个与之关联的监视器(`monitor`)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。\n\n### Java中有哪些锁\n- `synchronized`关键字\n  - 用于同步方法或同步代码块。\n  - 基于对象锁，每个对象都有一个监视器锁。\n- `ReentrantLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供更灵活的锁机制，相比`synchronized`，支持公平锁、非公平锁等特性。\n  - 支持可重入锁，即同一个线程可以多次获取同一个锁。\n- `ReentrantReadWriteLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供读写锁的实现，读锁共享，写锁独占。\n  - 适用于读多写少的场景，提升并发性能。 \n- `StampedLock`\n  - 在`java.util.concurrent.locks`包中提供。\n  - 提供三种锁模式：写锁、悲观读锁和乐观读锁。\n  - 乐观读锁在某些情况下可以避免加锁操作，提升性能。\n- `LockSupport`\n  - 提供基本的线程阻塞和唤醒机制。\n  - 通常用于构建更高级的同步器，如`Semaphore`、`CountDownLatch`等。\n- `Semaphore`\n  - 在`java.util.concurrent`包中提供。\n  - 用于控制同时访问特定资源的线程数量。\n- `CountDownLatch`\n  - 在`java.util.concurrent`包中提供。\n  - 允许一个或多个线程等待一组操作完成。 \n- `CyclicBarrier`\n  - 在`java.util.concurrent`包中提供。\n  - 使一组线程在到达一个共同的屏障点时被阻塞，直到所有线程都到达该点。\n- Phaser\n  - 在`java.util.concurrent`包中提供。\n  - 允许多阶段的线程协作，每个阶段完成后继续下一阶段。 \n- `Atomic`变量\n  - 在`java.util.concurrent.atomic`包中提供。\n  - 提供了一些基本类型(如`AtomicInteger`、`AtomicLong`)的原子操作，实现了无锁的线程安全。\n\n这些锁机制可以根据具体的应用场景选择，以实现高效、安全的并发控制。\n\n### 为什么wait()方法不定义在Thread中\n- 锁是对象级别的，每个对象都有一把锁。\n- `wait()` 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。\n\n### 为什么sleep()方法定义在Thread中\n- `sleep()` 是线程控制方法，作用对象是线程本身。\n- 线程暂停执行，不涉及到对象类，也不需要获得对象锁。\n\n### sleep()如何控制当前线程沉睡\n调用 `Thread.sleep()` 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。\n\n### 可以直接调用Thread类的run方法吗\n可以但不建议。`new` 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 `main` 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。\n\n### 并发/并行区别\n- 并发：两个及两个以上的作业在同一 **时间段** 内执行。\n- 并行：两个及两个以上的作业在同一 **时刻** 执行。\n\n### 同步/异步区别\n- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。\n- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。\n\n### 为什么要使用多线程\n- 线程切换和调度的成本远远小于进程。\n- 单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。\n- 多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。\n- 并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。\n\n### 使用多线程风险\n- 线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。\n- 死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。\n- 内存泄漏：线程未正确释放资源，导致内存泄漏。\n- 上下文切换：线程频繁切换，会增加系统开销。\n- ...\n\n### 如何理解线程安全和不安全\n线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性** 和**一致性** 的描述。\n- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。\n- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。\n\n### 高并发存在什么问题,Java如何解决的\n**高并发问题**\n- 资源竞争：多个线程竞争同一资源(如内存、文件、数据库连接等)，可能导致数据不一致、死锁等问题。\n- 死锁：多个线程在等待对方释放资源，从而相互阻塞，导致程序无法继续执行。\n- 上下文切换开销：线程之间的切换会消耗系统资源，频繁的上下文切换会降低系统性能。\n- 线程安全：确保多个线程对共享资源的操作不会导致数据不一致的问题。\n- 内存泄漏：大量创建和销毁线程，如果不合理管理，会导致内存泄漏。\n- 饥饿和公平性：某些线程可能长期得不到资源，导致饥饿问题。如何确保线程公平地获取资源也是一个挑战。\n- 负载均衡：在分布式系统中，如何将请求均衡地分配到不同的服务器，以避免某些服务器过载。\n\n**Java解决高并发问题**\n- 线程池(Thread Pool)：通过线程池管理线程的创建和销毁，减少资源消耗，提高系统性能。\n- 同步机制(Synchronization)：使用 `synchronized`关键字或显示锁(如`ReentrantLock`)来确保线程安全，避免资源竞争。\n- 并发工具类：如`ConcurrentHashMap`、`CopyOnWriteArrayList`等，这些工具类可以帮助开发者更方便地实现线程间的协调和资源共享。\n- 无锁算法(Lock-Free Algorithms)：使用原子变量类(如`AtomicInteger`、`AtomicLong`)来实现无锁并发，减少上下文切换开销，提高性能。\n- CAS操作(Compare-And-Swap)：CAS是一种无锁算法，通过比较和交换操作来实现原子性。Java中的`Unsafe`类和`Atomic`包使用了CAS操作来实现无锁算法。\n- Fork/Join框架：用于任务拆分和并行处理，适用于大规模数据并行处理。Java 7引入了`ForkJoinPool`来支持这一框架。\n- 异步编程(Asynchronous Programming)：通过`CompletableFuture`和异步方法调用，实现非阻塞的并发编程模型。\n\n### Java如何实现高并发\n**使用线程池**\n线程池可以有效管理线程的创建和销毁，减少资源消耗和上下文切换开销。Java中的`ExecutorService`和`Executors`类提供了便捷的线程池实现。\n```java\nExecutorService executor = Executors.newFixedThreadPool(10);\nfor (int i = 0; i < 100; i++) {\n    executor.submit(new Task());\n}\nexecutor.shutdown();\n```\n**同步机制**\n使用`synchronized`关键字或者显式锁(如`ReentrantLock`)来确保线程安全，避免资源竞争和数据不一致问题。\n```java\npublic synchronized void safeMethod() {\n    // Critical section\n}\n\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}\n```\n**并发集合类**\nJava提供了线程安全的并发集合类，如`ConcurrentHashMap`、`CopyOnWriteArrayList`、`BlockingQueue`等，这些集合类可以简化多线程编程。\n\n**原子变量类**\n使用原子变量类(如`AtomicInteger`、`AtomicLong`)来实现无锁并发，减少上下文切换，提高性能。\n\n**CAS操作**\nJava的`Atomic`包和`Unsafe`类使用了CAS(Compare-And-Swap)操作来实现无锁算法，从而提高并发性能。\n```java\nAtomicInteger count = new AtomicInteger(0);\nboolean updated = count.compareAndSet(0, 1);\n```\n**Fork/Join框架**\n`ForkJoinPool`用于任务拆分和并行处理，适用于大规模数据的并行计算。\n```java\nForkJoinPool pool = new ForkJoinPool();\npool.invoke(new RecursiveTask<Void>() {\n    @Override\n    protected Void compute() {\n        // Task implementation\n        return null;\n    }\n});\n```\n**异步编程**\n使用`CompletableFuture`和异步方法调用，实现非阻塞的并发编程模型。\n```java\nCompletableFuture.supplyAsync(() -> {\n    // Async task\n    return \"result\";\n}).thenAccept(result -> {\n    // Process result\n});\n```\n**使用非阻塞I/O**\n在网络编程中，使用NIO(Non-blocking I/O)实现高并发。NIO提供了选择器(`Selector`)、通道(`Channel`)和缓冲区(`Buffer`)等工具，可以实现高效的非阻塞I/O操作。\n\n**使用第三方并发框架**\n如Akka、RxJava、Vert.x等，它们提供了更加高级的并发和反应式编程模型。\n\n### 单核CPU上运行多个线程效率一定会高吗\n如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。\n如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。\n\n### 死锁\n死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\n> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n产生死锁的四个必要条件：\n- 互斥条件：该资源任意一个时刻只由一个线程占用。\n- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n- 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n### 如何检测死锁\n- 一般死锁可能会导致 CPU 使用率飙升，线程处于 `BLOCKED` 状态，可以通过监控工具查看。\n- jConsole： 可以检测死锁，查看线程的状态。\n- jstack： 如有死锁，会输出`Found one Java-level deadlock: `线程的状态信息\n\n### 如何预防和避免死锁\n破坏死锁的产生的必要条件：\n- 破坏请求与保持条件：一次性申请所有的资源。\n- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n避免死锁就是在资源分配时，借助于算法(比如**银行家算法** )对资源分配进行计算评估，使其进入安全状态。\n\n> 安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\n\n### Java内存模型JMM\nJMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。\n\n### 为什么需要Java内存模型\n- Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\n- JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。\n- 对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 `volatile`、`synchronized`、各种 `Lock`)即可开发出并发安全的程序。\n\n### Java内存区域和Java内存模型有什么区别\n- Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。\n- Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。\n\n### JMM是如何抽象线程和主内存之间的关系\nJava内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。\n\n### 主内存与工作内存\n- 主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。\n- 工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。\n\n### 并发编程三大特性\n可见性、原子性和有序性\n- 可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、`volatile`关键字、`synchronized`块等手段来实现可见性。\n- 原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。\n- 有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的`happens-before`规则，确保代码的执行顺序对多线程环境是可预测的。\n\nJMM通过上面三种属性来确保线程之间的内存一致性。\n\n### 如何保证变量的可见性(volatile)\n`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n### 如何禁止指令重排序\n`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 `volatile` ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\n\n### volatile可以保证原子性\n`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。\n\n### 乐观锁/悲观锁\n- 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n  - `synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n  - 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。\n  - 悲观锁可能会存在死锁问题。\n  - 通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。\n- 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。\n  - 具体方法可以使用版本号机制或 CAS 算法，`AtomicInteger`、`LongAdder`等都是乐观锁的实现。\n  - 高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。\n  - 如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n    - `LongAdder`以空间换时间的方式就解决了大量重试问题。\n  - 通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。\n\n### 如何实现乐观锁\n- 版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。\n- CAS算法：`compare and swap`，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。\n  - V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n\n> 举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V = 1，E=1，N=6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\n\n### CAS算法存在问题\n\n### ABA问题\n变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \"ABA\"问题。\n\nABA问题的解决思路是在变量前面追加上版本号或者时间戳。\n\n**循环时间长开销大**\nCAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。\n\n**只能保证一个共享变量的原子操作**\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用`AtomicReference`。\n\n### synchronized关键字\n`synchronized` 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n### JDK1.6之后synchronized的优化\n在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，`synchronized`引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。\n\n### 锁升级原理了解吗\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n### 如何使用synchronized\n- 修饰实例方法：锁住当前实例对象。\n```java\nsynchronized void method() {\n    //业务代码\n}\n```\n- 修饰静态方法：锁住当前类的 Class 对象。\n```java\nsynchronized static void method() {\n    //业务代码\n}\n```\n- 修饰代码块：锁住括号里面的对象。\n  - `synchronized(object)` 表示进入同步代码库前要获得 给定对象的锁。\n  - `synchronized(类.class)` 表示进入同步代码前要获得 给定 `Class` 的锁\n\n```\nsynchronized(对象) {\n    //业务代码\n}\nsynchronized(类.class) {\n    //业务代码\n}\n```\n\n### synchronized底层原理\n`synchronized` 关键字是通过对象内部的一个叫做监视器锁(`monitor`)来实现的。\n\n- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。\n- `synchronized` 修饰的方法使用 `ACC_SYNCHRONIZED` 标识，JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n两者的本质都是对对象监视器 `monitor` 的获取。\n\n### ReentrantLock\n`ReentrantLock` 是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\n\n`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承抽象类 `AQS(AbstractQueuedSynchronizer，抽象队列同步器)`，添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。\n\n### AQS核心思想\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于`CLH`锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。\n\n以可重入互斥锁 `ReentrantLock` 为例，其内部维护了一个使用`volatile`修饰(保证线程可见性)的`state`变量，用来表示锁的占用状态。`state` 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 `lock()` 方法时，会尝试通过 `tryAcquire()` 方法独占该锁，并让 `state` 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(`CLH` 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(`state` 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 `state` 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\n\n> `CLH`锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 `CLH` 队列锁的一个结点(`Node`)来实现锁的分配。在 `CLH` 队列锁中，一个节点表示一个线程，它保存着线程的引用(`thread`)、 当前节点在队列中的状态(`waitStatus`)、前驱节点(`prev`)、后继节点(`next`)。\n\n### AQS资源共享模式\nAQS 支持两种资源共享方式：独占和共享。\n- `Exclusive`(独占，只有一个线程能执行，如`ReentrantLock`)\n- `Share`(共享，多个线程可同时执行，如`Semaphore/CountDownLatch`)\n\n> 也可以自定义同步器同时实现独占和共享，如`ReentrantReadWriteLock`，读操作时多个线程可以同时进行，写操作时只能一个线程进行。\n\n### Semaphore\n`Semaphore` 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的`state`表示许可数(>=1)，当一个线程调用 `acquire()` 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 `release()` 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。\n\n### 公平锁/非公平锁\n- 公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n- 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n\n### synchronized和ReentrantLock有什么区别？\n两者都是可重入锁\n- `synchronized` 是关键字，是内置的语言实现，`ReentrantLock` 是一个类。\n- `synchronized` 是 JVM 实现的，`ReentrantLock` 是 JDK 实现的(也就是 API 层面，需要 `lock()` 和 `unlock()` 方法配合 `try/finally` 语句块来完成)\n- `ReentrantLock` 比 `synchronized` 增加了一些高级功能：\n  - 等待可中断 ： `ReentrantLock`提供一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()`实现。\n  - 可实现公平锁： `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。通过`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。\n  - 可实现选择性通知(锁可以绑定多个条件)： `synchronized`关键字与`wait()`和`notify()/notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以，但需借助`Condition`接口与`newCondition()`方法。\n\n> 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个`synchronized`修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\n\n### 可中断锁/不可中断锁\n- 可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。`ReentrantLock` 是可中断锁。\n- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 是不可中断锁。\n\n### ReentrantReadWriteLock\n是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n`ReentrantReadWriteLock` 其实是两把锁，一把是 `WriteLock` (写锁)，一把是 `ReadLock`(读锁) 。读锁是**共享锁**，写锁是**独占锁**。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n> 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\n> 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。\n\n### 共享锁/独占锁\n- 共享锁：一把锁可以被多个线程同时获得。\n- 独占锁：一把锁只能被一个线程获得。\n\n### 线程持有读锁还能获取写锁吗\n- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\n- 在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。\n\n### 读锁为什么不能升级为写锁\n- 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。\n- 可能会有死锁问题发生。\n\n### StampedLock\n`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，没有实现 `Lock`或 `ReadWriteLock`接口，而是基于 `CLH` 锁独立实现的。\n\n提供三种访问模式：\n- 写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。\n- 读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。\n- 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比`ReadWriteLock`更好的原因)\n\n### ThreadLocal\n`ThreadLocal` 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n### ThreadLocal原理\n`ThreadLocal` 通过 `ThreadLocalMap` 来实现线程内部的数据存储。`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，每个线程中都有一个 `ThreadLocalMap`，`ThreadLocal` 通过 `get()`、`set()` 方法访问 `ThreadLocalMap`。在一个线程中创造多个`ThreadLocal`对象，这个许多个`ThreadLocal`对象会被放到一个`ThreadLocalMap`中。\n\n> `ThreadLocalMap`可以理解为一个定制化的 `HashMap`，`key` 是 `ThreadLocal` 对象，`value` 是存储的值。\n> 可以存在这种情况： 在线程 1 中创建了两个 `ThreadLocal` 对象，在线程 1 中只有一个 `ThreadLocal` 对象。\n\n### ThreadLocal内存泄漏\n`ThreadLocalMap` 中使用的 `key` 为 `ThreadLocal` 的弱引用，而 `value` 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，`key` 会被清理掉，而 `value` 不会被清理掉。这样一来就会出现 `key` 为 `null` 的 键值对。如果不做任何措施的话，`value` 永远无法被 GC 回收，这个时候就可能会产生内存泄露。\n\n其实`ThreadLocalMap`实现中已经考虑了内存泄漏问题，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 `key` 为 `null` 的记录。不过使用完 `ThreadLocal`方法后最好手动调用`remove()`方法。\n\n> `HashMap` 的 `key` 和 `value` 都是强引用，因此不会存在弱引用导致的内存泄漏问题。\n\n### 线程池\n线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n### 为什么用线程池\n- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n> 在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n### 创建线程池的方式\n- 通过`ThreadPoolExecutor`构造函数来创建 _**(推荐)**_ 。\n- 通过`Executors`工具类来创建 _**(不推荐)**_ 。通过这种方式可以创建出多种类型的线程池\n  - `FixedThreadPool`：固定大小的线程池。\n  - `SingleThreadPool`：只有一个线程的线程池。\n  - `CachedThreadPool`：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。\n  - `ScheduledThreadPool`：定时任务的线程池。\n\n### 为什么不推荐使用内置线程池\n- `FixedThreadPool`，`SingleThreadPool`，`ScheduledThreadPool`：使用的是无界的 `LinkedBlockingQueue`，允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。\n- `CachedThreadPool`：使用同步队列`SynchronousQueue`，允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。\n\n### ThreadPoolExecutor参数\n3 个最重要的参数：\n- `corePoolSize` ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n- `maximumPoolSize` ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n- `workQueue`： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\n其他常见参数 ：\n- `keepAliveTime`：线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。\n- `unit` ： `keepAliveTime` 参数的时间单位。\n- `threadFactory` ：`executor` 创建新线程的时候会用到。\n- `handler` ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。\n\n### 线程池的拒绝策略\n- `AbortPolicy`：直接抛出异常，阻止系统正常工作。\n- `CallerRunsPolicy`：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。\n- `DiscardOldestPolicy`：丢弃最早的未处理的任务请求。\n- `DiscardPolicy`：不处理新任务，直接丢弃掉。\n\n### CallerRunsPolicy策略风险及解决方案\n**风险**\n`CallerRunsPolicy` 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n\n**解决方案**\n1. 使用`CallerRunsPolicy`是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列`BlockingQueue`中，这样在内存允许的情况下，可以增加阻塞队列`BlockingQueue`的大小以容纳更多的任务，同时调整线程池的`maximumPoolSize` (最大线程数)参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。\n2. 使用`ThreadPoolExecutor`的`setRejectedExecutionHandler`方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 `Redis`缓存任务。\n\n### 线程池常用阻塞队列\n- `LinkedBlockingQueue`：基于链表的阻塞队列，大小默认为 `Integer.MAX_VALUE`，即任务队列永远不会放满。`FixedThreadPool` 和 `SingleThreadExector`使用，前者只能创建核心线程数的线程，后者只能创建一个线程。\n- `SyncronousQueue`：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\n- `DelayedWorkQueue`：延迟阻塞队列，`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。\n\n### 线程池处理任务流程\n1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。\n3. 如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。\n\n### 线程池中线程异常后销毁还是复用？\n两种情况：\n- 使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；\n- 使用`ExecutorService.submit()`时，异常被封装在`Future`中，线程继续复用。\n\n### 如何设定线程池大小\n- CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。\n- I/O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I/O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。\n\n### 如何设计一个根据任务优先级执行的线程池\n- 使用`PriorityBlockingQueue`作为任务队列，队列中的任务按照优先级顺序执行。\n- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。\n\n这样还存在一些问题：\n- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。\n  - 解决方法：继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 `false 。\n- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。\n  - 解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。\n\n### 异步调用Future类\n\n`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n`Future`类是一个泛型接口，主要包含下面几个方法：\n```\n// V 代表了Future执行的任务返回值的类型\npublic interface Future<V> {\n    // 取消任务执行，成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 判断任务是否被取消\n    boolean isCancelled();\n    // 判断任务是否已经执行完成\n    boolean isDone();\n    // 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n}\n```\n\n### Callable和Future关系\n`Callable` 用于定义可以返回结果的任务，`Future` 用于获取 `Callable` 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。\n- 任务提交与执行：通常通过 `ExecutorService` 提交 `Callable` 任务，`submit` 方法返回一个 `Future` 对象。\n- 异步结果获取：`Future` 对象可以用来获取 `Callable` 任务的返回结果或处理异常。\n\n### CompletableFuture类有什么用？\n`CompletableFuture` 类是 Java 8 中引入的一个增强版 `Future`，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 `Future` 相比，`CompletableFuture` 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。\n\n### CompletableFuture类异步调用实现\n```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // 创建一个CompletableFuture来执行异步任务\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            // 模拟一个长时间运行的任务\n            try {\n                Thread.sleep(2000); // 休眠2秒\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"任务完成\";\n        });\n        // 注册一个回调函数，当任务完成时获取结果\n        future.thenAccept(result -> {\n            System.out.println(\"异步任务结果: \" + result);\n        });\n        // 主线程继续执行其他操作\n        System.out.println(\"主线程继续执行...\");\n        // 阻塞主线程，直到异步任务完成（可选）\n        try {\n            // 这一步会阻塞主线程，直到异步任务完成\n            String result = future.get();\n            System.out.println(\"异步任务完成后获取的结果: \" + result);\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n### 虚拟线程\n虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\n\n虚拟线程(`Virtual Thread`)是 JDK 而不是操作系统实现的轻量级线程(`Lightweight Process，LWP`)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n\n在没有虚拟线程之前，JVM使用的是**平台线程**，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。\n\nJVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。\n\n**优点**\n- 非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。\n- 简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。\n- 减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。\n\n**缺点**\n不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。\n依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。\n\n## IO\n\nIO(`Input/Output`)即输入/输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。\n\nIO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\n- `InputStream/Reader`： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- `OutputStream/Writer`： 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n### Java为什么要分字节流和字符流\nJava 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。\n- 字符流自动处理字符编码问题，非常适合文本数据；\n- 字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。\n\n### 字节流和字符流区别\n- 字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。\n- 字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。\n- 字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。\n\n### IO设计模式总结\n- 装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。\n- 适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\n- 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n- 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。\n\n### 装饰器模式和适配器模式区别\n- 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n- 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n\n### 3种常见的IO模型\n- BIO(`Blocking IO`)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n  - 优点：编程简单，代码易于理解。\n  - 缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。\n- NIO(`Non-blocking IO`)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。\n  - 优点：单线程可以处理多个连接，提高并发性能。\n  - 缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n- AIO(`Asynchronous IO`)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。\n  - 优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。\n  - 缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。\n\n\n\n\n## JVM\n### 内存区域\nJava内存区域/Java虚拟机内存 通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。\n\n线程私有的内存区域包括：\n- **程序计数器**：\n  - 这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。\n  - 如果正在执行的是本地方法，这个计数器是未指定值(undefined)。\n- **Java虚拟机栈**：\n  - Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。\n  - 栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。\n- **本地方法栈**：\n  - 本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。\n  - 一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。\n\n线程共享的内存区域包括：\n- **堆**：\n  - Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。\n  - 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。\n  - 堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。\n    - JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。\n- **方法区**：\n  - 方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n  - 方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。\n- **运行时常量池**：\n  - 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。\n  - JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。\n\n本地内存：\n- 直接内存：\n  - 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。\n  - JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。\n  - JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。\n\n\n**内存模型与内存管理**\n- **内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。\n- **垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。\n\n**总结**\nJava内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。\n\n### 成员变量/全局变量/局部变量存放在哪里\n- 成员变量(实例变量)存储在堆内存中，每个对象都有自己的一份成员变量。\n- 静态变量(类变量)存储在方法区(或元空间)中，是类级别的变量，共享给所有实例。\n- 局部变量存储在栈内存中，属于方法调用帧的一部分。\n\n### 对象的创建过程(5步)\n1. 类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n2. 分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n3. 初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n5. 执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 对象的内存布局\n对象在内存中的布局可以分为 3 块区域： \n- 对象头(`Header`)： \n  - 标记字段(`Mark Word`)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。\n  - 类型指针(`Klass Word`)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n- 实例数据(`Instance Data`)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n- 对齐填充(`Padding`)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。\n\n### 对象的访问定位\n建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。\n- 句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n- 直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n### 垃圾回收机制✅\n**垃圾回收机制定义**\n垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。\n\n**堆空间结构**\n堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。\n\n**内存分配和回收原则**\n- 对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。\n- 大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。\n- 长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。\n\n垃圾回收的基本步骤分两步：\n- 查找内存中不再使用的对象(GC判断策略)\n- 释放这些对象占用的内存(GC收集算法)\n\n**死亡对象/GC判断策略**\n- 引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。\n    - 循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n- 可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。\n    - 这些对象可以用作 GC Roots： \n      - 虚拟机栈(栈帧中的局部变量表)中引用的对象\n      - 本地方法栈(Native 方法)中引用的对象\n      - 方法区中类静态属性引用的对象\n      - 方法区中常量引用的对象\n      - 所有被同步锁持有的对象\n      - JNI(Java Native Interface)引用的对象\n\n> 对象被标记为不可达，就代表一定会被回收吗？\n> 不一定。真正宣告一个对象死亡至少要经过两次标记过程。\n\n**垃圾回收算法**\n- 标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。\n  - 存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。\n- 复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。\n  - 存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。\n- 标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。\n  - 问题：整理的过程效率也不高。\n- 分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。\n\n**垃圾回收器**\n默认收集器：\nJDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)\nJDK 9 ~ JDK20： G1(Garbage-First)收集器\n\n- Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( \"Stop The World\" )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。\n- ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。\n- Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。\n- Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。\n- Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。\n- CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。\n- G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。\n- ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。\n\n\n> HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\n> - 部分收集 (`Partial GC`)：\n>     - 新生代收集(Minor GC / Young GC)：只对新生代进行垃圾收集；\n>     - 老年代收集(Major GC / Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\n>     - 混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。\n> - 整堆收集 (Full GC)：收集整个 Java 堆和方法区。\n\n### 为什么要进行垃圾回收\n- **防止内存泄漏**：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。\n- **提高开发效率**：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。\n- **系统性能和稳定性**：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。\n\n### 强引用/软引用/弱引用/虚引用✅\nhttps://blog.csdn.net/u013718071/article/details/134789666\nJava中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。\n- 强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。\n- 软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。\n- 弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。\n- 虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(`ReferenceQueue`)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。\n\n以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。\n\n### 如何判断一个类是无用的\n类需要同时满足下面 3 个条件才能算是 “无用的类”：\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收\n\n### 类的生命周期\n加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。\n\n其中验证、准备、解析 3 部分统称为连接。\n\n### 类加载过程\n分三步：加载、连接(验证、准备、解析)、初始化。\n\n**加载**\n加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。加载主要分下面三步：\n1. 通过全类名获取定义此类的二进制字节流。\n2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。\n\n> 加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。\n\n**验证**\n连接的第一步，确保 `Class` 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：\n1. 文件格式验证：验证字节流是否符合 Class 文件格式规范。\n2. 元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。\n   - 如验证类是否有父类\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n   - 如验证函数的参数是否正确\n4. 符号引用验证：确保解析动作能正确执行。\n   - 如验证该类要使用的其他类、方法是否存在。\n\n**准备**\n连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。\n- 进行内存分配的仅包括类变量(被`static`修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\n- 初始值是数据类型的默认值，如 0、null 等。\n\n**解析**\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。\n\n**初始化**\n初始化阶段是执行初始化方法 `<clinit>()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\n\n### 类卸载\n卸载类即该类的 `Class` 对象被 GC。\n\n卸载类需要满足 3 个要求：\n- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。\n- 该类没有在其他任何地方被引用\n- 该类的类加载器的实例已被 GC\n\n在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如`BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。\n\n### 类加载器\n类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 `ClassLoader`。数组类不是通过 `ClassLoader` 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。\n\n> 类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。\n\nJVM内置三个重要的类加载器：\n`BootstrapClassLoader`(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 `null`，并且没有父级，主要用来加载 JDK 内部的核心类库。\n`ExtensionClassLoader`(扩展类加载器)：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。\n`AppClassLoader`(应用程序类加载器)：面向用户的加载器，负责加载当前应用 `classpath` 下的所有 jar 包和类。\n\n### 双亲委派模型\n双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。\n\n**优点**\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。\n\n如果需要打破双亲委派模型，需要自定义类加载器，并重写 `loadClass` 方法。\n\n\n\n","slug":"Java后端面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1n0009r7gn9tfi2u9x","content":"<blockquote>\n<p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"简历相关\"><a href=\"#简历相关\" class=\"headerlink\" title=\"简历相关\"></a>简历相关</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p>\n<h3 id=\"Casbin明日之星实习\"><a href=\"#Casbin明日之星实习\" class=\"headerlink\" title=\"Casbin明日之星实习\"></a>Casbin明日之星实习</h3><ol>\n<li><p>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</p>\n</li>\n<li><p>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</p>\n</li>\n<li><p>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</p>\n</li>\n</ol>\n<h3 id=\"中科院开源之夏项目\"><a href=\"#中科院开源之夏项目\" class=\"headerlink\" title=\"中科院开源之夏项目\"></a>中科院开源之夏项目</h3><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p>\n<p><strong>项目诉求</strong></p>\n<ol>\n<li><p>对微信第三方登录的移动端支持</p>\n<ul>\n<li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li>\n</ul>\n</li>\n<li><p>对flutter、react-native、unity等sdk的开发及功能的增强</p>\n<ul>\n<li>对flutter-sdk的增强如第一点</li>\n</ul>\n</li>\n<li><p>临时加上的开发casdoor-app诉求，对标Google Authenticator</p>\n</li>\n</ol>\n<p><strong>技术细节</strong></p>\n<ol>\n<li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p>\n<ul>\n<li>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</li>\n<li>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</li>\n<li>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</li>\n</ul>\n<p> 接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p>\n</li>\n<li><p>分为两部分</p>\n<ol>\n<li>casdoor-unity-example<ul>\n<li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li>\n<li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li>\n<li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li>\n<li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li>\n</ul>\n</li>\n<li>casdoor-react-native-sdk、example<ul>\n<li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li>\n<li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li>\n<li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。</p>\n<ul>\n<li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li>\n<li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p>\n</blockquote>\n<p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p>\n<h3 id=\"单点登录SSO原理\"><a href=\"#单点登录SSO原理\" class=\"headerlink\" title=\"单点登录SSO原理\"></a>单点登录SSO原理</h3><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p>\n<p>在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。</p>\n<p>流程：</p>\n<ol>\n<li>用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li>\n<li>此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li>\n</ol>\n<p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p>\n<h3 id=\"OAuth-2-0原理\"><a href=\"#OAuth-2-0原理\" class=\"headerlink\" title=\"OAuth 2.0原理\"></a>OAuth 2.0原理</h3><p><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p>\n<p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。</p>\n<p>定义了4种角色：</p>\n<ul>\n<li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li>\n<li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。</li>\n<li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li>\n<li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。</li>\n<li>如果用户授权该请求，应用程序会收到授权准许(<code>Authorization Grant</code>)。</li>\n<li>应用程序通过提供其自身的身份验证和授权准许(<code>Authorization Grant</code>)来向授权服务器 (API) 请求访问令牌(<code>access_token</code>)。</li>\n<li>如果应用程序身份通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器(API)向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li>\n<li>应用程序从资源服务器(API)请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li>\n<li>如果访问令牌(<code>access_token</code>)有效，则资源服务器 (API) 向应用程序提供资源。</li>\n</ol>\n<p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p>\n<ol>\n<li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li>\n<li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li>\n<li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li>\n</ol>\n<h3 id=\"2FA\"><a href=\"#2FA\" class=\"headerlink\" title=\"2FA\"></a>2FA</h3><p>两因素认证(<code>Two-Factor Authentication, 2FA)</code>是一种安全系统，用于确保用户登录到账户或访问资源时，需要通过两种不同类型的验证方式。这种方法比仅依靠密码更安全，因为它增加了额外的验证层，使得即使密码被泄露，攻击者仍然难以访问用户账户。</p>\n<p>身份验证因素：2FA通常结合两种不同的验证因素，分三类：</p>\n<ul>\n<li>知识因素(Something you know)：用户知道的东西，例如密码、PIN码、回答安全问题等。</li>\n<li>持有因素(Something you have)：用户拥有的物品，例如手机、硬件令牌、智能卡等。</li>\n<li>固有因素(Something you are)：用户自身的特征，例如指纹、面部识别、声音识别等生物特征。</li>\n</ul>\n<p>验证过程：</p>\n<ul>\n<li>第一步：输入用户名和密码：用户首先输入他们的用户名和密码(知识因素)。</li>\n<li>第二步：额外验证：系统会要求用户进行第二步验证。这可以是：  <ul>\n<li>一次性密码(OTP)：通过短信、电子邮件或专用应用程序(如Google Authenticator、Authy)生成并发送给用户的随机密码。</li>\n<li>硬件令牌：用户插入或展示硬件令牌生成的代码。</li>\n<li>生物特征识别：用户通过指纹、面部识别等方式进行验证。</li>\n</ul>\n</li>\n</ul>\n<p>验证成功：如果两步验证都通过，用户将获得访问权限。<br>验证失败：如果任何一步失败，访问将被拒绝。</p>\n<h3 id=\"PKCE\"><a href=\"#PKCE\" class=\"headerlink\" title=\"PKCE\"></a>PKCE</h3><p>PKCE(<code>Proof Key for Code Exchange, PKCE</code>)是一种用于保护OAuth 2.0授权码授权流程的机制，主要目的是防止授权码拦截攻击(Authorization Code Interception Attack)。</p>\n<p>原理：<br>PKCE通过在OAuth 2.0授权码请求和令牌交换过程中引入一个随机生成的<code>code_challenge</code>和<code>code_verifier</code>来增强安全性。具体来说，PKCE引入了两个新参数：</p>\n<ul>\n<li><code>code_verifier</code>：一个高熵的随机字符串，客户端在请求<code>code</code>(授权码)时生成并保存。</li>\n<li><code>code_challenge</code>：由<code>code_verifier</code>生成的一个变体，发送给授权服务器。可以是<code>code_verifier</code>本身，或者是<code>code_verifier</code>的SHA256哈希值。</li>\n</ul>\n<p>流程：</p>\n<ol>\n<li>客户端生成一个随机的<code>code_challenge</code>和<code>code_verifier</code>，<code>code_verifier</code>可以是明文(<code>plain</code>)SHA256哈希值(<code>s256</code>)。</li>\n<li>客户端将<code>code_challenge</code>和<code>code_challenge_method</code>(<code>plain</code>或<code>s256</code>)发送给授权服务器。<ul>\n<li>如：<code>GET /authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=SCOPE&amp;state=STATE&amp;code_challenge=CODE_CHALLENGE&amp;code_challenge_method=S256</code></li>\n</ul>\n</li>\n<li>用户在授权服务器进行身份验证，同意授权，授权服务器通过重定向URI将<code>code</code>(授权码)返回给客户端。</li>\n<li>客户端将<code>code</code>(授权码)和<code>code_verifier</code>发送给授权服务器，以获取<code>access_token</code>(访问令牌)。<ul>\n<li>如：<code>POST /token?grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=REDIRECT_URI&amp;client_id=CLIENT_ID&amp;code_verifier=CODE_VERIFIER</code></li>\n</ul>\n</li>\n<li>授权服务器收到客户端发送的<code>code</code>(授权码)和<code>code_verifier</code>后，使用之前保存的<code>code_challenge</code>进行验证。<ul>\n<li>如果<code>code_challenge_method</code>是<code>plain</code>，则直接比较<code>code_verifier</code>和<code>code_challenge</code>。</li>\n<li>如果<code>code_challenge_method</code>是<code>s256</code>，则比较<code>code_verifier</code>的SHA256哈希值和<code>code_challenge</code>。</li>\n</ul>\n</li>\n<li>如果验证通过，授权服务器返回<code>access_token</code>(访问令牌)给客户端。</li>\n</ol>\n<p>这样，即使<code>code</code>(授权码)在传输过程中被拦截，攻击者也无法使用该<code>code</code>(授权码)，因为缺少正确的<code>code_verifier</code>。</p>\n<h3 id=\"OTP-TOTP-HOTP\"><a href=\"#OTP-TOTP-HOTP\" class=\"headerlink\" title=\"OTP&#x2F;TOTP&#x2F;HOTP\"></a>OTP&#x2F;TOTP&#x2F;HOTP</h3><p>OTP (One-Time Password) 是一种一次性有效的密码，通常用于两因素身份验证(2FA)。每次使用 OTP 进行身份验证后，这个密码便失效，无法再使用。OTP 提高了安全性，因为即使密码被截获或暴力破解，也不能再次使用。OTP 生成和使用的方式有很多种，包括基于时间的(TOTP)和基于事件的(HOTP)。</p>\n<p><strong>TOTP(基于时间的一次性密码)</strong><br>TOTP (Time-Based One-Time Password) 是 OTP 的一种，它基于当前时间生成密码。TOTP 是 HOTP 的扩展，结合了时间元素来提高安全性。TOTP 的工作原理如下：</p>\n<ol>\n<li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 TOTP。</li>\n<li>时间段：TOTP 使用当前时间的一个窗口(通常是 30 秒)来生成密码。每个时间段内生成的密码是唯一的。</li>\n<li>算法：TOTP 使用 HMAC-SHA1 算法和共享密钥以及当前时间戳来生成密码。</li>\n</ol>\n<p><strong>生成和验证</strong></p>\n<ul>\n<li>生成 TOTP：用户的设备(如手机上的 Google Authenticator 应用)使用共享密钥和当前时间生成 TOTP。</li>\n<li>验证 TOTP：服务器使用同样的共享密钥和当前时间计算 TOTP，并与用户提供的 TOTP 进行对比。如果匹配，则验证成功。</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>安全性高：每个密码只能使用一次，有效时间短，降低了被攻击的风险。</li>\n<li>易于使用：用户只需要输入一次性密码，而不需要记住复杂的密码。</li>\n<li>灵活性：适用于各种应用场景，如登录、交易验证等。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>时间同步：TOTP 依赖于设备和服务器时间的同步，如果时间不同步，可能会导致验证失败。</li>\n<li>设备依赖：需要用户拥有生成 OTP 或 TOTP 的设备，如智能手机。</li>\n</ul>\n<p><strong>HOTP(基于事件的一次性密码)</strong><br>HOTP (HMAC-Based One-Time Password) 是一种基于事件的 OTP(一次性密码)生成方法。HOTP 的生成与验证基于 HMAC-SHA1 算法及一个计数器，确保每次生成的密码都是唯一的。HOTP 的工作原理如下：</p>\n<ol>\n<li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 HOTP。</li>\n<li>计数器：用户和服务器都维护一个计数器，计数器初始值相同，每次生成或验证 OTP 时都会增加计数器的值。</li>\n<li>HMAC-SHA1 算法：HOTP 使用 HMAC-SHA1 算法，将共享密钥和计数器作为输入，生成一个哈希值。</li>\n<li>生成 OTP：从哈希值中提取部分数据(通常是取哈希值的后几位)，将其转换为一个短数字串，即 OTP。</li>\n</ol>\n<p><strong>生成和验证</strong></p>\n<ul>\n<li>生成 HOTP：用户的设备使用共享密钥和计数器生成 HOTP。</li>\n<li>验证 HOTP：服务器使用同样的共享密钥和计数器计算 HOTP，并与用户提供的 OTP 进行对比。如果匹配，则验证成功，并增加计数器的值。</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无时间依赖：HOTP 不依赖于设备和服务器时间的同步，避免了时间不同步带来的问题。</li>\n<li>安全性高：每个密码只能使用一次，降低了密码被截获或重复使用的风险。</li>\n<li>灵活性：适用于各种应用场景，如登录、交易验证等。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>计数器同步：用户和服务器必须保持计数器的同步，否则会导致验证失败。如果计数器不同步，需要有机制进行重新同步。</li>\n<li>复杂性：相较于静态密码，HOTP 的实现和维护相对复杂。</li>\n</ul>\n<p><strong>使用场景</strong></p>\n<ul>\n<li>银行和金融服务：TOTP&#x2F;HOTP 经常用于网上银行和金融交易中，以确保只有授权用户才能进行操作。</li>\n<li>企业安全：企业系统常使用 TOTP&#x2F;HOTP 进行多因素身份验证，以保护敏感数据和资源。</li>\n<li>社交媒体和电子邮件：为了防止账户被黑客入侵，许多社交媒体和电子邮件服务提供商都提供 TOTP&#x2F;HOTP 作为额外的安全措施。</li>\n</ul>\n<h3 id=\"Casbin-Casdoor-介绍\"><a href=\"#Casbin-Casdoor-介绍\" class=\"headerlink\" title=\"Casbin Casdoor 介绍\"></a>Casbin Casdoor 介绍</h3><blockquote>\n<p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p>\n<ol>\n<li>多种访问控制模型支持：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li>\n<li>灵活的策略管理：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li>\n<li>细粒度的权限控制：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li>\n<li>跨语言支持：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p>\n<ol>\n<li>单点登录(SSO)：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li>\n<li>用户管理：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li>\n<li>权限控制：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li>\n<li>开源社区：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li>\n</ol>\n</blockquote>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><blockquote>\n<p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p>\n<ul>\n<li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li>\n<li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li>\n<li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li>\n<li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li>\n<li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li>\n<li>标准化操作：利用HTTP动词来描述对资源的操作。 </li>\n<li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li>\n<li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li>\n<li>无状态交互：每个请求独立，不依赖于之前的请求。</li>\n</ul>\n<p>优点 </p>\n<ul>\n<li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li>\n<li>性能高：无状态和可缓存性提高了性能。 </li>\n<li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li>\n<li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li>\n</ul>\n<p>缺点 </p>\n<ul>\n<li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li>\n<li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li>\n<li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li>\n</ul>\n<p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p>\n</blockquote>\n<h3 id=\"国家电网项目\"><a href=\"#国家电网项目\" class=\"headerlink\" title=\"国家电网项目\"></a>国家电网项目</h3><p><strong>简介</strong></p>\n<p>自己导师接的项目，江苏省国家电网智能诊断数据分析平台</p>\n<p><strong>项目诉求</strong></p>\n<ul>\n<li>对相应指标进行增删改查</li>\n<li>可以导入、导出一些excel表格</li>\n<li>对数据进行智能诊断分析</li>\n</ul>\n<p><strong>技术细节</strong><br>react、Antd、Flask、mongodb</p>\n<p><strong>我的职责</strong><br>在项目中，负责实现各项重要指标的计算、以及对各指标进行灵活的增删改查，实现数据的存取以及前端展示等功能。</p>\n<h3 id=\"为什么使用mongodb\"><a href=\"#为什么使用mongodb\" class=\"headerlink\" title=\"为什么使用mongodb\"></a>为什么使用mongodb</h3><p>mongodb是一个非关系型数据库，采用文档存储模型，数据以BSON格式存储。项目中，需要导入或者导出 Excel 表格，一个 Excel文件正好可以对应mongodb中的一个文档，这样可以方便地将 Excel 中的数据导入到 mongodb 中。</p>\n<h3 id=\"江南布衣实习\"><a href=\"#江南布衣实习\" class=\"headerlink\" title=\"江南布衣实习\"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p>\n<ol>\n<li><p>新入职员工设备管理：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p>\n</li>\n<li><p>离职员工设备回收和资料销毁：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p>\n</li>\n<li><p>订货会期间设备组装和网络连接：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p>\n</li>\n<li><p>员工设备报修响应与问题解决：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p>\n</li>\n</ol>\n<p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p>\n<blockquote>\n<p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p>\n<ol>\n<li>网络配置：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li>\n<li>身份验证：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li>\n<li>访问内部资源：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li>\n</ol>\n</blockquote>\n<h3 id=\"印象最深的一个项目\"><a href=\"#印象最深的一个项目\" class=\"headerlink\" title=\"印象最深的一个项目\"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p>\n<p><strong>亮点</strong></p>\n<ol>\n<li><strong>异步支持</strong>：<ul>\n<li>亮点：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li>\n<li>回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li>\n</ul>\n</li>\n<li><strong>灵活的过滤机制</strong>：<ul>\n<li>亮点：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li>\n<li>回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li>\n</ul>\n</li>\n<li><strong>可扩展性</strong>：<ul>\n<li>亮点：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li>\n<li>回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li>\n</ul>\n</li>\n<li><strong>事务处理</strong>：<ul>\n<li>亮点：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li>\n<li>回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>难点</strong></p>\n<ol>\n<li><strong>异步编程的复杂性</strong>：<ul>\n<li>难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li>\n<li>回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li>\n</ul>\n</li>\n<li><strong>数据库模型的灵活性与一致性</strong>：<ul>\n<li>难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li>\n<li>回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li>\n</ul>\n</li>\n<li><strong>复杂的策略更新逻辑</strong>：<ul>\n<li>难点：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li>\n<li>回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li>\n</ul>\n</li>\n<li><strong>高效的批量操作</strong>：<ul>\n<li>难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li>\n<li>回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li>\n</ul>\n</li>\n</ol>\n<p>测试方面</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p>\n<h3 id=\"学生生涯遇到的挫折和应对策略\"><a href=\"#学生生涯遇到的挫折和应对策略\" class=\"headerlink\" title=\"学生生涯遇到的挫折和应对策略\"></a>学生生涯遇到的挫折和应对策略</h3><p>高一升高二的时候，当时是从一个普通班进入全校最好的英才班嘛。然后第一次考试，我考了全班倒数第三，当时从普通班的前几名到倒数第三，可谓是很大的打击，我从小到大就没考过这么差的名词，当时很伤心沮丧吧，回家在房间偷偷哭。</p>\n<p>但我也知道，哭是没有用的，我跟别人的差距是确实存在的，从那次后，我比别人更加努力，我花别人更多的时间去学习，去做题，去复习。不会的知识点也请教老师和同学，他们也都很乐意帮助我，我很感谢他们。争取把遇到的每个不会的知识点攻克，我也慢慢的感觉到自己的进步，从才开始的在英才班倒数，到中游 10-20名这样子，到最后高考的时候，考了英才班第四名。</p>\n<p>我觉得吧，从这个经历中，我学到了很多，比如说遇到困难要找对方法才行，其次就是要有毅力，不要轻易放弃，最后就是要有信心，相信自己可以做到。</p>\n<p>最让我有感触的是，让我学会了 任何时候，都要对自己有信心，不要怀疑自己的能力，相信自己可以做到。这点在我后面的大学学习、跨专业保研中起到了很重要的作用。</p>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li>\n<li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li>\n<li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li>\n</ul>\n<blockquote>\n<p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p>\n</blockquote>\n<h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p><code>&lt;&lt;</code>：左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>：无符号右移，忽略符号位，空位都以 0 补齐。</p>\n<p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>\n<p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p>\n<h3 id=\"基本数据类型-包装类型-及区别\"><a href=\"#基本数据类型-包装类型-及区别\" class=\"headerlink\" title=\"基本数据类型&#x2F;包装类型 及区别\"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p>\n<ul>\n<li>6 种数字类型： <ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<blockquote>\n<p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>： 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>： 双引号。</p>\n</blockquote>\n<p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<p><strong>区别</strong></p>\n<ul>\n<li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li>\n<li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li>\n<li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li>\n<li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>\n<li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>\n</ul>\n<h3 id=\"包装类的缓存机制\"><a href=\"#包装类的缓存机制\" class=\"headerlink\" title=\"包装类的缓存机制\"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>\n<h3 id=\"什么是自动拆装箱\"><a href=\"#什么是自动拆装箱\" class=\"headerlink\" title=\"什么是自动拆装箱\"></a>什么是自动拆装箱</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;  <span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i;   <span class=\"comment\">//拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>\n<li>拆箱：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题\"><a href=\"#如何解决浮点数运算的精度丢失问题\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题\"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p>\n<h3 id=\"局部变量-成员变量-静态变量\"><a href=\"#局部变量-成员变量-静态变量\" class=\"headerlink\" title=\"局部变量&#x2F;成员变量&#x2F;静态变量\"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul>\n<li>语法形式：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>\n<li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>\n<li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li>\n</ul>\n<p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><ul>\n<li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>\n<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象和面向过程区别\"><a href=\"#面向对象和面向过程区别\" class=\"headerlink\" title=\"面向对象和面向过程区别\"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"接口和抽象类区别\"><a href=\"#接口和抽象类区别\" class=\"headerlink\" title=\"接口和抽象类区别\"></a>接口和抽象类区别</h3><p>共同点： 都不能被实例化<br><a href=\"https://learn.skyofit.com/archives/351\">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p>\n<ul>\n<li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li>\n<li>抽象类可以有构造方法，接口不能有构造方法。</li>\n<li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li>\n<li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li>\n<li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li>\n<li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li>\n</ul>\n<h3 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h3><p><a href=\"https://blog.csdn.net/qq_44944221/article/details/126692973\">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p>\n<ul>\n<li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li>\n<li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li>\n<li>共享性不同：栈是线程私有，而堆是线程共享；</li>\n<li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li>\n<li>空间大小不同：堆空间大小远远大于栈的内存空间。</li>\n</ul>\n<h3 id=\"深拷贝-浅拷贝-引用拷贝\"><a href=\"#深拷贝-浅拷贝-引用拷贝\" class=\"headerlink\" title=\"深拷贝&#x2F;浅拷贝&#x2F;引用拷贝\"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul>\n<li>深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。</li>\n<li>浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li>引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li>\n</ul>\n<h3 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"形参-实参\"><a href=\"#形参-实参\" class=\"headerlink\" title=\"形参&amp;实参\"></a>形参&amp;实参</h3><ul>\n<li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>\n<li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>\n</ul>\n<h3 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递&amp;引用传递\"></a>值传递&amp;引用传递</h3><ul>\n<li>值传递：方法接收的是实参值的拷贝，会创建副本。</li>\n<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p>Java 中只有值传递，C++ 中有值传递和引用传递。</p>\n<h3 id=\"和equals-区别\"><a href=\"#和equals-区别\" class=\"headerlink\" title=\"&#x3D;&#x3D;和equals()区别\"></a>&#x3D;&#x3D;和equals()区别</h3><ul>\n<li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul>\n<li>基本数据类型：比较的是值是否相等</li>\n<li>引用数据类型：比较的是引用地址是否相等</li>\n<li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li>\n</ul>\n</li>\n<li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul>\n<li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li>\n<li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hashCode-和equal\"><a href=\"#hashCode-和equal\" class=\"headerlink\" title=\"hashCode()和equal()\"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>\n<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li>\n</ul>\n<p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<h3 id=\"String-StringBuffer-StringBuilder\"><a href=\"#String-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"String&#x2F;StringBuffer&#x2F;StringBuilder\"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul>\n<li><p><code>String</code> ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuffer</code> ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuilder</code> ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p>\n</li>\n<li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>\n</li>\n<li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p>\n</li>\n<li><p><code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n</li>\n</ul>\n<p>** <code>String</code> 为什么不可变？**</p>\n<ul>\n<li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ul>\n<h3 id=\"字符串拼接使用-还是StringBuilder？\"><a href=\"#字符串拼接使用-还是StringBuilder？\" class=\"headerlink\" title=\"字符串拼接使用+还是StringBuilder？\"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p>\n<h3 id=\"String-equals-Object-equals\"><a href=\"#String-equals-Object-equals\" class=\"headerlink\" title=\"String.equals()&#x2F;Object.equals()\"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>： 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>： 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p>\n<h3 id=\"Checked-Unchecked-Exception\"><a href=\"#Checked-Unchecked-Exception\" class=\"headerlink\" title=\"Checked&#x2F;Unchecked Exception\"></a>Checked&#x2F;Unchecked Exception</h3><ul>\n<li><code>Checked Exception</code>即受检查异常 ，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<ul>\n<li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li>\n</ul>\n</li>\n<li><code>Unchecked Exception</code> 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。<ul>\n<li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"try-catch-finally\"><a href=\"#try-catch-finally\" class=\"headerlink\" title=\"try-catch-finally\"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>\n<blockquote>\n<p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p>\n</blockquote>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><ul>\n<li>使用泛型参数，可以增强代码的可读性以及稳定性。</li>\n<li>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>\n<ul>\n<li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>\n<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>\n</ul>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h3 id=\"序列化-反序列化\"><a href=\"#序列化-反序列化\" class=\"headerlink\" title=\"序列化&#x2F;反序列化\"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<ul>\n<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>\n<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>\n<p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p>\n<h2 id=\"Java集合\"><a href=\"#Java集合\" class=\"headerlink\" title=\"Java集合\"></a>Java集合</h2><h3 id=\"List-Set-Queue-Map区别\"><a href=\"#List-Set-Queue-Map区别\" class=\"headerlink\" title=\"List&#x2F;Set&#x2F;Queue&#x2F;Map区别\"></a>List&#x2F;Set&#x2F;Queue&#x2F;Map区别</h3><ul>\n<li>List： 存储的元素是有序的、可重复的。</li>\n<li>Set： 存储的元素不可重复的。</li>\n<li>Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li>Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>\n</ul>\n<h3 id=\"如何选用集合\"><a href=\"#如何选用集合\" class=\"headerlink\" title=\"如何选用集合?\"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p>\n<ul>\n<li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</li>\n<li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li>\n</ul>\n<h3 id=\"为什么要使用集合？\"><a href=\"#为什么要使用集合？\" class=\"headerlink\" title=\"为什么要使用集合？\"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>\n<h3 id=\"ArrayList和Array区别\"><a href=\"#ArrayList和Array区别\" class=\"headerlink\" title=\"ArrayList和Array区别\"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p>\n<ul>\n<li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li>\n<li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li>\n<li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li>\n<li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li>\n<li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li>\n</ul>\n<blockquote>\n<p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList区别\"><a href=\"#ArrayList和LinkedList区别\" class=\"headerlink\" title=\"ArrayList和LinkedList区别\"></a>ArrayList和LinkedList区别</h3><ul>\n<li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul>\n<li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li>\n<li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li>二者都是线程不安全的。</li>\n<li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li>\n<li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li>\n</ul>\n<blockquote>\n<p>项目中一般不会使用 <code>LinkedList</code>。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList插入-删除效率\"><a href=\"#ArrayList和LinkedList插入-删除效率\" class=\"headerlink\" title=\"ArrayList和LinkedList插入&#x2F;删除效率\"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p>\n<ul>\n<li>头部插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>尾部插入&#x2F;删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。<br><code>LinkedList</code></li>\n<li>头部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>尾部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要先移动到指定位置再插入和删除。</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p>\n<ul>\n<li>读多写少：大部分操作都是读取数据，写操作相对较少。</li>\n<li>不要求实时性：因为写操作需要创建数组副本，可能会有短暂的延迟。</li>\n</ul>\n<p><code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>线程安全：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li>\n<li>简化并发控制：不需要显式的同步块或锁定机制。</li>\n<li>迭代器安全：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>内存开销大：每次写操作都会创建数组副本，可能会占用较多的内存。</li>\n<li>写操作开销大：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li>\n<li>读取旧数据：在高并发场景下，可能会读取到旧的数据。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>配置类数据：如系统配置参数、常量集合等。</li>\n<li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li>\n</ul>\n<p><strong>不适用场景</strong></p>\n<ul>\n<li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li>\n<li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li>\n</ul>\n<p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p>\n<h3 id=\"HashSet-LinkedHashSet-TreeSet\"><a href=\"#HashSet-LinkedHashSet-TreeSet\" class=\"headerlink\" title=\"HashSet&#x2F;LinkedHashSet&#x2F;TreeSet\"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul>\n<li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li>\n<li>主要区别在于底层数据结构不同。<ul>\n<li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li>\n<li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>\n<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>\n</ul>\n</li>\n<li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>\n</ul>\n<h3 id=\"Map-重要\"><a href=\"#Map-重要\" class=\"headerlink\" title=\"Map(重要)\"></a>Map(重要)</h3><h3 id=\"HashMap-HashTable区别\"><a href=\"#HashMap-HashTable区别\" class=\"headerlink\" title=\"HashMap&#x2F;HashTable区别\"></a>HashMap&#x2F;HashTable区别</h3><ul>\n<li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li>\n<li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>\n<li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li>\n<li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和value，否则会报错<code>NullPointerException</code>。</li>\n<li>初始容量大小和每次扩充容量大小的不同： <ul>\n<li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li>\n<li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p>\n</blockquote>\n<h3 id=\"HashMap长度为什么是2的幂次方\"><a href=\"#HashMap长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap长度为什么是2的幂次方\"></a>HashMap长度为什么是2的幂次方</h3><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p>\n<p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p>\n<h3 id=\"HashMap-TreeMap区别\"><a href=\"#HashMap-TreeMap区别\" class=\"headerlink\" title=\"HashMap&#x2F;TreeMap区别\"></a>HashMap&#x2F;TreeMap区别</h3><ul>\n<li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li>\n<li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li>\n<li><code>HashMap</code> 的键值对允许有一个 <code>null</code> 键和多个 <code>null</code> 值，<code>TreeMap</code> 不允许有 <code>null</code> 键，但允许有 <code>null</code> 值。</li>\n<li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li>\n</ul>\n<p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>\n<h3 id=\"HashSet如何检查重复\"><a href=\"#HashSet如何检查重复\" class=\"headerlink\" title=\"HashSet如何检查重复\"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>\n<p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。</p>\n<h3 id=\"HashMap底层实现\"><a href=\"#HashMap底层实现\" class=\"headerlink\" title=\"HashMap底层实现\"></a>HashMap底层实现</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p>\n<p><code>HashMap</code> 通过 key 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p>\n<ul>\n<li>扰动函数 <code>hash()</code> 可以减少碰撞。</li>\n<li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>\n<li>“拉链法”中，数组的 index 就是通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li>\n</ul>\n<p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p>\n<ul>\n<li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li>\n<li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li>\n</ul>\n<h3 id=\"HashMap多线程扩容死循环问题\"><a href=\"#HashMap多线程扩容死循环问题\" class=\"headerlink\" title=\"HashMap多线程扩容死循环问题\"></a>HashMap多线程扩容死循环问题</h3><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>\n<p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>\n<blockquote>\n<p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p>\n</blockquote>\n<h3 id=\"HashMap为什么不支持高并发\"><a href=\"#HashMap为什么不支持高并发\" class=\"headerlink\" title=\"HashMap为什么不支持高并发\"></a>HashMap为什么不支持高并发</h3><h3 id=\"HashMap为什么线程不安全\"><a href=\"#HashMap为什么线程不安全\" class=\"headerlink\" title=\"HashMap为什么线程不安全\"></a>HashMap为什么线程不安全</h3><ul>\n<li>JDK1.7及之前版本，存在多线程扩容死循环问题，如上。</li>\n<li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。如下：</li>\n</ul>\n<p><strong>数据丢失</strong><br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>\n<blockquote>\n<p>例子：<br>线程 1,2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>\n</blockquote>\n<h3 id=\"遍历HashMap\"><a href=\"#遍历HashMap\" class=\"headerlink\" title=\"遍历HashMap\"></a>遍历HashMap</h3><p>七种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// ForEach EntrySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ForEach KeySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Integer key : map.keySet()) &#123;</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器EntrySet</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器KeySet</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(key);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 单线程</span></span><br><span class=\"line\">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 多线程</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-Hashtable区别\"><a href=\"#ConcurrentHashMap-Hashtable区别\" class=\"headerlink\" title=\"ConcurrentHashMap&#x2F;Hashtable区别\"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul>\n<li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong> 。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li>\n<li>实现线程安全的方式：<ul>\n<li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li>\n<li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li><code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConcurrentHashMap底层\"><a href=\"#ConcurrentHashMap底层\" class=\"headerlink\" title=\"ConcurrentHashMap底层\"></a>ConcurrentHashMap底层</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为**<code>Segment</code>数组+<code>HashEntry</code>数组+链表** 。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>\n<p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p>\n<p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，**<code>Node</code>数组+链表&#x2F;红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p>\n<h3 id=\"JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\"><a href=\"#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\" class=\"headerlink\" title=\"JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul>\n<li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>\n<li>Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li>\n<li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li>\n</ul>\n<h3 id=\"ConcurrentHashMap能保证复合操作的原子性吗？\"><a href=\"#ConcurrentHashMap能保证复合操作的原子性吗？\" class=\"headerlink\" title=\"ConcurrentHashMap能保证复合操作的原子性吗？\"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul>\n<li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li>\n<li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li>\n</ul>\n<h3 id=\"什么是LinkedHashMap\"><a href=\"#什么是LinkedHashMap\" class=\"headerlink\" title=\"什么是LinkedHashMap\"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代</li>\n<li>支持按照元素访问顺序排序,<em><strong>适用于封装 LRU 缓存工具</strong></em> 。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li>\n</ul>\n<blockquote>\n<p>在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n</blockquote>\n<h3 id=\"LinkedHashMap如何按照访问顺序迭代元素？\"><a href=\"#LinkedHashMap如何按照访问顺序迭代元素？\" class=\"headerlink\" title=\"LinkedHashMap如何按照访问顺序迭代元素？\"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>\n<h3 id=\"如何实现LRU缓存\"><a href=\"#如何实现LRU缓存\" class=\"headerlink\" title=\"如何实现LRU缓存\"></a>如何实现LRU缓存</h3><ul>\n<li><code>accessOrder</code> &#x3D; <code>true</code> </li>\n<li>继承<code>LinkedHashMap</code></li>\n<li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"LinkedHashMap和HashMap的区别\"><a href=\"#LinkedHashMap和HashMap的区别\" class=\"headerlink\" title=\"LinkedHashMap和HashMap的区别\"></a>LinkedHashMap和HashMap的区别</h3><ul>\n<li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li>\n<li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li>\n</ul>\n<h3 id=\"Queue-Deque区别\"><a href=\"#Queue-Deque区别\" class=\"headerlink\" title=\"Queue&#x2F;Deque区别\"></a>Queue&#x2F;Deque区别</h3><ul>\n<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li>\n<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li>\n</ul>\n<h3 id=\"ArrayDeque-LinkedList区别\"><a href=\"#ArrayDeque-LinkedList区别\" class=\"headerlink\" title=\"ArrayDeque&#x2F;LinkedList区别\"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul>\n<li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li>\n<li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li>\n<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li>\n</ul>\n<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>\n<h3 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>\n<ul>\n<li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>\n<li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>\n<li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>\n<li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>\n</ul>\n<blockquote>\n<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>\n</blockquote>\n<h3 id=\"BlockingQueue及其实现类\"><a href=\"#BlockingQueue及其实现类\" class=\"headerlink\" title=\"BlockingQueue及其实现类\"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p>\n<p><strong>实现类</strong></p>\n<ul>\n<li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>\n<li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。</li>\n<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li>\n<li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li>\n<li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li>\n<li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li>\n<li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue实现原理\"><a href=\"#ArrayBlockingQueue实现原理\" class=\"headerlink\" title=\"ArrayBlockingQueue实现原理\"></a>ArrayBlockingQueue实现原理</h3><ul>\n<li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li>\n<li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li>\n<li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li>\n</ul>\n<p>线程间的等待和唤醒具体的实现：</p>\n<ul>\n<li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li>\n<li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li>\n<li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li>\n<li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue区别\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue区别\" class=\"headerlink\" title=\"ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别\"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>\n<li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>\n<li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>\n</ul>\n<h3 id=\"DelayQueue底层\"><a href=\"#DelayQueue底层\" class=\"headerlink\" title=\"DelayQueue底层\"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>\n<p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可重入锁，实现线程安全的关键</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">//指向准备执行优先级最高的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Thread</span> <span class=\"variable\">leader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//实现多线程之间等待唤醒的交互</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>\n<p><code>leader</code> ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code> ： 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p>\n</blockquote>\n<h3 id=\"DelayQueue是否线程安全？\"><a href=\"#DelayQueue是否线程安全？\" class=\"headerlink\" title=\"DelayQueue是否线程安全？\"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>\n<h3 id=\"DelayQueue使用场景\"><a href=\"#DelayQueue使用场景\" class=\"headerlink\" title=\"DelayQueue使用场景\"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p>\n<ul>\n<li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li>\n<li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li>\n</ul>\n<h3 id=\"DelayQueue中Delayed接口的作用是什么？\"><a href=\"#DelayQueue中Delayed接口的作用是什么？\" class=\"headerlink\" title=\"DelayQueue中Delayed接口的作用是什么？\"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口),否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>\n<h3 id=\"DelayQueue-Timer-TimerTask区别\"><a href=\"#DelayQueue-Timer-TimerTask区别\" class=\"headerlink\" title=\"DelayQueue&#x2F;Timer&#x2F;TimerTask区别\"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p>\n<ul>\n<li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li>\n<li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li>\n<li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li>\n</ul>\n<h2 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程&#x2F;线程&#x2F;协程\"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href=\"https://blog.csdn.net/m0_60505735/article/details/131047046\">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href=\"https://blog.csdn.net/weixin_49199646/article/details/109210547\">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p>\n<ul>\n<li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li>\n<li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>\n<li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li>\n</ul>\n<p><strong>进程与线程的区别</strong></p>\n<ul>\n<li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li>\n<li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li>\n<li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li>\n</ul>\n<p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p>\n<p><em>进程与线程的选择</em>*</p>\n<ul>\n<li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li>\n<li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li>\n<li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li>\n<li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li>\n</ul>\n<p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p>\n<h3 id=\"Java线程和操作系统线程有何区别\"><a href=\"#Java线程和操作系统线程有何区别\" class=\"headerlink\" title=\"Java线程和操作系统线程有何区别\"></a>Java线程和操作系统线程有何区别</h3><p>现在的 Java 线程的本质其实就是操作系统的线程。</p>\n<ul>\n<li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li>\n<li>JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li>\n</ul>\n<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p>\n<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p>\n<h3 id=\"程序计数器为啥是私有的\"><a href=\"#程序计数器为啥是私有的\" class=\"headerlink\" title=\"程序计数器为啥是私有的\"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n<li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>\n</ul>\n<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>\n<h3 id=\"虚拟机栈和本地方法栈为啥是私有的\"><a href=\"#虚拟机栈和本地方法栈为啥是私有的\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈为啥是私有的\"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul>\n<li>虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>\n<li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>\n</ul>\n<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3 id=\"一句话简单了解堆和方法区\"><a href=\"#一句话简单了解堆和方法区\" class=\"headerlink\" title=\"一句话简单了解堆和方法区\"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h3 id=\"如何创建线程\"><a href=\"#如何创建线程\" class=\"headerlink\" title=\"如何创建线程\"></a>如何创建线程</h3><ul>\n<li>继承<code>Thread</code>类并重写<code>run()</code>方法</li>\n<li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li>\n<li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li>\n<li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li>\n<li>等等……</li>\n</ul>\n<p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>\n<h3 id=\"线程的生命周期和状态\"><a href=\"#线程的生命周期和状态\" class=\"headerlink\" title=\"线程的生命周期和状态\"></a>线程的生命周期和状态</h3><p>Java 线程 6 种状态：<br><code>NEW</code>： 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>： 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>\n<h3 id=\"线程上下文切换开销\"><a href=\"#线程上下文切换开销\" class=\"headerlink\" title=\"线程上下文切换开销\"></a>线程上下文切换开销</h3><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>\n<ul>\n<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>\n<li>时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n</ul>\n<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>\n<h3 id=\"Thread-sleep-方法和Object-wait-方法对比\"><a href=\"#Thread-sleep-方法和Object-wait-方法对比\" class=\"headerlink\" title=\"Thread.sleep()方法和Object.wait()方法对比\"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p>\n<ul>\n<li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁 。</li>\n<li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li>\n<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li>\n<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>\n</ul>\n<h3 id=\"锁的基本概念\"><a href=\"#锁的基本概念\" class=\"headerlink\" title=\"锁的基本概念\"></a>锁的基本概念</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p>\n<h3 id=\"Java中有哪些锁\"><a href=\"#Java中有哪些锁\" class=\"headerlink\" title=\"Java中有哪些锁\"></a>Java中有哪些锁</h3><ul>\n<li><code>synchronized</code>关键字<ul>\n<li>用于同步方法或同步代码块。</li>\n<li>基于对象锁，每个对象都有一个监视器锁。</li>\n</ul>\n</li>\n<li><code>ReentrantLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供更灵活的锁机制，相比<code>synchronized</code>，支持公平锁、非公平锁等特性。</li>\n<li>支持可重入锁，即同一个线程可以多次获取同一个锁。</li>\n</ul>\n</li>\n<li><code>ReentrantReadWriteLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供读写锁的实现，读锁共享，写锁独占。</li>\n<li>适用于读多写少的场景，提升并发性能。</li>\n</ul>\n</li>\n<li><code>StampedLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供三种锁模式：写锁、悲观读锁和乐观读锁。</li>\n<li>乐观读锁在某些情况下可以避免加锁操作，提升性能。</li>\n</ul>\n</li>\n<li><code>LockSupport</code><ul>\n<li>提供基本的线程阻塞和唤醒机制。</li>\n<li>通常用于构建更高级的同步器，如<code>Semaphore</code>、<code>CountDownLatch</code>等。</li>\n</ul>\n</li>\n<li><code>Semaphore</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>用于控制同时访问特定资源的线程数量。</li>\n</ul>\n</li>\n<li><code>CountDownLatch</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>允许一个或多个线程等待一组操作完成。</li>\n</ul>\n</li>\n<li><code>CyclicBarrier</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>使一组线程在到达一个共同的屏障点时被阻塞，直到所有线程都到达该点。</li>\n</ul>\n</li>\n<li>Phaser<ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>允许多阶段的线程协作，每个阶段完成后继续下一阶段。</li>\n</ul>\n</li>\n<li><code>Atomic</code>变量<ul>\n<li>在<code>java.util.concurrent.atomic</code>包中提供。</li>\n<li>提供了一些基本类型(如<code>AtomicInteger</code>、<code>AtomicLong</code>)的原子操作，实现了无锁的线程安全。</li>\n</ul>\n</li>\n</ul>\n<p>这些锁机制可以根据具体的应用场景选择，以实现高效、安全的并发控制。</p>\n<h3 id=\"为什么wait-方法不定义在Thread中\"><a href=\"#为什么wait-方法不定义在Thread中\" class=\"headerlink\" title=\"为什么wait()方法不定义在Thread中\"></a>为什么wait()方法不定义在Thread中</h3><ul>\n<li>锁是对象级别的，每个对象都有一把锁。</li>\n<li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li>\n</ul>\n<h3 id=\"为什么sleep-方法定义在Thread中\"><a href=\"#为什么sleep-方法定义在Thread中\" class=\"headerlink\" title=\"为什么sleep()方法定义在Thread中\"></a>为什么sleep()方法定义在Thread中</h3><ul>\n<li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li>\n<li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li>\n</ul>\n<h3 id=\"sleep-如何控制当前线程沉睡\"><a href=\"#sleep-如何控制当前线程沉睡\" class=\"headerlink\" title=\"sleep()如何控制当前线程沉睡\"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p>\n<h3 id=\"可以直接调用Thread类的run方法吗\"><a href=\"#可以直接调用Thread类的run方法吗\" class=\"headerlink\" title=\"可以直接调用Thread类的run方法吗\"></a>可以直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p>\n<h3 id=\"并发-并行区别\"><a href=\"#并发-并行区别\" class=\"headerlink\" title=\"并发&#x2F;并行区别\"></a>并发&#x2F;并行区别</h3><ul>\n<li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<h3 id=\"同步-异步区别\"><a href=\"#同步-异步区别\" class=\"headerlink\" title=\"同步&#x2F;异步区别\"></a>同步&#x2F;异步区别</h3><ul>\n<li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>\n<li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li>\n</ul>\n<h3 id=\"为什么要使用多线程\"><a href=\"#为什么要使用多线程\" class=\"headerlink\" title=\"为什么要使用多线程\"></a>为什么要使用多线程</h3><ul>\n<li>线程切换和调度的成本远远小于进程。</li>\n<li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li>\n<li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li>\n<li>并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。</li>\n</ul>\n<h3 id=\"使用多线程风险\"><a href=\"#使用多线程风险\" class=\"headerlink\" title=\"使用多线程风险\"></a>使用多线程风险</h3><ul>\n<li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li>\n<li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>\n<li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li>\n<li>上下文切换：线程频繁切换，会增加系统开销。</li>\n<li>…</li>\n</ul>\n<h3 id=\"如何理解线程安全和不安全\"><a href=\"#如何理解线程安全和不安全\" class=\"headerlink\" title=\"如何理解线程安全和不安全\"></a>如何理解线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p>\n<ul>\n<li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>\n<li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>\n</ul>\n<h3 id=\"高并发存在什么问题-Java如何解决的\"><a href=\"#高并发存在什么问题-Java如何解决的\" class=\"headerlink\" title=\"高并发存在什么问题,Java如何解决的\"></a>高并发存在什么问题,Java如何解决的</h3><p><strong>高并发问题</strong></p>\n<ul>\n<li>资源竞争：多个线程竞争同一资源(如内存、文件、数据库连接等)，可能导致数据不一致、死锁等问题。</li>\n<li>死锁：多个线程在等待对方释放资源，从而相互阻塞，导致程序无法继续执行。</li>\n<li>上下文切换开销：线程之间的切换会消耗系统资源，频繁的上下文切换会降低系统性能。</li>\n<li>线程安全：确保多个线程对共享资源的操作不会导致数据不一致的问题。</li>\n<li>内存泄漏：大量创建和销毁线程，如果不合理管理，会导致内存泄漏。</li>\n<li>饥饿和公平性：某些线程可能长期得不到资源，导致饥饿问题。如何确保线程公平地获取资源也是一个挑战。</li>\n<li>负载均衡：在分布式系统中，如何将请求均衡地分配到不同的服务器，以避免某些服务器过载。</li>\n</ul>\n<p><strong>Java解决高并发问题</strong></p>\n<ul>\n<li>线程池(Thread Pool)：通过线程池管理线程的创建和销毁，减少资源消耗，提高系统性能。</li>\n<li>同步机制(Synchronization)：使用 <code>synchronized</code>关键字或显示锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争。</li>\n<li>并发工具类：如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，这些工具类可以帮助开发者更方便地实现线程间的协调和资源共享。</li>\n<li>无锁算法(Lock-Free Algorithms)：使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换开销，提高性能。</li>\n<li>CAS操作(Compare-And-Swap)：CAS是一种无锁算法，通过比较和交换操作来实现原子性。Java中的<code>Unsafe</code>类和<code>Atomic</code>包使用了CAS操作来实现无锁算法。</li>\n<li>Fork&#x2F;Join框架：用于任务拆分和并行处理，适用于大规模数据并行处理。Java 7引入了<code>ForkJoinPool</code>来支持这一框架。</li>\n<li>异步编程(Asynchronous Programming)：通过<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</li>\n</ul>\n<h3 id=\"Java如何实现高并发\"><a href=\"#Java如何实现高并发\" class=\"headerlink\" title=\"Java如何实现高并发\"></a>Java如何实现高并发</h3><p><strong>使用线程池</strong><br>线程池可以有效管理线程的创建和销毁，减少资源消耗和上下文切换开销。Java中的<code>ExecutorService</code>和<code>Executors</code>类提供了便捷的线程池实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    executor.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">Task</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">executor.shutdown();</span><br></pre></td></tr></table></figure>\n<p><strong>同步机制</strong><br>使用<code>synchronized</code>关键字或者显式锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争和数据不一致问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">safeMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Critical section</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Critical section</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>并发集合类</strong><br>Java提供了线程安全的并发集合类，如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code>等，这些集合类可以简化多线程编程。</p>\n<p><strong>原子变量类</strong><br>使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换，提高性能。</p>\n<p><strong>CAS操作</strong><br>Java的<code>Atomic</code>包和<code>Unsafe</code>类使用了CAS(Compare-And-Swap)操作来实现无锁算法，从而提高并发性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AtomicInteger</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">updated</span> <span class=\"operator\">=</span> count.compareAndSet(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>Fork&#x2F;Join框架</strong><br><code>ForkJoinPool</code>用于任务拆分和并行处理，适用于大规模数据的并行计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">pool.invoke(<span class=\"keyword\">new</span> <span class=\"title class_\">RecursiveTask</span>&lt;Void&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Void <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Task implementation</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>异步编程</strong><br>使用<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Async task</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept(result -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Process result</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用非阻塞I&#x2F;O</strong><br>在网络编程中，使用NIO(Non-blocking I&#x2F;O)实现高并发。NIO提供了选择器(<code>Selector</code>)、通道(<code>Channel</code>)和缓冲区(<code>Buffer</code>)等工具，可以实现高效的非阻塞I&#x2F;O操作。</p>\n<p><strong>使用第三方并发框架</strong><br>如Akka、RxJava、Vert.x等，它们提供了更加高级的并发和反应式编程模型。</p>\n<h3 id=\"单核CPU上运行多个线程效率一定会高吗\"><a href=\"#单核CPU上运行多个线程效率一定会高吗\" class=\"headerlink\" title=\"单核CPU上运行多个线程效率一定会高吗\"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<blockquote>\n<p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n</blockquote>\n<p>产生死锁的四个必要条件：</p>\n<ul>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"如何检测死锁\"><a href=\"#如何检测死锁\" class=\"headerlink\" title=\"如何检测死锁\"></a>如何检测死锁</h3><ul>\n<li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li>\n<li>jConsole： 可以检测死锁，查看线程的状态。</li>\n<li>jstack： 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li>\n</ul>\n<h3 id=\"如何预防和避免死锁\"><a href=\"#如何预防和避免死锁\" class=\"headerlink\" title=\"如何预防和避免死锁\"></a>如何预防和避免死锁</h3><p>破坏死锁的产生的必要条件：</p>\n<ul>\n<li>破坏请求与保持条件：一次性申请所有的资源。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ul>\n<p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong> )对资源分配进行计算评估，使其进入安全状态。</p>\n<blockquote>\n<p>安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</p>\n</blockquote>\n<h3 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<h3 id=\"为什么需要Java内存模型\"><a href=\"#为什么需要Java内存模型\" class=\"headerlink\" title=\"为什么需要Java内存模型\"></a>为什么需要Java内存模型</h3><ul>\n<li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li>\n<li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li>\n<li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li>\n</ul>\n<h3 id=\"Java内存区域和Java内存模型有什么区别\"><a href=\"#Java内存区域和Java内存模型有什么区别\" class=\"headerlink\" title=\"Java内存区域和Java内存模型有什么区别\"></a>Java内存区域和Java内存模型有什么区别</h3><ul>\n<li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li>\n<li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li>\n</ul>\n<h3 id=\"JMM是如何抽象线程和主内存之间的关系\"><a href=\"#JMM是如何抽象线程和主内存之间的关系\" class=\"headerlink\" title=\"JMM是如何抽象线程和主内存之间的关系\"></a>JMM是如何抽象线程和主内存之间的关系</h3><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。</p>\n<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li>\n<li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li>\n</ul>\n<h3 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h3><p>可见性、原子性和有序性</p>\n<ul>\n<li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li>\n<li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li>\n<li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li>\n</ul>\n<p>JMM通过上面三种属性来确保线程之间的内存一致性。</p>\n<h3 id=\"如何保证变量的可见性-volatile\"><a href=\"#如何保证变量的可见性-volatile\" class=\"headerlink\" title=\"如何保证变量的可见性(volatile)\"></a>如何保证变量的可见性(volatile)</h3><p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3 id=\"如何禁止指令重排序\"><a href=\"#如何禁止指令重排序\" class=\"headerlink\" title=\"如何禁止指令重排序\"></a>如何禁止指令重排序</h3><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p>\n<h3 id=\"volatile可以保证原子性\"><a href=\"#volatile可以保证原子性\" class=\"headerlink\" title=\"volatile可以保证原子性\"></a>volatile可以保证原子性</h3><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>\n<h3 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁&#x2F;悲观锁\"></a>乐观锁&#x2F;悲观锁</h3><ul>\n<li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul>\n<li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li>\n<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li>\n<li>悲观锁可能会存在死锁问题。</li>\n<li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>\n</ul>\n</li>\n<li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul>\n<li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li>\n<li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li>\n<li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul>\n<li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li>\n</ul>\n</li>\n<li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何实现乐观锁\"><a href=\"#如何实现乐观锁\" class=\"headerlink\" title=\"如何实现乐观锁\"></a>如何实现乐观锁</h3><ul>\n<li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li>\n<li>CAS算法：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul>\n<li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n</blockquote>\n<h3 id=\"CAS算法存在问题\"><a href=\"#CAS算法存在问题\" class=\"headerlink\" title=\"CAS算法存在问题\"></a>CAS算法存在问题</h3><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>\n<p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p>\n<p><strong>循环时间长开销大</strong><br>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p>\n<p><strong>只能保证一个共享变量的原子操作</strong><br>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p>\n<h3 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h3><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>\n<h3 id=\"JDK1-6之后synchronized的优化\"><a href=\"#JDK1-6之后synchronized的优化\" class=\"headerlink\" title=\"JDK1.6之后synchronized的优化\"></a>JDK1.6之后synchronized的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p>\n<h3 id=\"锁升级原理了解吗\"><a href=\"#锁升级原理了解吗\" class=\"headerlink\" title=\"锁升级原理了解吗\"></a>锁升级原理了解吗</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<h3 id=\"如何使用synchronized\"><a href=\"#如何使用synchronized\" class=\"headerlink\" title=\"如何使用synchronized\"></a>如何使用synchronized</h3><ul>\n<li>修饰实例方法：锁住当前实例对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰静态方法：锁住当前类的 Class 对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰代码块：锁住括号里面的对象。<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(对象) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">synchronized(类.class) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized底层原理\"><a href=\"#synchronized底层原理\" class=\"headerlink\" title=\"synchronized底层原理\"></a>synchronized底层原理</h3><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p>\n<ul>\n<li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li>\n<li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li>\n</ul>\n<p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>\n<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>\n<h3 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p>\n<p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>\n<blockquote>\n<p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p>\n</blockquote>\n<h3 id=\"AQS资源共享模式\"><a href=\"#AQS资源共享模式\" class=\"headerlink\" title=\"AQS资源共享模式\"></a>AQS资源共享模式</h3><p>AQS 支持两种资源共享方式：独占和共享。</p>\n<ul>\n<li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li>\n<li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li>\n</ul>\n<blockquote>\n<p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p>\n</blockquote>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p>\n<h3 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁&#x2F;非公平锁\"></a>公平锁&#x2F;非公平锁</h3><ul>\n<li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>\n</ul>\n<h3 id=\"synchronized和ReentrantLock有什么区别？\"><a href=\"#synchronized和ReentrantLock有什么区别？\" class=\"headerlink\" title=\"synchronized和ReentrantLock有什么区别？\"></a>synchronized和ReentrantLock有什么区别？</h3><p>两者都是可重入锁</p>\n<ul>\n<li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li>\n<li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li>\n<li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：<ul>\n<li>等待可中断 ： <code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li>\n<li>可实现公平锁： <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>\n<li>可实现选择性通知(锁可以绑定多个条件)： <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>\n</blockquote>\n<h3 id=\"可中断锁-不可中断锁\"><a href=\"#可中断锁-不可中断锁\" class=\"headerlink\" title=\"可中断锁&#x2F;不可中断锁\"></a>可中断锁&#x2F;不可中断锁</h3><ul>\n<li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li>\n<li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li>\n</ul>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>\n<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁) 。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>\n<blockquote>\n<p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p>\n</blockquote>\n<h3 id=\"共享锁-独占锁\"><a href=\"#共享锁-独占锁\" class=\"headerlink\" title=\"共享锁&#x2F;独占锁\"></a>共享锁&#x2F;独占锁</h3><ul>\n<li>共享锁：一把锁可以被多个线程同时获得。</li>\n<li>独占锁：一把锁只能被一个线程获得。</li>\n</ul>\n<h3 id=\"线程持有读锁还能获取写锁吗\"><a href=\"#线程持有读锁还能获取写锁吗\" class=\"headerlink\" title=\"线程持有读锁还能获取写锁吗\"></a>线程持有读锁还能获取写锁吗</h3><ul>\n<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>\n<li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li>\n</ul>\n<h3 id=\"读锁为什么不能升级为写锁\"><a href=\"#读锁为什么不能升级为写锁\" class=\"headerlink\" title=\"读锁为什么不能升级为写锁\"></a>读锁为什么不能升级为写锁</h3><ul>\n<li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li>\n<li>可能会有死锁问题发生。</li>\n</ul>\n<h3 id=\"StampedLock\"><a href=\"#StampedLock\" class=\"headerlink\" title=\"StampedLock\"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p>\n<p>提供三种访问模式：</p>\n<ul>\n<li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。</li>\n<li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。</li>\n<li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"ThreadLocal原理\"><a href=\"#ThreadLocal原理\" class=\"headerlink\" title=\"ThreadLocal原理\"></a>ThreadLocal原理</h3><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p>\n<blockquote>\n<p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p>\n</blockquote>\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>\n<p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>\n<blockquote>\n<p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p>\n</blockquote>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3 id=\"为什么用线程池\"><a href=\"#为什么用线程池\" class=\"headerlink\" title=\"为什么用线程池\"></a>为什么用线程池</h3><ul>\n<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<blockquote>\n<p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<h3 id=\"创建线程池的方式\"><a href=\"#创建线程池的方式\" class=\"headerlink\" title=\"创建线程池的方式\"></a>创建线程池的方式</h3><ul>\n<li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li>\n<li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul>\n<li><code>FixedThreadPool</code>：固定大小的线程池。</li>\n<li><code>SingleThreadPool</code>：只有一个线程的线程池。</li>\n<li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li>\n<li><code>ScheduledThreadPool</code>：定时任务的线程池。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么不推荐使用内置线程池\"><a href=\"#为什么不推荐使用内置线程池\" class=\"headerlink\" title=\"为什么不推荐使用内置线程池\"></a>为什么不推荐使用内置线程池</h3><ul>\n<li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li>\n<li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor参数\"><a href=\"#ThreadPoolExecutor参数\" class=\"headerlink\" title=\"ThreadPoolExecutor参数\"></a>ThreadPoolExecutor参数</h3><p>3 个最重要的参数：</p>\n<ul>\n<li><code>corePoolSize</code> ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><code>maximumPoolSize</code> ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><code>workQueue</code>： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>其他常见参数 ：</p>\n<ul>\n<li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li>\n<li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><code>threadFactory</code> ：<code>executor</code> 创建新线程的时候会用到。</li>\n<li><code>handler</code> ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li>\n</ul>\n<h3 id=\"线程池的拒绝策略\"><a href=\"#线程池的拒绝策略\" class=\"headerlink\" title=\"线程池的拒绝策略\"></a>线程池的拒绝策略</h3><ul>\n<li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li>\n<li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li>\n<li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li>\n<li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy策略风险及解决方案\"><a href=\"#CallerRunsPolicy策略风险及解决方案\" class=\"headerlink\" title=\"CallerRunsPolicy策略风险及解决方案\"></a>CallerRunsPolicy策略风险及解决方案</h3><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li>\n<li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li>\n</ol>\n<h3 id=\"线程池常用阻塞队列\"><a href=\"#线程池常用阻塞队列\" class=\"headerlink\" title=\"线程池常用阻塞队列\"></a>线程池常用阻塞队列</h3><ul>\n<li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li>\n<li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3 id=\"线程池处理任务流程\"><a href=\"#线程池处理任务流程\" class=\"headerlink\" title=\"线程池处理任务流程\"></a>线程池处理任务流程</h3><ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li>\n</ol>\n<h3 id=\"线程池中线程异常后销毁还是复用？\"><a href=\"#线程池中线程异常后销毁还是复用？\" class=\"headerlink\" title=\"线程池中线程异常后销毁还是复用？\"></a>线程池中线程异常后销毁还是复用？</h3><p>两种情况：</p>\n<ul>\n<li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li>\n<li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li>\n</ul>\n<h3 id=\"如何设定线程池大小\"><a href=\"#如何设定线程池大小\" class=\"headerlink\" title=\"如何设定线程池大小\"></a>如何设定线程池大小</h3><ul>\n<li>CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li>\n<li>I&#x2F;O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I&#x2F;O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。</li>\n</ul>\n<h3 id=\"如何设计一个根据任务优先级执行的线程池\"><a href=\"#如何设计一个根据任务优先级执行的线程池\" class=\"headerlink\" title=\"如何设计一个根据任务优先级执行的线程池\"></a>如何设计一个根据任务优先级执行的线程池</h3><ul>\n<li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li>\n<li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li>\n</ul>\n<p>这样还存在一些问题：</p>\n<ul>\n<li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul>\n<li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 &#96;false 。</li>\n</ul>\n</li>\n<li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul>\n<li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异步调用Future类\"><a href=\"#异步调用Future类\" class=\"headerlink\" title=\"异步调用Future类\"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V 代表了Future执行的任务返回值的类型</span><br><span class=\"line\">public interface Future&lt;V&gt; &#123;</span><br><span class=\"line\">    // 取消任务执行，成功取消返回 true，否则返回 false</span><br><span class=\"line\">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\">    // 判断任务是否被取消</span><br><span class=\"line\">    boolean isCancelled();</span><br><span class=\"line\">    // 判断任务是否已经执行完成</span><br><span class=\"line\">    boolean isDone();</span><br><span class=\"line\">    // 获取任务执行结果</span><br><span class=\"line\">    V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\">    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br><span class=\"line\">    V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">        throws InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Callable和Future关系\"><a href=\"#Callable和Future关系\" class=\"headerlink\" title=\"Callable和Future关系\"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p>\n<ul>\n<li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li>\n<li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li>\n</ul>\n<h3 id=\"CompletableFuture类有什么用？\"><a href=\"#CompletableFuture类有什么用？\" class=\"headerlink\" title=\"CompletableFuture类有什么用？\"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p>\n<h3 id=\"CompletableFuture类异步调用实现\"><a href=\"#CompletableFuture类异步调用实现\" class=\"headerlink\" title=\"CompletableFuture类异步调用实现\"></a>CompletableFuture类异步调用实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟一个长时间运行的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">// 休眠2秒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务完成&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class=\"line\">        future.thenAccept(result -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 主线程继续执行其他操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主线程继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞主线程，直到异步任务完成（可选）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> future.get();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"虚拟线程\"><a href=\"#虚拟线程\" class=\"headerlink\" title=\"虚拟线程\"></a>虚拟线程</h3><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p>\n<p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>\n<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li>\n<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>\n</ul>\n<p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p>\n<p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream/Reader</code>： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream/Writer</code>： 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h3 id=\"Java为什么要分字节流和字符流\"><a href=\"#Java为什么要分字节流和字符流\" class=\"headerlink\" title=\"Java为什么要分字节流和字符流\"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p>\n<ul>\n<li>字符流自动处理字符编码问题，非常适合文本数据；</li>\n<li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li>\n</ul>\n<h3 id=\"字节流和字符流区别\"><a href=\"#字节流和字符流区别\" class=\"headerlink\" title=\"字节流和字符流区别\"></a>字节流和字符流区别</h3><ul>\n<li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li>\n<li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li>\n<li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li>\n</ul>\n<h3 id=\"IO设计模式总结\"><a href=\"#IO设计模式总结\" class=\"headerlink\" title=\"IO设计模式总结\"></a>IO设计模式总结</h3><ul>\n<li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li>\n<li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li>\n<li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>\n<li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li>\n</ul>\n<h3 id=\"装饰器模式和适配器模式区别\"><a href=\"#装饰器模式和适配器模式区别\" class=\"headerlink\" title=\"装饰器模式和适配器模式区别\"></a>装饰器模式和适配器模式区别</h3><ul>\n<li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li>\n<li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li>\n</ul>\n<h3 id=\"3种常见的IO模型\"><a href=\"#3种常见的IO模型\" class=\"headerlink\" title=\"3种常见的IO模型\"></a>3种常见的IO模型</h3><ul>\n<li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul>\n<li>优点：编程简单，代码易于理解。</li>\n<li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li>\n</ul>\n</li>\n<li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul>\n<li>优点：单线程可以处理多个连接，提高并发性能。</li>\n<li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li>\n</ul>\n</li>\n<li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul>\n<li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li>\n<li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h3><p>Java内存区域&#x2F;Java虚拟机内存 通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p>\n<p>线程私有的内存区域包括：</p>\n<ul>\n<li><strong>程序计数器</strong>：<ul>\n<li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li>\n<li>如果正在执行的是本地方法，这个计数器是未指定值(undefined)。</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：<ul>\n<li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li>\n<li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li>\n</ul>\n</li>\n<li><strong>本地方法栈</strong>：<ul>\n<li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li>\n<li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li>\n</ul>\n</li>\n</ul>\n<p>线程共享的内存区域包括：</p>\n<ul>\n<li><strong>堆</strong>：<ul>\n<li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li>\n<li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li>\n<li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul>\n<li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>方法区</strong>：<ul>\n<li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n<li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li>\n</ul>\n</li>\n<li><strong>运行时常量池</strong>：<ul>\n<li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li>\n<li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li>\n</ul>\n</li>\n</ul>\n<p>本地内存：</p>\n<ul>\n<li>直接内存：<ul>\n<li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li>\n<li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li>\n<li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li>\n</ul>\n</li>\n</ul>\n<p><strong>内存模型与内存管理</strong></p>\n<ul>\n<li>**内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li>\n<li>**垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li>\n</ul>\n<p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p>\n<h3 id=\"成员变量-全局变量-局部变量存放在哪里\"><a href=\"#成员变量-全局变量-局部变量存放在哪里\" class=\"headerlink\" title=\"成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里\"></a>成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里</h3><ul>\n<li>成员变量(实例变量)存储在堆内存中，每个对象都有自己的一份成员变量。</li>\n<li>静态变量(类变量)存储在方法区(或元空间)中，是类级别的变量，共享给所有实例。</li>\n<li>局部变量存储在栈内存中，属于方法调用帧的一部分。</li>\n</ul>\n<h3 id=\"对象的创建过程-5步\"><a href=\"#对象的创建过程-5步\" class=\"headerlink\" title=\"对象的创建过程(5步)\"></a>对象的创建过程(5步)</h3><ol>\n<li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>\n<li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>\n<li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>\n<li>执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域： </p>\n<ul>\n<li>对象头(<code>Header</code>)： <ul>\n<li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li>\n<li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n</li>\n<li>实例数据(<code>Instance Data</code>)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>\n<li>对齐填充(<code>Padding</code>)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li>\n</ul>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>\n<ul>\n<li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li>\n<li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li>\n</ul>\n<p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<h3 id=\"垃圾回收机制✅\"><a href=\"#垃圾回收机制✅\" class=\"headerlink\" title=\"垃圾回收机制✅\"></a>垃圾回收机制✅</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p>\n<p><strong>堆空间结构</strong><br>堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p>\n<p><strong>内存分配和回收原则</strong></p>\n<ul>\n<li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li>\n<li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li>\n</ul>\n<p>垃圾回收的基本步骤分两步：</p>\n<ul>\n<li>查找内存中不再使用的对象(GC判断策略)</li>\n<li>释放这些对象占用的内存(GC收集算法)</li>\n</ul>\n<p><strong>死亡对象&#x2F;GC判断策略</strong></p>\n<ul>\n<li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul>\n<li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n</ul>\n</li>\n<li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul>\n<li>这些对象可以用作 GC Roots： <ul>\n<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n<li>JNI(Java Native Interface)引用的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p>\n</blockquote>\n<p><strong>垃圾回收算法</strong></p>\n<ul>\n<li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul>\n<li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li>\n</ul>\n</li>\n<li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul>\n<li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li>\n</ul>\n</li>\n<li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul>\n<li>问题：整理的过程效率也不高。</li>\n</ul>\n</li>\n<li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li>\n</ul>\n<p><strong>垃圾回收器</strong><br>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20： G1(Garbage-First)收集器</p>\n<ul>\n<li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。</li>\n<li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。</li>\n<li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。</li>\n<li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。</li>\n<li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。</li>\n<li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。</li>\n<li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。</li>\n<li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。</li>\n</ul>\n<blockquote>\n<p>HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<ul>\n<li>部分收集 (<code>Partial GC</code>)：<ul>\n<li>新生代收集(Minor GC &#x2F; Young GC)：只对新生代进行垃圾收集；</li>\n<li>老年代收集(Major GC &#x2F; Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>\n</ul>\n</blockquote>\n<h3 id=\"为什么要进行垃圾回收\"><a href=\"#为什么要进行垃圾回收\" class=\"headerlink\" title=\"为什么要进行垃圾回收\"></a>为什么要进行垃圾回收</h3><ul>\n<li><strong>防止内存泄漏</strong>：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li>\n<li><strong>提高开发效率</strong>：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li>\n<li><strong>系统性能和稳定性</strong>：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li>\n</ul>\n<h3 id=\"强引用-软引用-弱引用-虚引用✅\"><a href=\"#强引用-软引用-弱引用-虚引用✅\" class=\"headerlink\" title=\"强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅\"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅</h3><p><a href=\"https://blog.csdn.net/u013718071/article/details/134789666\">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p>\n<ul>\n<li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li>\n<li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li>\n<li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li>\n<li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li>\n</ul>\n<p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p>\n<h3 id=\"如何判断一个类是无用的\"><a href=\"#如何判断一个类是无用的\" class=\"headerlink\" title=\"如何判断一个类是无用的\"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p>\n<h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p>\n<p>其中验证、准备、解析 3 部分统称为连接。</p>\n<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p>\n<p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流。</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>\n</ol>\n<blockquote>\n<p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p>\n</blockquote>\n<p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul>\n<li>如验证类是否有父类</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul>\n<li>如验证函数的参数是否正确</li>\n</ul>\n</li>\n<li>符号引用验证：确保解析动作能正确执行。<ul>\n<li>如验证该类要使用的其他类、方法是否存在。</li>\n</ul>\n</li>\n</ol>\n<p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p>\n<ul>\n<li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>\n<li>初始值是数据类型的默认值，如 0、null 等。</li>\n</ul>\n<p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p>\n<p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>\n<h3 id=\"类卸载\"><a href=\"#类卸载\" class=\"headerlink\" title=\"类卸载\"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p>\n<p>卸载类需要满足 3 个要求：</p>\n<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n<p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p>\n<blockquote>\n<p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p>\n</blockquote>\n<p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p>\n<p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p>\n<p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"简历相关\"><a href=\"#简历相关\" class=\"headerlink\" title=\"简历相关\"></a>简历相关</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p>\n<h3 id=\"Casbin明日之星实习\"><a href=\"#Casbin明日之星实习\" class=\"headerlink\" title=\"Casbin明日之星实习\"></a>Casbin明日之星实习</h3><ol>\n<li><p>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</p>\n</li>\n<li><p>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</p>\n</li>\n<li><p>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</p>\n</li>\n</ol>\n<h3 id=\"中科院开源之夏项目\"><a href=\"#中科院开源之夏项目\" class=\"headerlink\" title=\"中科院开源之夏项目\"></a>中科院开源之夏项目</h3><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p>\n<p><strong>项目诉求</strong></p>\n<ol>\n<li><p>对微信第三方登录的移动端支持</p>\n<ul>\n<li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li>\n</ul>\n</li>\n<li><p>对flutter、react-native、unity等sdk的开发及功能的增强</p>\n<ul>\n<li>对flutter-sdk的增强如第一点</li>\n</ul>\n</li>\n<li><p>临时加上的开发casdoor-app诉求，对标Google Authenticator</p>\n</li>\n</ol>\n<p><strong>技术细节</strong></p>\n<ol>\n<li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p>\n<ul>\n<li>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</li>\n<li>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</li>\n<li>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</li>\n</ul>\n<p> 接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p>\n</li>\n<li><p>分为两部分</p>\n<ol>\n<li>casdoor-unity-example<ul>\n<li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li>\n<li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li>\n<li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li>\n<li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li>\n</ul>\n</li>\n<li>casdoor-react-native-sdk、example<ul>\n<li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li>\n<li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li>\n<li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。</p>\n<ul>\n<li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li>\n<li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p>\n</blockquote>\n<p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p>\n<h3 id=\"单点登录SSO原理\"><a href=\"#单点登录SSO原理\" class=\"headerlink\" title=\"单点登录SSO原理\"></a>单点登录SSO原理</h3><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p>\n<p>在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。</p>\n<p>流程：</p>\n<ol>\n<li>用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li>\n<li>此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li>\n</ol>\n<p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p>\n<h3 id=\"OAuth-2-0原理\"><a href=\"#OAuth-2-0原理\" class=\"headerlink\" title=\"OAuth 2.0原理\"></a>OAuth 2.0原理</h3><p><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p>\n<p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。</p>\n<p>定义了4种角色：</p>\n<ul>\n<li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li>\n<li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。</li>\n<li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li>\n<li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。</li>\n<li>如果用户授权该请求，应用程序会收到授权准许(<code>Authorization Grant</code>)。</li>\n<li>应用程序通过提供其自身的身份验证和授权准许(<code>Authorization Grant</code>)来向授权服务器 (API) 请求访问令牌(<code>access_token</code>)。</li>\n<li>如果应用程序身份通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器(API)向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li>\n<li>应用程序从资源服务器(API)请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li>\n<li>如果访问令牌(<code>access_token</code>)有效，则资源服务器 (API) 向应用程序提供资源。</li>\n</ol>\n<p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p>\n<ol>\n<li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li>\n<li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li>\n<li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li>\n</ol>\n<h3 id=\"2FA\"><a href=\"#2FA\" class=\"headerlink\" title=\"2FA\"></a>2FA</h3><p>两因素认证(<code>Two-Factor Authentication, 2FA)</code>是一种安全系统，用于确保用户登录到账户或访问资源时，需要通过两种不同类型的验证方式。这种方法比仅依靠密码更安全，因为它增加了额外的验证层，使得即使密码被泄露，攻击者仍然难以访问用户账户。</p>\n<p>身份验证因素：2FA通常结合两种不同的验证因素，分三类：</p>\n<ul>\n<li>知识因素(Something you know)：用户知道的东西，例如密码、PIN码、回答安全问题等。</li>\n<li>持有因素(Something you have)：用户拥有的物品，例如手机、硬件令牌、智能卡等。</li>\n<li>固有因素(Something you are)：用户自身的特征，例如指纹、面部识别、声音识别等生物特征。</li>\n</ul>\n<p>验证过程：</p>\n<ul>\n<li>第一步：输入用户名和密码：用户首先输入他们的用户名和密码(知识因素)。</li>\n<li>第二步：额外验证：系统会要求用户进行第二步验证。这可以是：  <ul>\n<li>一次性密码(OTP)：通过短信、电子邮件或专用应用程序(如Google Authenticator、Authy)生成并发送给用户的随机密码。</li>\n<li>硬件令牌：用户插入或展示硬件令牌生成的代码。</li>\n<li>生物特征识别：用户通过指纹、面部识别等方式进行验证。</li>\n</ul>\n</li>\n</ul>\n<p>验证成功：如果两步验证都通过，用户将获得访问权限。<br>验证失败：如果任何一步失败，访问将被拒绝。</p>\n<h3 id=\"PKCE\"><a href=\"#PKCE\" class=\"headerlink\" title=\"PKCE\"></a>PKCE</h3><p>PKCE(<code>Proof Key for Code Exchange, PKCE</code>)是一种用于保护OAuth 2.0授权码授权流程的机制，主要目的是防止授权码拦截攻击(Authorization Code Interception Attack)。</p>\n<p>原理：<br>PKCE通过在OAuth 2.0授权码请求和令牌交换过程中引入一个随机生成的<code>code_challenge</code>和<code>code_verifier</code>来增强安全性。具体来说，PKCE引入了两个新参数：</p>\n<ul>\n<li><code>code_verifier</code>：一个高熵的随机字符串，客户端在请求<code>code</code>(授权码)时生成并保存。</li>\n<li><code>code_challenge</code>：由<code>code_verifier</code>生成的一个变体，发送给授权服务器。可以是<code>code_verifier</code>本身，或者是<code>code_verifier</code>的SHA256哈希值。</li>\n</ul>\n<p>流程：</p>\n<ol>\n<li>客户端生成一个随机的<code>code_challenge</code>和<code>code_verifier</code>，<code>code_verifier</code>可以是明文(<code>plain</code>)SHA256哈希值(<code>s256</code>)。</li>\n<li>客户端将<code>code_challenge</code>和<code>code_challenge_method</code>(<code>plain</code>或<code>s256</code>)发送给授权服务器。<ul>\n<li>如：<code>GET /authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=SCOPE&amp;state=STATE&amp;code_challenge=CODE_CHALLENGE&amp;code_challenge_method=S256</code></li>\n</ul>\n</li>\n<li>用户在授权服务器进行身份验证，同意授权，授权服务器通过重定向URI将<code>code</code>(授权码)返回给客户端。</li>\n<li>客户端将<code>code</code>(授权码)和<code>code_verifier</code>发送给授权服务器，以获取<code>access_token</code>(访问令牌)。<ul>\n<li>如：<code>POST /token?grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=REDIRECT_URI&amp;client_id=CLIENT_ID&amp;code_verifier=CODE_VERIFIER</code></li>\n</ul>\n</li>\n<li>授权服务器收到客户端发送的<code>code</code>(授权码)和<code>code_verifier</code>后，使用之前保存的<code>code_challenge</code>进行验证。<ul>\n<li>如果<code>code_challenge_method</code>是<code>plain</code>，则直接比较<code>code_verifier</code>和<code>code_challenge</code>。</li>\n<li>如果<code>code_challenge_method</code>是<code>s256</code>，则比较<code>code_verifier</code>的SHA256哈希值和<code>code_challenge</code>。</li>\n</ul>\n</li>\n<li>如果验证通过，授权服务器返回<code>access_token</code>(访问令牌)给客户端。</li>\n</ol>\n<p>这样，即使<code>code</code>(授权码)在传输过程中被拦截，攻击者也无法使用该<code>code</code>(授权码)，因为缺少正确的<code>code_verifier</code>。</p>\n<h3 id=\"OTP-TOTP-HOTP\"><a href=\"#OTP-TOTP-HOTP\" class=\"headerlink\" title=\"OTP&#x2F;TOTP&#x2F;HOTP\"></a>OTP&#x2F;TOTP&#x2F;HOTP</h3><p>OTP (One-Time Password) 是一种一次性有效的密码，通常用于两因素身份验证(2FA)。每次使用 OTP 进行身份验证后，这个密码便失效，无法再使用。OTP 提高了安全性，因为即使密码被截获或暴力破解，也不能再次使用。OTP 生成和使用的方式有很多种，包括基于时间的(TOTP)和基于事件的(HOTP)。</p>\n<p><strong>TOTP(基于时间的一次性密码)</strong><br>TOTP (Time-Based One-Time Password) 是 OTP 的一种，它基于当前时间生成密码。TOTP 是 HOTP 的扩展，结合了时间元素来提高安全性。TOTP 的工作原理如下：</p>\n<ol>\n<li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 TOTP。</li>\n<li>时间段：TOTP 使用当前时间的一个窗口(通常是 30 秒)来生成密码。每个时间段内生成的密码是唯一的。</li>\n<li>算法：TOTP 使用 HMAC-SHA1 算法和共享密钥以及当前时间戳来生成密码。</li>\n</ol>\n<p><strong>生成和验证</strong></p>\n<ul>\n<li>生成 TOTP：用户的设备(如手机上的 Google Authenticator 应用)使用共享密钥和当前时间生成 TOTP。</li>\n<li>验证 TOTP：服务器使用同样的共享密钥和当前时间计算 TOTP，并与用户提供的 TOTP 进行对比。如果匹配，则验证成功。</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>安全性高：每个密码只能使用一次，有效时间短，降低了被攻击的风险。</li>\n<li>易于使用：用户只需要输入一次性密码，而不需要记住复杂的密码。</li>\n<li>灵活性：适用于各种应用场景，如登录、交易验证等。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>时间同步：TOTP 依赖于设备和服务器时间的同步，如果时间不同步，可能会导致验证失败。</li>\n<li>设备依赖：需要用户拥有生成 OTP 或 TOTP 的设备，如智能手机。</li>\n</ul>\n<p><strong>HOTP(基于事件的一次性密码)</strong><br>HOTP (HMAC-Based One-Time Password) 是一种基于事件的 OTP(一次性密码)生成方法。HOTP 的生成与验证基于 HMAC-SHA1 算法及一个计数器，确保每次生成的密码都是唯一的。HOTP 的工作原理如下：</p>\n<ol>\n<li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 HOTP。</li>\n<li>计数器：用户和服务器都维护一个计数器，计数器初始值相同，每次生成或验证 OTP 时都会增加计数器的值。</li>\n<li>HMAC-SHA1 算法：HOTP 使用 HMAC-SHA1 算法，将共享密钥和计数器作为输入，生成一个哈希值。</li>\n<li>生成 OTP：从哈希值中提取部分数据(通常是取哈希值的后几位)，将其转换为一个短数字串，即 OTP。</li>\n</ol>\n<p><strong>生成和验证</strong></p>\n<ul>\n<li>生成 HOTP：用户的设备使用共享密钥和计数器生成 HOTP。</li>\n<li>验证 HOTP：服务器使用同样的共享密钥和计数器计算 HOTP，并与用户提供的 OTP 进行对比。如果匹配，则验证成功，并增加计数器的值。</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无时间依赖：HOTP 不依赖于设备和服务器时间的同步，避免了时间不同步带来的问题。</li>\n<li>安全性高：每个密码只能使用一次，降低了密码被截获或重复使用的风险。</li>\n<li>灵活性：适用于各种应用场景，如登录、交易验证等。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>计数器同步：用户和服务器必须保持计数器的同步，否则会导致验证失败。如果计数器不同步，需要有机制进行重新同步。</li>\n<li>复杂性：相较于静态密码，HOTP 的实现和维护相对复杂。</li>\n</ul>\n<p><strong>使用场景</strong></p>\n<ul>\n<li>银行和金融服务：TOTP&#x2F;HOTP 经常用于网上银行和金融交易中，以确保只有授权用户才能进行操作。</li>\n<li>企业安全：企业系统常使用 TOTP&#x2F;HOTP 进行多因素身份验证，以保护敏感数据和资源。</li>\n<li>社交媒体和电子邮件：为了防止账户被黑客入侵，许多社交媒体和电子邮件服务提供商都提供 TOTP&#x2F;HOTP 作为额外的安全措施。</li>\n</ul>\n<h3 id=\"Casbin-Casdoor-介绍\"><a href=\"#Casbin-Casdoor-介绍\" class=\"headerlink\" title=\"Casbin Casdoor 介绍\"></a>Casbin Casdoor 介绍</h3><blockquote>\n<p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p>\n<ol>\n<li>多种访问控制模型支持：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li>\n<li>灵活的策略管理：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li>\n<li>细粒度的权限控制：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li>\n<li>跨语言支持：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p>\n<ol>\n<li>单点登录(SSO)：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li>\n<li>用户管理：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li>\n<li>权限控制：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li>\n<li>开源社区：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li>\n</ol>\n</blockquote>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><blockquote>\n<p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p>\n<ul>\n<li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li>\n<li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li>\n<li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li>\n<li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li>\n<li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li>\n<li>标准化操作：利用HTTP动词来描述对资源的操作。 </li>\n<li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li>\n<li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li>\n<li>无状态交互：每个请求独立，不依赖于之前的请求。</li>\n</ul>\n<p>优点 </p>\n<ul>\n<li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li>\n<li>性能高：无状态和可缓存性提高了性能。 </li>\n<li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li>\n<li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li>\n</ul>\n<p>缺点 </p>\n<ul>\n<li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li>\n<li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li>\n<li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li>\n</ul>\n<p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p>\n</blockquote>\n<h3 id=\"国家电网项目\"><a href=\"#国家电网项目\" class=\"headerlink\" title=\"国家电网项目\"></a>国家电网项目</h3><p><strong>简介</strong></p>\n<p>自己导师接的项目，江苏省国家电网智能诊断数据分析平台</p>\n<p><strong>项目诉求</strong></p>\n<ul>\n<li>对相应指标进行增删改查</li>\n<li>可以导入、导出一些excel表格</li>\n<li>对数据进行智能诊断分析</li>\n</ul>\n<p><strong>技术细节</strong><br>react、Antd、Flask、mongodb</p>\n<p><strong>我的职责</strong><br>在项目中，负责实现各项重要指标的计算、以及对各指标进行灵活的增删改查，实现数据的存取以及前端展示等功能。</p>\n<h3 id=\"为什么使用mongodb\"><a href=\"#为什么使用mongodb\" class=\"headerlink\" title=\"为什么使用mongodb\"></a>为什么使用mongodb</h3><p>mongodb是一个非关系型数据库，采用文档存储模型，数据以BSON格式存储。项目中，需要导入或者导出 Excel 表格，一个 Excel文件正好可以对应mongodb中的一个文档，这样可以方便地将 Excel 中的数据导入到 mongodb 中。</p>\n<h3 id=\"江南布衣实习\"><a href=\"#江南布衣实习\" class=\"headerlink\" title=\"江南布衣实习\"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p>\n<ol>\n<li><p>新入职员工设备管理：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p>\n</li>\n<li><p>离职员工设备回收和资料销毁：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p>\n</li>\n<li><p>订货会期间设备组装和网络连接：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p>\n</li>\n<li><p>员工设备报修响应与问题解决：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p>\n</li>\n</ol>\n<p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p>\n<blockquote>\n<p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p>\n<ol>\n<li>网络配置：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li>\n<li>身份验证：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li>\n<li>访问内部资源：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li>\n</ol>\n</blockquote>\n<h3 id=\"印象最深的一个项目\"><a href=\"#印象最深的一个项目\" class=\"headerlink\" title=\"印象最深的一个项目\"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p>\n<p><strong>亮点</strong></p>\n<ol>\n<li><strong>异步支持</strong>：<ul>\n<li>亮点：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li>\n<li>回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li>\n</ul>\n</li>\n<li><strong>灵活的过滤机制</strong>：<ul>\n<li>亮点：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li>\n<li>回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li>\n</ul>\n</li>\n<li><strong>可扩展性</strong>：<ul>\n<li>亮点：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li>\n<li>回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li>\n</ul>\n</li>\n<li><strong>事务处理</strong>：<ul>\n<li>亮点：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li>\n<li>回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>难点</strong></p>\n<ol>\n<li><strong>异步编程的复杂性</strong>：<ul>\n<li>难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li>\n<li>回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li>\n</ul>\n</li>\n<li><strong>数据库模型的灵活性与一致性</strong>：<ul>\n<li>难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li>\n<li>回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li>\n</ul>\n</li>\n<li><strong>复杂的策略更新逻辑</strong>：<ul>\n<li>难点：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li>\n<li>回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li>\n</ul>\n</li>\n<li><strong>高效的批量操作</strong>：<ul>\n<li>难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li>\n<li>回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li>\n</ul>\n</li>\n</ol>\n<p>测试方面</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p>\n<h3 id=\"学生生涯遇到的挫折和应对策略\"><a href=\"#学生生涯遇到的挫折和应对策略\" class=\"headerlink\" title=\"学生生涯遇到的挫折和应对策略\"></a>学生生涯遇到的挫折和应对策略</h3><p>高一升高二的时候，当时是从一个普通班进入全校最好的英才班嘛。然后第一次考试，我考了全班倒数第三，当时从普通班的前几名到倒数第三，可谓是很大的打击，我从小到大就没考过这么差的名词，当时很伤心沮丧吧，回家在房间偷偷哭。</p>\n<p>但我也知道，哭是没有用的，我跟别人的差距是确实存在的，从那次后，我比别人更加努力，我花别人更多的时间去学习，去做题，去复习。不会的知识点也请教老师和同学，他们也都很乐意帮助我，我很感谢他们。争取把遇到的每个不会的知识点攻克，我也慢慢的感觉到自己的进步，从才开始的在英才班倒数，到中游 10-20名这样子，到最后高考的时候，考了英才班第四名。</p>\n<p>我觉得吧，从这个经历中，我学到了很多，比如说遇到困难要找对方法才行，其次就是要有毅力，不要轻易放弃，最后就是要有信心，相信自己可以做到。</p>\n<p>最让我有感触的是，让我学会了 任何时候，都要对自己有信心，不要怀疑自己的能力，相信自己可以做到。这点在我后面的大学学习、跨专业保研中起到了很重要的作用。</p>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li>\n<li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li>\n<li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li>\n</ul>\n<blockquote>\n<p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p>\n</blockquote>\n<h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p><code>&lt;&lt;</code>：左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>：无符号右移，忽略符号位，空位都以 0 补齐。</p>\n<p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>\n<p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p>\n<h3 id=\"基本数据类型-包装类型-及区别\"><a href=\"#基本数据类型-包装类型-及区别\" class=\"headerlink\" title=\"基本数据类型&#x2F;包装类型 及区别\"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p>\n<ul>\n<li>6 种数字类型： <ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<blockquote>\n<p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>： 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>： 双引号。</p>\n</blockquote>\n<p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<p><strong>区别</strong></p>\n<ul>\n<li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li>\n<li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li>\n<li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li>\n<li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>\n<li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>\n</ul>\n<h3 id=\"包装类的缓存机制\"><a href=\"#包装类的缓存机制\" class=\"headerlink\" title=\"包装类的缓存机制\"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>\n<h3 id=\"什么是自动拆装箱\"><a href=\"#什么是自动拆装箱\" class=\"headerlink\" title=\"什么是自动拆装箱\"></a>什么是自动拆装箱</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;  <span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i;   <span class=\"comment\">//拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>\n<li>拆箱：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题\"><a href=\"#如何解决浮点数运算的精度丢失问题\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题\"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p>\n<h3 id=\"局部变量-成员变量-静态变量\"><a href=\"#局部变量-成员变量-静态变量\" class=\"headerlink\" title=\"局部变量&#x2F;成员变量&#x2F;静态变量\"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul>\n<li>语法形式：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>\n<li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>\n<li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li>\n</ul>\n<p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><ul>\n<li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>\n<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象和面向过程区别\"><a href=\"#面向对象和面向过程区别\" class=\"headerlink\" title=\"面向对象和面向过程区别\"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"接口和抽象类区别\"><a href=\"#接口和抽象类区别\" class=\"headerlink\" title=\"接口和抽象类区别\"></a>接口和抽象类区别</h3><p>共同点： 都不能被实例化<br><a href=\"https://learn.skyofit.com/archives/351\">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p>\n<ul>\n<li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li>\n<li>抽象类可以有构造方法，接口不能有构造方法。</li>\n<li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li>\n<li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li>\n<li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li>\n<li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li>\n</ul>\n<h3 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h3><p><a href=\"https://blog.csdn.net/qq_44944221/article/details/126692973\">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p>\n<ul>\n<li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li>\n<li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li>\n<li>共享性不同：栈是线程私有，而堆是线程共享；</li>\n<li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li>\n<li>空间大小不同：堆空间大小远远大于栈的内存空间。</li>\n</ul>\n<h3 id=\"深拷贝-浅拷贝-引用拷贝\"><a href=\"#深拷贝-浅拷贝-引用拷贝\" class=\"headerlink\" title=\"深拷贝&#x2F;浅拷贝&#x2F;引用拷贝\"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul>\n<li>深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。</li>\n<li>浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li>引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li>\n</ul>\n<h3 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"形参-实参\"><a href=\"#形参-实参\" class=\"headerlink\" title=\"形参&amp;实参\"></a>形参&amp;实参</h3><ul>\n<li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>\n<li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>\n</ul>\n<h3 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递&amp;引用传递\"></a>值传递&amp;引用传递</h3><ul>\n<li>值传递：方法接收的是实参值的拷贝，会创建副本。</li>\n<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p>Java 中只有值传递，C++ 中有值传递和引用传递。</p>\n<h3 id=\"和equals-区别\"><a href=\"#和equals-区别\" class=\"headerlink\" title=\"&#x3D;&#x3D;和equals()区别\"></a>&#x3D;&#x3D;和equals()区别</h3><ul>\n<li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul>\n<li>基本数据类型：比较的是值是否相等</li>\n<li>引用数据类型：比较的是引用地址是否相等</li>\n<li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li>\n</ul>\n</li>\n<li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul>\n<li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li>\n<li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hashCode-和equal\"><a href=\"#hashCode-和equal\" class=\"headerlink\" title=\"hashCode()和equal()\"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>\n<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li>\n</ul>\n<p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<h3 id=\"String-StringBuffer-StringBuilder\"><a href=\"#String-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"String&#x2F;StringBuffer&#x2F;StringBuilder\"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul>\n<li><p><code>String</code> ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuffer</code> ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuilder</code> ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p>\n</li>\n<li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>\n</li>\n<li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p>\n</li>\n<li><p><code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n</li>\n</ul>\n<p>** <code>String</code> 为什么不可变？**</p>\n<ul>\n<li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ul>\n<h3 id=\"字符串拼接使用-还是StringBuilder？\"><a href=\"#字符串拼接使用-还是StringBuilder？\" class=\"headerlink\" title=\"字符串拼接使用+还是StringBuilder？\"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p>\n<h3 id=\"String-equals-Object-equals\"><a href=\"#String-equals-Object-equals\" class=\"headerlink\" title=\"String.equals()&#x2F;Object.equals()\"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>： 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>： 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p>\n<h3 id=\"Checked-Unchecked-Exception\"><a href=\"#Checked-Unchecked-Exception\" class=\"headerlink\" title=\"Checked&#x2F;Unchecked Exception\"></a>Checked&#x2F;Unchecked Exception</h3><ul>\n<li><code>Checked Exception</code>即受检查异常 ，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<ul>\n<li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li>\n</ul>\n</li>\n<li><code>Unchecked Exception</code> 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。<ul>\n<li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"try-catch-finally\"><a href=\"#try-catch-finally\" class=\"headerlink\" title=\"try-catch-finally\"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>\n<blockquote>\n<p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p>\n</blockquote>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><ul>\n<li>使用泛型参数，可以增强代码的可读性以及稳定性。</li>\n<li>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>\n<ul>\n<li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>\n<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>\n</ul>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h3 id=\"序列化-反序列化\"><a href=\"#序列化-反序列化\" class=\"headerlink\" title=\"序列化&#x2F;反序列化\"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<ul>\n<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>\n<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>\n<p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p>\n<h2 id=\"Java集合\"><a href=\"#Java集合\" class=\"headerlink\" title=\"Java集合\"></a>Java集合</h2><h3 id=\"List-Set-Queue-Map区别\"><a href=\"#List-Set-Queue-Map区别\" class=\"headerlink\" title=\"List&#x2F;Set&#x2F;Queue&#x2F;Map区别\"></a>List&#x2F;Set&#x2F;Queue&#x2F;Map区别</h3><ul>\n<li>List： 存储的元素是有序的、可重复的。</li>\n<li>Set： 存储的元素不可重复的。</li>\n<li>Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li>Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>\n</ul>\n<h3 id=\"如何选用集合\"><a href=\"#如何选用集合\" class=\"headerlink\" title=\"如何选用集合?\"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p>\n<ul>\n<li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</li>\n<li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li>\n</ul>\n<h3 id=\"为什么要使用集合？\"><a href=\"#为什么要使用集合？\" class=\"headerlink\" title=\"为什么要使用集合？\"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>\n<h3 id=\"ArrayList和Array区别\"><a href=\"#ArrayList和Array区别\" class=\"headerlink\" title=\"ArrayList和Array区别\"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p>\n<ul>\n<li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li>\n<li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li>\n<li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li>\n<li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li>\n<li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li>\n</ul>\n<blockquote>\n<p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList区别\"><a href=\"#ArrayList和LinkedList区别\" class=\"headerlink\" title=\"ArrayList和LinkedList区别\"></a>ArrayList和LinkedList区别</h3><ul>\n<li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul>\n<li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li>\n<li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li>二者都是线程不安全的。</li>\n<li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li>\n<li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li>\n</ul>\n<blockquote>\n<p>项目中一般不会使用 <code>LinkedList</code>。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList插入-删除效率\"><a href=\"#ArrayList和LinkedList插入-删除效率\" class=\"headerlink\" title=\"ArrayList和LinkedList插入&#x2F;删除效率\"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p>\n<ul>\n<li>头部插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>尾部插入&#x2F;删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。<br><code>LinkedList</code></li>\n<li>头部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>尾部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要先移动到指定位置再插入和删除。</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p>\n<ul>\n<li>读多写少：大部分操作都是读取数据，写操作相对较少。</li>\n<li>不要求实时性：因为写操作需要创建数组副本，可能会有短暂的延迟。</li>\n</ul>\n<p><code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>线程安全：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li>\n<li>简化并发控制：不需要显式的同步块或锁定机制。</li>\n<li>迭代器安全：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>内存开销大：每次写操作都会创建数组副本，可能会占用较多的内存。</li>\n<li>写操作开销大：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li>\n<li>读取旧数据：在高并发场景下，可能会读取到旧的数据。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>配置类数据：如系统配置参数、常量集合等。</li>\n<li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li>\n</ul>\n<p><strong>不适用场景</strong></p>\n<ul>\n<li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li>\n<li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li>\n</ul>\n<p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p>\n<h3 id=\"HashSet-LinkedHashSet-TreeSet\"><a href=\"#HashSet-LinkedHashSet-TreeSet\" class=\"headerlink\" title=\"HashSet&#x2F;LinkedHashSet&#x2F;TreeSet\"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul>\n<li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li>\n<li>主要区别在于底层数据结构不同。<ul>\n<li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li>\n<li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>\n<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>\n</ul>\n</li>\n<li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>\n</ul>\n<h3 id=\"Map-重要\"><a href=\"#Map-重要\" class=\"headerlink\" title=\"Map(重要)\"></a>Map(重要)</h3><h3 id=\"HashMap-HashTable区别\"><a href=\"#HashMap-HashTable区别\" class=\"headerlink\" title=\"HashMap&#x2F;HashTable区别\"></a>HashMap&#x2F;HashTable区别</h3><ul>\n<li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li>\n<li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>\n<li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li>\n<li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和value，否则会报错<code>NullPointerException</code>。</li>\n<li>初始容量大小和每次扩充容量大小的不同： <ul>\n<li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li>\n<li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p>\n</blockquote>\n<h3 id=\"HashMap长度为什么是2的幂次方\"><a href=\"#HashMap长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap长度为什么是2的幂次方\"></a>HashMap长度为什么是2的幂次方</h3><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p>\n<p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p>\n<h3 id=\"HashMap-TreeMap区别\"><a href=\"#HashMap-TreeMap区别\" class=\"headerlink\" title=\"HashMap&#x2F;TreeMap区别\"></a>HashMap&#x2F;TreeMap区别</h3><ul>\n<li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li>\n<li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li>\n<li><code>HashMap</code> 的键值对允许有一个 <code>null</code> 键和多个 <code>null</code> 值，<code>TreeMap</code> 不允许有 <code>null</code> 键，但允许有 <code>null</code> 值。</li>\n<li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li>\n</ul>\n<p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>\n<h3 id=\"HashSet如何检查重复\"><a href=\"#HashSet如何检查重复\" class=\"headerlink\" title=\"HashSet如何检查重复\"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>\n<p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。</p>\n<h3 id=\"HashMap底层实现\"><a href=\"#HashMap底层实现\" class=\"headerlink\" title=\"HashMap底层实现\"></a>HashMap底层实现</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p>\n<p><code>HashMap</code> 通过 key 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p>\n<ul>\n<li>扰动函数 <code>hash()</code> 可以减少碰撞。</li>\n<li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>\n<li>“拉链法”中，数组的 index 就是通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li>\n</ul>\n<p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p>\n<ul>\n<li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li>\n<li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li>\n</ul>\n<h3 id=\"HashMap多线程扩容死循环问题\"><a href=\"#HashMap多线程扩容死循环问题\" class=\"headerlink\" title=\"HashMap多线程扩容死循环问题\"></a>HashMap多线程扩容死循环问题</h3><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>\n<p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>\n<blockquote>\n<p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p>\n</blockquote>\n<h3 id=\"HashMap为什么不支持高并发\"><a href=\"#HashMap为什么不支持高并发\" class=\"headerlink\" title=\"HashMap为什么不支持高并发\"></a>HashMap为什么不支持高并发</h3><h3 id=\"HashMap为什么线程不安全\"><a href=\"#HashMap为什么线程不安全\" class=\"headerlink\" title=\"HashMap为什么线程不安全\"></a>HashMap为什么线程不安全</h3><ul>\n<li>JDK1.7及之前版本，存在多线程扩容死循环问题，如上。</li>\n<li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。如下：</li>\n</ul>\n<p><strong>数据丢失</strong><br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>\n<blockquote>\n<p>例子：<br>线程 1,2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>\n</blockquote>\n<h3 id=\"遍历HashMap\"><a href=\"#遍历HashMap\" class=\"headerlink\" title=\"遍历HashMap\"></a>遍历HashMap</h3><p>七种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// ForEach EntrySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ForEach KeySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Integer key : map.keySet()) &#123;</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器EntrySet</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器KeySet</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(key);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 单线程</span></span><br><span class=\"line\">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 多线程</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-Hashtable区别\"><a href=\"#ConcurrentHashMap-Hashtable区别\" class=\"headerlink\" title=\"ConcurrentHashMap&#x2F;Hashtable区别\"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul>\n<li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong> 。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li>\n<li>实现线程安全的方式：<ul>\n<li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li>\n<li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li><code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConcurrentHashMap底层\"><a href=\"#ConcurrentHashMap底层\" class=\"headerlink\" title=\"ConcurrentHashMap底层\"></a>ConcurrentHashMap底层</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为**<code>Segment</code>数组+<code>HashEntry</code>数组+链表** 。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>\n<p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p>\n<p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，**<code>Node</code>数组+链表&#x2F;红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p>\n<h3 id=\"JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\"><a href=\"#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\" class=\"headerlink\" title=\"JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul>\n<li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>\n<li>Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li>\n<li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li>\n</ul>\n<h3 id=\"ConcurrentHashMap能保证复合操作的原子性吗？\"><a href=\"#ConcurrentHashMap能保证复合操作的原子性吗？\" class=\"headerlink\" title=\"ConcurrentHashMap能保证复合操作的原子性吗？\"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul>\n<li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li>\n<li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li>\n</ul>\n<h3 id=\"什么是LinkedHashMap\"><a href=\"#什么是LinkedHashMap\" class=\"headerlink\" title=\"什么是LinkedHashMap\"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代</li>\n<li>支持按照元素访问顺序排序,<em><strong>适用于封装 LRU 缓存工具</strong></em> 。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li>\n</ul>\n<blockquote>\n<p>在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n</blockquote>\n<h3 id=\"LinkedHashMap如何按照访问顺序迭代元素？\"><a href=\"#LinkedHashMap如何按照访问顺序迭代元素？\" class=\"headerlink\" title=\"LinkedHashMap如何按照访问顺序迭代元素？\"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>\n<h3 id=\"如何实现LRU缓存\"><a href=\"#如何实现LRU缓存\" class=\"headerlink\" title=\"如何实现LRU缓存\"></a>如何实现LRU缓存</h3><ul>\n<li><code>accessOrder</code> &#x3D; <code>true</code> </li>\n<li>继承<code>LinkedHashMap</code></li>\n<li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"LinkedHashMap和HashMap的区别\"><a href=\"#LinkedHashMap和HashMap的区别\" class=\"headerlink\" title=\"LinkedHashMap和HashMap的区别\"></a>LinkedHashMap和HashMap的区别</h3><ul>\n<li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li>\n<li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li>\n</ul>\n<h3 id=\"Queue-Deque区别\"><a href=\"#Queue-Deque区别\" class=\"headerlink\" title=\"Queue&#x2F;Deque区别\"></a>Queue&#x2F;Deque区别</h3><ul>\n<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li>\n<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li>\n</ul>\n<h3 id=\"ArrayDeque-LinkedList区别\"><a href=\"#ArrayDeque-LinkedList区别\" class=\"headerlink\" title=\"ArrayDeque&#x2F;LinkedList区别\"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul>\n<li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li>\n<li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li>\n<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li>\n</ul>\n<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>\n<h3 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>\n<ul>\n<li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>\n<li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>\n<li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>\n<li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>\n</ul>\n<blockquote>\n<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>\n</blockquote>\n<h3 id=\"BlockingQueue及其实现类\"><a href=\"#BlockingQueue及其实现类\" class=\"headerlink\" title=\"BlockingQueue及其实现类\"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p>\n<p><strong>实现类</strong></p>\n<ul>\n<li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>\n<li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。</li>\n<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li>\n<li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li>\n<li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li>\n<li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li>\n<li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue实现原理\"><a href=\"#ArrayBlockingQueue实现原理\" class=\"headerlink\" title=\"ArrayBlockingQueue实现原理\"></a>ArrayBlockingQueue实现原理</h3><ul>\n<li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li>\n<li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li>\n<li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li>\n</ul>\n<p>线程间的等待和唤醒具体的实现：</p>\n<ul>\n<li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li>\n<li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li>\n<li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li>\n<li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue区别\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue区别\" class=\"headerlink\" title=\"ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别\"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>\n<li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>\n<li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>\n</ul>\n<h3 id=\"DelayQueue底层\"><a href=\"#DelayQueue底层\" class=\"headerlink\" title=\"DelayQueue底层\"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>\n<p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可重入锁，实现线程安全的关键</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">//指向准备执行优先级最高的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Thread</span> <span class=\"variable\">leader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//实现多线程之间等待唤醒的交互</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>\n<p><code>leader</code> ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code> ： 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p>\n</blockquote>\n<h3 id=\"DelayQueue是否线程安全？\"><a href=\"#DelayQueue是否线程安全？\" class=\"headerlink\" title=\"DelayQueue是否线程安全？\"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>\n<h3 id=\"DelayQueue使用场景\"><a href=\"#DelayQueue使用场景\" class=\"headerlink\" title=\"DelayQueue使用场景\"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p>\n<ul>\n<li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li>\n<li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li>\n</ul>\n<h3 id=\"DelayQueue中Delayed接口的作用是什么？\"><a href=\"#DelayQueue中Delayed接口的作用是什么？\" class=\"headerlink\" title=\"DelayQueue中Delayed接口的作用是什么？\"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口),否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>\n<h3 id=\"DelayQueue-Timer-TimerTask区别\"><a href=\"#DelayQueue-Timer-TimerTask区别\" class=\"headerlink\" title=\"DelayQueue&#x2F;Timer&#x2F;TimerTask区别\"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p>\n<ul>\n<li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li>\n<li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li>\n<li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li>\n</ul>\n<h2 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程&#x2F;线程&#x2F;协程\"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href=\"https://blog.csdn.net/m0_60505735/article/details/131047046\">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href=\"https://blog.csdn.net/weixin_49199646/article/details/109210547\">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p>\n<ul>\n<li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li>\n<li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>\n<li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li>\n</ul>\n<p><strong>进程与线程的区别</strong></p>\n<ul>\n<li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li>\n<li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li>\n<li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li>\n</ul>\n<p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p>\n<p><em>进程与线程的选择</em>*</p>\n<ul>\n<li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li>\n<li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li>\n<li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li>\n<li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li>\n</ul>\n<p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p>\n<h3 id=\"Java线程和操作系统线程有何区别\"><a href=\"#Java线程和操作系统线程有何区别\" class=\"headerlink\" title=\"Java线程和操作系统线程有何区别\"></a>Java线程和操作系统线程有何区别</h3><p>现在的 Java 线程的本质其实就是操作系统的线程。</p>\n<ul>\n<li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li>\n<li>JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li>\n</ul>\n<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p>\n<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p>\n<h3 id=\"程序计数器为啥是私有的\"><a href=\"#程序计数器为啥是私有的\" class=\"headerlink\" title=\"程序计数器为啥是私有的\"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n<li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>\n</ul>\n<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>\n<h3 id=\"虚拟机栈和本地方法栈为啥是私有的\"><a href=\"#虚拟机栈和本地方法栈为啥是私有的\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈为啥是私有的\"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul>\n<li>虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>\n<li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>\n</ul>\n<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3 id=\"一句话简单了解堆和方法区\"><a href=\"#一句话简单了解堆和方法区\" class=\"headerlink\" title=\"一句话简单了解堆和方法区\"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h3 id=\"如何创建线程\"><a href=\"#如何创建线程\" class=\"headerlink\" title=\"如何创建线程\"></a>如何创建线程</h3><ul>\n<li>继承<code>Thread</code>类并重写<code>run()</code>方法</li>\n<li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li>\n<li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li>\n<li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li>\n<li>等等……</li>\n</ul>\n<p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>\n<h3 id=\"线程的生命周期和状态\"><a href=\"#线程的生命周期和状态\" class=\"headerlink\" title=\"线程的生命周期和状态\"></a>线程的生命周期和状态</h3><p>Java 线程 6 种状态：<br><code>NEW</code>： 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>： 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>\n<h3 id=\"线程上下文切换开销\"><a href=\"#线程上下文切换开销\" class=\"headerlink\" title=\"线程上下文切换开销\"></a>线程上下文切换开销</h3><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>\n<ul>\n<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>\n<li>时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n</ul>\n<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>\n<h3 id=\"Thread-sleep-方法和Object-wait-方法对比\"><a href=\"#Thread-sleep-方法和Object-wait-方法对比\" class=\"headerlink\" title=\"Thread.sleep()方法和Object.wait()方法对比\"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p>\n<ul>\n<li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁 。</li>\n<li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li>\n<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li>\n<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>\n</ul>\n<h3 id=\"锁的基本概念\"><a href=\"#锁的基本概念\" class=\"headerlink\" title=\"锁的基本概念\"></a>锁的基本概念</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p>\n<h3 id=\"Java中有哪些锁\"><a href=\"#Java中有哪些锁\" class=\"headerlink\" title=\"Java中有哪些锁\"></a>Java中有哪些锁</h3><ul>\n<li><code>synchronized</code>关键字<ul>\n<li>用于同步方法或同步代码块。</li>\n<li>基于对象锁，每个对象都有一个监视器锁。</li>\n</ul>\n</li>\n<li><code>ReentrantLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供更灵活的锁机制，相比<code>synchronized</code>，支持公平锁、非公平锁等特性。</li>\n<li>支持可重入锁，即同一个线程可以多次获取同一个锁。</li>\n</ul>\n</li>\n<li><code>ReentrantReadWriteLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供读写锁的实现，读锁共享，写锁独占。</li>\n<li>适用于读多写少的场景，提升并发性能。</li>\n</ul>\n</li>\n<li><code>StampedLock</code><ul>\n<li>在<code>java.util.concurrent.locks</code>包中提供。</li>\n<li>提供三种锁模式：写锁、悲观读锁和乐观读锁。</li>\n<li>乐观读锁在某些情况下可以避免加锁操作，提升性能。</li>\n</ul>\n</li>\n<li><code>LockSupport</code><ul>\n<li>提供基本的线程阻塞和唤醒机制。</li>\n<li>通常用于构建更高级的同步器，如<code>Semaphore</code>、<code>CountDownLatch</code>等。</li>\n</ul>\n</li>\n<li><code>Semaphore</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>用于控制同时访问特定资源的线程数量。</li>\n</ul>\n</li>\n<li><code>CountDownLatch</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>允许一个或多个线程等待一组操作完成。</li>\n</ul>\n</li>\n<li><code>CyclicBarrier</code><ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>使一组线程在到达一个共同的屏障点时被阻塞，直到所有线程都到达该点。</li>\n</ul>\n</li>\n<li>Phaser<ul>\n<li>在<code>java.util.concurrent</code>包中提供。</li>\n<li>允许多阶段的线程协作，每个阶段完成后继续下一阶段。</li>\n</ul>\n</li>\n<li><code>Atomic</code>变量<ul>\n<li>在<code>java.util.concurrent.atomic</code>包中提供。</li>\n<li>提供了一些基本类型(如<code>AtomicInteger</code>、<code>AtomicLong</code>)的原子操作，实现了无锁的线程安全。</li>\n</ul>\n</li>\n</ul>\n<p>这些锁机制可以根据具体的应用场景选择，以实现高效、安全的并发控制。</p>\n<h3 id=\"为什么wait-方法不定义在Thread中\"><a href=\"#为什么wait-方法不定义在Thread中\" class=\"headerlink\" title=\"为什么wait()方法不定义在Thread中\"></a>为什么wait()方法不定义在Thread中</h3><ul>\n<li>锁是对象级别的，每个对象都有一把锁。</li>\n<li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li>\n</ul>\n<h3 id=\"为什么sleep-方法定义在Thread中\"><a href=\"#为什么sleep-方法定义在Thread中\" class=\"headerlink\" title=\"为什么sleep()方法定义在Thread中\"></a>为什么sleep()方法定义在Thread中</h3><ul>\n<li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li>\n<li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li>\n</ul>\n<h3 id=\"sleep-如何控制当前线程沉睡\"><a href=\"#sleep-如何控制当前线程沉睡\" class=\"headerlink\" title=\"sleep()如何控制当前线程沉睡\"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p>\n<h3 id=\"可以直接调用Thread类的run方法吗\"><a href=\"#可以直接调用Thread类的run方法吗\" class=\"headerlink\" title=\"可以直接调用Thread类的run方法吗\"></a>可以直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p>\n<h3 id=\"并发-并行区别\"><a href=\"#并发-并行区别\" class=\"headerlink\" title=\"并发&#x2F;并行区别\"></a>并发&#x2F;并行区别</h3><ul>\n<li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<h3 id=\"同步-异步区别\"><a href=\"#同步-异步区别\" class=\"headerlink\" title=\"同步&#x2F;异步区别\"></a>同步&#x2F;异步区别</h3><ul>\n<li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>\n<li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li>\n</ul>\n<h3 id=\"为什么要使用多线程\"><a href=\"#为什么要使用多线程\" class=\"headerlink\" title=\"为什么要使用多线程\"></a>为什么要使用多线程</h3><ul>\n<li>线程切换和调度的成本远远小于进程。</li>\n<li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li>\n<li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li>\n<li>并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。</li>\n</ul>\n<h3 id=\"使用多线程风险\"><a href=\"#使用多线程风险\" class=\"headerlink\" title=\"使用多线程风险\"></a>使用多线程风险</h3><ul>\n<li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li>\n<li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>\n<li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li>\n<li>上下文切换：线程频繁切换，会增加系统开销。</li>\n<li>…</li>\n</ul>\n<h3 id=\"如何理解线程安全和不安全\"><a href=\"#如何理解线程安全和不安全\" class=\"headerlink\" title=\"如何理解线程安全和不安全\"></a>如何理解线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p>\n<ul>\n<li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>\n<li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>\n</ul>\n<h3 id=\"高并发存在什么问题-Java如何解决的\"><a href=\"#高并发存在什么问题-Java如何解决的\" class=\"headerlink\" title=\"高并发存在什么问题,Java如何解决的\"></a>高并发存在什么问题,Java如何解决的</h3><p><strong>高并发问题</strong></p>\n<ul>\n<li>资源竞争：多个线程竞争同一资源(如内存、文件、数据库连接等)，可能导致数据不一致、死锁等问题。</li>\n<li>死锁：多个线程在等待对方释放资源，从而相互阻塞，导致程序无法继续执行。</li>\n<li>上下文切换开销：线程之间的切换会消耗系统资源，频繁的上下文切换会降低系统性能。</li>\n<li>线程安全：确保多个线程对共享资源的操作不会导致数据不一致的问题。</li>\n<li>内存泄漏：大量创建和销毁线程，如果不合理管理，会导致内存泄漏。</li>\n<li>饥饿和公平性：某些线程可能长期得不到资源，导致饥饿问题。如何确保线程公平地获取资源也是一个挑战。</li>\n<li>负载均衡：在分布式系统中，如何将请求均衡地分配到不同的服务器，以避免某些服务器过载。</li>\n</ul>\n<p><strong>Java解决高并发问题</strong></p>\n<ul>\n<li>线程池(Thread Pool)：通过线程池管理线程的创建和销毁，减少资源消耗，提高系统性能。</li>\n<li>同步机制(Synchronization)：使用 <code>synchronized</code>关键字或显示锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争。</li>\n<li>并发工具类：如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，这些工具类可以帮助开发者更方便地实现线程间的协调和资源共享。</li>\n<li>无锁算法(Lock-Free Algorithms)：使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换开销，提高性能。</li>\n<li>CAS操作(Compare-And-Swap)：CAS是一种无锁算法，通过比较和交换操作来实现原子性。Java中的<code>Unsafe</code>类和<code>Atomic</code>包使用了CAS操作来实现无锁算法。</li>\n<li>Fork&#x2F;Join框架：用于任务拆分和并行处理，适用于大规模数据并行处理。Java 7引入了<code>ForkJoinPool</code>来支持这一框架。</li>\n<li>异步编程(Asynchronous Programming)：通过<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</li>\n</ul>\n<h3 id=\"Java如何实现高并发\"><a href=\"#Java如何实现高并发\" class=\"headerlink\" title=\"Java如何实现高并发\"></a>Java如何实现高并发</h3><p><strong>使用线程池</strong><br>线程池可以有效管理线程的创建和销毁，减少资源消耗和上下文切换开销。Java中的<code>ExecutorService</code>和<code>Executors</code>类提供了便捷的线程池实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    executor.submit(<span class=\"keyword\">new</span> <span class=\"title class_\">Task</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">executor.shutdown();</span><br></pre></td></tr></table></figure>\n<p><strong>同步机制</strong><br>使用<code>synchronized</code>关键字或者显式锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争和数据不一致问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">safeMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Critical section</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Critical section</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>并发集合类</strong><br>Java提供了线程安全的并发集合类，如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code>等，这些集合类可以简化多线程编程。</p>\n<p><strong>原子变量类</strong><br>使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换，提高性能。</p>\n<p><strong>CAS操作</strong><br>Java的<code>Atomic</code>包和<code>Unsafe</code>类使用了CAS(Compare-And-Swap)操作来实现无锁算法，从而提高并发性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">AtomicInteger</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">updated</span> <span class=\"operator\">=</span> count.compareAndSet(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>Fork&#x2F;Join框架</strong><br><code>ForkJoinPool</code>用于任务拆分和并行处理，适用于大规模数据的并行计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">pool.invoke(<span class=\"keyword\">new</span> <span class=\"title class_\">RecursiveTask</span>&lt;Void&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Void <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Task implementation</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>异步编程</strong><br>使用<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Async task</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;result&quot;</span>;</span><br><span class=\"line\">&#125;).thenAccept(result -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Process result</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用非阻塞I&#x2F;O</strong><br>在网络编程中，使用NIO(Non-blocking I&#x2F;O)实现高并发。NIO提供了选择器(<code>Selector</code>)、通道(<code>Channel</code>)和缓冲区(<code>Buffer</code>)等工具，可以实现高效的非阻塞I&#x2F;O操作。</p>\n<p><strong>使用第三方并发框架</strong><br>如Akka、RxJava、Vert.x等，它们提供了更加高级的并发和反应式编程模型。</p>\n<h3 id=\"单核CPU上运行多个线程效率一定会高吗\"><a href=\"#单核CPU上运行多个线程效率一定会高吗\" class=\"headerlink\" title=\"单核CPU上运行多个线程效率一定会高吗\"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<blockquote>\n<p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n</blockquote>\n<p>产生死锁的四个必要条件：</p>\n<ul>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"如何检测死锁\"><a href=\"#如何检测死锁\" class=\"headerlink\" title=\"如何检测死锁\"></a>如何检测死锁</h3><ul>\n<li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li>\n<li>jConsole： 可以检测死锁，查看线程的状态。</li>\n<li>jstack： 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li>\n</ul>\n<h3 id=\"如何预防和避免死锁\"><a href=\"#如何预防和避免死锁\" class=\"headerlink\" title=\"如何预防和避免死锁\"></a>如何预防和避免死锁</h3><p>破坏死锁的产生的必要条件：</p>\n<ul>\n<li>破坏请求与保持条件：一次性申请所有的资源。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ul>\n<p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong> )对资源分配进行计算评估，使其进入安全状态。</p>\n<blockquote>\n<p>安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</p>\n</blockquote>\n<h3 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<h3 id=\"为什么需要Java内存模型\"><a href=\"#为什么需要Java内存模型\" class=\"headerlink\" title=\"为什么需要Java内存模型\"></a>为什么需要Java内存模型</h3><ul>\n<li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li>\n<li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li>\n<li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li>\n</ul>\n<h3 id=\"Java内存区域和Java内存模型有什么区别\"><a href=\"#Java内存区域和Java内存模型有什么区别\" class=\"headerlink\" title=\"Java内存区域和Java内存模型有什么区别\"></a>Java内存区域和Java内存模型有什么区别</h3><ul>\n<li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li>\n<li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li>\n</ul>\n<h3 id=\"JMM是如何抽象线程和主内存之间的关系\"><a href=\"#JMM是如何抽象线程和主内存之间的关系\" class=\"headerlink\" title=\"JMM是如何抽象线程和主内存之间的关系\"></a>JMM是如何抽象线程和主内存之间的关系</h3><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。</p>\n<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li>\n<li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li>\n</ul>\n<h3 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h3><p>可见性、原子性和有序性</p>\n<ul>\n<li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li>\n<li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li>\n<li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li>\n</ul>\n<p>JMM通过上面三种属性来确保线程之间的内存一致性。</p>\n<h3 id=\"如何保证变量的可见性-volatile\"><a href=\"#如何保证变量的可见性-volatile\" class=\"headerlink\" title=\"如何保证变量的可见性(volatile)\"></a>如何保证变量的可见性(volatile)</h3><p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3 id=\"如何禁止指令重排序\"><a href=\"#如何禁止指令重排序\" class=\"headerlink\" title=\"如何禁止指令重排序\"></a>如何禁止指令重排序</h3><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p>\n<h3 id=\"volatile可以保证原子性\"><a href=\"#volatile可以保证原子性\" class=\"headerlink\" title=\"volatile可以保证原子性\"></a>volatile可以保证原子性</h3><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>\n<h3 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁&#x2F;悲观锁\"></a>乐观锁&#x2F;悲观锁</h3><ul>\n<li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul>\n<li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li>\n<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li>\n<li>悲观锁可能会存在死锁问题。</li>\n<li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>\n</ul>\n</li>\n<li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul>\n<li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li>\n<li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li>\n<li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul>\n<li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li>\n</ul>\n</li>\n<li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何实现乐观锁\"><a href=\"#如何实现乐观锁\" class=\"headerlink\" title=\"如何实现乐观锁\"></a>如何实现乐观锁</h3><ul>\n<li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li>\n<li>CAS算法：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul>\n<li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n</blockquote>\n<h3 id=\"CAS算法存在问题\"><a href=\"#CAS算法存在问题\" class=\"headerlink\" title=\"CAS算法存在问题\"></a>CAS算法存在问题</h3><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>\n<p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p>\n<p><strong>循环时间长开销大</strong><br>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p>\n<p><strong>只能保证一个共享变量的原子操作</strong><br>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p>\n<h3 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h3><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>\n<h3 id=\"JDK1-6之后synchronized的优化\"><a href=\"#JDK1-6之后synchronized的优化\" class=\"headerlink\" title=\"JDK1.6之后synchronized的优化\"></a>JDK1.6之后synchronized的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p>\n<h3 id=\"锁升级原理了解吗\"><a href=\"#锁升级原理了解吗\" class=\"headerlink\" title=\"锁升级原理了解吗\"></a>锁升级原理了解吗</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<h3 id=\"如何使用synchronized\"><a href=\"#如何使用synchronized\" class=\"headerlink\" title=\"如何使用synchronized\"></a>如何使用synchronized</h3><ul>\n<li>修饰实例方法：锁住当前实例对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰静态方法：锁住当前类的 Class 对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰代码块：锁住括号里面的对象。<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(对象) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">synchronized(类.class) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized底层原理\"><a href=\"#synchronized底层原理\" class=\"headerlink\" title=\"synchronized底层原理\"></a>synchronized底层原理</h3><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p>\n<ul>\n<li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li>\n<li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li>\n</ul>\n<p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>\n<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>\n<h3 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p>\n<p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>\n<blockquote>\n<p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p>\n</blockquote>\n<h3 id=\"AQS资源共享模式\"><a href=\"#AQS资源共享模式\" class=\"headerlink\" title=\"AQS资源共享模式\"></a>AQS资源共享模式</h3><p>AQS 支持两种资源共享方式：独占和共享。</p>\n<ul>\n<li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li>\n<li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li>\n</ul>\n<blockquote>\n<p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p>\n</blockquote>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p>\n<h3 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁&#x2F;非公平锁\"></a>公平锁&#x2F;非公平锁</h3><ul>\n<li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>\n</ul>\n<h3 id=\"synchronized和ReentrantLock有什么区别？\"><a href=\"#synchronized和ReentrantLock有什么区别？\" class=\"headerlink\" title=\"synchronized和ReentrantLock有什么区别？\"></a>synchronized和ReentrantLock有什么区别？</h3><p>两者都是可重入锁</p>\n<ul>\n<li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li>\n<li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li>\n<li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：<ul>\n<li>等待可中断 ： <code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li>\n<li>可实现公平锁： <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>\n<li>可实现选择性通知(锁可以绑定多个条件)： <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>\n</blockquote>\n<h3 id=\"可中断锁-不可中断锁\"><a href=\"#可中断锁-不可中断锁\" class=\"headerlink\" title=\"可中断锁&#x2F;不可中断锁\"></a>可中断锁&#x2F;不可中断锁</h3><ul>\n<li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li>\n<li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li>\n</ul>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>\n<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁) 。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>\n<blockquote>\n<p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p>\n</blockquote>\n<h3 id=\"共享锁-独占锁\"><a href=\"#共享锁-独占锁\" class=\"headerlink\" title=\"共享锁&#x2F;独占锁\"></a>共享锁&#x2F;独占锁</h3><ul>\n<li>共享锁：一把锁可以被多个线程同时获得。</li>\n<li>独占锁：一把锁只能被一个线程获得。</li>\n</ul>\n<h3 id=\"线程持有读锁还能获取写锁吗\"><a href=\"#线程持有读锁还能获取写锁吗\" class=\"headerlink\" title=\"线程持有读锁还能获取写锁吗\"></a>线程持有读锁还能获取写锁吗</h3><ul>\n<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>\n<li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li>\n</ul>\n<h3 id=\"读锁为什么不能升级为写锁\"><a href=\"#读锁为什么不能升级为写锁\" class=\"headerlink\" title=\"读锁为什么不能升级为写锁\"></a>读锁为什么不能升级为写锁</h3><ul>\n<li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li>\n<li>可能会有死锁问题发生。</li>\n</ul>\n<h3 id=\"StampedLock\"><a href=\"#StampedLock\" class=\"headerlink\" title=\"StampedLock\"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p>\n<p>提供三种访问模式：</p>\n<ul>\n<li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。</li>\n<li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。</li>\n<li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"ThreadLocal原理\"><a href=\"#ThreadLocal原理\" class=\"headerlink\" title=\"ThreadLocal原理\"></a>ThreadLocal原理</h3><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p>\n<blockquote>\n<p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p>\n</blockquote>\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>\n<p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>\n<blockquote>\n<p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p>\n</blockquote>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3 id=\"为什么用线程池\"><a href=\"#为什么用线程池\" class=\"headerlink\" title=\"为什么用线程池\"></a>为什么用线程池</h3><ul>\n<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<blockquote>\n<p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<h3 id=\"创建线程池的方式\"><a href=\"#创建线程池的方式\" class=\"headerlink\" title=\"创建线程池的方式\"></a>创建线程池的方式</h3><ul>\n<li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li>\n<li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul>\n<li><code>FixedThreadPool</code>：固定大小的线程池。</li>\n<li><code>SingleThreadPool</code>：只有一个线程的线程池。</li>\n<li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li>\n<li><code>ScheduledThreadPool</code>：定时任务的线程池。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么不推荐使用内置线程池\"><a href=\"#为什么不推荐使用内置线程池\" class=\"headerlink\" title=\"为什么不推荐使用内置线程池\"></a>为什么不推荐使用内置线程池</h3><ul>\n<li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li>\n<li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor参数\"><a href=\"#ThreadPoolExecutor参数\" class=\"headerlink\" title=\"ThreadPoolExecutor参数\"></a>ThreadPoolExecutor参数</h3><p>3 个最重要的参数：</p>\n<ul>\n<li><code>corePoolSize</code> ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><code>maximumPoolSize</code> ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><code>workQueue</code>： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>其他常见参数 ：</p>\n<ul>\n<li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li>\n<li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><code>threadFactory</code> ：<code>executor</code> 创建新线程的时候会用到。</li>\n<li><code>handler</code> ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li>\n</ul>\n<h3 id=\"线程池的拒绝策略\"><a href=\"#线程池的拒绝策略\" class=\"headerlink\" title=\"线程池的拒绝策略\"></a>线程池的拒绝策略</h3><ul>\n<li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li>\n<li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li>\n<li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li>\n<li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy策略风险及解决方案\"><a href=\"#CallerRunsPolicy策略风险及解决方案\" class=\"headerlink\" title=\"CallerRunsPolicy策略风险及解决方案\"></a>CallerRunsPolicy策略风险及解决方案</h3><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li>\n<li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li>\n</ol>\n<h3 id=\"线程池常用阻塞队列\"><a href=\"#线程池常用阻塞队列\" class=\"headerlink\" title=\"线程池常用阻塞队列\"></a>线程池常用阻塞队列</h3><ul>\n<li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li>\n<li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3 id=\"线程池处理任务流程\"><a href=\"#线程池处理任务流程\" class=\"headerlink\" title=\"线程池处理任务流程\"></a>线程池处理任务流程</h3><ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li>\n</ol>\n<h3 id=\"线程池中线程异常后销毁还是复用？\"><a href=\"#线程池中线程异常后销毁还是复用？\" class=\"headerlink\" title=\"线程池中线程异常后销毁还是复用？\"></a>线程池中线程异常后销毁还是复用？</h3><p>两种情况：</p>\n<ul>\n<li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li>\n<li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li>\n</ul>\n<h3 id=\"如何设定线程池大小\"><a href=\"#如何设定线程池大小\" class=\"headerlink\" title=\"如何设定线程池大小\"></a>如何设定线程池大小</h3><ul>\n<li>CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li>\n<li>I&#x2F;O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I&#x2F;O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。</li>\n</ul>\n<h3 id=\"如何设计一个根据任务优先级执行的线程池\"><a href=\"#如何设计一个根据任务优先级执行的线程池\" class=\"headerlink\" title=\"如何设计一个根据任务优先级执行的线程池\"></a>如何设计一个根据任务优先级执行的线程池</h3><ul>\n<li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li>\n<li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li>\n</ul>\n<p>这样还存在一些问题：</p>\n<ul>\n<li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul>\n<li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 &#96;false 。</li>\n</ul>\n</li>\n<li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul>\n<li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异步调用Future类\"><a href=\"#异步调用Future类\" class=\"headerlink\" title=\"异步调用Future类\"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V 代表了Future执行的任务返回值的类型</span><br><span class=\"line\">public interface Future&lt;V&gt; &#123;</span><br><span class=\"line\">    // 取消任务执行，成功取消返回 true，否则返回 false</span><br><span class=\"line\">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\">    // 判断任务是否被取消</span><br><span class=\"line\">    boolean isCancelled();</span><br><span class=\"line\">    // 判断任务是否已经执行完成</span><br><span class=\"line\">    boolean isDone();</span><br><span class=\"line\">    // 获取任务执行结果</span><br><span class=\"line\">    V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\">    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br><span class=\"line\">    V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">        throws InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Callable和Future关系\"><a href=\"#Callable和Future关系\" class=\"headerlink\" title=\"Callable和Future关系\"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p>\n<ul>\n<li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li>\n<li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li>\n</ul>\n<h3 id=\"CompletableFuture类有什么用？\"><a href=\"#CompletableFuture类有什么用？\" class=\"headerlink\" title=\"CompletableFuture类有什么用？\"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p>\n<h3 id=\"CompletableFuture类异步调用实现\"><a href=\"#CompletableFuture类异步调用实现\" class=\"headerlink\" title=\"CompletableFuture类异步调用实现\"></a>CompletableFuture类异步调用实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟一个长时间运行的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">// 休眠2秒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务完成&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class=\"line\">        future.thenAccept(result -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 主线程继续执行其他操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主线程继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞主线程，直到异步任务完成（可选）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> future.get();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"虚拟线程\"><a href=\"#虚拟线程\" class=\"headerlink\" title=\"虚拟线程\"></a>虚拟线程</h3><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p>\n<p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>\n<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li>\n<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>\n</ul>\n<p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p>\n<p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream/Reader</code>： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream/Writer</code>： 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h3 id=\"Java为什么要分字节流和字符流\"><a href=\"#Java为什么要分字节流和字符流\" class=\"headerlink\" title=\"Java为什么要分字节流和字符流\"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p>\n<ul>\n<li>字符流自动处理字符编码问题，非常适合文本数据；</li>\n<li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li>\n</ul>\n<h3 id=\"字节流和字符流区别\"><a href=\"#字节流和字符流区别\" class=\"headerlink\" title=\"字节流和字符流区别\"></a>字节流和字符流区别</h3><ul>\n<li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li>\n<li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li>\n<li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li>\n</ul>\n<h3 id=\"IO设计模式总结\"><a href=\"#IO设计模式总结\" class=\"headerlink\" title=\"IO设计模式总结\"></a>IO设计模式总结</h3><ul>\n<li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li>\n<li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li>\n<li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>\n<li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li>\n</ul>\n<h3 id=\"装饰器模式和适配器模式区别\"><a href=\"#装饰器模式和适配器模式区别\" class=\"headerlink\" title=\"装饰器模式和适配器模式区别\"></a>装饰器模式和适配器模式区别</h3><ul>\n<li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li>\n<li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li>\n</ul>\n<h3 id=\"3种常见的IO模型\"><a href=\"#3种常见的IO模型\" class=\"headerlink\" title=\"3种常见的IO模型\"></a>3种常见的IO模型</h3><ul>\n<li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul>\n<li>优点：编程简单，代码易于理解。</li>\n<li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li>\n</ul>\n</li>\n<li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul>\n<li>优点：单线程可以处理多个连接，提高并发性能。</li>\n<li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li>\n</ul>\n</li>\n<li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul>\n<li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li>\n<li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h3><p>Java内存区域&#x2F;Java虚拟机内存 通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p>\n<p>线程私有的内存区域包括：</p>\n<ul>\n<li><strong>程序计数器</strong>：<ul>\n<li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li>\n<li>如果正在执行的是本地方法，这个计数器是未指定值(undefined)。</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：<ul>\n<li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li>\n<li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li>\n</ul>\n</li>\n<li><strong>本地方法栈</strong>：<ul>\n<li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li>\n<li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li>\n</ul>\n</li>\n</ul>\n<p>线程共享的内存区域包括：</p>\n<ul>\n<li><strong>堆</strong>：<ul>\n<li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li>\n<li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li>\n<li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul>\n<li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>方法区</strong>：<ul>\n<li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n<li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li>\n</ul>\n</li>\n<li><strong>运行时常量池</strong>：<ul>\n<li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li>\n<li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li>\n</ul>\n</li>\n</ul>\n<p>本地内存：</p>\n<ul>\n<li>直接内存：<ul>\n<li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li>\n<li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li>\n<li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li>\n</ul>\n</li>\n</ul>\n<p><strong>内存模型与内存管理</strong></p>\n<ul>\n<li>**内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li>\n<li>**垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li>\n</ul>\n<p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p>\n<h3 id=\"成员变量-全局变量-局部变量存放在哪里\"><a href=\"#成员变量-全局变量-局部变量存放在哪里\" class=\"headerlink\" title=\"成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里\"></a>成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里</h3><ul>\n<li>成员变量(实例变量)存储在堆内存中，每个对象都有自己的一份成员变量。</li>\n<li>静态变量(类变量)存储在方法区(或元空间)中，是类级别的变量，共享给所有实例。</li>\n<li>局部变量存储在栈内存中，属于方法调用帧的一部分。</li>\n</ul>\n<h3 id=\"对象的创建过程-5步\"><a href=\"#对象的创建过程-5步\" class=\"headerlink\" title=\"对象的创建过程(5步)\"></a>对象的创建过程(5步)</h3><ol>\n<li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>\n<li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>\n<li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>\n<li>执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域： </p>\n<ul>\n<li>对象头(<code>Header</code>)： <ul>\n<li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li>\n<li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n</li>\n<li>实例数据(<code>Instance Data</code>)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>\n<li>对齐填充(<code>Padding</code>)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li>\n</ul>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>\n<ul>\n<li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li>\n<li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li>\n</ul>\n<p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<h3 id=\"垃圾回收机制✅\"><a href=\"#垃圾回收机制✅\" class=\"headerlink\" title=\"垃圾回收机制✅\"></a>垃圾回收机制✅</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p>\n<p><strong>堆空间结构</strong><br>堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p>\n<p><strong>内存分配和回收原则</strong></p>\n<ul>\n<li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li>\n<li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li>\n</ul>\n<p>垃圾回收的基本步骤分两步：</p>\n<ul>\n<li>查找内存中不再使用的对象(GC判断策略)</li>\n<li>释放这些对象占用的内存(GC收集算法)</li>\n</ul>\n<p><strong>死亡对象&#x2F;GC判断策略</strong></p>\n<ul>\n<li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul>\n<li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n</ul>\n</li>\n<li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul>\n<li>这些对象可以用作 GC Roots： <ul>\n<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n<li>JNI(Java Native Interface)引用的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p>\n</blockquote>\n<p><strong>垃圾回收算法</strong></p>\n<ul>\n<li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul>\n<li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li>\n</ul>\n</li>\n<li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul>\n<li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li>\n</ul>\n</li>\n<li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul>\n<li>问题：整理的过程效率也不高。</li>\n</ul>\n</li>\n<li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li>\n</ul>\n<p><strong>垃圾回收器</strong><br>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20： G1(Garbage-First)收集器</p>\n<ul>\n<li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。</li>\n<li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。</li>\n<li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。</li>\n<li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。</li>\n<li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。</li>\n<li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。</li>\n<li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。</li>\n<li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。</li>\n</ul>\n<blockquote>\n<p>HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<ul>\n<li>部分收集 (<code>Partial GC</code>)：<ul>\n<li>新生代收集(Minor GC &#x2F; Young GC)：只对新生代进行垃圾收集；</li>\n<li>老年代收集(Major GC &#x2F; Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>\n</ul>\n</blockquote>\n<h3 id=\"为什么要进行垃圾回收\"><a href=\"#为什么要进行垃圾回收\" class=\"headerlink\" title=\"为什么要进行垃圾回收\"></a>为什么要进行垃圾回收</h3><ul>\n<li><strong>防止内存泄漏</strong>：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li>\n<li><strong>提高开发效率</strong>：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li>\n<li><strong>系统性能和稳定性</strong>：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li>\n</ul>\n<h3 id=\"强引用-软引用-弱引用-虚引用✅\"><a href=\"#强引用-软引用-弱引用-虚引用✅\" class=\"headerlink\" title=\"强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅\"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅</h3><p><a href=\"https://blog.csdn.net/u013718071/article/details/134789666\">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p>\n<ul>\n<li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li>\n<li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li>\n<li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li>\n<li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li>\n</ul>\n<p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p>\n<h3 id=\"如何判断一个类是无用的\"><a href=\"#如何判断一个类是无用的\" class=\"headerlink\" title=\"如何判断一个类是无用的\"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p>\n<h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p>\n<p>其中验证、准备、解析 3 部分统称为连接。</p>\n<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p>\n<p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流。</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>\n</ol>\n<blockquote>\n<p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p>\n</blockquote>\n<p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul>\n<li>如验证类是否有父类</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul>\n<li>如验证函数的参数是否正确</li>\n</ul>\n</li>\n<li>符号引用验证：确保解析动作能正确执行。<ul>\n<li>如验证该类要使用的其他类、方法是否存在。</li>\n</ul>\n</li>\n</ol>\n<p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p>\n<ul>\n<li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>\n<li>初始值是数据类型的默认值，如 0、null 等。</li>\n</ul>\n<p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p>\n<p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>\n<h3 id=\"类卸载\"><a href=\"#类卸载\" class=\"headerlink\" title=\"类卸载\"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p>\n<p>卸载类需要满足 3 个要求：</p>\n<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n<p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p>\n<blockquote>\n<p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p>\n</blockquote>\n<p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p>\n<p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p>\n<p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p>\n"},{"title":"RNN/LSTM/GRU/GCN","keywords":["算法"],"description":"多智能体强化学习的算法和思路总结","abbrlink":17765,"date":"2023-12-21T11:51:33.000Z","updated":"2023-12-21T11:51:33.000Z","top_img":"https://s2.loli.net/2024/06/27/Z8pDimra7ugnHkv.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/3uoiqZOIw6CPygm.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。\n\n> 参考：https://zhuanlan.zhihu.com/p/587276701\n> 参考：https://zhuanlan.zhihu.com/p/605750441\n\n## 循环神经网络RNN\n传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。\n\n由此诞生了RNN。\n\n循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。\n\n![img_1.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_1.png)\n\n```\nx 输入层 向量\nU 输入层到隐藏层的 权重矩阵\ns 隐藏层 向量\nV 隐藏层到输出层的 权重矩阵\no 输出层 向量\nW 上一次隐藏层的值作为这一次输入的权重 权重矩阵\n```\n循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。\n\n![img_2.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_2.png)\n\n\n具体的抽象图：\n![img.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg.png)\n\n## 长短期记忆网络LSTM\n\n长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。\n\n![img_3.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_3.png)\n(左：RNN，右：LSTM)\n\n\n\n","source":"_posts/RNN-LSTM-GRU-GCN.md","raw":"---\ntitle: RNN/LSTM/GRU/GCN\ntags:\n  - 算法\ncategories:\n  - 算法\nkeywords:\n  - 算法\ndescription: 多智能体强化学习的算法和思路总结\nabbrlink: 17765\ndate: 2023-12-21 19:51:33\nupdated: 2023-12-21 19:51:33\ntop_img: https://s2.loli.net/2024/06/27/Z8pDimra7ugnHkv.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/3uoiqZOIw6CPygm.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。\n\n> 参考：https://zhuanlan.zhihu.com/p/587276701\n> 参考：https://zhuanlan.zhihu.com/p/605750441\n\n## 循环神经网络RNN\n传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。\n\n由此诞生了RNN。\n\n循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。\n\n![img_1.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_1.png)\n\n```\nx 输入层 向量\nU 输入层到隐藏层的 权重矩阵\ns 隐藏层 向量\nV 隐藏层到输出层的 权重矩阵\no 输出层 向量\nW 上一次隐藏层的值作为这一次输入的权重 权重矩阵\n```\n循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。\n\n![img_2.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_2.png)\n\n\n具体的抽象图：\n![img.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg.png)\n\n## 长短期记忆网络LSTM\n\n长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。\n\n![img_3.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_3.png)\n(左：RNN，右：LSTM)\n\n\n\n","slug":"RNN-LSTM-GRU-GCN","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1n000br7gnfu8fe9o1","content":"<blockquote>\n<p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/587276701\">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href=\"https://zhuanlan.zhihu.com/p/605750441\">https://zhuanlan.zhihu.com/p/605750441</a></p>\n</blockquote>\n<h2 id=\"循环神经网络RNN\"><a href=\"#循环神经网络RNN\" class=\"headerlink\" title=\"循环神经网络RNN\"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p>\n<p>由此诞生了RNN。</p>\n<p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_1.png\" alt=\"img_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x 输入层 向量</span><br><span class=\"line\">U 输入层到隐藏层的 权重矩阵</span><br><span class=\"line\">s 隐藏层 向量</span><br><span class=\"line\">V 隐藏层到输出层的 权重矩阵</span><br><span class=\"line\">o 输出层 向量</span><br><span class=\"line\">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure>\n<p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_2.png\" alt=\"img_2.png\"></p>\n<p>具体的抽象图：<br><img src=\"/../image/RNN-LSTM-GRU-GCN/img.png\" alt=\"img.png\"></p>\n<h2 id=\"长短期记忆网络LSTM\"><a href=\"#长短期记忆网络LSTM\" class=\"headerlink\" title=\"长短期记忆网络LSTM\"></a>长短期记忆网络LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_3.png\" alt=\"img_3.png\"><br>(左：RNN，右：LSTM)</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/587276701\">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href=\"https://zhuanlan.zhihu.com/p/605750441\">https://zhuanlan.zhihu.com/p/605750441</a></p>\n</blockquote>\n<h2 id=\"循环神经网络RNN\"><a href=\"#循环神经网络RNN\" class=\"headerlink\" title=\"循环神经网络RNN\"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p>\n<p>由此诞生了RNN。</p>\n<p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_1.png\" alt=\"img_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x 输入层 向量</span><br><span class=\"line\">U 输入层到隐藏层的 权重矩阵</span><br><span class=\"line\">s 隐藏层 向量</span><br><span class=\"line\">V 隐藏层到输出层的 权重矩阵</span><br><span class=\"line\">o 输出层 向量</span><br><span class=\"line\">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure>\n<p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_2.png\" alt=\"img_2.png\"></p>\n<p>具体的抽象图：<br><img src=\"/../image/RNN-LSTM-GRU-GCN/img.png\" alt=\"img.png\"></p>\n<h2 id=\"长短期记忆网络LSTM\"><a href=\"#长短期记忆网络LSTM\" class=\"headerlink\" title=\"长短期记忆网络LSTM\"></a>长短期记忆网络LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_3.png\" alt=\"img_3.png\"><br>(左：RNN，右：LSTM)</p>\n"},{"title":"Hello World","abbrlink":16107,"date":"2018-01-04T16:00:00.000Z","updated":"2023-09-13T16:10:00.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - hexo\n  - 教程\ncategories:\n  - hexo\nabbrlink: 16107\ndate: 2018-01-05 00:00:00\nupdated: 2023-09-14 00:10:00\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1o000fr7gnfzla2loa","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"react技巧","keywords":["react"],"description":"写代码的时候对react-native使用的一些技巧","abbrlink":56292,"date":"2023-10-07T07:03:23.000Z","updated":"2023-10-07T07:30:23.000Z","top_img":"https://s2.loli.net/2024/02/06/lhsVBAGIouNxRUa.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/u1DMChx86N93wPR.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：[casdoor-app](https://github.com/cwp0/casdoor-app)\n\n> 后面如果做react的话可能也会做一些总结，到时候再加。\n\n# react-native\n\n## React Context\n\n用于在不同的组件中或者 `js` 文件中共享同一个数据。\n\n使用方法：\n\n例如要共享 `userInfo`\n\n1. 在应用程序中创建一个 `React Context`，用于共享 `userInfo`。\n\n   `UserContext.js`\n\n    ```jsx\n    import React from \"react\";\n    \n    const UserContext = React.createContext();\n    export const UserProvider = UserContext.Provider;\n    export const UserConsumer = UserContext.Consumer;\n    export default UserContext;\n    ```\n\n\n1. 在 `App.js` 中使用 **`UserProvider`** 包裹应用程序\n\n   注意这里要设置需要共享的数据 `value={{userInfo, setUserInfo}}`\n\n    ```jsx\n    import * as React from \"react\";\n    import {PaperProvider} from \"react-native-paper\";\n    import NavigationBar from \"./NavigationBar\";\n    import {NavigationContainer} from \"@react-navigation/native\";\n    import Header from \"./Header\";\n    import {UserProvider} from \"./UserContext\";\n    \n    const App = () => {\n      const [userInfo, setUserInfo] = React.useState(null);\n      return (\n        <UserProvider value={{userInfo, setUserInfo}} >\n          <NavigationContainer>\n            <PaperProvider>\n              <Header />\n              <NavigationBar />\n            </PaperProvider>\n          </NavigationContainer>\n        </UserProvider>\n      );\n    };\n    export default App;\n    ```\n\n\n1. 在其他组件中，通过导入 `UserContext.js` 进行使用共享的数据。\n\n   注意：声明新的 `React.useContext`的时候需要用花括号。\n\n   `Header.js`\n\n    ```jsx\n    import * as React from \"react\";\n    import {Appbar, Avatar, Button, Menu, Text} from \"react-native-paper\";\n    import UserContext from \"./UserContext\";\n    import {View} from \"react-native\";\n    import CasdoorLoginPage, {CasdoorLogout} from \"./CasdoorLoginPage\";\n    \n    const Header = () => {\n      const {userInfo, setUserInfo} = React.useContext(UserContext);\n      const [showLoginPage, setShowLoginPage] = React.useState(false);\n      const [menuVisible, setMenuVisible] = React.useState(false);\n      const openMenu = () => setMenuVisible(true);\n      const closeMenu = () => setMenuVisible(false);\n      const handleMenuLogoutClicked = () => {\n        handleCasdoorLogout();\n        closeMenu();\n      };\n    \n      const handleCasdoorLogin = () => {\n        setShowLoginPage(true);\n      };\n      const handleCasdoorLogout = () => {\n        CasdoorLogout();\n        setUserInfo(null);\n      };\n      const handleHideLoginPage = () => {\n        setShowLoginPage(false);\n      };\n      return (\n        <View>\n          <Appbar.Header style={{height: 40}}>\n            <Appbar.Content title=\"Casdoor\" />\n            <Menu\n              visible={menuVisible}\n              anchor={\n                <Button\n                  style={{marginRight: 10, backgroundColor: \"transparent\", height: 40}}\n                  onPress={userInfo === null ? handleCasdoorLogin : openMenu}\n                >\n                  {\n                    userInfo === null ?\n                      null :\n                      <Avatar.Image\n                        size={32}\n                        source={{uri: userInfo.avatar}}\n                        style={{marginRight: 10, backgroundColor: \"transparent\"}}\n                      />\n                  }\n                  <Text style={{marginRight: 10}} variant=\"titleMedium\">\n                    {userInfo === null ? \"Login\" : userInfo.name}\n                  </Text>\n                </Button>\n              }\n              onDismiss={closeMenu}\n            >\n              <Menu.Item onPress={() => handleMenuLogoutClicked()} title=\"Logout\" />\n            </Menu>\n          </Appbar.Header>\n          {showLoginPage && <CasdoorLoginPage onWebviewClose={handleHideLoginPage} />}\n        </View>\n      );\n    };\n    \n    export default Header;\n    ```\n\n\n## 子组件使用父组件的函数等参数\n\n在父组件中：\n\n定义好相关函数及变量，将参数传递给子组件。\n\n```jsx\nconst [placeholder, setPlaceholder] = React.useState(\"\");\n\nconst closeEditAccountModal = () => {\n    setShowEditAccountModal(false);\n};\n\nconst onAccountEdit = (accountDescp) => {\n    const accountToEdit = accountList.find(account => account.getEditStatus() === true);\n    if (accountToEdit) {\n      accountToEdit.setTitle(accountDescp);\n    }\n    setPlaceholder(\"\");\n    closeEditAccountModal();\n}\n\n<EditAccountDetails onClose={closeEditAccountModal} onEdit={onAccountEdit} placeholder={placeholder} />\n```\n\n在子组件中：\n\n添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。\n\n```jsx\nimport React, {useState} from \"react\";\nimport {Text, TextInput, View} from \"react-native\";\nimport {Button, IconButton} from \"react-native-paper\";\nimport PropTypes from \"prop-types\";\n\nexport default function EnterAccountDetails({onClose, onEdit, placeholder}) {\n  EnterAccountDetails.propTypes = {\n    onClose: PropTypes.func.isRequired,\n    onEdit: PropTypes.func.isRequired,\n    placeholder: PropTypes.string.isRequired,\n  };\n\n  const [description, setDescription] = useState(\"\");\n\n  const handleConfirm = () => {\n    onEdit(description);\n  };\n  return (\n    <View style={{flex: 1, justifyContent: \"center\", alignItems: \"center\"}}>\n      <Text style={{fontSize: 24, marginBottom: 5}}>Enter new description</Text>\n      <View style={{flexDirection: \"row\", alignItems: \"center\"}}>\n        <IconButton icon=\"account-details\" size={35} />\n        <TextInput\n          placeholder={placeholder}\n          value={description}\n          onChangeText={(text) => setDescription(text)}\n          style={{borderWidth: 3, borderColor: \"white\", margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: \"gray\", paddingLeft: 10}}\n        />\n      </View>\n      <Button\n        style={{\n          backgroundColor: \"#E6DFF3\",\n          borderRadius: 5,\n          margin: 10,\n          alignItems: \"center\",\n          position: \"absolute\",\n          top: 160,\n          width: 300,\n        }}\n        onPress={handleConfirm}\n      >\n        <Text style={{fontSize: 18, width: 280}}>Confirm</Text>\n      </Button>\n      <IconButton icon={\"close\"} size={30} onPress={onClose} style={{position: \"absolute\", top: 5, right: 5}} />\n    </View>\n  );\n}\n```\n\n## 父组件使用自组件的函数等参数\n\n在子组件中：\n\n将父组件要使用的函数导出：\n\n```jsx\nimport React, {useEffect} from \"react\";\nimport {WebView} from \"react-native-webview\";\nimport {View} from \"react-native\";\nimport {Portal} from \"react-native-paper\";\nimport CasdoorSdkConfig from \"./CasdoorSdkConfig\";\nimport SDK from \"casdoor-react-native-sdk\";\nimport UserContext from \"./UserContext\";\nimport PropTypes from \"prop-types\";\n// import {LogBox} from \"react-native\";\n// LogBox.ignoreAllLogs();\nconst sdk = new SDK(CasdoorSdkConfig);\n\nconst CasdoorLoginPage = ({onWebviewClose}) => {\n  CasdoorLoginPage.propTypes = {\n    onWebviewClose: PropTypes.func.isRequired,\n  };\n  const [casdoorLoginURL, setCasdoorLoginURL] = React.useState(\"\");\n  const {setUserInfo} = React.useContext(UserContext);\n  const getCasdoorSignInUrl = async() => {\n    const signinUrl = await sdk.getSigninUrl();\n    setCasdoorLoginURL(signinUrl);\n  };\n\n  useEffect(() => {\n    getCasdoorSignInUrl();\n  }, []);\n\n  const onNavigationStateChange = async(navState) => {\n    if (navState.url.startsWith(CasdoorSdkConfig.redirectPath)) {\n      onWebviewClose();\n      const token = await sdk.getAccessToken(navState.url);\n      const userInfo = sdk.JwtDecode(token);\n      setUserInfo(userInfo);\n    }\n  };\n\n  return (\n    <Portal>\n      <View style={{flex: 1}}>\n        {casdoorLoginURL !== \"\" && (\n          <WebView\n            source={{uri: casdoorLoginURL}}\n            onNavigationStateChange={onNavigationStateChange}\n            style={{flex: 1}}\n            mixedContentMode=\"always\"\n            javaScriptEnabled={true}\n          />\n        )}\n      </View>\n    </Portal>\n  );\n};\n\nexport const CasdoorLogout = () => {\n  sdk.clearState();\n};\nexport default CasdoorLoginPage;\n```\n\n在父组件中：\n\n导入子组件及其导出的函数，注意导出的方式，导出的组件直接 `import` ，导出的组件的函数要使用花括号来包裹。\n","source":"_posts/react技巧.md","raw":"---\ntitle: react技巧\ntags:\n  - 移动端\n  - 前端\n  - react\n  - react-native\ncategories:\n  - react\nkeywords:\n  - react\ndescription: 写代码的时候对react-native使用的一些技巧\nabbrlink: 56292\ndate: 2023-10-07 15:03:23\nupdated: 2023-10-07 15:30:23\ntop_img: https://s2.loli.net/2024/02/06/lhsVBAGIouNxRUa.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/u1DMChx86N93wPR.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：[casdoor-app](https://github.com/cwp0/casdoor-app)\n\n> 后面如果做react的话可能也会做一些总结，到时候再加。\n\n# react-native\n\n## React Context\n\n用于在不同的组件中或者 `js` 文件中共享同一个数据。\n\n使用方法：\n\n例如要共享 `userInfo`\n\n1. 在应用程序中创建一个 `React Context`，用于共享 `userInfo`。\n\n   `UserContext.js`\n\n    ```jsx\n    import React from \"react\";\n    \n    const UserContext = React.createContext();\n    export const UserProvider = UserContext.Provider;\n    export const UserConsumer = UserContext.Consumer;\n    export default UserContext;\n    ```\n\n\n1. 在 `App.js` 中使用 **`UserProvider`** 包裹应用程序\n\n   注意这里要设置需要共享的数据 `value={{userInfo, setUserInfo}}`\n\n    ```jsx\n    import * as React from \"react\";\n    import {PaperProvider} from \"react-native-paper\";\n    import NavigationBar from \"./NavigationBar\";\n    import {NavigationContainer} from \"@react-navigation/native\";\n    import Header from \"./Header\";\n    import {UserProvider} from \"./UserContext\";\n    \n    const App = () => {\n      const [userInfo, setUserInfo] = React.useState(null);\n      return (\n        <UserProvider value={{userInfo, setUserInfo}} >\n          <NavigationContainer>\n            <PaperProvider>\n              <Header />\n              <NavigationBar />\n            </PaperProvider>\n          </NavigationContainer>\n        </UserProvider>\n      );\n    };\n    export default App;\n    ```\n\n\n1. 在其他组件中，通过导入 `UserContext.js` 进行使用共享的数据。\n\n   注意：声明新的 `React.useContext`的时候需要用花括号。\n\n   `Header.js`\n\n    ```jsx\n    import * as React from \"react\";\n    import {Appbar, Avatar, Button, Menu, Text} from \"react-native-paper\";\n    import UserContext from \"./UserContext\";\n    import {View} from \"react-native\";\n    import CasdoorLoginPage, {CasdoorLogout} from \"./CasdoorLoginPage\";\n    \n    const Header = () => {\n      const {userInfo, setUserInfo} = React.useContext(UserContext);\n      const [showLoginPage, setShowLoginPage] = React.useState(false);\n      const [menuVisible, setMenuVisible] = React.useState(false);\n      const openMenu = () => setMenuVisible(true);\n      const closeMenu = () => setMenuVisible(false);\n      const handleMenuLogoutClicked = () => {\n        handleCasdoorLogout();\n        closeMenu();\n      };\n    \n      const handleCasdoorLogin = () => {\n        setShowLoginPage(true);\n      };\n      const handleCasdoorLogout = () => {\n        CasdoorLogout();\n        setUserInfo(null);\n      };\n      const handleHideLoginPage = () => {\n        setShowLoginPage(false);\n      };\n      return (\n        <View>\n          <Appbar.Header style={{height: 40}}>\n            <Appbar.Content title=\"Casdoor\" />\n            <Menu\n              visible={menuVisible}\n              anchor={\n                <Button\n                  style={{marginRight: 10, backgroundColor: \"transparent\", height: 40}}\n                  onPress={userInfo === null ? handleCasdoorLogin : openMenu}\n                >\n                  {\n                    userInfo === null ?\n                      null :\n                      <Avatar.Image\n                        size={32}\n                        source={{uri: userInfo.avatar}}\n                        style={{marginRight: 10, backgroundColor: \"transparent\"}}\n                      />\n                  }\n                  <Text style={{marginRight: 10}} variant=\"titleMedium\">\n                    {userInfo === null ? \"Login\" : userInfo.name}\n                  </Text>\n                </Button>\n              }\n              onDismiss={closeMenu}\n            >\n              <Menu.Item onPress={() => handleMenuLogoutClicked()} title=\"Logout\" />\n            </Menu>\n          </Appbar.Header>\n          {showLoginPage && <CasdoorLoginPage onWebviewClose={handleHideLoginPage} />}\n        </View>\n      );\n    };\n    \n    export default Header;\n    ```\n\n\n## 子组件使用父组件的函数等参数\n\n在父组件中：\n\n定义好相关函数及变量，将参数传递给子组件。\n\n```jsx\nconst [placeholder, setPlaceholder] = React.useState(\"\");\n\nconst closeEditAccountModal = () => {\n    setShowEditAccountModal(false);\n};\n\nconst onAccountEdit = (accountDescp) => {\n    const accountToEdit = accountList.find(account => account.getEditStatus() === true);\n    if (accountToEdit) {\n      accountToEdit.setTitle(accountDescp);\n    }\n    setPlaceholder(\"\");\n    closeEditAccountModal();\n}\n\n<EditAccountDetails onClose={closeEditAccountModal} onEdit={onAccountEdit} placeholder={placeholder} />\n```\n\n在子组件中：\n\n添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。\n\n```jsx\nimport React, {useState} from \"react\";\nimport {Text, TextInput, View} from \"react-native\";\nimport {Button, IconButton} from \"react-native-paper\";\nimport PropTypes from \"prop-types\";\n\nexport default function EnterAccountDetails({onClose, onEdit, placeholder}) {\n  EnterAccountDetails.propTypes = {\n    onClose: PropTypes.func.isRequired,\n    onEdit: PropTypes.func.isRequired,\n    placeholder: PropTypes.string.isRequired,\n  };\n\n  const [description, setDescription] = useState(\"\");\n\n  const handleConfirm = () => {\n    onEdit(description);\n  };\n  return (\n    <View style={{flex: 1, justifyContent: \"center\", alignItems: \"center\"}}>\n      <Text style={{fontSize: 24, marginBottom: 5}}>Enter new description</Text>\n      <View style={{flexDirection: \"row\", alignItems: \"center\"}}>\n        <IconButton icon=\"account-details\" size={35} />\n        <TextInput\n          placeholder={placeholder}\n          value={description}\n          onChangeText={(text) => setDescription(text)}\n          style={{borderWidth: 3, borderColor: \"white\", margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: \"gray\", paddingLeft: 10}}\n        />\n      </View>\n      <Button\n        style={{\n          backgroundColor: \"#E6DFF3\",\n          borderRadius: 5,\n          margin: 10,\n          alignItems: \"center\",\n          position: \"absolute\",\n          top: 160,\n          width: 300,\n        }}\n        onPress={handleConfirm}\n      >\n        <Text style={{fontSize: 18, width: 280}}>Confirm</Text>\n      </Button>\n      <IconButton icon={\"close\"} size={30} onPress={onClose} style={{position: \"absolute\", top: 5, right: 5}} />\n    </View>\n  );\n}\n```\n\n## 父组件使用自组件的函数等参数\n\n在子组件中：\n\n将父组件要使用的函数导出：\n\n```jsx\nimport React, {useEffect} from \"react\";\nimport {WebView} from \"react-native-webview\";\nimport {View} from \"react-native\";\nimport {Portal} from \"react-native-paper\";\nimport CasdoorSdkConfig from \"./CasdoorSdkConfig\";\nimport SDK from \"casdoor-react-native-sdk\";\nimport UserContext from \"./UserContext\";\nimport PropTypes from \"prop-types\";\n// import {LogBox} from \"react-native\";\n// LogBox.ignoreAllLogs();\nconst sdk = new SDK(CasdoorSdkConfig);\n\nconst CasdoorLoginPage = ({onWebviewClose}) => {\n  CasdoorLoginPage.propTypes = {\n    onWebviewClose: PropTypes.func.isRequired,\n  };\n  const [casdoorLoginURL, setCasdoorLoginURL] = React.useState(\"\");\n  const {setUserInfo} = React.useContext(UserContext);\n  const getCasdoorSignInUrl = async() => {\n    const signinUrl = await sdk.getSigninUrl();\n    setCasdoorLoginURL(signinUrl);\n  };\n\n  useEffect(() => {\n    getCasdoorSignInUrl();\n  }, []);\n\n  const onNavigationStateChange = async(navState) => {\n    if (navState.url.startsWith(CasdoorSdkConfig.redirectPath)) {\n      onWebviewClose();\n      const token = await sdk.getAccessToken(navState.url);\n      const userInfo = sdk.JwtDecode(token);\n      setUserInfo(userInfo);\n    }\n  };\n\n  return (\n    <Portal>\n      <View style={{flex: 1}}>\n        {casdoorLoginURL !== \"\" && (\n          <WebView\n            source={{uri: casdoorLoginURL}}\n            onNavigationStateChange={onNavigationStateChange}\n            style={{flex: 1}}\n            mixedContentMode=\"always\"\n            javaScriptEnabled={true}\n          />\n        )}\n      </View>\n    </Portal>\n  );\n};\n\nexport const CasdoorLogout = () => {\n  sdk.clearState();\n};\nexport default CasdoorLoginPage;\n```\n\n在父组件中：\n\n导入子组件及其导出的函数，注意导出的方式，导出的组件直接 `import` ，导出的组件的函数要使用花括号来包裹。\n","slug":"react技巧","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1o000hr7gn9cm330j0","content":"<blockquote>\n<p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href=\"https://github.com/cwp0/casdoor-app\">casdoor-app</a></p>\n</blockquote>\n<blockquote>\n<p>后面如果做react的话可能也会做一些总结，到时候再加。</p>\n</blockquote>\n<h1 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h1><h2 id=\"React-Context\"><a href=\"#React-Context\" class=\"headerlink\" title=\"React Context\"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p>\n<p>使用方法：</p>\n<p>例如要共享 <code>userInfo</code></p>\n<ol>\n<li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p>\n<p><code>UserContext.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">UserContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserProvider</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Provider</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserConsumer</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Consumer</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">UserContext</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p>\n<p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">PaperProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">NavigationBar</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./NavigationBar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">NavigationContainer</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@react-navigation/native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Header</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Header&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">UserProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [userInfo, setUserInfo] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserProvider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;userInfo,</span> <span class=\"attr\">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Header</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">NavigationBar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">UserProvider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p>\n<p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p>\n<p><code>Header.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Appbar</span>, <span class=\"title class_\">Avatar</span>, <span class=\"title class_\">Button</span>, <span class=\"title class_\">Menu</span>, <span class=\"title class_\">Text</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorLoginPage</span>, &#123;<span class=\"title class_\">CasdoorLogout</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Header</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;userInfo, setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [showLoginPage, setShowLoginPage] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [menuVisible, setMenuVisible] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">openMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">closeMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleMenuLogoutClicked</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleCasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">closeMenu</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogin</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setUserInfo</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleHideLoginPage</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Appbar.Header</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;height:</span> <span class=\"attr\">40</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Appbar.Content</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Menu</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">visible</span>=<span class=\"string\">&#123;menuVisible&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">anchor</span>=<span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &lt;<span class=\"attr\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;, <span class=\"attr\">height:</span> <span class=\"attr\">40</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;userInfo</span> === <span class=\"string\">null</span> ? <span class=\"attr\">handleCasdoorLogin</span> <span class=\"attr\">:</span> <span class=\"attr\">openMenu</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                userInfo === null ?</span></span><br><span class=\"line\"><span class=\"language-xml\">                  null :</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">Avatar.Image</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">size</span>=<span class=\"string\">&#123;32&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>&#125;&#125; <span class=\"attr\">variant</span>=<span class=\"string\">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        &gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Menu.Item</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Menu</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Appbar.Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;showLoginPage &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">CasdoorLoginPage</span> <span class=\"attr\">onWebviewClose</span>=<span class=\"string\">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Header</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件使用父组件的函数等参数\"><a href=\"#子组件使用父组件的函数等参数\" class=\"headerlink\" title=\"子组件使用父组件的函数等参数\"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p>\n<p>定义好相关函数及变量，将参数传递给子组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [placeholder, setPlaceholder] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">closeEditAccountModal</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowEditAccountModal</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">onAccountEdit</span> = (<span class=\"params\">accountDescp</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accountToEdit = accountList.<span class=\"title function_\">find</span>(<span class=\"function\"><span class=\"params\">account</span> =&gt;</span> account.<span class=\"title function_\">getEditStatus</span>() === <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accountToEdit) &#123;</span><br><span class=\"line\">      accountToEdit.<span class=\"title function_\">setTitle</span>(accountDescp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">setPlaceholder</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_\">closeEditAccountModal</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"title class_\">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在子组件中：</p>\n<p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Text</span>, <span class=\"title class_\">TextInput</span>, <span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Button</span>, <span class=\"title class_\">IconButton</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">EnterAccountDetails</span>(<span class=\"params\">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">EnterAccountDetails</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">onEdit</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [description, setDescription] = <span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleConfirm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">onEdit</span>(description);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>, <span class=\"attr\">justifyContent:</span> &quot;<span class=\"attr\">center</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">24</span>, <span class=\"attr\">marginBottom:</span> <span class=\"attr\">5</span>&#125;&#125;&gt;</span>Enter new description<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flexDirection:</span> &quot;<span class=\"attr\">row</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&quot;account-details&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">&#123;35&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TextInput</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">placeholder</span>=<span class=\"string\">&#123;placeholder&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">value</span>=<span class=\"string\">&#123;description&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChangeText</span>=<span class=\"string\">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">backgroundColor:</span> &quot;#<span class=\"attr\">E6DFF3</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">borderRadius:</span> <span class=\"attr\">5</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">margin:</span> <span class=\"attr\">10</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">position:</span> &quot;<span class=\"attr\">absolute</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">top:</span> <span class=\"attr\">160</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">width:</span> <span class=\"attr\">300</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;handleConfirm&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">18</span>, <span class=\"attr\">width:</span> <span class=\"attr\">280</span>&#125;&#125;&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&#123;</span>&quot;<span class=\"attr\">close</span>&quot;&#125; <span class=\"attr\">size</span>=<span class=\"string\">&#123;30&#125;</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;onClose&#125;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;position:</span> &quot;<span class=\"attr\">absolute</span>&quot;, <span class=\"attr\">top:</span> <span class=\"attr\">5</span>, <span class=\"attr\">right:</span> <span class=\"attr\">5</span>&#125;&#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"父组件使用自组件的函数等参数\"><a href=\"#父组件使用自组件的函数等参数\" class=\"headerlink\" title=\"父组件使用自组件的函数等参数\"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p>\n<p>将父组件要使用的函数导出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">WebView</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-webview&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Portal</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorSdkConfig</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"variable constant_\">SDK</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// LogBox.ignoreAllLogs();</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sdk = <span class=\"keyword\">new</span> <span class=\"title function_\">SDK</span>(<span class=\"title class_\">CasdoorSdkConfig</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLoginPage</span> = (<span class=\"params\">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CasdoorLoginPage</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onWebviewClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">getCasdoorSignInUrl</span> = <span class=\"keyword\">async</span>(<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> signinUrl = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getSigninUrl</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setCasdoorLoginURL</span>(signinUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getCasdoorSignInUrl</span>();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onNavigationStateChange</span> = <span class=\"keyword\">async</span>(<span class=\"params\">navState</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navState.<span class=\"property\">url</span>.<span class=\"title function_\">startsWith</span>(<span class=\"title class_\">CasdoorSdkConfig</span>.<span class=\"property\">redirectPath</span>)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onWebviewClose</span>();</span><br><span class=\"line\">      <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getAccessToken</span>(navState.<span class=\"property\">url</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> userInfo = sdk.<span class=\"title class_\">JwtDecode</span>(token);</span><br><span class=\"line\">      <span class=\"title function_\">setUserInfo</span>(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">WebView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">onNavigationStateChange</span>=<span class=\"string\">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">mixedContentMode</span>=<span class=\"string\">&quot;always&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">javaScriptEnabled</span>=<span class=\"string\">&#123;true&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  sdk.<span class=\"title function_\">clearState</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在父组件中：</p>\n<p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href=\"https://github.com/cwp0/casdoor-app\">casdoor-app</a></p>\n</blockquote>\n<blockquote>\n<p>后面如果做react的话可能也会做一些总结，到时候再加。</p>\n</blockquote>\n<h1 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h1><h2 id=\"React-Context\"><a href=\"#React-Context\" class=\"headerlink\" title=\"React Context\"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p>\n<p>使用方法：</p>\n<p>例如要共享 <code>userInfo</code></p>\n<ol>\n<li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p>\n<p><code>UserContext.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">UserContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserProvider</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Provider</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserConsumer</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Consumer</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">UserContext</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p>\n<p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">PaperProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">NavigationBar</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./NavigationBar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">NavigationContainer</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@react-navigation/native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Header</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Header&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">UserProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [userInfo, setUserInfo] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserProvider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;userInfo,</span> <span class=\"attr\">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Header</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">NavigationBar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">UserProvider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p>\n<p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p>\n<p><code>Header.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Appbar</span>, <span class=\"title class_\">Avatar</span>, <span class=\"title class_\">Button</span>, <span class=\"title class_\">Menu</span>, <span class=\"title class_\">Text</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorLoginPage</span>, &#123;<span class=\"title class_\">CasdoorLogout</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Header</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;userInfo, setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [showLoginPage, setShowLoginPage] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [menuVisible, setMenuVisible] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">openMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">closeMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleMenuLogoutClicked</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleCasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">closeMenu</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogin</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setUserInfo</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleHideLoginPage</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Appbar.Header</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;height:</span> <span class=\"attr\">40</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Appbar.Content</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Menu</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">visible</span>=<span class=\"string\">&#123;menuVisible&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">anchor</span>=<span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &lt;<span class=\"attr\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;, <span class=\"attr\">height:</span> <span class=\"attr\">40</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;userInfo</span> === <span class=\"string\">null</span> ? <span class=\"attr\">handleCasdoorLogin</span> <span class=\"attr\">:</span> <span class=\"attr\">openMenu</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                userInfo === null ?</span></span><br><span class=\"line\"><span class=\"language-xml\">                  null :</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">Avatar.Image</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">size</span>=<span class=\"string\">&#123;32&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>&#125;&#125; <span class=\"attr\">variant</span>=<span class=\"string\">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        &gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Menu.Item</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Menu</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Appbar.Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;showLoginPage &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">CasdoorLoginPage</span> <span class=\"attr\">onWebviewClose</span>=<span class=\"string\">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Header</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件使用父组件的函数等参数\"><a href=\"#子组件使用父组件的函数等参数\" class=\"headerlink\" title=\"子组件使用父组件的函数等参数\"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p>\n<p>定义好相关函数及变量，将参数传递给子组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [placeholder, setPlaceholder] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">closeEditAccountModal</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowEditAccountModal</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">onAccountEdit</span> = (<span class=\"params\">accountDescp</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accountToEdit = accountList.<span class=\"title function_\">find</span>(<span class=\"function\"><span class=\"params\">account</span> =&gt;</span> account.<span class=\"title function_\">getEditStatus</span>() === <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accountToEdit) &#123;</span><br><span class=\"line\">      accountToEdit.<span class=\"title function_\">setTitle</span>(accountDescp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">setPlaceholder</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_\">closeEditAccountModal</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"title class_\">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在子组件中：</p>\n<p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Text</span>, <span class=\"title class_\">TextInput</span>, <span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Button</span>, <span class=\"title class_\">IconButton</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">EnterAccountDetails</span>(<span class=\"params\">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">EnterAccountDetails</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">onEdit</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [description, setDescription] = <span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleConfirm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">onEdit</span>(description);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>, <span class=\"attr\">justifyContent:</span> &quot;<span class=\"attr\">center</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">24</span>, <span class=\"attr\">marginBottom:</span> <span class=\"attr\">5</span>&#125;&#125;&gt;</span>Enter new description<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flexDirection:</span> &quot;<span class=\"attr\">row</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&quot;account-details&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">&#123;35&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TextInput</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">placeholder</span>=<span class=\"string\">&#123;placeholder&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">value</span>=<span class=\"string\">&#123;description&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChangeText</span>=<span class=\"string\">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">backgroundColor:</span> &quot;#<span class=\"attr\">E6DFF3</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">borderRadius:</span> <span class=\"attr\">5</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">margin:</span> <span class=\"attr\">10</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">position:</span> &quot;<span class=\"attr\">absolute</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">top:</span> <span class=\"attr\">160</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">width:</span> <span class=\"attr\">300</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;handleConfirm&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">18</span>, <span class=\"attr\">width:</span> <span class=\"attr\">280</span>&#125;&#125;&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&#123;</span>&quot;<span class=\"attr\">close</span>&quot;&#125; <span class=\"attr\">size</span>=<span class=\"string\">&#123;30&#125;</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;onClose&#125;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;position:</span> &quot;<span class=\"attr\">absolute</span>&quot;, <span class=\"attr\">top:</span> <span class=\"attr\">5</span>, <span class=\"attr\">right:</span> <span class=\"attr\">5</span>&#125;&#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"父组件使用自组件的函数等参数\"><a href=\"#父组件使用自组件的函数等参数\" class=\"headerlink\" title=\"父组件使用自组件的函数等参数\"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p>\n<p>将父组件要使用的函数导出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">WebView</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-webview&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Portal</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorSdkConfig</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"variable constant_\">SDK</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// LogBox.ignoreAllLogs();</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sdk = <span class=\"keyword\">new</span> <span class=\"title function_\">SDK</span>(<span class=\"title class_\">CasdoorSdkConfig</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLoginPage</span> = (<span class=\"params\">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CasdoorLoginPage</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onWebviewClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">getCasdoorSignInUrl</span> = <span class=\"keyword\">async</span>(<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> signinUrl = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getSigninUrl</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setCasdoorLoginURL</span>(signinUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getCasdoorSignInUrl</span>();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onNavigationStateChange</span> = <span class=\"keyword\">async</span>(<span class=\"params\">navState</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navState.<span class=\"property\">url</span>.<span class=\"title function_\">startsWith</span>(<span class=\"title class_\">CasdoorSdkConfig</span>.<span class=\"property\">redirectPath</span>)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onWebviewClose</span>();</span><br><span class=\"line\">      <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getAccessToken</span>(navState.<span class=\"property\">url</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> userInfo = sdk.<span class=\"title class_\">JwtDecode</span>(token);</span><br><span class=\"line\">      <span class=\"title function_\">setUserInfo</span>(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">WebView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">onNavigationStateChange</span>=<span class=\"string\">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">mixedContentMode</span>=<span class=\"string\">&quot;always&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">javaScriptEnabled</span>=<span class=\"string\">&#123;true&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  sdk.<span class=\"title function_\">clearState</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在父组件中：</p>\n<p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>\n"},{"title":"k8s部署云笔记系统","description":"在k8s服务器上部署云笔记系统","top_img":"../image/k8s部署云笔记系统/可莉.png","abbrlink":16330,"date":"2023-09-19T14:35:00.000Z","updated":"2023-09-20T05:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。\n\n## 创建namespace\n\n```kubernetes helm\n# 创建namespace\nkubectl create namespace note\n```\n\n## 1. 部署MySQL\n\n创建mysql文件夹\n\n```shell\nsudo mkdir -p /home/mysql/data\n```\n\n### 1.1 挂载数据卷\n\nnote-mysql-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n\tstorage: 1Gi\n  accessModes:\n\t- ReadWriteOnce\n  hostPath:\n\tpath: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n\t- ReadWriteOnce\n  resources:\n\trequests:\n\t  storage: 1Gi\n  storageClassName: \"\"\n\tvolumeName: note-mysql-pv\n```\n\n部署\n\n```kubernetes helm\nkubectl create -f note-mysql-pvc.yaml -n note\n```\n\n查看是否部署成功：\n\n![mysql是否部署成功](../image/k8s部署云笔记系统/1.png)\n\n### 1.2 部署mysql\n\nnote-mysql.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n\tmatchLabels:\n\t  app: note-mysql-pod\n  template:\n\tmetadata:\n\t  labels:\n\t\tapp: note-mysql-pod\n\tspec:\n\t  containers:\n\t\t- name: note-mysql\n\t\t  image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n\t\t  imagePullPolicy: IfNotPresent\n\t\t  env:\n\t\t\t- name: MYSQL_ROOT_PASSWORD\n\t\t\t  value: dfa6f1b032ee42ed95d12647225f2ff4\n\t\t  ports:\n\t\t\t- containerPort: 3306\n\t\t  volumeMounts:\n\t\t\t- name: note-mysql-persistent-storage\n\t\t\t  mountPath: /var/lib/mysql\n\tvolumes:\n\t  - name: note-mysql-persistent-storage\n\t\tpersistentVolumeClaim:\n\t\t  claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n\tapp: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n\tnodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n\ttargetPort: 3306\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-mysql.yaml -n note\n```\n\n## 2. 部署redis\n\nnote-redis.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-redis-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-redis-pod\n  template:\n    metadata:\n      labels:\n        app: note-redis-pod\n    spec:\n      containers:\n        - name: note-redis\n          image: redis:latest\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: REDIS_PASSWORD\n              value: adcc64a4a9b04324914626590fb52a1a\n          ports:\n            - containerPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-redis-service\nspec:\n  selector:\n    app: note-redis-pod\n  type: NodePort # service类型\n  ports:\n  - port: 6379\n    nodePort: 30079 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 6379\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-redis.yaml -n note\n```\n\n## 3. 部署mongodb\n\n创建mongodb文件夹\n\n```shell\nsudo mkdir -p /home/mongodb/data\n```\n\n### 3.1 挂载数据卷\n\nnote-mongodb-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 1Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n使用\n\n```kubernetes helm\nkubectl create -f note-mongodb-pvc.yaml -n note\n```\n\n查看是否装好：\n\n![mongodb-pvc](../image/k8s部署云笔记系统/2.png)\n\n### 3.2 部署\n\nnote-mongodb.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n```kubernetes helm\nkubectl create -f note-mongodb.yaml -n note\n```\n\n检查部署情况\n\n![mongodb](../image/k8s部署云笔记系统/3.png)\n\n## 4. 部署服务bert_flask\n\nbert_flask.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: bert-flask-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: bert-flask-pod\n  template:\n    metadata:\n      labels:\n        app: bert-flask-pod\n    spec:\n      containers:\n      - name: bert-flask\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: bert-flask-service\nspec:\n  selector:\n    app: bert-flask-pod\n  type: NodePort # service类型\n  ports:\n  - port: 5000\n    nodePort: 30050 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 5000\n```\n\n```kubernetes helm\nkubectl create -f bert_flask.yaml -n note\n```\n\n检查部署情况\n![bert_flask](../image/k8s部署云笔记系统/4.png)\n\n## 5. 部署服务note_cloud\n\n### 5.1 配置ConfigMap\n\n   新建application-prod.yml\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /api\nspring:\n  datasource:\n    url: jdbc:mysql://note-mysql-service:3306/db_note\n    username: root\n    password: dfa6f1b032ee42ed95d12647225f2ff4\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n  redis:\n    host: note-redis-service\n    port: 6379\n    password: adcc64a4a9b04324914626590fb52a1a\n    lettuce:\n      pool:\n        max-active: 10\n        max-idle: 10\n        min-idle: 1\n        time-between-eviction-runs: 10s\n    jackson:\n      default-property-inclusion: non_null # JSON处理时忽略非空字段\n  data:\n    mongodb:\n      uri: mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note\n  servlet:\n    multipart:\n      max-file-size: 10MB\n      max-request-size: 10MB\njwt:\n  base64-encoded-secret-key: lab_of_njust_cloud_computing # jwt的签名密码\nbert-base-chinese-service:\n  host: bert-flask-service\n  port: 5000\n```\n\n```kubernetes helm\nkubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml\n```\n\n   查看部署状态\n   ![部署效果](../image/k8s部署云笔记系统/4.png)\n\n### 5.2 部署服务\n\nnote-cloud.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-cloud-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-cloud-pod\n  template:\n    metadata:\n      labels:\n        app: note-cloud-pod\n    spec:\n      containers:\n      - name: note-cloud\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/config # 配置文件将挂载到容器的/app/config目录\n      volumes:\n      - name: config-volume\n        configMap:\n          name: note-cloud-config # 引用之前创建的 ConfigMap\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-cloud-service\nspec:\n  selector:\n    app: note-cloud-pod\n  type: NodePort # service类型\n  ports:\n  - port: 8080\n    nodePort: 30080 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 8080\n```\n\n```kubernetes helm\nkubectl create -f note-cloud.yaml -n note\n```\n\n查看日志\n\n```kubernetes helm\nkubectl get pod -n note\nkubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note\n```\n\n## 6. 部署前端\n\nnote-nginx.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-nginx-pod\n  template:\n    metadata:\n      labels:\n        app: note-nginx-pod\n    spec:\n      containers:\n        - name: note-nginx\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-nginx-service\nspec:\n  selector:\n    app: note-nginx-pod\n  type: NodePort # service类型\n  ports:\n  - port: 80\n    nodePort: 30088 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 80\n```\n\n```kubernetes helm\nkubectl create -f note-nginx.yaml -n note\n```\n\n## 最终部署pod查看\n\n![pod](../image/k8s部署云笔记系统/5.png)\n\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n账号：姓名小写拼音\n密码：123456\n\n\n最终效果：\n![6](../image/k8s部署云笔记系统/6.png)\n","source":"_posts/k8s部署云笔记系统.md","raw":"---\ntitle: k8s部署云笔记系统\ntags:\n  - k8s\n  - Kubernetes\n  - 教程\ncategories:\n  - Kubernetes\ndescription: 在k8s服务器上部署云笔记系统\ntop_img: ../image/k8s部署云笔记系统/可莉.png\nabbrlink: 16330\ndate: 2023-09-19 22:35:00\nupdated: 2023-09-20 13:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。\n\n## 创建namespace\n\n```kubernetes helm\n# 创建namespace\nkubectl create namespace note\n```\n\n## 1. 部署MySQL\n\n创建mysql文件夹\n\n```shell\nsudo mkdir -p /home/mysql/data\n```\n\n### 1.1 挂载数据卷\n\nnote-mysql-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n\tstorage: 1Gi\n  accessModes:\n\t- ReadWriteOnce\n  hostPath:\n\tpath: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n\t- ReadWriteOnce\n  resources:\n\trequests:\n\t  storage: 1Gi\n  storageClassName: \"\"\n\tvolumeName: note-mysql-pv\n```\n\n部署\n\n```kubernetes helm\nkubectl create -f note-mysql-pvc.yaml -n note\n```\n\n查看是否部署成功：\n\n![mysql是否部署成功](../image/k8s部署云笔记系统/1.png)\n\n### 1.2 部署mysql\n\nnote-mysql.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n\tmatchLabels:\n\t  app: note-mysql-pod\n  template:\n\tmetadata:\n\t  labels:\n\t\tapp: note-mysql-pod\n\tspec:\n\t  containers:\n\t\t- name: note-mysql\n\t\t  image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n\t\t  imagePullPolicy: IfNotPresent\n\t\t  env:\n\t\t\t- name: MYSQL_ROOT_PASSWORD\n\t\t\t  value: dfa6f1b032ee42ed95d12647225f2ff4\n\t\t  ports:\n\t\t\t- containerPort: 3306\n\t\t  volumeMounts:\n\t\t\t- name: note-mysql-persistent-storage\n\t\t\t  mountPath: /var/lib/mysql\n\tvolumes:\n\t  - name: note-mysql-persistent-storage\n\t\tpersistentVolumeClaim:\n\t\t  claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n\tapp: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n\tnodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n\ttargetPort: 3306\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-mysql.yaml -n note\n```\n\n## 2. 部署redis\n\nnote-redis.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-redis-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-redis-pod\n  template:\n    metadata:\n      labels:\n        app: note-redis-pod\n    spec:\n      containers:\n        - name: note-redis\n          image: redis:latest\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: REDIS_PASSWORD\n              value: adcc64a4a9b04324914626590fb52a1a\n          ports:\n            - containerPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-redis-service\nspec:\n  selector:\n    app: note-redis-pod\n  type: NodePort # service类型\n  ports:\n  - port: 6379\n    nodePort: 30079 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 6379\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-redis.yaml -n note\n```\n\n## 3. 部署mongodb\n\n创建mongodb文件夹\n\n```shell\nsudo mkdir -p /home/mongodb/data\n```\n\n### 3.1 挂载数据卷\n\nnote-mongodb-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 1Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n使用\n\n```kubernetes helm\nkubectl create -f note-mongodb-pvc.yaml -n note\n```\n\n查看是否装好：\n\n![mongodb-pvc](../image/k8s部署云笔记系统/2.png)\n\n### 3.2 部署\n\nnote-mongodb.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n```kubernetes helm\nkubectl create -f note-mongodb.yaml -n note\n```\n\n检查部署情况\n\n![mongodb](../image/k8s部署云笔记系统/3.png)\n\n## 4. 部署服务bert_flask\n\nbert_flask.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: bert-flask-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: bert-flask-pod\n  template:\n    metadata:\n      labels:\n        app: bert-flask-pod\n    spec:\n      containers:\n      - name: bert-flask\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: bert-flask-service\nspec:\n  selector:\n    app: bert-flask-pod\n  type: NodePort # service类型\n  ports:\n  - port: 5000\n    nodePort: 30050 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 5000\n```\n\n```kubernetes helm\nkubectl create -f bert_flask.yaml -n note\n```\n\n检查部署情况\n![bert_flask](../image/k8s部署云笔记系统/4.png)\n\n## 5. 部署服务note_cloud\n\n### 5.1 配置ConfigMap\n\n   新建application-prod.yml\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /api\nspring:\n  datasource:\n    url: jdbc:mysql://note-mysql-service:3306/db_note\n    username: root\n    password: dfa6f1b032ee42ed95d12647225f2ff4\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n  redis:\n    host: note-redis-service\n    port: 6379\n    password: adcc64a4a9b04324914626590fb52a1a\n    lettuce:\n      pool:\n        max-active: 10\n        max-idle: 10\n        min-idle: 1\n        time-between-eviction-runs: 10s\n    jackson:\n      default-property-inclusion: non_null # JSON处理时忽略非空字段\n  data:\n    mongodb:\n      uri: mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note\n  servlet:\n    multipart:\n      max-file-size: 10MB\n      max-request-size: 10MB\njwt:\n  base64-encoded-secret-key: lab_of_njust_cloud_computing # jwt的签名密码\nbert-base-chinese-service:\n  host: bert-flask-service\n  port: 5000\n```\n\n```kubernetes helm\nkubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml\n```\n\n   查看部署状态\n   ![部署效果](../image/k8s部署云笔记系统/4.png)\n\n### 5.2 部署服务\n\nnote-cloud.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-cloud-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-cloud-pod\n  template:\n    metadata:\n      labels:\n        app: note-cloud-pod\n    spec:\n      containers:\n      - name: note-cloud\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/config # 配置文件将挂载到容器的/app/config目录\n      volumes:\n      - name: config-volume\n        configMap:\n          name: note-cloud-config # 引用之前创建的 ConfigMap\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-cloud-service\nspec:\n  selector:\n    app: note-cloud-pod\n  type: NodePort # service类型\n  ports:\n  - port: 8080\n    nodePort: 30080 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 8080\n```\n\n```kubernetes helm\nkubectl create -f note-cloud.yaml -n note\n```\n\n查看日志\n\n```kubernetes helm\nkubectl get pod -n note\nkubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note\n```\n\n## 6. 部署前端\n\nnote-nginx.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-nginx-pod\n  template:\n    metadata:\n      labels:\n        app: note-nginx-pod\n    spec:\n      containers:\n        - name: note-nginx\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-nginx-service\nspec:\n  selector:\n    app: note-nginx-pod\n  type: NodePort # service类型\n  ports:\n  - port: 80\n    nodePort: 30088 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 80\n```\n\n```kubernetes helm\nkubectl create -f note-nginx.yaml -n note\n```\n\n## 最终部署pod查看\n\n![pod](../image/k8s部署云笔记系统/5.png)\n\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n账号：姓名小写拼音\n密码：123456\n\n\n最终效果：\n![6](../image/k8s部署云笔记系统/6.png)\n","slug":"k8s部署云笔记系统","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1q000mr7gngkzg6hk6","content":"<blockquote>\n<p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p>\n</blockquote>\n<h2 id=\"创建namespace\"><a href=\"#创建namespace\" class=\"headerlink\" title=\"创建namespace\"></a>创建namespace</h2><figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建namespace</span><br><span class=\"line\">kubectl create namespace note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-部署MySQL\"><a href=\"#1-部署MySQL\" class=\"headerlink\" title=\"1. 部署MySQL\"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-挂载数据卷\"><a href=\"#1-1-挂载数据卷\" class=\"headerlink\" title=\"1.1 挂载数据卷\"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">\t<span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">\t<span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">\t<span class=\"attr\">requests:</span></span><br><span class=\"line\">\t  <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t<span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>部署</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否部署成功：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png\" alt=\"mysql是否部署成功\"></p>\n<h3 id=\"1-2-部署mysql\"><a href=\"#1-2-部署mysql\" class=\"headerlink\" title=\"1.2 部署mysql\"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">\t  <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">\t<span class=\"attr\">metadata:</span></span><br><span class=\"line\">\t  <span class=\"attr\">labels:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">\t<span class=\"attr\">spec:</span></span><br><span class=\"line\">\t  <span class=\"attr\">containers:</span></span><br><span class=\"line\">\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">env:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">ports:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">\t<span class=\"attr\">volumes:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t<span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t<span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">\t<span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-部署redis\"><a href=\"#2-部署redis\" class=\"headerlink\" title=\"2. 部署redis\"></a>2. 部署redis</h2><p>note-redis.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-redis</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">redis:latest</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">REDIS_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30079</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-部署mongodb\"><a href=\"#3-部署mongodb\" class=\"headerlink\" title=\"3. 部署mongodb\"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-挂载数据卷\"><a href=\"#3-1-挂载数据卷\" class=\"headerlink\" title=\"3.1 挂载数据卷\"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否装好：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png\" alt=\"mongodb-pvc\"></p>\n<h3 id=\"3-2-部署\"><a href=\"#3-2-部署\" class=\"headerlink\" title=\"3.2 部署\"></a>3.2 部署</h3><p>note-mongodb.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png\" alt=\"mongodb\"></p>\n<h2 id=\"4-部署服务bert-flask\"><a href=\"#4-部署服务bert-flask\" class=\"headerlink\" title=\"4. 部署服务bert_flask\"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">bert-flask</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5000</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30050</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"bert_flask\"></p>\n<h2 id=\"5-部署服务note-cloud\"><a href=\"#5-部署服务note-cloud\" class=\"headerlink\" title=\"5. 部署服务note_cloud\"></a>5. 部署服务note_cloud</h2><h3 id=\"5-1-配置ConfigMap\"><a href=\"#5-1-配置ConfigMap\" class=\"headerlink\" title=\"5.1 配置ConfigMap\"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/api</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">time-between-eviction-runs:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">    <span class=\"attr\">jackson:</span></span><br><span class=\"line\">      <span class=\"attr\">default-property-inclusion:</span> <span class=\"string\">non_null</span> <span class=\"comment\"># JSON处理时忽略非空字段</span></span><br><span class=\"line\">  <span class=\"attr\">data:</span></span><br><span class=\"line\">    <span class=\"attr\">mongodb:</span></span><br><span class=\"line\">      <span class=\"attr\">uri:</span> <span class=\"string\">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">multipart:</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\">      <span class=\"attr\">max-request-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\"><span class=\"attr\">jwt:</span></span><br><span class=\"line\">  <span class=\"attr\">base64-encoded-secret-key:</span> <span class=\"string\">lab_of_njust_cloud_computing</span> <span class=\"comment\"># jwt的签名密码</span></span><br><span class=\"line\"><span class=\"attr\">bert-base-chinese-service:</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure>\n\n<p>   查看部署状态<br>   <img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"部署效果\"></p>\n<h3 id=\"5-2-部署服务\"><a href=\"#5-2-部署服务\" class=\"headerlink\" title=\"5.2 部署服务\"></a>5.2 部署服务</h3><p>note-cloud.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-cloud</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/app/config</span> <span class=\"comment\"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">        <span class=\"attr\">configMap:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-config</span> <span class=\"comment\"># 引用之前创建的 ConfigMap</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看日志</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br><span class=\"line\">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-部署前端\"><a href=\"#6-部署前端\" class=\"headerlink\" title=\"6. 部署前端\"></a>6. 部署前端</h2><p>note-nginx.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-nginx</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30088</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最终部署pod查看\"><a href=\"#最终部署pod查看\" class=\"headerlink\" title=\"最终部署pod查看\"></a>最终部署pod查看</h2><p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png\" alt=\"pod\"></p>\n<p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p>\n<p>最终效果：<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png\" alt=\"6\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p>\n</blockquote>\n<h2 id=\"创建namespace\"><a href=\"#创建namespace\" class=\"headerlink\" title=\"创建namespace\"></a>创建namespace</h2><figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建namespace</span><br><span class=\"line\">kubectl create namespace note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-部署MySQL\"><a href=\"#1-部署MySQL\" class=\"headerlink\" title=\"1. 部署MySQL\"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-挂载数据卷\"><a href=\"#1-1-挂载数据卷\" class=\"headerlink\" title=\"1.1 挂载数据卷\"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">\t<span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">\t<span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">\t<span class=\"attr\">requests:</span></span><br><span class=\"line\">\t  <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t<span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>部署</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否部署成功：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png\" alt=\"mysql是否部署成功\"></p>\n<h3 id=\"1-2-部署mysql\"><a href=\"#1-2-部署mysql\" class=\"headerlink\" title=\"1.2 部署mysql\"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">\t  <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">\t<span class=\"attr\">metadata:</span></span><br><span class=\"line\">\t  <span class=\"attr\">labels:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">\t<span class=\"attr\">spec:</span></span><br><span class=\"line\">\t  <span class=\"attr\">containers:</span></span><br><span class=\"line\">\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">env:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">ports:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">\t<span class=\"attr\">volumes:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t<span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t<span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">\t<span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-部署redis\"><a href=\"#2-部署redis\" class=\"headerlink\" title=\"2. 部署redis\"></a>2. 部署redis</h2><p>note-redis.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-redis</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">redis:latest</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">REDIS_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30079</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-部署mongodb\"><a href=\"#3-部署mongodb\" class=\"headerlink\" title=\"3. 部署mongodb\"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-挂载数据卷\"><a href=\"#3-1-挂载数据卷\" class=\"headerlink\" title=\"3.1 挂载数据卷\"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否装好：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png\" alt=\"mongodb-pvc\"></p>\n<h3 id=\"3-2-部署\"><a href=\"#3-2-部署\" class=\"headerlink\" title=\"3.2 部署\"></a>3.2 部署</h3><p>note-mongodb.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png\" alt=\"mongodb\"></p>\n<h2 id=\"4-部署服务bert-flask\"><a href=\"#4-部署服务bert-flask\" class=\"headerlink\" title=\"4. 部署服务bert_flask\"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">bert-flask</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5000</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30050</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"bert_flask\"></p>\n<h2 id=\"5-部署服务note-cloud\"><a href=\"#5-部署服务note-cloud\" class=\"headerlink\" title=\"5. 部署服务note_cloud\"></a>5. 部署服务note_cloud</h2><h3 id=\"5-1-配置ConfigMap\"><a href=\"#5-1-配置ConfigMap\" class=\"headerlink\" title=\"5.1 配置ConfigMap\"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/api</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">time-between-eviction-runs:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">    <span class=\"attr\">jackson:</span></span><br><span class=\"line\">      <span class=\"attr\">default-property-inclusion:</span> <span class=\"string\">non_null</span> <span class=\"comment\"># JSON处理时忽略非空字段</span></span><br><span class=\"line\">  <span class=\"attr\">data:</span></span><br><span class=\"line\">    <span class=\"attr\">mongodb:</span></span><br><span class=\"line\">      <span class=\"attr\">uri:</span> <span class=\"string\">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">multipart:</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\">      <span class=\"attr\">max-request-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\"><span class=\"attr\">jwt:</span></span><br><span class=\"line\">  <span class=\"attr\">base64-encoded-secret-key:</span> <span class=\"string\">lab_of_njust_cloud_computing</span> <span class=\"comment\"># jwt的签名密码</span></span><br><span class=\"line\"><span class=\"attr\">bert-base-chinese-service:</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure>\n\n<p>   查看部署状态<br>   <img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"部署效果\"></p>\n<h3 id=\"5-2-部署服务\"><a href=\"#5-2-部署服务\" class=\"headerlink\" title=\"5.2 部署服务\"></a>5.2 部署服务</h3><p>note-cloud.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-cloud</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/app/config</span> <span class=\"comment\"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">        <span class=\"attr\">configMap:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-config</span> <span class=\"comment\"># 引用之前创建的 ConfigMap</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看日志</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br><span class=\"line\">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-部署前端\"><a href=\"#6-部署前端\" class=\"headerlink\" title=\"6. 部署前端\"></a>6. 部署前端</h2><p>note-nginx.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-nginx</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30088</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最终部署pod查看\"><a href=\"#最终部署pod查看\" class=\"headerlink\" title=\"最终部署pod查看\"></a>最终部署pod查看</h2><p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png\" alt=\"pod\"></p>\n<p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p>\n<p>最终效果：<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png\" alt=\"6\"></p>\n"},{"title":"云笔记系统扩容","keywords":["k8s"],"description":"对k8s服务器上部署的云笔记系统进行扩容","abbrlink":36313,"date":"2023-09-20T06:50:58.000Z","updated":"2023-09-20T07:00:00.000Z","top_img":"https://s2.loli.net/2024/02/06/MemxlCZb8nKTBXp.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/ENM4lTRwfKyOtJB.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n### 起因\n\n之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 `mysql`和存储笔记信息的 `mongodb`在部署的时候我都设置了 `1G`的存储卷，这是远远不够的，因此需对其进行扩容。\n\n根据老师要求，需将内存从 `1G`扩展到  `50G`，这是针对存笔记系统的 `mongodb`，为了更加稳妥，跟学弟协商后决定将存用户数据的 `mysql`也扩充到 `10G`。\n\n### 大体思路：\n\n1. 确定 `mongodb`和 `mysql`的 `pod`所在的 `node`节点。\n2. 备份数据\n3. 删除旧的 `pod`\n4. 分别修改 `mongodb`和 `mysql`的 `pv`、 `pvc`为 `50Gi`、 `10Gi`。\n5. 指定 `mongodb`和 `mysql`的 `pv`、 `pvc`及 `mongodb`、 `mysql`部署的亲和性，让其部署在指定 `node`节点，便于扩容。\n6. 重新部署相应 `pod`\n7. 扩容指定的 `mongodb`、 `mysql`部署的节点的虚拟机。\n\n> 注：本笔记图片里的 `deployment`的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。\n\n## 1. 确定pod所在的node节点\n\n首先远程连接 `131`服务器。\n\n云笔记系统有 `6`个 `pod`，在 `note`空间里，如下所示：\n\n```bash\nkubectl get pod -n note\n```\n\n![pod](../image/云笔记系统扩容/pod.png)\n\n需确定 `mongodb`、 `mysql`所在的 `node`节点，命令如下：\n\n```bash\nkubectl get pod -n note -o wide\n```\n\n![pod-node](../image/云笔记系统扩容/pod-node.png)\n\n由上图可知， `mongodb`和 `mysql`的 `pod`分别被部署到了 `k8s-node6`、 `k8s-node7`节点。\n\n## 2. 备份数据\n\n问学长得知， `k8s-node6`、 `k8s-node7`节点位于 `122`服务器\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，登录 `node6`节点：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n账号密码为 `root 123456`，登陆后如下：\n\n![login](../image/云笔记系统扩容/login.png)\n\n按下面命令将数据拷贝到 `tmp/backup`文件夹下进行备份：\n\n![backup](../image/云笔记系统扩容/backup.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n为了保险起见，使用 `xShell`中的 `xftp`将备份的文件再备份到桌面一份：\n\n![xftp](../image/云笔记系统扩容/xftp.png)\n\n打开 `xshell`点击新建文件传输，将 `/home`下的 `mongodb`文件夹拖动到桌面。\n\n![backup-desktop](../image/云笔记系统扩容/backup-desktop.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n## 3. 删除旧的pod\n\n删除旧的 `pod`：\n\n```yaml\nkubectl delete -f note-mysql-pvc.yaml -n note\nkubectl delete -f note-mysql.yaml -n note\nkubectl delete -f note-mongodb-pvc.yaml -n note\nkubectl delete -f note-mongodb.yaml -n note\n```\n\n![delete-pod](../image/云笔记系统扩容/delete-pod.png)\n\n此时查看 `pod`结果：\n\n```yaml\nkubectl get pod -n note\n```\n\n![pod-after-deleted](../image/云笔记系统扩容/pod-after-deleted.png)\n\n`mongodb`和 `mysql`的 `pod`已经被删掉。\n\n## 4. 修改pv、pvc\n\n将相关的 `yaml`文件修改为如下内容：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`yaml`文件里已经将内存修改为目标内存。\n\n## 5. 指定亲和性\n\n这里的亲和性是 `Affinity`，指定了这个后会让其部署在指定标签的 `node`节点上。这样仅需将指定的 `node`节点的虚拟机扩容即可。\n\n首先需要为 `node`节点添加标签。如下所示：\n\n```bash\nkubectl get nodes --show-labels\n\n# 为节点6和7添加label\nkubectl label nodes k8s-node6 notelabel=mongodb\nkubectl label nodes k8s-node7 notelabel=mysql\n```\n\n![add-labels](../image/云笔记系统扩容/add-labels.png)\n\n指定完标签就可以添加亲和性了，如下：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mongodb\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mysql\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`note-mongodb.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mongodb\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n`note-mysql.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mysql-pod\n  template:\n    metadata:\n      labels:\n        app: note-mysql-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mysql\n      containers:\n        - name: note-mysql\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: MYSQL_ROOT_PASSWORD\n              value: dfa6f1b032ee42ed95d12647225f2ff4\n          ports:\n            - containerPort: 3306\n          volumeMounts:\n            - name: note-mysql-persistent-storage\n              mountPath: /var/lib/mysql\n      volumes:\n        - name: note-mysql-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n    app: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n    nodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n    targetPort: 3306\n```\n\n这样，亲和性就修改完毕了。\n\n## 6. 重新部署相应的pod\n\n接下来按 `5. 指定亲和性` 所修改的 `yaml`重新进行 `pod`部署：\n\n```yaml\nkubectl create -f note-mysql-pvc.yaml -n note\nkubectl create -f note-mysql.yaml -n note\nkubectl create -f note-mongodb-pvc.yaml -n note\nkubectl create -f note-mongodb.yaml -n note\n```\n\n![pod-deploy](../image/云笔记系统扩容/pod-deploy.png)\n\n查看部署的结果：\n\n```yaml\nkubectl get pod -n note -o wide\n```\n\n![pod-after-deploy](../image/云笔记系统扩容/pod-after-deploy.png)\n\n可以看到已经将 `mongodb`和 `mysql`分别部署到了节点 `6`和 `7`上。\n\n## 7. 扩容节点的虚拟机\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，如下：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n对于 `sx-k8s-node6`，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。\n\n![shutdown](../image/云笔记系统扩容/shutdown.png)\n\n然后右键 `sx-k8s-node6`，点设置\n\n![setting](../image/云笔记系统扩容/setting.png)\n\n点击硬盘后点击右下角扩展\n\n![expand](../image/云笔记系统扩容/expand.png)\n\n对硬盘容量进行修改。\n\n这里原本是 `40G`，我增加了 `50G`后变为了 `90G`。\n\n`sx-k8s-node7`的操作类似，不再赘述。\n\n此时打开网址，访问成功！扩容成功！\n\n## 访问\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n\n账号：姓名小写拼音\n\n密码：123456\n\n效果：\n\n![6](../image/云笔记系统扩容/6.png)\n","source":"_posts/云笔记系统扩容.md","raw":"---\ntitle: 云笔记系统扩容\ntags:\n  - k8s\n  - Kubernetes\n  - 教程\ncategories:\n  - Kubernetes\nkeywords:\n  - k8s\ndescription: 对k8s服务器上部署的云笔记系统进行扩容\nabbrlink: 36313\ndate: 2023-09-20 14:50:58\nupdated: 2023-09-20 15:00:00\ntop_img: https://s2.loli.net/2024/02/06/MemxlCZb8nKTBXp.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/ENM4lTRwfKyOtJB.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n### 起因\n\n之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 `mysql`和存储笔记信息的 `mongodb`在部署的时候我都设置了 `1G`的存储卷，这是远远不够的，因此需对其进行扩容。\n\n根据老师要求，需将内存从 `1G`扩展到  `50G`，这是针对存笔记系统的 `mongodb`，为了更加稳妥，跟学弟协商后决定将存用户数据的 `mysql`也扩充到 `10G`。\n\n### 大体思路：\n\n1. 确定 `mongodb`和 `mysql`的 `pod`所在的 `node`节点。\n2. 备份数据\n3. 删除旧的 `pod`\n4. 分别修改 `mongodb`和 `mysql`的 `pv`、 `pvc`为 `50Gi`、 `10Gi`。\n5. 指定 `mongodb`和 `mysql`的 `pv`、 `pvc`及 `mongodb`、 `mysql`部署的亲和性，让其部署在指定 `node`节点，便于扩容。\n6. 重新部署相应 `pod`\n7. 扩容指定的 `mongodb`、 `mysql`部署的节点的虚拟机。\n\n> 注：本笔记图片里的 `deployment`的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。\n\n## 1. 确定pod所在的node节点\n\n首先远程连接 `131`服务器。\n\n云笔记系统有 `6`个 `pod`，在 `note`空间里，如下所示：\n\n```bash\nkubectl get pod -n note\n```\n\n![pod](../image/云笔记系统扩容/pod.png)\n\n需确定 `mongodb`、 `mysql`所在的 `node`节点，命令如下：\n\n```bash\nkubectl get pod -n note -o wide\n```\n\n![pod-node](../image/云笔记系统扩容/pod-node.png)\n\n由上图可知， `mongodb`和 `mysql`的 `pod`分别被部署到了 `k8s-node6`、 `k8s-node7`节点。\n\n## 2. 备份数据\n\n问学长得知， `k8s-node6`、 `k8s-node7`节点位于 `122`服务器\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，登录 `node6`节点：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n账号密码为 `root 123456`，登陆后如下：\n\n![login](../image/云笔记系统扩容/login.png)\n\n按下面命令将数据拷贝到 `tmp/backup`文件夹下进行备份：\n\n![backup](../image/云笔记系统扩容/backup.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n为了保险起见，使用 `xShell`中的 `xftp`将备份的文件再备份到桌面一份：\n\n![xftp](../image/云笔记系统扩容/xftp.png)\n\n打开 `xshell`点击新建文件传输，将 `/home`下的 `mongodb`文件夹拖动到桌面。\n\n![backup-desktop](../image/云笔记系统扩容/backup-desktop.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n## 3. 删除旧的pod\n\n删除旧的 `pod`：\n\n```yaml\nkubectl delete -f note-mysql-pvc.yaml -n note\nkubectl delete -f note-mysql.yaml -n note\nkubectl delete -f note-mongodb-pvc.yaml -n note\nkubectl delete -f note-mongodb.yaml -n note\n```\n\n![delete-pod](../image/云笔记系统扩容/delete-pod.png)\n\n此时查看 `pod`结果：\n\n```yaml\nkubectl get pod -n note\n```\n\n![pod-after-deleted](../image/云笔记系统扩容/pod-after-deleted.png)\n\n`mongodb`和 `mysql`的 `pod`已经被删掉。\n\n## 4. 修改pv、pvc\n\n将相关的 `yaml`文件修改为如下内容：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`yaml`文件里已经将内存修改为目标内存。\n\n## 5. 指定亲和性\n\n这里的亲和性是 `Affinity`，指定了这个后会让其部署在指定标签的 `node`节点上。这样仅需将指定的 `node`节点的虚拟机扩容即可。\n\n首先需要为 `node`节点添加标签。如下所示：\n\n```bash\nkubectl get nodes --show-labels\n\n# 为节点6和7添加label\nkubectl label nodes k8s-node6 notelabel=mongodb\nkubectl label nodes k8s-node7 notelabel=mysql\n```\n\n![add-labels](../image/云笔记系统扩容/add-labels.png)\n\n指定完标签就可以添加亲和性了，如下：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mongodb\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mysql\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`note-mongodb.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mongodb\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n`note-mysql.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mysql-pod\n  template:\n    metadata:\n      labels:\n        app: note-mysql-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mysql\n      containers:\n        - name: note-mysql\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: MYSQL_ROOT_PASSWORD\n              value: dfa6f1b032ee42ed95d12647225f2ff4\n          ports:\n            - containerPort: 3306\n          volumeMounts:\n            - name: note-mysql-persistent-storage\n              mountPath: /var/lib/mysql\n      volumes:\n        - name: note-mysql-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n    app: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n    nodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n    targetPort: 3306\n```\n\n这样，亲和性就修改完毕了。\n\n## 6. 重新部署相应的pod\n\n接下来按 `5. 指定亲和性` 所修改的 `yaml`重新进行 `pod`部署：\n\n```yaml\nkubectl create -f note-mysql-pvc.yaml -n note\nkubectl create -f note-mysql.yaml -n note\nkubectl create -f note-mongodb-pvc.yaml -n note\nkubectl create -f note-mongodb.yaml -n note\n```\n\n![pod-deploy](../image/云笔记系统扩容/pod-deploy.png)\n\n查看部署的结果：\n\n```yaml\nkubectl get pod -n note -o wide\n```\n\n![pod-after-deploy](../image/云笔记系统扩容/pod-after-deploy.png)\n\n可以看到已经将 `mongodb`和 `mysql`分别部署到了节点 `6`和 `7`上。\n\n## 7. 扩容节点的虚拟机\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，如下：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n对于 `sx-k8s-node6`，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。\n\n![shutdown](../image/云笔记系统扩容/shutdown.png)\n\n然后右键 `sx-k8s-node6`，点设置\n\n![setting](../image/云笔记系统扩容/setting.png)\n\n点击硬盘后点击右下角扩展\n\n![expand](../image/云笔记系统扩容/expand.png)\n\n对硬盘容量进行修改。\n\n这里原本是 `40G`，我增加了 `50G`后变为了 `90G`。\n\n`sx-k8s-node7`的操作类似，不再赘述。\n\n此时打开网址，访问成功！扩容成功！\n\n## 访问\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n\n账号：姓名小写拼音\n\n密码：123456\n\n效果：\n\n![6](../image/云笔记系统扩容/6.png)\n","slug":"云笔记系统扩容","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1q000qr7gnade15vig","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p>\n<p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p>\n<h3 id=\"大体思路：\"><a href=\"#大体思路：\" class=\"headerlink\" title=\"大体思路：\"></a>大体思路：</h3><ol>\n<li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li>\n<li>备份数据</li>\n<li>删除旧的 <code>pod</code></li>\n<li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li>\n<li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li>\n<li>重新部署相应 <code>pod</code></li>\n<li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li>\n</ol>\n<blockquote>\n<p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p>\n</blockquote>\n<h2 id=\"1-确定pod所在的node节点\"><a href=\"#1-确定pod所在的node节点\" class=\"headerlink\" title=\"1. 确定pod所在的node节点\"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p>\n<p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png\" alt=\"pod\"></p>\n<p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png\" alt=\"pod-node\"></p>\n<p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p>\n<h2 id=\"2-备份数据\"><a href=\"#2-备份数据\" class=\"headerlink\" title=\"2. 备份数据\"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p>\n<p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>账号密码为 <code>root 123456</code>，登陆后如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png\" alt=\"login\"></p>\n<p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png\" alt=\"backup\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png\" alt=\"xftp\"></p>\n<p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png\" alt=\"backup-desktop\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<h2 id=\"3-删除旧的pod\"><a href=\"#3-删除旧的pod\" class=\"headerlink\" title=\"3. 删除旧的pod\"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png\" alt=\"delete-pod\"></p>\n<p>此时查看 <code>pod</code>结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png\" alt=\"pod-after-deleted\"></p>\n<p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p>\n<h2 id=\"4-修改pv、pvc\"><a href=\"#4-修改pv、pvc\" class=\"headerlink\" title=\"4. 修改pv、pvc\"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>yaml</code>文件里已经将内存修改为目标内存。</p>\n<h2 id=\"5-指定亲和性\"><a href=\"#5-指定亲和性\" class=\"headerlink\" title=\"5. 指定亲和性\"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p>\n<p>首先需要为 <code>node</code>节点添加标签。如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为节点6和7添加label</span></span><br><span class=\"line\">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class=\"line\">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png\" alt=\"add-labels\"></p>\n<p>指定完标签就可以添加亲和性了，如下：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mongodb.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，亲和性就修改完毕了。</p>\n<h2 id=\"6-重新部署相应的pod\"><a href=\"#6-重新部署相应的pod\" class=\"headerlink\" title=\"6. 重新部署相应的pod\"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png\" alt=\"pod-deploy\"></p>\n<p>查看部署的结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span> <span class=\"string\">-o</span> <span class=\"string\">wide</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png\" alt=\"pod-after-deploy\"></p>\n<p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p>\n<h2 id=\"7-扩容节点的虚拟机\"><a href=\"#7-扩容节点的虚拟机\" class=\"headerlink\" title=\"7. 扩容节点的虚拟机\"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png\" alt=\"shutdown\"></p>\n<p>然后右键 <code>sx-k8s-node6</code>，点设置</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png\" alt=\"setting\"></p>\n<p>点击硬盘后点击右下角扩展</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png\" alt=\"expand\"></p>\n<p>对硬盘容量进行修改。</p>\n<p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p>\n<p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p>\n<p>此时打开网址，访问成功！扩容成功！</p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a></p>\n<p>账号：姓名小写拼音</p>\n<p>密码：123456</p>\n<p>效果：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png\" alt=\"6\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p>\n<p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p>\n<h3 id=\"大体思路：\"><a href=\"#大体思路：\" class=\"headerlink\" title=\"大体思路：\"></a>大体思路：</h3><ol>\n<li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li>\n<li>备份数据</li>\n<li>删除旧的 <code>pod</code></li>\n<li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li>\n<li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li>\n<li>重新部署相应 <code>pod</code></li>\n<li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li>\n</ol>\n<blockquote>\n<p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p>\n</blockquote>\n<h2 id=\"1-确定pod所在的node节点\"><a href=\"#1-确定pod所在的node节点\" class=\"headerlink\" title=\"1. 确定pod所在的node节点\"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p>\n<p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png\" alt=\"pod\"></p>\n<p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png\" alt=\"pod-node\"></p>\n<p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p>\n<h2 id=\"2-备份数据\"><a href=\"#2-备份数据\" class=\"headerlink\" title=\"2. 备份数据\"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p>\n<p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>账号密码为 <code>root 123456</code>，登陆后如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png\" alt=\"login\"></p>\n<p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png\" alt=\"backup\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png\" alt=\"xftp\"></p>\n<p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png\" alt=\"backup-desktop\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<h2 id=\"3-删除旧的pod\"><a href=\"#3-删除旧的pod\" class=\"headerlink\" title=\"3. 删除旧的pod\"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png\" alt=\"delete-pod\"></p>\n<p>此时查看 <code>pod</code>结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png\" alt=\"pod-after-deleted\"></p>\n<p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p>\n<h2 id=\"4-修改pv、pvc\"><a href=\"#4-修改pv、pvc\" class=\"headerlink\" title=\"4. 修改pv、pvc\"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>yaml</code>文件里已经将内存修改为目标内存。</p>\n<h2 id=\"5-指定亲和性\"><a href=\"#5-指定亲和性\" class=\"headerlink\" title=\"5. 指定亲和性\"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p>\n<p>首先需要为 <code>node</code>节点添加标签。如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为节点6和7添加label</span></span><br><span class=\"line\">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class=\"line\">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png\" alt=\"add-labels\"></p>\n<p>指定完标签就可以添加亲和性了，如下：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mongodb.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，亲和性就修改完毕了。</p>\n<h2 id=\"6-重新部署相应的pod\"><a href=\"#6-重新部署相应的pod\" class=\"headerlink\" title=\"6. 重新部署相应的pod\"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png\" alt=\"pod-deploy\"></p>\n<p>查看部署的结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span> <span class=\"string\">-o</span> <span class=\"string\">wide</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png\" alt=\"pod-after-deploy\"></p>\n<p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p>\n<h2 id=\"7-扩容节点的虚拟机\"><a href=\"#7-扩容节点的虚拟机\" class=\"headerlink\" title=\"7. 扩容节点的虚拟机\"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png\" alt=\"shutdown\"></p>\n<p>然后右键 <code>sx-k8s-node6</code>，点设置</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png\" alt=\"setting\"></p>\n<p>点击硬盘后点击右下角扩展</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png\" alt=\"expand\"></p>\n<p>对硬盘容量进行修改。</p>\n<p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p>\n<p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p>\n<p>此时打开网址，访问成功！扩容成功！</p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a></p>\n<p>账号：姓名小写拼音</p>\n<p>密码：123456</p>\n<p>效果：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png\" alt=\"6\"></p>\n"},{"title":"前端&移动端面经","keywords":["面经"],"description":"前端&移动端面经","abbrlink":17767,"date":"2024-05-27T12:14:47.000Z","updated":"2024-05-27T12:58:53.000Z","top_img":"https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\nthis is a test file.\n","source":"_posts/前端-移动端面经.md","raw":"---\ntitle: 前端&移动端面经\ntags:\n  - 前端\n  - 移动端\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 前端&移动端面经\nabbrlink: 17767\ndate: 2024-05-27 20:14:47\nupdated: 2024-05-27 20:58:53\ntop_img: https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\nthis is a test file.\n","slug":"前端-移动端面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1r000vr7gn0ai7elpr","content":"<p>this is a test file.</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<p>this is a test file.</p>\n"},{"title":"手撕相关","keywords":["面经"],"description":"手撕代码技巧","abbrlink":17772,"date":"2024-06-13T08:18:26.000Z","updated":"2024-06-25T08:46:24.000Z","top_img":"https://s2.loli.net/2024/06/13/YBqXTWpEVFg6hSl.png","comments":1,"cover":"https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n## 经典题型\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n    - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n    - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 有序链表合并\n```java\nListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    // 虚拟头结点\n    ListNode dummy = new ListNode(-1), p = dummy;\n    ListNode p1 = l1, p2 = l2;\n    while (p1 != null && p2 != null) {\n        // 比较 p1 和 p2 两个指针\n        // 将值较小的的节点接到 p 指针\n        if (p1.val > p2.val) {\n            p.next = p2;\n            p2 = p2.next;\n        } else {\n            p.next = p1;\n            p1 = p1.next;\n        }\n        // p 指针不断前进\n        p = p.next;\n    }\n    if (p1 != null) {\n        p.next = p1;\n    }\n    if (p2 != null) {\n        p.next = p2;\n    }\n    return dummy.next;\n}\n```\n\n\n\n### 反转整个链表\n- 递归法\n\n```java\n// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点\nListNode reverse(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    ListNode last = reverse(head.next); // 除了头结点外，反转其余结点，last 为新的头结点\n    head.next.next = head; // 其余节点反转好了，将反转后的链表的尾结点指向头节点\n    head.next = null; // 头结点原本指向第二个元素，现在指向空节点\n    return last; // 返回新的头结点\n}\n```\n\n### 反转部分链表\n- 迭代法\n\n```java\nListNode successor = null; // 后驱节点\nListNode reverseBetween(ListNode head, int m, int n) {\n    // base case\n    if (m == 1) {\n        return reverse(head, n);\n    }\n    // 前进到反转的起点触发 base case\n    head.next = reverseBetween(head.next, m - 1, n - 1);\n    return head;\n}\n\n// 反转以 head 为起点的 n 个节点，返回新的头结点\nListNode reverse(ListNode head, int n) {\n    if (n == 1) {\n        // 记录第 n + 1 个节点\n        successor = head.next;\n        return head;\n    }\n    // 以 head.next 为起点，需要反转前 n - 1 个节点\n    ListNode last = reverse(head.next, n - 1);\n    head.next.next = head;\n    // 让反转之后的 head 节点和后面的节点连起来\n    head.next = successor;\n    return last;\n}\n```\n### LRU缓存\n```java\nclass LRUCache {\n\n    // 缓存的容量\n    private int cap;\n    // 用LinkedHashMap作为cache，尾部为新使用过的数据，头部为未使用过的数据。\n    private LinkedHashMap<Integer, Integer> cache;\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        cache = new LinkedHashMap<>();\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n        makeNew(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n        makeNew(key);\n\n        if (cache.size() > this.cap) {\n            // 头部的元素是最老的\n            int head = cache.keySet().iterator().next();\n            cache.remove(head);\n        }\n    }\n\n    // 让key变为新使用的数据\n    private void makeNew(int key) {\n        int value = cache.get(key);\n        cache.remove(key);\n        // 将key添加到LinkedHashMap尾部\n        cache.put(key, value);\n    }\n}\n\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n\n    public static void main(String[] args) {\n        LRUCache<Integer, String> lruCache = new LRUCache<>(5);\n        lruCache.put(1, \"apple\");\n        lruCache.put(2, \"banana\");\n        lruCache.put(3, \"pear\");\n        lruCache.put(4, \"watermelon\");\n        lruCache.put(5, \"peach\");\n        System.out.println(lruCache);\n        lruCache.put(6, \"orange\");\n        System.out.println(lruCache);\n        lruCache.get(4);\n        System.out.println(lruCache);\n    }\n\n}\n```\n\n### 排序算法\n> 链接：https://learn.skyofit.com/archives/1291\n\n**复杂度**\n![排序算法总结](./image/Hand-Torn-Code/20230615083937874.png)\n\n概念：\n- 稳定：如果a原本在b前面且a=b，排序之后a仍然在b的前面。\n- 不稳定：如果a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。\n- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\n- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\n- In-Place：占用常数内存，不占用额外内存。比如：程序里没有创建新数组来保存数据，只用了临时变量。\n- Out-Place：占用额外内存。比如：创建了新的数组来保存或者处理数据。\n\n#### 冒泡排序\n**基本思想**\n冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。\n\n**算法描述**\n1. 比较相邻的元素。如果前一个比后一个大，就交换它们两个；\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n3. 针对所有的元素重复以上的步骤，除了最后一个；\n4. 重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。\n\n```java\npublic static int[] bubbleSort(int[] array) {\n    if (array.length == 0)\n        return array;\n    for (int i = 0; i < array.length; i++){  //外层循环一次为一趟排序\n        /*设置标识，判断这趟排序是否发生了交换。\n       如果未发生交换，则说明数组已经有序，不必再排序了*/\n        boolean isSwap = false;\n        //内层循环一次为一次相邻比较\n        for (int j = 0; j < array.length - 1 - i; j++) {\n            if (array[j + 1] < array[j]) {\n                int temp = array[j + 1];\n                array[j + 1] = array[j];\n                array[j] = temp;\n                isSwap = true;\n            }\n        }\n        if (!isSwap)\n            break;\n    }\n    return array;\n}\n```\n\n- 时间复杂度：冒泡排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。\n- 最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) / 2和 3 * n * (n-1) / 2。因此最坏情况下的时间复杂度为O(n2)。\n- 空间复杂度：冒泡排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。\n\n> 拓展：鸡尾酒排序\n> 又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。\n> ```java\n> public static void cocktailSort(int[] array) {\n>    int left = 0,right = array.length-1;\n>    while(left < right) {\n>        for(int i = left; i < right; i++)\n>          if(array[i] > array[i+1])\n>                swap(array,i,i + 1);\n>        right--;\n>        for(int i = right; i > left; i--)\n>          if(array[i] < array[i-1])\n>                swap(array,i,i-1);\n>        left++;\n>    }\n> }\n> ```\n> 鸡尾酒排序是稳定的。它的平均时间复杂度为O(n2)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n2)。空间复杂度为O(1)。\n\n#### 选择排序\n**基本思想**\n简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n**算法描述**\nn个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：\n1. 初始状态：无序区为R[1..n]，有序区为空； \n2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n3. (n-1)趟结束，数组有序化了。\n\n```java\npublic static int[] selectionSort(int[] array) {\n    if (array.length == 0)\n         return array;\n    for (int i = 0; i < array.length; i++) {\n        int minIndex = i;\n        for (int j = i; j < array.length; j++) {\n            if (array[j] < array[minIndex]) //找到最小的数\n                minIndex = j; //将最小数的索引保存\n        }\n        int temp = array[minIndex]; //将最小数和无序区的第一个数交换\n        array[minIndex] = array[i];\n        array[i] = temp;\n    }\n    return array;\n}\n```\n- 时间复杂度：简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n – 1) / 2 次比较。\n- 最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n – 1) / 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n – 1)次。\n  - 需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。\n- 空间复杂度：简单选择排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。\n\n#### 直接插入排序\n**基本思想**\n直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n**算法描述**\n一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：\n1. 从第一个元素开始，该元素可以认为已经被排序；\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n5. 将新元素插入到该位置后；\n6. 重复步骤2~5。\n\n```java\npublic static int[] insertionSort(int[] array) {\n    if (array.length == 0)\n        return array;\n    int current;\n    for (int i = 1; i < array.length; i++) {\n        current = array[i];\n        int preIndex = i - 1;\n        while (preIndex >= 0 && current < array[preIndex]) {\n            array[preIndex + 1] = array[preIndex];\n            preIndex--;\n        }\n        array[preIndex + 1] = current;\n    }\n    return array;\n}\n```\n- 时间复杂度：直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。\n- 最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) / 2和 n * (n – 1) / 2。因此最坏情况下的时间复杂度为O(n2)。\n- 空间复杂度：直接插入排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：直接插入排序是稳定的。\n\n> 拓展：在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。\n> ```java\n> public static int[] BinaryInsertionSort(int[] array) {\n>     if (array.length == 0)\n>         return array;\n>     for(int i = 1;i < array.length;i++) {\n>         int left = 0;\n>         int right = i - 1;  // left 和 right 分别为有序区的左右边界 \n>         int current = array[i];\n>         while (left <= right) {\n>             //搜索有序区中第一个大于 current 的位置，即为 current 要插入的位置\n>             int mid = left + ((right - left) >> 1);\n>             if(array[mid] > current){\n>                 right = mid - 1;\n>             }else{\n>                 left = mid + 1;\n>             }\n>         }\n>         for(int j = i - 1;j >= left;j--) {\n>             array[j + 1] = array[j];\n>         }\n>         array[left] = current; // left 为第一个大于 current 的位置，插入 current\n>     }\n>     return array;\n> }\n> ```\n> 二分插入排序是稳定的。它的平均时间复杂度是O(n2)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。\n\n#### 希尔排序\n**基本思想**\n1959年Shell发明，第一个突破O(n2)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n\n**算法描述**\n先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。\n\n```java\npublic static int[] ShellSort(int[] array) {\n    int len = array.length;\n    if(len == 0)\n        return array;\n    int current, gap = len / 2;\n    while (gap > 0) {\n        for (int i = gap; i < len; i++) {\n            current = array[i];\n            int preIndex = i - gap;\n            while (preIndex >= 0 && array[preIndex] > current) {\n                array[preIndex + gap] = array[preIndex];\n                preIndex -= gap;\n            }\n            array[preIndex + gap] = current;\n        }\n        gap /= 2;\n    }\n    return array;\n}\n```\n- 时间复杂度：希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。\n- 空间复杂度：希尔排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。\n\n#### 归并排序\n**基本思想**\n归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n**算法描述**\n1. 把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；\n2. 对这两个子序列分别采用归并排序；\n3. 将两个排序好的子序列合并成一个最终的排序序列。\n\n```java\n// 归并排序\npublic static int[] MergeSort(int[] array) {\n    if (array.length < 2) return array;\n    int mid = array.length / 2;\n    int[] left = Arrays.copyOfRange(array, 0, mid);\n    int[] right = Arrays.copyOfRange(array, mid, array.length);\n    return merge(MergeSort(left), MergeSort(right));\n}\n// 将两段有序数组结合成一个有序数组\npublic static int[] merge(int[] left, int[] right) {\n   int[] result = new int[left.length + right.length];\n   int i = 0,j = 0,k = 0;\n   while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result[k++] = left[i++];\n        } else {\n            result[k++] = right[j++];\n        }\n    }\n    while (i < left.length) {\n        result[k++] = left[i++];\n    }\n    while (j < right.length) {\n        result[k++] = right[j++];\n    }\n    return result;\n}\n```\n- 时间复杂度：归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。\n- 空间复杂度：归并排序空间复杂度为O(n)\n- 稳定性：归并排序是稳定的。\n\n#### 快速排序\n**基本思想**\n快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n**算法描述**\n快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：\n1. 从数列中挑出一个元素，称为 “基准”（pivot）；\n2. 重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；\n3. 递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。\n\n**代码实现**\n快速排序最核心的步骤就是partition操作，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。\n\n两种方法：左右指针法、挖坑法\n左右指针法：\n1. 将数组的最后一个数 right 作为基准数 key。\n2. 分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin >= end 终止遍历。最后将 begin（此时begin == end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）\n3. 再对左右区间重复第二步，直到各区间只有一个数。\n![左右指针法](./image/Hand-Torn-Code/20230615085001544.png)\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        int[] a = {3, 5, 8, 1, 2, 9, 4, 7, 6};\n        sort(a, 0, a.length - 1);\n        for(int i = 0; i < a.length; i++){\n            System.out.print(a[i] + \",\");\n        }\n    }\n    // left 数列左边界 right 数列右边界\n    public static void sort(int[] array,int left,int right) {\n        int p = left;\n        int q = right;\n        int key = right;\n        if(left >= right)\n            return;\n        while( p < q ) {\n            //p找大\n            while(p < q && array[p] <= array[key])\n                p++;\n            //q找小\n            while(p < q && array[q] >= array[key])\n                q--;\n            if(p < q)\n                swap(array, p, q);\n        }\n        swap(array, p, key);\n        sort(array, left, p - 1);\n        sort(array, q + 1, right);\n    }\n    // 交换数组内两个元素\n    public static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}\n```\n挖坑法：\n1. 定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。\n2. left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。\n![挖坑法](./image/Hand-Torn-Code/20230615085019913.png)\n```java\n// 快速排序方法 left 数列左边界 right 数列右边界\npublic static void Quicksort(int array[], int left, int right) {\n    if (left < right){\n        int pos = partition(array, left, right);\n        Quicksort(array, left, pos - 1);\n        Quicksort(array, pos + 1, right);\n    }\n}\n// partition操作\npublic static int partition(int[] array,int left,int right) {\n    int key = array[right];//初始坑\n    while(left < right) {\n        //left找大\n        while(left < right && array[left] <= key )\n            left++;\n        array[right] = array[left];//赋值，然后left作为新坑\n        //right找小\n        while(left <right && array[right] >= key)\n            right--;\n        array[left] = array[right];//right作为新坑\n    }\n    array[left] = key;\n    /*将key赋值给left和right的相遇点，保持key的左边都是比key小的数，key的右边都是比key大的数*/\n    return left;//最终返回基准\n} \n```\n##### 优化\n之前选择基准的策略都是固定基准，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n2)）。\n\n**优化一：随机基准**\n每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。\n只需要在 partition 函数前增加如下操作即可：\n```java\n//随机选择 left ~ right 之间的一个位置作为基准\nint random = (int) (left + Math.random() * (right - left + 1));\n//把基准值交换到右边界\nswap(array, random, right);\n```\n**优化二：三数取中法**\n取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。\n\n举个例子，对于int[] array = { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N/2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。\n\n实现getMid函数即可：\n```java\n// 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准\npublic static int getMid(int[] array,int left,int right) {\n    int mid = left + ((right - left) >> 1);\n    int a = array[left];\n    int b = array[mid];\n    int c = array[right];\n    if ((b <= a && a <= c) || (c <= a && a <= b)) { //a为中间值\n        return left;\n    }\n    if ((a <= b && b <= c) || (c <= b && b <= a)) { //b为中间值\n        return mid;\n    }\n    if ((a <= c && c <= b) || (b <= c && c <= a)) { //c为中间值\n        return right;\n    }\n    return left;\n}\n```\n**优化三：当待排序序列的长度分割到一定大小后，使用插入排序**\n在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。\n\n实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。\n\n此时QuickSort()函数如下：\n```java\npublic static void Quicksort(int array[], int left, int right) {\n    if(right - left > 5){\n        int pos = partition(array, left, right);\n        Quicksort(array, left, pos - 1);\n        Quicksort(array, pos + 1, right);\n    }else{\n        insertionSort(array);\n    }\n}\n```\n**优化四：三路划分**\n如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。\n\n三路划分的思想是利用 partition 函数将待排序列划分为三部分：第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。这样在递归排序区间的时候，我们就不必再对第二部分元素均相等的区间进行快排了，这在待排序列存在大量相同元素的情况下能大大提高快排效率。\n![三路划分示意图](./image/Hand-Torn-Code/20230615085141896.png)\n\n红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。\n\nleft 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。\n\n算法思路：\n1. 由于最初红色和蓝色区域没有元素，初始化 less = left – 1，more = right + 1，cur = left。整个区间为未知部分（白色）。\n2. 如果当前 array[cur] < v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。\n3. 如果当前 array[cur] = v，则不必交换，直接 cur++\n4. 如果当前 array[cur] > v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。\n\n```java\npublic static int[] partition(int[] array,int left,int right){\n    int v = array[right]; //选择右边界为基准\n    int less = left - 1; // < v 部分的最后一个数\n    int more = right + 1; // > v 部分的第一个数\n    int cur = left;\n    while(cur < more){\n        if(array[cur] < v){\n            swap(array,++less,cur++);\n        }else if(array[cur] > v){\n            swap(array,--more,cur);\n        }else{\n            cur++;\n        }\n    }\n    return new int[]{less + 1,more - 1};  //返回的是 = v 区域的左右下标\n}\npublic static void Quicksort(int array[], int left, int right) {\n    if (left < right) {\n        int[] p = partition(array,left,right);\n        Quicksort(array,left,p[0] - 1); //避开重复元素区间\n        Quicksort(array,p[1] + 1,right);\n    }\n}\n```\n- 时间复杂度：快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。\n- 最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。\n- 最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左（右）结点的树，树的深度为 n，时间复杂度为O(n2)。\n- 空间复杂度：快速排序的空间复杂度主要考虑递归时使用的栈空间。在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。\n- 稳定性：快速排序是不稳定的。\n\n#### 堆排序\n**基本思想**\n堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。\n\n**算法描述**\n1. 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。\n\n```java\n//声明全局变量，用于记录数组array的长度；\nstatic int len;\n// 堆排序算法\npublic static int[] HeapSort(int[] array) {\n        len = array.length;\n        if (len == 0) return array;\n        //1.构建一个大根堆\n        buildMaxHeap(array);\n        //2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆\n        while (len > 0) {\n            swap(array, 0, len - 1);\n            len--; //原先的堆尾进入有序区，删除堆尾元素\n            adjustHeap(array, 0); //重新调整大根堆\n        }\n        return array;\n }\n// 自顶向下调整以 i 为根的堆为大根堆\npublic static void adjustHeap(int[] array, int i) {\n        int maxIndex = i;\n        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树\n        if (2 * i + 1 < len && array[2 * i + 1] > array[maxIndex])\n            maxIndex = 2 * i + 1;\n        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树\n        if (2 * i + 2 < len && array[2 * i + 2] > array[maxIndex])\n            maxIndex = 2 * i + 2;\n        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。\n        if (maxIndex != i) {\n            swap(array, maxIndex, i);\n            adjustHeap(array, maxIndex);\n        }\n }\n // 自底向上构建初始大根堆\n public static void buildMaxHeap(int[] array) {\n        //从最后一个非叶子节点开始自底向上构造大根堆\n        for (int i = (len - 2) / 2; i >= 0; i--) {\n            adjustHeap(array, i);\n        }\n }\n```\n- 拓展： \n  - 插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。\n  - 删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。\n- 时间复杂度：堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。\n- 空间复杂度：堆排序使用了常数空间，空间复杂度为O(1)。\n- 稳定性：堆排序是不稳定的。\n\n#### 计数排序\n**基本思想**\n计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n**算法描述**\n1. 找出待排序的数组中最大和最小的元素；\n2. 统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；\n3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n4. 反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n\n```java\npublic static int[] CountingSort(int[] array) {\n    if (array.length == 0) return array;\n    int bias, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n        max = Math.max(max, array[i]);\n        min = Math.min(min, array[i]);\n    }\n   //计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上\n    bias = -min;\n    int[] bucket = new int[max - min + 1];\n    Arrays.fill(bucket, 0);\n    for (int i = 0; i < array.length; i++) {\n        bucket[array[i] + bias]++;\n    }\n    int index = 0, i = 0;\n    while (index < array.length) {\n        if (bucket[i] != 0) {\n            array[index] = i - bias;\n            bucket[i]--;\n            index++;\n        } else\n            i++;\n    }\n    return array;\n}\n```\n- 时间复杂度：计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。\n- 空间复杂度：计数排序空间复杂度为O(k)，k为桶数组的长度。\n- 稳定性：计数排序是稳定的。\n\n#### 桶排序\n**基本思想**\n桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i < j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i – min) / arr.length。\n\n**算法描述**\n1. 设置一个定量的数组当作空桶；\n2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n3. 对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；\n4. 从不是空的桶里把排好序的数据拼接起来。\n\n```java\npublic static int[] bucketSort(int[] array){\n    int max = Integer.MIN_VALUE;\n    int min = Integer.MAX_VALUE;\n    for(int i = 0; i < array.length; i++){\n        max = Math.max(max, array[i]);\n        min = Math.min(min, array[i]);\n    }\n    /*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i < j）的数，即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/\n    int bucketNum = (max - min) / array.length + 1;\n    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);\n    for(int i = 0; i < bucketNum; i++){\n        bucketArr.add(new ArrayList<Integer>());\n    }\n    //将每个元素放入桶\n    for(int i = 0; i < array.length; i++){\n        int num = (array[i] - min) / (array.length);\n        bucketArr.get(num).add(array[i]);\n    }\n    //对每个桶进行排序\n    for(int i = 0; i < bucketArr.size(); i++){\n        Collections.sort(bucketArr.get(i));\n    }\n   int k = 0;\n   for(int i = 0; i < bucketArr.size(); i++){\n      for(int j = 0;j < bucketArr.get(i).size();j++) {\n           array[k++] = bucketArr.get(i).get(j);\n      }\n  }\n  return array;\n}\n```\n- 时间复杂度：桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。\n- 空间复杂度：桶排序空间复杂度为O(n + k)。\n- 稳定性：桶排序是稳定的。\n\n#### 基数排序\n**基本思想**\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\n\n**算法描述**\n1. 取得数组中的最大数，并取得位数；\n2. array 为原始数组，从最低位开始取每个位组成 radix 数组；\n3. 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；\n\n```java\npublic static int[] RadixSort(int[] array) {\n     if (array == null || array.length < 2)\n        return array;\n        // 1.先算出最大数的位数；\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n            max = Math.max(max, array[i]);\n    }\n    int maxDigit = 0;\n    while (max != 0) {\n            max /= 10;\n            maxDigit++;\n    }\n    int div = 1;\n    ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < 10; i++)\n        bucketList.add(new ArrayList<Integer>());\n        //2.进行maxDigit趟分配\n    for (int i = 0; i < maxDigit; i++,div *= 10) {\n            for (int j = 0; j < array.length; j++) {\n                int num = (array[j] / div) % 10;\n                bucketList.get(num).add(array[j]);\n            }\n        //3.收集\n            int index = 0;\n            for (int j = 0; j < bucketList.size(); j++) {\n                for (int k = 0; k < bucketList.get(j).size(); k++)\n                    array[index++] = bucketList.get(j).get(k);\n                bucketList.get(j).clear();\n            }\n   }\n   return array;\n}\n```\n- 时间复杂度：基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。\n- 空间复杂度：基数排序空间复杂度为O(n + k)。\n- 稳定性：基数排序是稳定的。\n\n### 二分查找\n```\npublic class BinarySearch {\n    public static int binarySearch(int[] array, int target) {\n        int left = 0;\n        int right = array.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2; // 防止整形的(left + right)/2溢出\n            if (array[mid] == target) {\n                return mid;\n            } else if (array[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1; // 未找到目标值\n    }\n    public static void main(String[] args) {\n        int[] array = {1, 3, 5, 7, 9, 11, 13};\n        int target = 7;\n        int result = binarySearch(array, target);\n        System.out.println(\"目标值的索引: \" + result);\n    }\n}\n\n// 递归实现\npublic class BinarySearch {\n    public static int binarySearch(int[] array, int target, int left, int right) {\n        if (left > right) {\n            return -1;\n        }\n\n        int mid = left + (right - left) / 2;\n        if (array[mid] == target) {\n            return mid;\n        } else if (array[mid] < target) {\n            return binarySearch(array, target, mid + 1, right);\n        } else {\n            return binarySearch(array, target, left, mid - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = {1, 3, 5, 7, 9, 11, 13};\n        int target = 7;\n        int result = binarySearch(array, target, 0, array.length - 1);\n        System.out.println(\"目标值的索引: \" + result);\n    }\n}\n```\n### 递归删除文件夹\n```java\nimport java.io.File;\npublic class FileDeleter {\n    public static void main(String[] args) {\n        // 示例：删除路径为\"example\"的文件或目录\n        String path = \"example\";\n        boolean result = deleteRecursively(new File(path));\n        if (result) {\n            System.out.println(\"删除成功: \" + path);\n        } else {\n            System.out.println(\"删除失败: \" + path);\n        }\n    }\n\n    /**\n     * 递归删除文件或目录\n     * @param file 要删除的文件或目录\n     * @return 如果成功删除，则返回true；否则返回false\n     */\n    public static boolean deleteRecursively(File file) {\n        if (!file.exists()) {\n            System.out.println(\"文件不存在: \" + file.getAbsolutePath());\n            return false;\n        }\n        // 如果是目录，则递归删除目录中的内容\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    if (!deleteRecursively(child)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        // 删除文件或空目录\n        return file.delete();\n    }\n}\n```\n### 无重复最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int res = 0;\n        // 滑动窗口\n        HashMap<Character, Integer> window = new HashMap<>();\n        int left = 0, right = 0;\n        while (right < s.length()) {\n            char c = s.charAt(right);\n            // 增大窗口\n            right++;\n            // 窗口变化后对数据进行处理\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            // 是否需要缩小窗口\n            while (window.get(c) > 1) {\n                char d = s.charAt(left);\n                // 缩小窗口\n                left++;\n                // 窗口变化后对数据进行处理\n                window.put(d, window.get(d) - 1);\n            }\n            // 缩小窗口后保证window内没有重复元素\n            res = Math.max(right - left, res);\n        }\n        return res;\n    }\n}\n```\n\n### 二叉树前序遍历转链表\n二叉树的先序遍历，然后按照前序顺序将其转化为一个链表\n```java\npublic class Solution {\n    private static Node trans(TreeNode root) {\n        Node dummy = new Node(-1), p = dummy;\n        traverse(root, p);\n        return dummy.next;\n    }\n    private static void traverse(TreeNode root, Node p) {\n        if (root == null)\n            return ;\n        Node node = new Node(root.val, null);\n        p.next = node;\n        p = p.next;\n        traverse(root.left, p);\n        traverse(root.right, p);\n    }\n}\n```\n\n### 最长重复子串(不会。。。后面有时间再研究吧)\n```java\nclass Solution {\n    public String longestDupSubstring(String s) {\n        Random random = new Random();\n        // 生成两个进制\n        int a1 = random.nextInt(75) + 26;\n        int a2 = random.nextInt(75) + 26;\n        // 生成两个模\n        int mod1 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int mod2 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int n = s.length();\n        // 先对所有字符进行编码\n        int[] arr = new int[n];\n        for (int i = 0; i < n; ++i) {\n            arr[i] = s.charAt(i) - 'a';\n        }\n        // 二分查找的范围是[1, n-1]\n        int l = 1, r = n - 1;\n        int length = 0, start = -1;\n        while (l <= r) {\n            int m = l + (r - l + 1) / 2;\n            int idx = check(arr, m, a1, a2, mod1, mod2);\n            if (idx != -1) {\n                // 有重复子串，移动左边界\n                l = m + 1;\n                length = m;\n                start = idx;\n            } else {\n                // 无重复子串，移动右边界\n                r = m - 1;\n            }\n        }\n        return start != -1 ? s.substring(start, start + length) : \"\";\n    }\n    public int check(int[] arr, int m, int a1, int a2, int mod1, int mod2) {\n        int n = arr.length;\n        long aL1 = pow(a1, m, mod1);\n        long aL2 = pow(a2, m, mod2);\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < m; ++i) {\n            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;\n            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n        }\n        // 存储一个编码组合是否出现过\n        Set<Long> seen = new HashSet<Long>();\n        seen.add(h1 * mod2 + h2);\n        for (int start = 1; start <= n - m; ++start) {\n            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;\n            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n            long num = h1 * mod2 + h2;\n            // 如果重复，则返回重复串的起点\n            if (!seen.add(num)) {\n                return start;\n            }\n        }\n        // 没有重复，则返回-1\n        return -1;\n    }\n    public long pow(int a, int m, int mod) {\n        long ans = 1;\n        long contribute = a;\n        while (m > 0) {\n            if (m % 2 == 1) {\n                ans = ans * contribute % mod;\n                if (ans < 0) {\n                    ans += mod;\n                }\n            }\n            contribute = contribute * contribute % mod;\n            if (contribute < 0) {\n                contribute += mod;\n            }\n            m /= 2;\n        }\n        return ans;\n    }\n}\n```\n\n### CompletableFuture类异步调用实现\n```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // 创建一个CompletableFuture来执行异步任务\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            // 模拟一个长时间运行的任务\n            try {\n                Thread.sleep(2000); // 休眠2秒\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"任务完成\";\n        });\n        // 注册一个回调函数，当任务完成时获取结果\n        future.thenAccept(result -> {\n            System.out.println(\"异步任务结果: \" + result);\n        });\n        // 主线程继续执行其他操作\n        System.out.println(\"主线程继续执行...\");\n        // 阻塞主线程，直到异步任务完成（可选）\n        try {\n            // 这一步会阻塞主线程，直到异步任务完成\n            String result = future.get();\n            System.out.println(\"异步任务完成后获取的结果: \" + result);\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n","source":"_posts/手撕相关.md","raw":"---\ntitle: 手撕相关\ntags:\n  - 手撕技巧\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 手撕代码技巧\nabbrlink: 17772\ndate: 2024-06-13 16:18:26\nupdated: 2024-06-25 16:46:24\ntop_img: https://s2.loli.net/2024/06/13/YBqXTWpEVFg6hSl.png\ncomments:\ncover: https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n## 经典题型\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n    - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n    - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 有序链表合并\n```java\nListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    // 虚拟头结点\n    ListNode dummy = new ListNode(-1), p = dummy;\n    ListNode p1 = l1, p2 = l2;\n    while (p1 != null && p2 != null) {\n        // 比较 p1 和 p2 两个指针\n        // 将值较小的的节点接到 p 指针\n        if (p1.val > p2.val) {\n            p.next = p2;\n            p2 = p2.next;\n        } else {\n            p.next = p1;\n            p1 = p1.next;\n        }\n        // p 指针不断前进\n        p = p.next;\n    }\n    if (p1 != null) {\n        p.next = p1;\n    }\n    if (p2 != null) {\n        p.next = p2;\n    }\n    return dummy.next;\n}\n```\n\n\n\n### 反转整个链表\n- 递归法\n\n```java\n// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点\nListNode reverse(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    ListNode last = reverse(head.next); // 除了头结点外，反转其余结点，last 为新的头结点\n    head.next.next = head; // 其余节点反转好了，将反转后的链表的尾结点指向头节点\n    head.next = null; // 头结点原本指向第二个元素，现在指向空节点\n    return last; // 返回新的头结点\n}\n```\n\n### 反转部分链表\n- 迭代法\n\n```java\nListNode successor = null; // 后驱节点\nListNode reverseBetween(ListNode head, int m, int n) {\n    // base case\n    if (m == 1) {\n        return reverse(head, n);\n    }\n    // 前进到反转的起点触发 base case\n    head.next = reverseBetween(head.next, m - 1, n - 1);\n    return head;\n}\n\n// 反转以 head 为起点的 n 个节点，返回新的头结点\nListNode reverse(ListNode head, int n) {\n    if (n == 1) {\n        // 记录第 n + 1 个节点\n        successor = head.next;\n        return head;\n    }\n    // 以 head.next 为起点，需要反转前 n - 1 个节点\n    ListNode last = reverse(head.next, n - 1);\n    head.next.next = head;\n    // 让反转之后的 head 节点和后面的节点连起来\n    head.next = successor;\n    return last;\n}\n```\n### LRU缓存\n```java\nclass LRUCache {\n\n    // 缓存的容量\n    private int cap;\n    // 用LinkedHashMap作为cache，尾部为新使用过的数据，头部为未使用过的数据。\n    private LinkedHashMap<Integer, Integer> cache;\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        cache = new LinkedHashMap<>();\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n        makeNew(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n        makeNew(key);\n\n        if (cache.size() > this.cap) {\n            // 头部的元素是最老的\n            int head = cache.keySet().iterator().next();\n            cache.remove(head);\n        }\n    }\n\n    // 让key变为新使用的数据\n    private void makeNew(int key) {\n        int value = cache.get(key);\n        cache.remove(key);\n        // 将key添加到LinkedHashMap尾部\n        cache.put(key, value);\n    }\n}\n\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n\n    public static void main(String[] args) {\n        LRUCache<Integer, String> lruCache = new LRUCache<>(5);\n        lruCache.put(1, \"apple\");\n        lruCache.put(2, \"banana\");\n        lruCache.put(3, \"pear\");\n        lruCache.put(4, \"watermelon\");\n        lruCache.put(5, \"peach\");\n        System.out.println(lruCache);\n        lruCache.put(6, \"orange\");\n        System.out.println(lruCache);\n        lruCache.get(4);\n        System.out.println(lruCache);\n    }\n\n}\n```\n\n### 排序算法\n> 链接：https://learn.skyofit.com/archives/1291\n\n**复杂度**\n![排序算法总结](./image/Hand-Torn-Code/20230615083937874.png)\n\n概念：\n- 稳定：如果a原本在b前面且a=b，排序之后a仍然在b的前面。\n- 不稳定：如果a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。\n- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\n- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\n- In-Place：占用常数内存，不占用额外内存。比如：程序里没有创建新数组来保存数据，只用了临时变量。\n- Out-Place：占用额外内存。比如：创建了新的数组来保存或者处理数据。\n\n#### 冒泡排序\n**基本思想**\n冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。\n\n**算法描述**\n1. 比较相邻的元素。如果前一个比后一个大，就交换它们两个；\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n3. 针对所有的元素重复以上的步骤，除了最后一个；\n4. 重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。\n\n```java\npublic static int[] bubbleSort(int[] array) {\n    if (array.length == 0)\n        return array;\n    for (int i = 0; i < array.length; i++){  //外层循环一次为一趟排序\n        /*设置标识，判断这趟排序是否发生了交换。\n       如果未发生交换，则说明数组已经有序，不必再排序了*/\n        boolean isSwap = false;\n        //内层循环一次为一次相邻比较\n        for (int j = 0; j < array.length - 1 - i; j++) {\n            if (array[j + 1] < array[j]) {\n                int temp = array[j + 1];\n                array[j + 1] = array[j];\n                array[j] = temp;\n                isSwap = true;\n            }\n        }\n        if (!isSwap)\n            break;\n    }\n    return array;\n}\n```\n\n- 时间复杂度：冒泡排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。\n- 最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) / 2和 3 * n * (n-1) / 2。因此最坏情况下的时间复杂度为O(n2)。\n- 空间复杂度：冒泡排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。\n\n> 拓展：鸡尾酒排序\n> 又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。\n> ```java\n> public static void cocktailSort(int[] array) {\n>    int left = 0,right = array.length-1;\n>    while(left < right) {\n>        for(int i = left; i < right; i++)\n>          if(array[i] > array[i+1])\n>                swap(array,i,i + 1);\n>        right--;\n>        for(int i = right; i > left; i--)\n>          if(array[i] < array[i-1])\n>                swap(array,i,i-1);\n>        left++;\n>    }\n> }\n> ```\n> 鸡尾酒排序是稳定的。它的平均时间复杂度为O(n2)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n2)。空间复杂度为O(1)。\n\n#### 选择排序\n**基本思想**\n简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n**算法描述**\nn个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：\n1. 初始状态：无序区为R[1..n]，有序区为空； \n2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n3. (n-1)趟结束，数组有序化了。\n\n```java\npublic static int[] selectionSort(int[] array) {\n    if (array.length == 0)\n         return array;\n    for (int i = 0; i < array.length; i++) {\n        int minIndex = i;\n        for (int j = i; j < array.length; j++) {\n            if (array[j] < array[minIndex]) //找到最小的数\n                minIndex = j; //将最小数的索引保存\n        }\n        int temp = array[minIndex]; //将最小数和无序区的第一个数交换\n        array[minIndex] = array[i];\n        array[i] = temp;\n    }\n    return array;\n}\n```\n- 时间复杂度：简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n – 1) / 2 次比较。\n- 最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n – 1) / 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n – 1)次。\n  - 需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。\n- 空间复杂度：简单选择排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。\n\n#### 直接插入排序\n**基本思想**\n直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n**算法描述**\n一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：\n1. 从第一个元素开始，该元素可以认为已经被排序；\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n5. 将新元素插入到该位置后；\n6. 重复步骤2~5。\n\n```java\npublic static int[] insertionSort(int[] array) {\n    if (array.length == 0)\n        return array;\n    int current;\n    for (int i = 1; i < array.length; i++) {\n        current = array[i];\n        int preIndex = i - 1;\n        while (preIndex >= 0 && current < array[preIndex]) {\n            array[preIndex + 1] = array[preIndex];\n            preIndex--;\n        }\n        array[preIndex + 1] = current;\n    }\n    return array;\n}\n```\n- 时间复杂度：直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。\n- 最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。\n- 最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) / 2和 n * (n – 1) / 2。因此最坏情况下的时间复杂度为O(n2)。\n- 空间复杂度：直接插入排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：直接插入排序是稳定的。\n\n> 拓展：在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。\n> ```java\n> public static int[] BinaryInsertionSort(int[] array) {\n>     if (array.length == 0)\n>         return array;\n>     for(int i = 1;i < array.length;i++) {\n>         int left = 0;\n>         int right = i - 1;  // left 和 right 分别为有序区的左右边界 \n>         int current = array[i];\n>         while (left <= right) {\n>             //搜索有序区中第一个大于 current 的位置，即为 current 要插入的位置\n>             int mid = left + ((right - left) >> 1);\n>             if(array[mid] > current){\n>                 right = mid - 1;\n>             }else{\n>                 left = mid + 1;\n>             }\n>         }\n>         for(int j = i - 1;j >= left;j--) {\n>             array[j + 1] = array[j];\n>         }\n>         array[left] = current; // left 为第一个大于 current 的位置，插入 current\n>     }\n>     return array;\n> }\n> ```\n> 二分插入排序是稳定的。它的平均时间复杂度是O(n2)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。\n\n#### 希尔排序\n**基本思想**\n1959年Shell发明，第一个突破O(n2)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n\n**算法描述**\n先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len / 2。\n\n```java\npublic static int[] ShellSort(int[] array) {\n    int len = array.length;\n    if(len == 0)\n        return array;\n    int current, gap = len / 2;\n    while (gap > 0) {\n        for (int i = gap; i < len; i++) {\n            current = array[i];\n            int preIndex = i - gap;\n            while (preIndex >= 0 && array[preIndex] > current) {\n                array[preIndex + gap] = array[preIndex];\n                preIndex -= gap;\n            }\n            array[preIndex + gap] = current;\n        }\n        gap /= 2;\n    }\n    return array;\n}\n```\n- 时间复杂度：希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。\n- 空间复杂度：希尔排序使用了常数空间，空间复杂度为O(1)\n- 稳定性：由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。\n\n#### 归并排序\n**基本思想**\n归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n**算法描述**\n1. 把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；\n2. 对这两个子序列分别采用归并排序；\n3. 将两个排序好的子序列合并成一个最终的排序序列。\n\n```java\n// 归并排序\npublic static int[] MergeSort(int[] array) {\n    if (array.length < 2) return array;\n    int mid = array.length / 2;\n    int[] left = Arrays.copyOfRange(array, 0, mid);\n    int[] right = Arrays.copyOfRange(array, mid, array.length);\n    return merge(MergeSort(left), MergeSort(right));\n}\n// 将两段有序数组结合成一个有序数组\npublic static int[] merge(int[] left, int[] right) {\n   int[] result = new int[left.length + right.length];\n   int i = 0,j = 0,k = 0;\n   while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result[k++] = left[i++];\n        } else {\n            result[k++] = right[j++];\n        }\n    }\n    while (i < left.length) {\n        result[k++] = left[i++];\n    }\n    while (j < right.length) {\n        result[k++] = right[j++];\n    }\n    return result;\n}\n```\n- 时间复杂度：归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。\n- 空间复杂度：归并排序空间复杂度为O(n)\n- 稳定性：归并排序是稳定的。\n\n#### 快速排序\n**基本思想**\n快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n**算法描述**\n快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：\n1. 从数列中挑出一个元素，称为 “基准”（pivot）；\n2. 重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；\n3. 递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。\n\n**代码实现**\n快速排序最核心的步骤就是partition操作，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。\n\n两种方法：左右指针法、挖坑法\n左右指针法：\n1. 将数组的最后一个数 right 作为基准数 key。\n2. 分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin >= end 终止遍历。最后将 begin（此时begin == end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）\n3. 再对左右区间重复第二步，直到各区间只有一个数。\n![左右指针法](./image/Hand-Torn-Code/20230615085001544.png)\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        int[] a = {3, 5, 8, 1, 2, 9, 4, 7, 6};\n        sort(a, 0, a.length - 1);\n        for(int i = 0; i < a.length; i++){\n            System.out.print(a[i] + \",\");\n        }\n    }\n    // left 数列左边界 right 数列右边界\n    public static void sort(int[] array,int left,int right) {\n        int p = left;\n        int q = right;\n        int key = right;\n        if(left >= right)\n            return;\n        while( p < q ) {\n            //p找大\n            while(p < q && array[p] <= array[key])\n                p++;\n            //q找小\n            while(p < q && array[q] >= array[key])\n                q--;\n            if(p < q)\n                swap(array, p, q);\n        }\n        swap(array, p, key);\n        sort(array, left, p - 1);\n        sort(array, q + 1, right);\n    }\n    // 交换数组内两个元素\n    public static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}\n```\n挖坑法：\n1. 定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。\n2. left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。\n![挖坑法](./image/Hand-Torn-Code/20230615085019913.png)\n```java\n// 快速排序方法 left 数列左边界 right 数列右边界\npublic static void Quicksort(int array[], int left, int right) {\n    if (left < right){\n        int pos = partition(array, left, right);\n        Quicksort(array, left, pos - 1);\n        Quicksort(array, pos + 1, right);\n    }\n}\n// partition操作\npublic static int partition(int[] array,int left,int right) {\n    int key = array[right];//初始坑\n    while(left < right) {\n        //left找大\n        while(left < right && array[left] <= key )\n            left++;\n        array[right] = array[left];//赋值，然后left作为新坑\n        //right找小\n        while(left <right && array[right] >= key)\n            right--;\n        array[left] = array[right];//right作为新坑\n    }\n    array[left] = key;\n    /*将key赋值给left和right的相遇点，保持key的左边都是比key小的数，key的右边都是比key大的数*/\n    return left;//最终返回基准\n} \n```\n##### 优化\n之前选择基准的策略都是固定基准，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n2)）。\n\n**优化一：随机基准**\n每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。\n只需要在 partition 函数前增加如下操作即可：\n```java\n//随机选择 left ~ right 之间的一个位置作为基准\nint random = (int) (left + Math.random() * (right - left + 1));\n//把基准值交换到右边界\nswap(array, random, right);\n```\n**优化二：三数取中法**\n取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。\n\n举个例子，对于int[] array = { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N/2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。\n\n实现getMid函数即可：\n```java\n// 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准\npublic static int getMid(int[] array,int left,int right) {\n    int mid = left + ((right - left) >> 1);\n    int a = array[left];\n    int b = array[mid];\n    int c = array[right];\n    if ((b <= a && a <= c) || (c <= a && a <= b)) { //a为中间值\n        return left;\n    }\n    if ((a <= b && b <= c) || (c <= b && b <= a)) { //b为中间值\n        return mid;\n    }\n    if ((a <= c && c <= b) || (b <= c && c <= a)) { //c为中间值\n        return right;\n    }\n    return left;\n}\n```\n**优化三：当待排序序列的长度分割到一定大小后，使用插入排序**\n在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。\n\n实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。\n\n此时QuickSort()函数如下：\n```java\npublic static void Quicksort(int array[], int left, int right) {\n    if(right - left > 5){\n        int pos = partition(array, left, right);\n        Quicksort(array, left, pos - 1);\n        Quicksort(array, pos + 1, right);\n    }else{\n        insertionSort(array);\n    }\n}\n```\n**优化四：三路划分**\n如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。\n\n三路划分的思想是利用 partition 函数将待排序列划分为三部分：第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。这样在递归排序区间的时候，我们就不必再对第二部分元素均相等的区间进行快排了，这在待排序列存在大量相同元素的情况下能大大提高快排效率。\n![三路划分示意图](./image/Hand-Torn-Code/20230615085141896.png)\n\n红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。\n\nleft 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。\n\n算法思路：\n1. 由于最初红色和蓝色区域没有元素，初始化 less = left – 1，more = right + 1，cur = left。整个区间为未知部分（白色）。\n2. 如果当前 array[cur] < v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。\n3. 如果当前 array[cur] = v，则不必交换，直接 cur++\n4. 如果当前 array[cur] > v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。\n\n```java\npublic static int[] partition(int[] array,int left,int right){\n    int v = array[right]; //选择右边界为基准\n    int less = left - 1; // < v 部分的最后一个数\n    int more = right + 1; // > v 部分的第一个数\n    int cur = left;\n    while(cur < more){\n        if(array[cur] < v){\n            swap(array,++less,cur++);\n        }else if(array[cur] > v){\n            swap(array,--more,cur);\n        }else{\n            cur++;\n        }\n    }\n    return new int[]{less + 1,more - 1};  //返回的是 = v 区域的左右下标\n}\npublic static void Quicksort(int array[], int left, int right) {\n    if (left < right) {\n        int[] p = partition(array,left,right);\n        Quicksort(array,left,p[0] - 1); //避开重复元素区间\n        Quicksort(array,p[1] + 1,right);\n    }\n}\n```\n- 时间复杂度：快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。\n- 最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。\n- 最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左（右）结点的树，树的深度为 n，时间复杂度为O(n2)。\n- 空间复杂度：快速排序的空间复杂度主要考虑递归时使用的栈空间。在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。\n- 稳定性：快速排序是不稳定的。\n\n#### 堆排序\n**基本思想**\n堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。\n\n**算法描述**\n1. 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。\n\n```java\n//声明全局变量，用于记录数组array的长度；\nstatic int len;\n// 堆排序算法\npublic static int[] HeapSort(int[] array) {\n        len = array.length;\n        if (len == 0) return array;\n        //1.构建一个大根堆\n        buildMaxHeap(array);\n        //2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆\n        while (len > 0) {\n            swap(array, 0, len - 1);\n            len--; //原先的堆尾进入有序区，删除堆尾元素\n            adjustHeap(array, 0); //重新调整大根堆\n        }\n        return array;\n }\n// 自顶向下调整以 i 为根的堆为大根堆\npublic static void adjustHeap(int[] array, int i) {\n        int maxIndex = i;\n        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树\n        if (2 * i + 1 < len && array[2 * i + 1] > array[maxIndex])\n            maxIndex = 2 * i + 1;\n        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树\n        if (2 * i + 2 < len && array[2 * i + 2] > array[maxIndex])\n            maxIndex = 2 * i + 2;\n        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。\n        if (maxIndex != i) {\n            swap(array, maxIndex, i);\n            adjustHeap(array, maxIndex);\n        }\n }\n // 自底向上构建初始大根堆\n public static void buildMaxHeap(int[] array) {\n        //从最后一个非叶子节点开始自底向上构造大根堆\n        for (int i = (len - 2) / 2; i >= 0; i--) {\n            adjustHeap(array, i);\n        }\n }\n```\n- 拓展： \n  - 插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。\n  - 删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。\n- 时间复杂度：堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。\n- 空间复杂度：堆排序使用了常数空间，空间复杂度为O(1)。\n- 稳定性：堆排序是不稳定的。\n\n#### 计数排序\n**基本思想**\n计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n**算法描述**\n1. 找出待排序的数组中最大和最小的元素；\n2. 统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；\n3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n4. 反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n\n```java\npublic static int[] CountingSort(int[] array) {\n    if (array.length == 0) return array;\n    int bias, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n        max = Math.max(max, array[i]);\n        min = Math.min(min, array[i]);\n    }\n   //计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上\n    bias = -min;\n    int[] bucket = new int[max - min + 1];\n    Arrays.fill(bucket, 0);\n    for (int i = 0; i < array.length; i++) {\n        bucket[array[i] + bias]++;\n    }\n    int index = 0, i = 0;\n    while (index < array.length) {\n        if (bucket[i] != 0) {\n            array[index] = i - bias;\n            bucket[i]--;\n            index++;\n        } else\n            i++;\n    }\n    return array;\n}\n```\n- 时间复杂度：计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。\n- 空间复杂度：计数排序空间复杂度为O(k)，k为桶数组的长度。\n- 稳定性：计数排序是稳定的。\n\n#### 桶排序\n**基本思想**\n桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i < j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i – min) / arr.length。\n\n**算法描述**\n1. 设置一个定量的数组当作空桶；\n2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n3. 对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；\n4. 从不是空的桶里把排好序的数据拼接起来。\n\n```java\npublic static int[] bucketSort(int[] array){\n    int max = Integer.MIN_VALUE;\n    int min = Integer.MAX_VALUE;\n    for(int i = 0; i < array.length; i++){\n        max = Math.max(max, array[i]);\n        min = Math.min(min, array[i]);\n    }\n    /*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i < j）的数，即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/\n    int bucketNum = (max - min) / array.length + 1;\n    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);\n    for(int i = 0; i < bucketNum; i++){\n        bucketArr.add(new ArrayList<Integer>());\n    }\n    //将每个元素放入桶\n    for(int i = 0; i < array.length; i++){\n        int num = (array[i] - min) / (array.length);\n        bucketArr.get(num).add(array[i]);\n    }\n    //对每个桶进行排序\n    for(int i = 0; i < bucketArr.size(); i++){\n        Collections.sort(bucketArr.get(i));\n    }\n   int k = 0;\n   for(int i = 0; i < bucketArr.size(); i++){\n      for(int j = 0;j < bucketArr.get(i).size();j++) {\n           array[k++] = bucketArr.get(i).get(j);\n      }\n  }\n  return array;\n}\n```\n- 时间复杂度：桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。\n- 空间复杂度：桶排序空间复杂度为O(n + k)。\n- 稳定性：桶排序是稳定的。\n\n#### 基数排序\n**基本思想**\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\n\n**算法描述**\n1. 取得数组中的最大数，并取得位数；\n2. array 为原始数组，从最低位开始取每个位组成 radix 数组；\n3. 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；\n\n```java\npublic static int[] RadixSort(int[] array) {\n     if (array == null || array.length < 2)\n        return array;\n        // 1.先算出最大数的位数；\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n            max = Math.max(max, array[i]);\n    }\n    int maxDigit = 0;\n    while (max != 0) {\n            max /= 10;\n            maxDigit++;\n    }\n    int div = 1;\n    ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();\n    for (int i = 0; i < 10; i++)\n        bucketList.add(new ArrayList<Integer>());\n        //2.进行maxDigit趟分配\n    for (int i = 0; i < maxDigit; i++,div *= 10) {\n            for (int j = 0; j < array.length; j++) {\n                int num = (array[j] / div) % 10;\n                bucketList.get(num).add(array[j]);\n            }\n        //3.收集\n            int index = 0;\n            for (int j = 0; j < bucketList.size(); j++) {\n                for (int k = 0; k < bucketList.get(j).size(); k++)\n                    array[index++] = bucketList.get(j).get(k);\n                bucketList.get(j).clear();\n            }\n   }\n   return array;\n}\n```\n- 时间复杂度：基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。\n- 空间复杂度：基数排序空间复杂度为O(n + k)。\n- 稳定性：基数排序是稳定的。\n\n### 二分查找\n```\npublic class BinarySearch {\n    public static int binarySearch(int[] array, int target) {\n        int left = 0;\n        int right = array.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2; // 防止整形的(left + right)/2溢出\n            if (array[mid] == target) {\n                return mid;\n            } else if (array[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1; // 未找到目标值\n    }\n    public static void main(String[] args) {\n        int[] array = {1, 3, 5, 7, 9, 11, 13};\n        int target = 7;\n        int result = binarySearch(array, target);\n        System.out.println(\"目标值的索引: \" + result);\n    }\n}\n\n// 递归实现\npublic class BinarySearch {\n    public static int binarySearch(int[] array, int target, int left, int right) {\n        if (left > right) {\n            return -1;\n        }\n\n        int mid = left + (right - left) / 2;\n        if (array[mid] == target) {\n            return mid;\n        } else if (array[mid] < target) {\n            return binarySearch(array, target, mid + 1, right);\n        } else {\n            return binarySearch(array, target, left, mid - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = {1, 3, 5, 7, 9, 11, 13};\n        int target = 7;\n        int result = binarySearch(array, target, 0, array.length - 1);\n        System.out.println(\"目标值的索引: \" + result);\n    }\n}\n```\n### 递归删除文件夹\n```java\nimport java.io.File;\npublic class FileDeleter {\n    public static void main(String[] args) {\n        // 示例：删除路径为\"example\"的文件或目录\n        String path = \"example\";\n        boolean result = deleteRecursively(new File(path));\n        if (result) {\n            System.out.println(\"删除成功: \" + path);\n        } else {\n            System.out.println(\"删除失败: \" + path);\n        }\n    }\n\n    /**\n     * 递归删除文件或目录\n     * @param file 要删除的文件或目录\n     * @return 如果成功删除，则返回true；否则返回false\n     */\n    public static boolean deleteRecursively(File file) {\n        if (!file.exists()) {\n            System.out.println(\"文件不存在: \" + file.getAbsolutePath());\n            return false;\n        }\n        // 如果是目录，则递归删除目录中的内容\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    if (!deleteRecursively(child)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        // 删除文件或空目录\n        return file.delete();\n    }\n}\n```\n### 无重复最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int res = 0;\n        // 滑动窗口\n        HashMap<Character, Integer> window = new HashMap<>();\n        int left = 0, right = 0;\n        while (right < s.length()) {\n            char c = s.charAt(right);\n            // 增大窗口\n            right++;\n            // 窗口变化后对数据进行处理\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            // 是否需要缩小窗口\n            while (window.get(c) > 1) {\n                char d = s.charAt(left);\n                // 缩小窗口\n                left++;\n                // 窗口变化后对数据进行处理\n                window.put(d, window.get(d) - 1);\n            }\n            // 缩小窗口后保证window内没有重复元素\n            res = Math.max(right - left, res);\n        }\n        return res;\n    }\n}\n```\n\n### 二叉树前序遍历转链表\n二叉树的先序遍历，然后按照前序顺序将其转化为一个链表\n```java\npublic class Solution {\n    private static Node trans(TreeNode root) {\n        Node dummy = new Node(-1), p = dummy;\n        traverse(root, p);\n        return dummy.next;\n    }\n    private static void traverse(TreeNode root, Node p) {\n        if (root == null)\n            return ;\n        Node node = new Node(root.val, null);\n        p.next = node;\n        p = p.next;\n        traverse(root.left, p);\n        traverse(root.right, p);\n    }\n}\n```\n\n### 最长重复子串(不会。。。后面有时间再研究吧)\n```java\nclass Solution {\n    public String longestDupSubstring(String s) {\n        Random random = new Random();\n        // 生成两个进制\n        int a1 = random.nextInt(75) + 26;\n        int a2 = random.nextInt(75) + 26;\n        // 生成两个模\n        int mod1 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int mod2 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;\n        int n = s.length();\n        // 先对所有字符进行编码\n        int[] arr = new int[n];\n        for (int i = 0; i < n; ++i) {\n            arr[i] = s.charAt(i) - 'a';\n        }\n        // 二分查找的范围是[1, n-1]\n        int l = 1, r = n - 1;\n        int length = 0, start = -1;\n        while (l <= r) {\n            int m = l + (r - l + 1) / 2;\n            int idx = check(arr, m, a1, a2, mod1, mod2);\n            if (idx != -1) {\n                // 有重复子串，移动左边界\n                l = m + 1;\n                length = m;\n                start = idx;\n            } else {\n                // 无重复子串，移动右边界\n                r = m - 1;\n            }\n        }\n        return start != -1 ? s.substring(start, start + length) : \"\";\n    }\n    public int check(int[] arr, int m, int a1, int a2, int mod1, int mod2) {\n        int n = arr.length;\n        long aL1 = pow(a1, m, mod1);\n        long aL2 = pow(a2, m, mod2);\n        long h1 = 0, h2 = 0;\n        for (int i = 0; i < m; ++i) {\n            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;\n            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n        }\n        // 存储一个编码组合是否出现过\n        Set<Long> seen = new HashSet<Long>();\n        seen.add(h1 * mod2 + h2);\n        for (int start = 1; start <= n - m; ++start) {\n            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;\n            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;\n            if (h1 < 0) {\n                h1 += mod1;\n            }\n            if (h2 < 0) {\n                h2 += mod2;\n            }\n            long num = h1 * mod2 + h2;\n            // 如果重复，则返回重复串的起点\n            if (!seen.add(num)) {\n                return start;\n            }\n        }\n        // 没有重复，则返回-1\n        return -1;\n    }\n    public long pow(int a, int m, int mod) {\n        long ans = 1;\n        long contribute = a;\n        while (m > 0) {\n            if (m % 2 == 1) {\n                ans = ans * contribute % mod;\n                if (ans < 0) {\n                    ans += mod;\n                }\n            }\n            contribute = contribute * contribute % mod;\n            if (contribute < 0) {\n                contribute += mod;\n            }\n            m /= 2;\n        }\n        return ans;\n    }\n}\n```\n\n### CompletableFuture类异步调用实现\n```java\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // 创建一个CompletableFuture来执行异步任务\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            // 模拟一个长时间运行的任务\n            try {\n                Thread.sleep(2000); // 休眠2秒\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"任务完成\";\n        });\n        // 注册一个回调函数，当任务完成时获取结果\n        future.thenAccept(result -> {\n            System.out.println(\"异步任务结果: \" + result);\n        });\n        // 主线程继续执行其他操作\n        System.out.println(\"主线程继续执行...\");\n        // 阻塞主线程，直到异步任务完成（可选）\n        try {\n            // 这一步会阻塞主线程，直到异步任务完成\n            String result = future.get();\n            System.out.println(\"异步任务完成后获取的结果: \" + result);\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n","slug":"手撕相关","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1w002hr7gn1qki9rqf","content":"<h2 id=\"经典题型\"><a href=\"#经典题型\" class=\"headerlink\" title=\"经典题型\"></a>经典题型</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有序链表合并\"><a href=\"#有序链表合并\" class=\"headerlink\" title=\"有序链表合并\"></a>有序链表合并</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode <span class=\"title function_\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 虚拟头结点</span></span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">dummy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>), p = dummy;</span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> l1, p2 = l2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p1 != <span class=\"literal\">null</span> &amp;&amp; p2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 比较 p1 和 p2 两个指针</span></span><br><span class=\"line\">        <span class=\"comment\">// 将值较小的的节点接到 p 指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class=\"line\">            p.next = p2;</span><br><span class=\"line\">            p2 = p2.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.next = p1;</span><br><span class=\"line\">            p1 = p1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// p 指针不断前进</span></span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.next = p1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.next = p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"反转整个链表\"><a href=\"#反转整个链表\" class=\"headerlink\" title=\"反转整个链表\"></a>反转整个链表</h3><ul>\n<li>递归法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverse</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span> reverse(head.next); <span class=\"comment\">// 除了头结点外，反转其余结点，last 为新的头结点</span></span><br><span class=\"line\">    head.next.next = head; <span class=\"comment\">// 其余节点反转好了，将反转后的链表的尾结点指向头节点</span></span><br><span class=\"line\">    head.next = <span class=\"literal\">null</span>; <span class=\"comment\">// 头结点原本指向第二个元素，现在指向空节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> last; <span class=\"comment\">// 返回新的头结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转部分链表\"><a href=\"#反转部分链表\" class=\"headerlink\" title=\"反转部分链表\"></a>反转部分链表</h3><ul>\n<li>迭代法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ListNode</span> <span class=\"variable\">successor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 后驱节点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverseBetween</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reverse(head, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 前进到反转的起点触发 base case</span></span><br><span class=\"line\">    head.next = reverseBetween(head.next, m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverse</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录第 n + 1 个节点</span></span><br><span class=\"line\">        successor = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span> reverse(head.next, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    <span class=\"comment\">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class=\"line\">    head.next = successor;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LRU缓存\"><a href=\"#LRU缓存\" class=\"headerlink\" title=\"LRU缓存\"></a>LRU缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 缓存的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> cap;</span><br><span class=\"line\">    <span class=\"comment\">// 用LinkedHashMap作为cache，尾部为新使用过的数据，头部为未使用过的数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cap = capacity;</span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.containsKey(key)) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        makeNew(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\">        makeNew(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.size() &gt; <span class=\"built_in\">this</span>.cap) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头部的元素是最老的</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> cache.keySet().iterator().next();</span><br><span class=\"line\">            cache.remove(head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让key变为新使用的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">makeNew</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\">        cache.remove(key);</span><br><span class=\"line\">        <span class=\"comment\">// 将key添加到LinkedHashMap尾部</span></span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        LRUCache&lt;Integer, String&gt; lruCache = <span class=\"keyword\">new</span> <span class=\"title class_\">LRUCache</span>&lt;&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">3</span>, <span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">4</span>, <span class=\"string\">&quot;watermelon&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">5</span>, <span class=\"string\">&quot;peach&quot;</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">6</span>, <span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">        lruCache.get(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><blockquote>\n<p>链接：<a href=\"https://learn.skyofit.com/archives/1291\">https://learn.skyofit.com/archives/1291</a></p>\n</blockquote>\n<p><strong>复杂度</strong><br><img src=\"/./image/Hand-Torn-Code/20230615083937874.png\" alt=\"排序算法总结\"></p>\n<p>概念：</p>\n<ul>\n<li>稳定：如果a原本在b前面且a&#x3D;b，排序之后a仍然在b的前面。</li>\n<li>不稳定：如果a原本在b的前面且a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</li>\n<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>\n<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>\n<li>In-Place：占用常数内存，不占用额外内存。比如：程序里没有创建新数组来保存数据，只用了临时变量。</li>\n<li>Out-Place：占用额外内存。比如：创建了新的数组来保存或者处理数据。</li>\n</ul>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>基本思想</strong><br>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] bubbleSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;  <span class=\"comment\">//外层循环一次为一趟排序</span></span><br><span class=\"line\">        <span class=\"comment\">/*设置标识，判断这趟排序是否发生了交换。</span></span><br><span class=\"line\"><span class=\"comment\">       如果未发生交换，则说明数组已经有序，不必再排序了*/</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isSwap</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//内层循环一次为一次相邻比较</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j + <span class=\"number\">1</span>] &lt; array[j]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                array[j] = temp;</span><br><span class=\"line\">                isSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isSwap)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度：冒泡排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li>\n<li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 3 * n * (n-1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li>\n<li>空间复杂度：冒泡排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：当 array[j] &#x3D;&#x3D; array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。</li>\n</ul>\n<blockquote>\n<p>拓展：鸡尾酒排序<br>又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cocktailSort</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,right = array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> left; i &lt; right; i++)</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(array[i] &gt; array[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">               swap(array,i,i + <span class=\"number\">1</span>);</span><br><span class=\"line\">       right--;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> right; i &gt; left; i--)</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(array[i] &lt; array[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">               swap(array,i,i-<span class=\"number\">1</span>);</span><br><span class=\"line\">       left++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>鸡尾酒排序是稳定的。它的平均时间复杂度为O(n2)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n2)。空间复杂度为O(1)。</p>\n</blockquote>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p><strong>基本思想</strong><br>简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<p><strong>算法描述</strong><br>n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：</p>\n<ol>\n<li>初始状态：无序区为R[1..n]，有序区为空； </li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>(n-1)趟结束，数组有序化了。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] selectionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j] &lt; array[minIndex]) <span class=\"comment\">//找到最小的数</span></span><br><span class=\"line\">                minIndex = j; <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[minIndex]; <span class=\"comment\">//将最小数和无序区的第一个数交换</span></span><br><span class=\"line\">        array[minIndex] = array[i];</span><br><span class=\"line\">        array[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n – 1) &#x2F; 2 次比较。</li>\n<li>最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n – 1) &#x2F; 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n – 1)次。<ul>\n<li>需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。</li>\n</ul>\n</li>\n<li>空间复杂度：简单选择排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。</li>\n</ul>\n<h4 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h4><p><strong>基本思想</strong><br>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p><strong>算法描述</strong><br>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] insertionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        current = array[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">preIndex</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class=\"line\">            array[preIndex + <span class=\"number\">1</span>] = array[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li>\n<li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 n * (n – 1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li>\n<li>空间复杂度：直接插入排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：直接插入排序是稳定的。</li>\n</ul>\n<blockquote>\n<p>拓展：在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] BinaryInsertionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;i &lt; array.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;  <span class=\"comment\">// left 和 right 分别为有序区的左右边界 </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//搜索有序区中第一个大于 current 的位置，即为 current 要插入的位置</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[mid] &gt; current)&#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;j &gt;= left;j--) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[left] = current; <span class=\"comment\">// left 为第一个大于 current 的位置，插入 current</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二分插入排序是稳定的。它的平均时间复杂度是O(n2)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</p>\n</blockquote>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p><strong>基本思想</strong><br>1959年Shell发明，第一个突破O(n2)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n<p><strong>算法描述</strong><br>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n &#x2F; gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap &#x3D;&#x3D; 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len &#x2F; 2。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] ShellSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> current, gap = len / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (gap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            current = array[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">preIndex</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; array[preIndex] &gt; current) &#123;</span><br><span class=\"line\">                array[preIndex + gap] = array[preIndex];</span><br><span class=\"line\">                preIndex -= gap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[preIndex + gap] = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。</li>\n<li>空间复杂度：希尔排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。</li>\n</ul>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p><strong>基本思想</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>把长度为 n 的输入序列分成两个长度为 n &#x2F; 2 的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归并排序</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] MergeSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> array.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] left = Arrays.copyOfRange(array, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">    <span class=\"type\">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将两段有序数组结合成一个有序数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] left, <span class=\"type\">int</span>[] right) &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[left.length + right.length];</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j = <span class=\"number\">0</span>,k = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class=\"line\">            result[k++] = left[i++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result[k++] = right[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; left.length) &#123;</span><br><span class=\"line\">        result[k++] = left[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; right.length) &#123;</span><br><span class=\"line\">        result[k++] = right[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li>\n<li>空间复杂度：归并排序空间复杂度为O(n)</li>\n<li>稳定性：归并排序是稳定的。</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p><strong>基本思想</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p><strong>算法描述</strong><br>快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：</p>\n<ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；</li>\n<li>递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li>\n</ol>\n<p><strong>代码实现</strong><br>快速排序最核心的步骤就是partition操作，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。</p>\n<p>两种方法：左右指针法、挖坑法<br>左右指针法：</p>\n<ol>\n<li>将数组的最后一个数 right 作为基准数 key。</li>\n<li>分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin &gt;&#x3D; end 终止遍历。最后将 begin（此时begin &#x3D;&#x3D; end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数。<br><img src=\"/./image/Hand-Torn-Code/20230615085001544.png\" alt=\"左右指针法\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] a = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        sort(a, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i++)&#123;</span><br><span class=\"line\">            System.out.print(a[i] + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// left 数列左边界 right 数列右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sort</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">q</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( p &lt; q ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p找大</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p &lt; q &amp;&amp; array[p] &lt;= array[key])</span><br><span class=\"line\">                p++;</span><br><span class=\"line\">            <span class=\"comment\">//q找小</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p &lt; q &amp;&amp; array[q] &gt;= array[key])</span><br><span class=\"line\">                q--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p &lt; q)</span><br><span class=\"line\">                swap(array, p, q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(array, p, key);</span><br><span class=\"line\">        sort(array, left, p - <span class=\"number\">1</span>);</span><br><span class=\"line\">        sort(array, q + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交换数组内两个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] array, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">        array[i] = array[j];</span><br><span class=\"line\">        array[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n挖坑法：</li>\n<li>定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。</li>\n<li>left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。<br><img src=\"/./image/Hand-Torn-Code/20230615085019913.png\" alt=\"挖坑法\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快速排序方法 left 数列左边界 right 数列右边界</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> partition(array, left, right);</span><br><span class=\"line\">        Quicksort(array, left, pos - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Quicksort(array, pos + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// partition操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> array[right];<span class=\"comment\">//初始坑</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//left找大</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; array[left] &lt;= key )</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        array[right] = array[left];<span class=\"comment\">//赋值，然后left作为新坑</span></span><br><span class=\"line\">        <span class=\"comment\">//right找小</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;right &amp;&amp; array[right] &gt;= key)</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        array[left] = array[right];<span class=\"comment\">//right作为新坑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[left] = key;</span><br><span class=\"line\">    <span class=\"comment\">/*将key赋值给left和right的相遇点，保持key的左边都是比key小的数，key的右边都是比key大的数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;<span class=\"comment\">//最终返回基准</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><p>之前选择基准的策略都是固定基准，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n2)）。</p>\n<p><strong>优化一：随机基准</strong><br>每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。<br>只需要在 partition 函数前增加如下操作即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//随机选择 left ~ right 之间的一个位置作为基准</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (left + Math.random() * (right - left + <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">//把基准值交换到右边界</span></span><br><span class=\"line\">swap(array, random, right);</span><br></pre></td></tr></table></figure>\n<p><strong>优化二：三数取中法</strong><br>取第一个数，最后一个数，第（N&#x2F;2）个数即中间数，三个数中数值中间的那个数作为基准值。</p>\n<p>举个例子，对于int[] array &#x3D; { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N&#x2F;2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。</p>\n<p>实现getMid函数即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getMid</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> array[left];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> array[mid];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> array[right];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((b &lt;= a &amp;&amp; a &lt;= c) || (c &lt;= a &amp;&amp; a &lt;= b)) &#123; <span class=\"comment\">//a为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a &lt;= b &amp;&amp; b &lt;= c) || (c &lt;= b &amp;&amp; b &lt;= a)) &#123; <span class=\"comment\">//b为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a &lt;= c &amp;&amp; c &lt;= b) || (b &lt;= c &amp;&amp; c &lt;= a)) &#123; <span class=\"comment\">//c为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优化三：当待排序序列的长度分割到一定大小后，使用插入排序</strong><br>在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。</p>\n<p>实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。</p>\n<p>此时QuickSort()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right - left &gt; <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> partition(array, left, right);</span><br><span class=\"line\">        Quicksort(array, left, pos - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Quicksort(array, pos + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        insertionSort(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优化四：三路划分</strong><br>如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。</p>\n<p>三路划分的思想是利用 partition 函数将待排序列划分为三部分：第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。这样在递归排序区间的时候，我们就不必再对第二部分元素均相等的区间进行快排了，这在待排序列存在大量相同元素的情况下能大大提高快排效率。<br><img src=\"/./image/Hand-Torn-Code/20230615085141896.png\" alt=\"三路划分示意图\"></p>\n<p>红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。</p>\n<p>left 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。</p>\n<p>算法思路：</p>\n<ol>\n<li>由于最初红色和蓝色区域没有元素，初始化 less &#x3D; left – 1，more &#x3D; right + 1，cur &#x3D; left。整个区间为未知部分（白色）。</li>\n<li>如果当前 array[cur] &lt; v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</li>\n<li>如果当前 array[cur] &#x3D; v，则不必交换，直接 cur++</li>\n<li>如果当前 array[cur] &gt; v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] partition(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">v</span> <span class=\"operator\">=</span> array[right]; <span class=\"comment\">//选择右边界为基准</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">less</span> <span class=\"operator\">=</span> left - <span class=\"number\">1</span>; <span class=\"comment\">// &lt; v 部分的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">more</span> <span class=\"operator\">=</span> right + <span class=\"number\">1</span>; <span class=\"comment\">// &gt; v 部分的第一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur &lt; more)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array[cur] &lt; v)&#123;</span><br><span class=\"line\">            swap(array,++less,cur++);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[cur] &gt; v)&#123;</span><br><span class=\"line\">            swap(array,--more,cur);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cur++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;less + <span class=\"number\">1</span>,more - <span class=\"number\">1</span>&#125;;  <span class=\"comment\">//返回的是 = v 区域的左右下标</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] p = partition(array,left,right);</span><br><span class=\"line\">        Quicksort(array,left,p[<span class=\"number\">0</span>] - <span class=\"number\">1</span>); <span class=\"comment\">//避开重复元素区间</span></span><br><span class=\"line\">        Quicksort(array,p[<span class=\"number\">1</span>] + <span class=\"number\">1</span>,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。</li>\n<li>最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左（右）结点的树，树的深度为 n，时间复杂度为O(n2)。</li>\n<li>空间复杂度：快速排序的空间复杂度主要考虑递归时使用的栈空间。在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。</li>\n<li>稳定性：快速排序是不稳定的。</li>\n</ul>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><p><strong>基本思想</strong><br>堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明全局变量，用于记录数组array的长度；</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> len;</span><br><span class=\"line\"><span class=\"comment\">// 堆排序算法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] HeapSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">        len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">//1.构建一个大根堆</span></span><br><span class=\"line\">        buildMaxHeap(array);</span><br><span class=\"line\">        <span class=\"comment\">//2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            swap(array, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            len--; <span class=\"comment\">//原先的堆尾进入有序区，删除堆尾元素</span></span><br><span class=\"line\">            adjustHeap(array, <span class=\"number\">0</span>); <span class=\"comment\">//重新调整大根堆</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 自顶向下调整以 i 为根的堆为大根堆</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjustHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] array, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"comment\">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * i + <span class=\"number\">1</span> &lt; len &amp;&amp; array[<span class=\"number\">2</span> * i + <span class=\"number\">1</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * i + <span class=\"number\">2</span> &lt; len &amp;&amp; array[<span class=\"number\">2</span> * i + <span class=\"number\">2</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxIndex != i) &#123;</span><br><span class=\"line\">            swap(array, maxIndex, i);</span><br><span class=\"line\">            adjustHeap(array, maxIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 自底向上构建初始大根堆</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildMaxHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从最后一个非叶子节点开始自底向上构造大根堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (len - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            adjustHeap(array, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拓展： <ul>\n<li>插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。</li>\n<li>删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。</li>\n</ul>\n</li>\n<li>时间复杂度：堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li>\n<li>空间复杂度：堆排序使用了常数空间，空间复杂度为O(1)。</li>\n<li>稳定性：堆排序是不稳定的。</li>\n</ul>\n<h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><p><strong>基本思想</strong><br>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] CountingSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> bias, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        max = Math.max(max, array[i]);</span><br><span class=\"line\">        min = Math.min(min, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上</span></span><br><span class=\"line\">    bias = -min;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] bucket = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[max - min + <span class=\"number\">1</span>];</span><br><span class=\"line\">    Arrays.fill(bucket, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        bucket[array[i] + bias]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index &lt; array.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bucket[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            array[index] = i - bias;</span><br><span class=\"line\">            bucket[i]--;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</li>\n<li>空间复杂度：计数排序空间复杂度为O(k)，k为桶数组的长度。</li>\n<li>稳定性：计数排序是稳定的。</li>\n</ul>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><p><strong>基本思想</strong><br>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i &lt; j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i – min) &#x2F; arr.length。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] bucketSort(<span class=\"type\">int</span>[] array)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        max = Math.max(max, array[i]);</span><br><span class=\"line\">        min = Math.min(min, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i &lt; j）的数，即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">bucketNum</span> <span class=\"operator\">=</span> (max - min) / array.length + <span class=\"number\">1</span>;</span><br><span class=\"line\">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class=\"line\">        bucketArr.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将每个元素放入桶</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> (array[i] - min) / (array.length);</span><br><span class=\"line\">        bucketArr.get(num).add(array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对每个桶进行排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class=\"line\">        Collections.sort(bucketArr.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;j &lt; bucketArr.get(i).size();j++) &#123;</span><br><span class=\"line\">           array[k++] = bucketArr.get(i).get(j);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。</li>\n<li>空间复杂度：桶排序空间复杂度为O(n + k)。</li>\n<li>稳定性：桶排序是稳定的。</li>\n</ul>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><p><strong>基本思想</strong><br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>array 为原始数组，从最低位开始取每个位组成 radix 数组；</li>\n<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] RadixSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span> || array.length &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">// 1.先算出最大数的位数；</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            max = Math.max(max, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxDigit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (max != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            max /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            maxDigit++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">div</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        bucketList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"comment\">//2.进行maxDigit趟分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; maxDigit; i++,div *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> (array[j] / div) % <span class=\"number\">10</span>;</span><br><span class=\"line\">                bucketList.get(num).add(array[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3.收集</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class=\"line\">                    array[index++] = bucketList.get(j).get(k);</span><br><span class=\"line\">                bucketList.get(j).clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。</li>\n<li>空间复杂度：基数排序空间复杂度为O(n + k)。</li>\n<li>稳定性：基数排序是稳定的。</li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BinarySearch &#123;</span><br><span class=\"line\">    public static int binarySearch(int[] array, int target) &#123;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = array.length - 1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        while (left &lt;= right) &#123;</span><br><span class=\"line\">            int mid = left + (right - left) / 2; // 防止整形的(left + right)/2溢出</span><br><span class=\"line\">            if (array[mid] == target) &#123;</span><br><span class=\"line\">                return mid;</span><br><span class=\"line\">            &#125; else if (array[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                right = mid - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1; // 未找到目标值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class=\"line\">        int target = 7;</span><br><span class=\"line\">        int result = binarySearch(array, target);</span><br><span class=\"line\">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 递归实现</span><br><span class=\"line\">public class BinarySearch &#123;</span><br><span class=\"line\">    public static int binarySearch(int[] array, int target, int left, int right) &#123;</span><br><span class=\"line\">        if (left &gt; right) &#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int mid = left + (right - left) / 2;</span><br><span class=\"line\">        if (array[mid] == target) &#123;</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">        &#125; else if (array[mid] &lt; target) &#123;</span><br><span class=\"line\">            return binarySearch(array, target, mid + 1, right);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return binarySearch(array, target, left, mid - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class=\"line\">        int target = 7;</span><br><span class=\"line\">        int result = binarySearch(array, target, 0, array.length - 1);</span><br><span class=\"line\">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归删除文件夹\"><a href=\"#递归删除文件夹\" class=\"headerlink\" title=\"递归删除文件夹\"></a>递归删除文件夹</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileDeleter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 示例：删除路径为&quot;example&quot;的文件或目录</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> deleteRecursively(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(path));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;删除成功: &quot;</span> + path);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;删除失败: &quot;</span> + path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归删除文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file 要删除的文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果成功删除，则返回true；否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">deleteRecursively</span><span class=\"params\">(File file)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;文件不存在: &quot;</span> + file.getAbsolutePath());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是目录，则递归删除目录中的内容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isDirectory()) &#123;</span><br><span class=\"line\">            File[] files = file.listFiles();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (files != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (File child : files) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!deleteRecursively(child)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 删除文件或空目录</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> file.delete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"无重复最长子串\"><a href=\"#无重复最长子串\" class=\"headerlink\" title=\"无重复最长子串\"></a>无重复最长子串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 滑动窗口</span></span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; window = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; s.length()) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> s.charAt(right);</span><br><span class=\"line\">            <span class=\"comment\">// 增大窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">// 窗口变化后对数据进行处理</span></span><br><span class=\"line\">            window.put(c, window.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 是否需要缩小窗口</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (window.get(c) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> s.charAt(left);</span><br><span class=\"line\">                <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">// 窗口变化后对数据进行处理</span></span><br><span class=\"line\">                window.put(d, window.get(d) - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 缩小窗口后保证window内没有重复元素</span></span><br><span class=\"line\">            res = Math.max(right - left, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树前序遍历转链表\"><a href=\"#二叉树前序遍历转链表\" class=\"headerlink\" title=\"二叉树前序遍历转链表\"></a>二叉树前序遍历转链表</h3><p>二叉树的先序遍历，然后按照前序顺序将其转化为一个链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Node <span class=\"title function_\">trans</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">dummy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(-<span class=\"number\">1</span>), p = dummy;</span><br><span class=\"line\">        traverse(root, p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traverse</span><span class=\"params\">(TreeNode root, Node p)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(root.val, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        p.next = node;</span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">        traverse(root.left, p);</span><br><span class=\"line\">        traverse(root.right, p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长重复子串-不会。。。后面有时间再研究吧\"><a href=\"#最长重复子串-不会。。。后面有时间再研究吧\" class=\"headerlink\" title=\"最长重复子串(不会。。。后面有时间再研究吧)\"></a>最长重复子串(不会。。。后面有时间再研究吧)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestDupSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Random</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 生成两个进制</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> random.nextInt(<span class=\"number\">75</span>) + <span class=\"number\">26</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a2</span> <span class=\"operator\">=</span> random.nextInt(<span class=\"number\">75</span>) + <span class=\"number\">26</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 生成两个模</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mod1</span> <span class=\"operator\">=</span> random.nextInt(Integer.MAX_VALUE - <span class=\"number\">1000000007</span> + <span class=\"number\">1</span>) + <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mod2</span> <span class=\"operator\">=</span> random.nextInt(Integer.MAX_VALUE - <span class=\"number\">1000000007</span> + <span class=\"number\">1</span>) + <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"comment\">// 先对所有字符进行编码</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            arr[i] = s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找的范围是[1, n-1]</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, start = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> l + (r - l + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> check(arr, m, a1, a2, mod1, mod2);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (idx != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有重复子串，移动左边界</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                length = m;</span><br><span class=\"line\">                start = idx;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无重复子串，移动右边界</span></span><br><span class=\"line\">                r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start != -<span class=\"number\">1</span> ? s.substring(start, start + length) : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> m, <span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> mod1, <span class=\"type\">int</span> mod2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aL1</span> <span class=\"operator\">=</span> pow(a1, m, mod1);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aL2</span> <span class=\"operator\">=</span> pow(a2, m, mod2);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">h1</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, h2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;</span><br><span class=\"line\">            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h1 += mod1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h2 += mod2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 存储一个编码组合是否出现过</span></span><br><span class=\"line\">        Set&lt;Long&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Long&gt;();</span><br><span class=\"line\">        seen.add(h1 * mod2 + h2);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; start &lt;= n - m; ++start) &#123;</span><br><span class=\"line\">            h1 = (h1 * a1 % mod1 - arr[start - <span class=\"number\">1</span>] * aL1 % mod1 + arr[start + m - <span class=\"number\">1</span>]) % mod1;</span><br><span class=\"line\">            h2 = (h2 * a2 % mod2 - arr[start - <span class=\"number\">1</span>] * aL2 % mod2 + arr[start + m - <span class=\"number\">1</span>]) % mod2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h1 += mod1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h2 += mod2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> h1 * mod2 + h2;</span><br><span class=\"line\">            <span class=\"comment\">// 如果重复，则返回重复串的起点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(num)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没有重复，则返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">pow</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> m, <span class=\"type\">int</span> mod)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">contribute</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = ans * contribute % mod;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    ans += mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            contribute = contribute * contribute % mod;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (contribute &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                contribute += mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CompletableFuture类异步调用实现\"><a href=\"#CompletableFuture类异步调用实现\" class=\"headerlink\" title=\"CompletableFuture类异步调用实现\"></a>CompletableFuture类异步调用实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟一个长时间运行的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">// 休眠2秒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务完成&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class=\"line\">        future.thenAccept(result -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 主线程继续执行其他操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主线程继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞主线程，直到异步任务完成（可选）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> future.get();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"经典题型\"><a href=\"#经典题型\" class=\"headerlink\" title=\"经典题型\"></a>经典题型</h2><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有序链表合并\"><a href=\"#有序链表合并\" class=\"headerlink\" title=\"有序链表合并\"></a>有序链表合并</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode <span class=\"title function_\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 虚拟头结点</span></span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">dummy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>), p = dummy;</span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> l1, p2 = l2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p1 != <span class=\"literal\">null</span> &amp;&amp; p2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 比较 p1 和 p2 两个指针</span></span><br><span class=\"line\">        <span class=\"comment\">// 将值较小的的节点接到 p 指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class=\"line\">            p.next = p2;</span><br><span class=\"line\">            p2 = p2.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.next = p1;</span><br><span class=\"line\">            p1 = p1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// p 指针不断前进</span></span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.next = p1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        p.next = p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"反转整个链表\"><a href=\"#反转整个链表\" class=\"headerlink\" title=\"反转整个链表\"></a>反转整个链表</h3><ul>\n<li>递归法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverse</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span> reverse(head.next); <span class=\"comment\">// 除了头结点外，反转其余结点，last 为新的头结点</span></span><br><span class=\"line\">    head.next.next = head; <span class=\"comment\">// 其余节点反转好了，将反转后的链表的尾结点指向头节点</span></span><br><span class=\"line\">    head.next = <span class=\"literal\">null</span>; <span class=\"comment\">// 头结点原本指向第二个元素，现在指向空节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> last; <span class=\"comment\">// 返回新的头结点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反转部分链表\"><a href=\"#反转部分链表\" class=\"headerlink\" title=\"反转部分链表\"></a>反转部分链表</h3><ul>\n<li>迭代法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ListNode</span> <span class=\"variable\">successor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 后驱节点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverseBetween</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reverse(head, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 前进到反转的起点触发 base case</span></span><br><span class=\"line\">    head.next = reverseBetween(head.next, m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class=\"line\">ListNode <span class=\"title function_\">reverse</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录第 n + 1 个节点</span></span><br><span class=\"line\">        successor = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class=\"line\">    <span class=\"type\">ListNode</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span> reverse(head.next, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    head.next.next = head;</span><br><span class=\"line\">    <span class=\"comment\">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class=\"line\">    head.next = successor;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LRU缓存\"><a href=\"#LRU缓存\" class=\"headerlink\" title=\"LRU缓存\"></a>LRU缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 缓存的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> cap;</span><br><span class=\"line\">    <span class=\"comment\">// 用LinkedHashMap作为cache，尾部为新使用过的数据，头部为未使用过的数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cap = capacity;</span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.containsKey(key)) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        makeNew(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\">        makeNew(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.size() &gt; <span class=\"built_in\">this</span>.cap) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头部的元素是最老的</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> cache.keySet().iterator().next();</span><br><span class=\"line\">            cache.remove(head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让key变为新使用的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">makeNew</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\">        cache.remove(key);</span><br><span class=\"line\">        <span class=\"comment\">// 将key添加到LinkedHashMap尾部</span></span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        LRUCache&lt;Integer, String&gt; lruCache = <span class=\"keyword\">new</span> <span class=\"title class_\">LRUCache</span>&lt;&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">3</span>, <span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">4</span>, <span class=\"string\">&quot;watermelon&quot;</span>);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">5</span>, <span class=\"string\">&quot;peach&quot;</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">        lruCache.put(<span class=\"number\">6</span>, <span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">        lruCache.get(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(lruCache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><blockquote>\n<p>链接：<a href=\"https://learn.skyofit.com/archives/1291\">https://learn.skyofit.com/archives/1291</a></p>\n</blockquote>\n<p><strong>复杂度</strong><br><img src=\"/./image/Hand-Torn-Code/20230615083937874.png\" alt=\"排序算法总结\"></p>\n<p>概念：</p>\n<ul>\n<li>稳定：如果a原本在b前面且a&#x3D;b，排序之后a仍然在b的前面。</li>\n<li>不稳定：如果a原本在b的前面且a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</li>\n<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>\n<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>\n<li>In-Place：占用常数内存，不占用额外内存。比如：程序里没有创建新数组来保存数据，只用了临时变量。</li>\n<li>Out-Place：占用额外内存。比如：创建了新的数组来保存或者处理数据。</li>\n</ul>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>基本思想</strong><br>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] bubbleSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;  <span class=\"comment\">//外层循环一次为一趟排序</span></span><br><span class=\"line\">        <span class=\"comment\">/*设置标识，判断这趟排序是否发生了交换。</span></span><br><span class=\"line\"><span class=\"comment\">       如果未发生交换，则说明数组已经有序，不必再排序了*/</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">isSwap</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//内层循环一次为一次相邻比较</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j + <span class=\"number\">1</span>] &lt; array[j]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                array[j] = temp;</span><br><span class=\"line\">                isSwap = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isSwap)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>时间复杂度：冒泡排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li>\n<li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 3 * n * (n-1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li>\n<li>空间复杂度：冒泡排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：当 array[j] &#x3D;&#x3D; array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。</li>\n</ul>\n<blockquote>\n<p>拓展：鸡尾酒排序<br>又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cocktailSort</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,right = array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> left; i &lt; right; i++)</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(array[i] &gt; array[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">               swap(array,i,i + <span class=\"number\">1</span>);</span><br><span class=\"line\">       right--;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> right; i &gt; left; i--)</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(array[i] &lt; array[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">               swap(array,i,i-<span class=\"number\">1</span>);</span><br><span class=\"line\">       left++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>鸡尾酒排序是稳定的。它的平均时间复杂度为O(n2)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n2)。空间复杂度为O(1)。</p>\n</blockquote>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p><strong>基本思想</strong><br>简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<p><strong>算法描述</strong><br>n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：</p>\n<ol>\n<li>初始状态：无序区为R[1..n]，有序区为空； </li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>(n-1)趟结束，数组有序化了。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] selectionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[j] &lt; array[minIndex]) <span class=\"comment\">//找到最小的数</span></span><br><span class=\"line\">                minIndex = j; <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[minIndex]; <span class=\"comment\">//将最小数和无序区的第一个数交换</span></span><br><span class=\"line\">        array[minIndex] = array[i];</span><br><span class=\"line\">        array[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n – 1) &#x2F; 2 次比较。</li>\n<li>最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n – 1) &#x2F; 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n – 1)次。<ul>\n<li>需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。</li>\n</ul>\n</li>\n<li>空间复杂度：简单选择排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。</li>\n</ul>\n<h4 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h4><p><strong>基本思想</strong><br>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<p><strong>算法描述</strong><br>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] insertionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> current;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        current = array[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">preIndex</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class=\"line\">            array[preIndex + <span class=\"number\">1</span>] = array[preIndex];</span><br><span class=\"line\">            preIndex--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li>\n<li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 n * (n – 1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li>\n<li>空间复杂度：直接插入排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：直接插入排序是稳定的。</li>\n</ul>\n<blockquote>\n<p>拓展：在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] BinaryInsertionSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;i &lt; array.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;  <span class=\"comment\">// left 和 right 分别为有序区的左右边界 </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//搜索有序区中第一个大于 current 的位置，即为 current 要插入的位置</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[mid] &gt; current)&#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;j &gt;= left;j--) &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[left] = current; <span class=\"comment\">// left 为第一个大于 current 的位置，插入 current</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二分插入排序是稳定的。它的平均时间复杂度是O(n2)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</p>\n</blockquote>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p><strong>基本思想</strong><br>1959年Shell发明，第一个突破O(n2)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n<p><strong>算法描述</strong><br>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n &#x2F; gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap &#x3D;&#x3D; 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。gap初始值一般取 len &#x2F; 2。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] ShellSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> current, gap = len / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (gap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">            current = array[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">preIndex</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; array[preIndex] &gt; current) &#123;</span><br><span class=\"line\">                array[preIndex + gap] = array[preIndex];</span><br><span class=\"line\">                preIndex -= gap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[preIndex + gap] = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。</li>\n<li>空间复杂度：希尔排序使用了常数空间，空间复杂度为O(1)</li>\n<li>稳定性：由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。</li>\n</ul>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p><strong>基本思想</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>把长度为 n 的输入序列分成两个长度为 n &#x2F; 2 的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 归并排序</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] MergeSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> array.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] left = Arrays.copyOfRange(array, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">    <span class=\"type\">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将两段有序数组结合成一个有序数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] left, <span class=\"type\">int</span>[] right) &#123;</span><br><span class=\"line\">   <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[left.length + right.length];</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j = <span class=\"number\">0</span>,k = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class=\"line\">            result[k++] = left[i++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result[k++] = right[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; left.length) &#123;</span><br><span class=\"line\">        result[k++] = left[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; right.length) &#123;</span><br><span class=\"line\">        result[k++] = right[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li>\n<li>空间复杂度：归并排序空间复杂度为O(n)</li>\n<li>稳定性：归并排序是稳定的。</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p><strong>基本思想</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p><strong>算法描述</strong><br>快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：</p>\n<ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；</li>\n<li>递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li>\n</ol>\n<p><strong>代码实现</strong><br>快速排序最核心的步骤就是partition操作，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。</p>\n<p>两种方法：左右指针法、挖坑法<br>左右指针法：</p>\n<ol>\n<li>将数组的最后一个数 right 作为基准数 key。</li>\n<li>分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin &gt;&#x3D; end 终止遍历。最后将 begin（此时begin &#x3D;&#x3D; end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数。<br><img src=\"/./image/Hand-Torn-Code/20230615085001544.png\" alt=\"左右指针法\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] a = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        sort(a, <span class=\"number\">0</span>, a.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i++)&#123;</span><br><span class=\"line\">            System.out.print(a[i] + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// left 数列左边界 right 数列右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sort</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">q</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= right)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( p &lt; q ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//p找大</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p &lt; q &amp;&amp; array[p] &lt;= array[key])</span><br><span class=\"line\">                p++;</span><br><span class=\"line\">            <span class=\"comment\">//q找小</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p &lt; q &amp;&amp; array[q] &gt;= array[key])</span><br><span class=\"line\">                q--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p &lt; q)</span><br><span class=\"line\">                swap(array, p, q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(array, p, key);</span><br><span class=\"line\">        sort(array, left, p - <span class=\"number\">1</span>);</span><br><span class=\"line\">        sort(array, q + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交换数组内两个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] array, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">        array[i] = array[j];</span><br><span class=\"line\">        array[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n挖坑法：</li>\n<li>定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。</li>\n<li>left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。<br><img src=\"/./image/Hand-Torn-Code/20230615085019913.png\" alt=\"挖坑法\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 快速排序方法 left 数列左边界 right 数列右边界</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> partition(array, left, right);</span><br><span class=\"line\">        Quicksort(array, left, pos - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Quicksort(array, pos + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// partition操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> array[right];<span class=\"comment\">//初始坑</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//left找大</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right &amp;&amp; array[left] &lt;= key )</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        array[right] = array[left];<span class=\"comment\">//赋值，然后left作为新坑</span></span><br><span class=\"line\">        <span class=\"comment\">//right找小</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;right &amp;&amp; array[right] &gt;= key)</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        array[left] = array[right];<span class=\"comment\">//right作为新坑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[left] = key;</span><br><span class=\"line\">    <span class=\"comment\">/*将key赋值给left和right的相遇点，保持key的左边都是比key小的数，key的右边都是比key大的数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;<span class=\"comment\">//最终返回基准</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><p>之前选择基准的策略都是固定基准，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n2)）。</p>\n<p><strong>优化一：随机基准</strong><br>每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。<br>只需要在 partition 函数前增加如下操作即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//随机选择 left ~ right 之间的一个位置作为基准</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) (left + Math.random() * (right - left + <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">//把基准值交换到右边界</span></span><br><span class=\"line\">swap(array, random, right);</span><br></pre></td></tr></table></figure>\n<p><strong>优化二：三数取中法</strong><br>取第一个数，最后一个数，第（N&#x2F;2）个数即中间数，三个数中数值中间的那个数作为基准值。</p>\n<p>举个例子，对于int[] array &#x3D; { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N&#x2F;2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。</p>\n<p>实现getMid函数即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getMid</span><span class=\"params\">(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> array[left];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> array[mid];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> array[right];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((b &lt;= a &amp;&amp; a &lt;= c) || (c &lt;= a &amp;&amp; a &lt;= b)) &#123; <span class=\"comment\">//a为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a &lt;= b &amp;&amp; b &lt;= c) || (c &lt;= b &amp;&amp; b &lt;= a)) &#123; <span class=\"comment\">//b为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a &lt;= c &amp;&amp; c &lt;= b) || (b &lt;= c &amp;&amp; c &lt;= a)) &#123; <span class=\"comment\">//c为中间值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优化三：当待排序序列的长度分割到一定大小后，使用插入排序</strong><br>在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。</p>\n<p>实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。</p>\n<p>此时QuickSort()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right - left &gt; <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> partition(array, left, right);</span><br><span class=\"line\">        Quicksort(array, left, pos - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Quicksort(array, pos + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        insertionSort(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优化四：三路划分</strong><br>如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。</p>\n<p>三路划分的思想是利用 partition 函数将待排序列划分为三部分：第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。这样在递归排序区间的时候，我们就不必再对第二部分元素均相等的区间进行快排了，这在待排序列存在大量相同元素的情况下能大大提高快排效率。<br><img src=\"/./image/Hand-Torn-Code/20230615085141896.png\" alt=\"三路划分示意图\"></p>\n<p>红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。</p>\n<p>left 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。</p>\n<p>算法思路：</p>\n<ol>\n<li>由于最初红色和蓝色区域没有元素，初始化 less &#x3D; left – 1，more &#x3D; right + 1，cur &#x3D; left。整个区间为未知部分（白色）。</li>\n<li>如果当前 array[cur] &lt; v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</li>\n<li>如果当前 array[cur] &#x3D; v，则不必交换，直接 cur++</li>\n<li>如果当前 array[cur] &gt; v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] partition(<span class=\"type\">int</span>[] array,<span class=\"type\">int</span> left,<span class=\"type\">int</span> right)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">v</span> <span class=\"operator\">=</span> array[right]; <span class=\"comment\">//选择右边界为基准</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">less</span> <span class=\"operator\">=</span> left - <span class=\"number\">1</span>; <span class=\"comment\">// &lt; v 部分的最后一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">more</span> <span class=\"operator\">=</span> right + <span class=\"number\">1</span>; <span class=\"comment\">// &gt; v 部分的第一个数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur &lt; more)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array[cur] &lt; v)&#123;</span><br><span class=\"line\">            swap(array,++less,cur++);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[cur] &gt; v)&#123;</span><br><span class=\"line\">            swap(array,--more,cur);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cur++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;less + <span class=\"number\">1</span>,more - <span class=\"number\">1</span>&#125;;  <span class=\"comment\">//返回的是 = v 区域的左右下标</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Quicksort</span><span class=\"params\">(<span class=\"type\">int</span> array[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] p = partition(array,left,right);</span><br><span class=\"line\">        Quicksort(array,left,p[<span class=\"number\">0</span>] - <span class=\"number\">1</span>); <span class=\"comment\">//避开重复元素区间</span></span><br><span class=\"line\">        Quicksort(array,p[<span class=\"number\">1</span>] + <span class=\"number\">1</span>,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</li>\n<li>最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。</li>\n<li>最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左（右）结点的树，树的深度为 n，时间复杂度为O(n2)。</li>\n<li>空间复杂度：快速排序的空间复杂度主要考虑递归时使用的栈空间。在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。</li>\n<li>稳定性：快速排序是不稳定的。</li>\n</ul>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><p><strong>基本思想</strong><br>堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明全局变量，用于记录数组array的长度；</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> len;</span><br><span class=\"line\"><span class=\"comment\">// 堆排序算法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] HeapSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">        len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">//1.构建一个大根堆</span></span><br><span class=\"line\">        buildMaxHeap(array);</span><br><span class=\"line\">        <span class=\"comment\">//2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            swap(array, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            len--; <span class=\"comment\">//原先的堆尾进入有序区，删除堆尾元素</span></span><br><span class=\"line\">            adjustHeap(array, <span class=\"number\">0</span>); <span class=\"comment\">//重新调整大根堆</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">// 自顶向下调整以 i 为根的堆为大根堆</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjustHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] array, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxIndex</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"comment\">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * i + <span class=\"number\">1</span> &lt; len &amp;&amp; array[<span class=\"number\">2</span> * i + <span class=\"number\">1</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * i + <span class=\"number\">2</span> &lt; len &amp;&amp; array[<span class=\"number\">2</span> * i + <span class=\"number\">2</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxIndex != i) &#123;</span><br><span class=\"line\">            swap(array, maxIndex, i);</span><br><span class=\"line\">            adjustHeap(array, maxIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// 自底向上构建初始大根堆</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildMaxHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从最后一个非叶子节点开始自底向上构造大根堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (len - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            adjustHeap(array, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拓展： <ul>\n<li>插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。</li>\n<li>删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。</li>\n</ul>\n</li>\n<li>时间复杂度：堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li>\n<li>空间复杂度：堆排序使用了常数空间，空间复杂度为O(1)。</li>\n<li>稳定性：堆排序是不稳定的。</li>\n</ul>\n<h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><p><strong>基本思想</strong><br>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] CountingSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    <span class=\"type\">int</span> bias, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        max = Math.max(max, array[i]);</span><br><span class=\"line\">        min = Math.min(min, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上</span></span><br><span class=\"line\">    bias = -min;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] bucket = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[max - min + <span class=\"number\">1</span>];</span><br><span class=\"line\">    Arrays.fill(bucket, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        bucket[array[i] + bias]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index &lt; array.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bucket[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            array[index] = i - bias;</span><br><span class=\"line\">            bucket[i]--;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</li>\n<li>空间复杂度：计数排序空间复杂度为O(k)，k为桶数组的长度。</li>\n<li>稳定性：计数排序是稳定的。</li>\n</ul>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><p><strong>基本思想</strong><br>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i &lt; j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i – min) &#x2F; arr.length。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] bucketSort(<span class=\"type\">int</span>[] array)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        max = Math.max(max, array[i]);</span><br><span class=\"line\">        min = Math.min(min, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i &lt; j）的数，即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">bucketNum</span> <span class=\"operator\">=</span> (max - min) / array.length + <span class=\"number\">1</span>;</span><br><span class=\"line\">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class=\"line\">        bucketArr.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将每个元素放入桶</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> (array[i] - min) / (array.length);</span><br><span class=\"line\">        bucketArr.get(num).add(array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对每个桶进行排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class=\"line\">        Collections.sort(bucketArr.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;j &lt; bucketArr.get(i).size();j++) &#123;</span><br><span class=\"line\">           array[k++] = bucketArr.get(i).get(j);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。</li>\n<li>空间复杂度：桶排序空间复杂度为O(n + k)。</li>\n<li>稳定性：桶排序是稳定的。</li>\n</ul>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><p><strong>基本思想</strong><br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<p><strong>算法描述</strong></p>\n<ol>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>array 为原始数组，从最低位开始取每个位组成 radix 数组；</li>\n<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] RadixSort(<span class=\"type\">int</span>[] array) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span> || array.length &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">// 1.先算出最大数的位数；</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            max = Math.max(max, array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxDigit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (max != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            max /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            maxDigit++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">div</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        bucketList.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"comment\">//2.进行maxDigit趟分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; maxDigit; i++,div *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> (array[j] / div) % <span class=\"number\">10</span>;</span><br><span class=\"line\">                bucketList.get(num).add(array[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3.收集</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class=\"line\">                    array[index++] = bucketList.get(j).get(k);</span><br><span class=\"line\">                bucketList.get(j).clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。</li>\n<li>空间复杂度：基数排序空间复杂度为O(n + k)。</li>\n<li>稳定性：基数排序是稳定的。</li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BinarySearch &#123;</span><br><span class=\"line\">    public static int binarySearch(int[] array, int target) &#123;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = array.length - 1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        while (left &lt;= right) &#123;</span><br><span class=\"line\">            int mid = left + (right - left) / 2; // 防止整形的(left + right)/2溢出</span><br><span class=\"line\">            if (array[mid] == target) &#123;</span><br><span class=\"line\">                return mid;</span><br><span class=\"line\">            &#125; else if (array[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                right = mid - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1; // 未找到目标值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class=\"line\">        int target = 7;</span><br><span class=\"line\">        int result = binarySearch(array, target);</span><br><span class=\"line\">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 递归实现</span><br><span class=\"line\">public class BinarySearch &#123;</span><br><span class=\"line\">    public static int binarySearch(int[] array, int target, int left, int right) &#123;</span><br><span class=\"line\">        if (left &gt; right) &#123;</span><br><span class=\"line\">            return -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int mid = left + (right - left) / 2;</span><br><span class=\"line\">        if (array[mid] == target) &#123;</span><br><span class=\"line\">            return mid;</span><br><span class=\"line\">        &#125; else if (array[mid] &lt; target) &#123;</span><br><span class=\"line\">            return binarySearch(array, target, mid + 1, right);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return binarySearch(array, target, left, mid - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class=\"line\">        int target = 7;</span><br><span class=\"line\">        int result = binarySearch(array, target, 0, array.length - 1);</span><br><span class=\"line\">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归删除文件夹\"><a href=\"#递归删除文件夹\" class=\"headerlink\" title=\"递归删除文件夹\"></a>递归删除文件夹</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileDeleter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 示例：删除路径为&quot;example&quot;的文件或目录</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> deleteRecursively(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(path));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;删除成功: &quot;</span> + path);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;删除失败: &quot;</span> + path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递归删除文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file 要删除的文件或目录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果成功删除，则返回true；否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">deleteRecursively</span><span class=\"params\">(File file)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;文件不存在: &quot;</span> + file.getAbsolutePath());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是目录，则递归删除目录中的内容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isDirectory()) &#123;</span><br><span class=\"line\">            File[] files = file.listFiles();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (files != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (File child : files) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!deleteRecursively(child)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 删除文件或空目录</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> file.delete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"无重复最长子串\"><a href=\"#无重复最长子串\" class=\"headerlink\" title=\"无重复最长子串\"></a>无重复最长子串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 滑动窗口</span></span><br><span class=\"line\">        HashMap&lt;Character, Integer&gt; window = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; s.length()) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> s.charAt(right);</span><br><span class=\"line\">            <span class=\"comment\">// 增大窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">// 窗口变化后对数据进行处理</span></span><br><span class=\"line\">            window.put(c, window.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 是否需要缩小窗口</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (window.get(c) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> s.charAt(left);</span><br><span class=\"line\">                <span class=\"comment\">// 缩小窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">// 窗口变化后对数据进行处理</span></span><br><span class=\"line\">                window.put(d, window.get(d) - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 缩小窗口后保证window内没有重复元素</span></span><br><span class=\"line\">            res = Math.max(right - left, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树前序遍历转链表\"><a href=\"#二叉树前序遍历转链表\" class=\"headerlink\" title=\"二叉树前序遍历转链表\"></a>二叉树前序遍历转链表</h3><p>二叉树的先序遍历，然后按照前序顺序将其转化为一个链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Node <span class=\"title function_\">trans</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">dummy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(-<span class=\"number\">1</span>), p = dummy;</span><br><span class=\"line\">        traverse(root, p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traverse</span><span class=\"params\">(TreeNode root, Node p)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(root.val, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        p.next = node;</span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">        traverse(root.left, p);</span><br><span class=\"line\">        traverse(root.right, p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最长重复子串-不会。。。后面有时间再研究吧\"><a href=\"#最长重复子串-不会。。。后面有时间再研究吧\" class=\"headerlink\" title=\"最长重复子串(不会。。。后面有时间再研究吧)\"></a>最长重复子串(不会。。。后面有时间再研究吧)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestDupSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Random</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 生成两个进制</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> random.nextInt(<span class=\"number\">75</span>) + <span class=\"number\">26</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a2</span> <span class=\"operator\">=</span> random.nextInt(<span class=\"number\">75</span>) + <span class=\"number\">26</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 生成两个模</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mod1</span> <span class=\"operator\">=</span> random.nextInt(Integer.MAX_VALUE - <span class=\"number\">1000000007</span> + <span class=\"number\">1</span>) + <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mod2</span> <span class=\"operator\">=</span> random.nextInt(Integer.MAX_VALUE - <span class=\"number\">1000000007</span> + <span class=\"number\">1</span>) + <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"comment\">// 先对所有字符进行编码</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            arr[i] = s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找的范围是[1, n-1]</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, start = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> l + (r - l + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> check(arr, m, a1, a2, mod1, mod2);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (idx != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 有重复子串，移动左边界</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                length = m;</span><br><span class=\"line\">                start = idx;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无重复子串，移动右边界</span></span><br><span class=\"line\">                r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start != -<span class=\"number\">1</span> ? s.substring(start, start + length) : <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> m, <span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> mod1, <span class=\"type\">int</span> mod2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aL1</span> <span class=\"operator\">=</span> pow(a1, m, mod1);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aL2</span> <span class=\"operator\">=</span> pow(a2, m, mod2);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">h1</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, h2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;</span><br><span class=\"line\">            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h1 += mod1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h2 += mod2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 存储一个编码组合是否出现过</span></span><br><span class=\"line\">        Set&lt;Long&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Long&gt;();</span><br><span class=\"line\">        seen.add(h1 * mod2 + h2);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; start &lt;= n - m; ++start) &#123;</span><br><span class=\"line\">            h1 = (h1 * a1 % mod1 - arr[start - <span class=\"number\">1</span>] * aL1 % mod1 + arr[start + m - <span class=\"number\">1</span>]) % mod1;</span><br><span class=\"line\">            h2 = (h2 * a2 % mod2 - arr[start - <span class=\"number\">1</span>] * aL2 % mod2 + arr[start + m - <span class=\"number\">1</span>]) % mod2;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h1 += mod1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                h2 += mod2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> h1 * mod2 + h2;</span><br><span class=\"line\">            <span class=\"comment\">// 如果重复，则返回重复串的起点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(num)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没有重复，则返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">pow</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> m, <span class=\"type\">int</span> mod)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">contribute</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = ans * contribute % mod;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ans &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    ans += mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            contribute = contribute * contribute % mod;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (contribute &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                contribute += mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CompletableFuture类异步调用实现\"><a href=\"#CompletableFuture类异步调用实现\" class=\"headerlink\" title=\"CompletableFuture类异步调用实现\"></a>CompletableFuture类异步调用实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟一个长时间运行的任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>); <span class=\"comment\">// 休眠2秒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;任务完成&quot;</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class=\"line\">        future.thenAccept(result -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 主线程继续执行其他操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主线程继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞主线程，直到异步任务完成（可选）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> future.get();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"测开面经","keywords":["面经"],"description":"测开面经","abbrlink":17768,"date":"2024-05-27T12:15:34.000Z","updated":"2024-06-25T08:47:53.000Z","top_img":"https://s2.loli.net/2024/05/27/BLZiDeVdQokmptg.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/drCF3NnMKboz1AQ.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 注：下面内容一部分来自于我舍友的博客\n\n### 测开自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 测试开发岗位。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！\n\n\n### 为什么选择测开\n之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。\n\n> 需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。\n\n### 做过哪些关于测开的工作\n之前负责给社区写一个适配器。\n\nCasbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 `SQLAlchemy` 适配器。这种适配器允许在异步环境中使用 `SQLAlchemy` 作为持久化层，管理 Casbin 的策略存储。\n\n主要工作：\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。 \n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n  - 测试添加一个策略，添加多个策略\n  - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n  - 测试更新一个策略，测试更新多个策略。\n\n还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。\n\n### 黑盒测试\n又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。\n\n### 白盒测试\n又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。\n\n### 测试用例\n描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束\n\n### 测试用例的设计方法\n- 等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。\n- 边界值分析：测试边界值\n- 决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果\n- 随机测试：随机生成输入数据进行测试\n\n### 如何理解测试开发中的开发\n- 编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。\n- 编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如`JUnit`、`TestNG`、`Selenium`等）来组织和运行测试。\n- 开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。\n- 维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。\n- 参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。\n\n### 如何测试一个Java项目？\n- 单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。\n- 集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。\n- 性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。\n- 持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。\n\n### 如何判断所写接口功能正常？\n- 功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。\n- 性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。\n- 安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。\n- 兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。\n\n### 怎么构造无用测试用例？\n- 随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。\n- 非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。\n- 重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。\n\n### 如何感知线上项目出现问题\n日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。\n性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。\n自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。\n\n### 小红书购物搜索框设计测试用例\n测试用例名称：搜索框输入有效关键词\n- 输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示与输入关键词相关的商品列表。\n\n测试用例名称：搜索框输入无效关键词\n- 输入：在搜索框中输入无效的商品关键词，例如“@@@”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面提示“未找到相关商品”。\n\n测试用例名称：搜索框输入空关键词\n- 输入：在搜索框中不输入任何内容。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示全部商品列表。\n\n测试用例名称：搜索框联想功能\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：等待几秒钟，观察搜索框下方是否出现联想词。\n- 预期结果：搜索框下方显示与输入关键词相关的联想词列表。\n\n测试用例名称：搜索框输入并选择联想词\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：从联想词列表中选择一个词，例如“连衣裙”。\n- 预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。\n\n测试用例名称：搜索框清空功能\n- 输入：在搜索框中输入关键词，例如“连衣裙”。\n- 操作：点击搜索框右侧的清空按钮。\n- 预期结果：搜索框中的文本被清空，搜索框恢复为空状态。\n\n### 登录设计测试样例\n测试用例名称：输入有效的用户名和密码登录\n- 输入：有效的用户名和密码。\n- 操作：在登录页面输入用户名和密码，点击登录按钮。\n- 预期结果：成功登录，跳转到用户的个人资料页面或首页。\n\n测试用例名称：输入无效的用户名和密码登录\n- 输入：无效的用户名和密码。\n- 操作：在登录页面输入错误的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码错误的错误信息。\n\n测试用例名称：输入不存在的用户名登录\n- 输入：不存在的用户名和有效密码。\n- 操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不存在的错误信息。\n\n测试用例名称：输入正确的用户名和空密码登录\n- 输入：有效的用户名和空密码。\n- 操作：在登录页面输入正确的用户名和空密码，点击登录按钮。\n- 预期结果：登录失败，提示密码不能为空的错误信息。\n\n测试用例名称：输入空用户名和正确密码登录\n- 输入：空用户名和有效的密码。\n- 操作：在登录页面输入空用户名和正确的密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不能为空的错误信息。\n\n测试用例名称：输入特殊字符的用户名和密码登录\n- 输入：包含特殊字符的用户名和密码。\n- 操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码格式不正确的错误信息。\n\n测试用例名称：记住登录状态\n- 输入：有效的用户名和密码。\n- 操作：在登录页面勾选“记住我”选项后登录。\n- 预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。\n\n测试用例名称：登录页链接验证\n- 输入：无。\n- 操作：检查登录页面上的链接。\n- 预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。\n\n测试用例名称：跳转到登录页面\n- 输入：未登录状态。\n- 操作：尝试访问需要登录权限的页面。\n- 预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。\n\n测试用例名称：登录界面的响应速度\n- 输入：无。\n- 操作：在不同网络环境下打开登录页面。\n- 预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。\n\n### 微信发送文件的测试用例\n功能测试\n- 正常发送文件\n- 发送支持的文件类型\n\n边界值测试\n- 发送最大允许大小的文件\n- 发送超过最大允许大小的文件\n\n异常情况测试\n- 发送空文件\n- 发送损坏文件\n- 网络中断后重新发送\n\n性能测试\n- 同时发送多个文件\n- 选择一个接近最大允许大小的文件\n\n用户体验测试\n- 发送文件时的用户提示\n- 文件发送记录\n\n安全性测试\n- 发送包含敏感信息的文件\n- 病毒文件检测\n\n跨平台测试\n\n### 微信发送红包的测试用例\n- 功能测试\n正常发送红包\n发送拼手气红包\n发送定向红包\n\n- 边界值测试\n发送最低和最高金额的红包\n发送超过最高金额的红包\n\n- 异常情况测试\n余额不足时发送红包\n网络中断后重新发送\n取消发送红包\n\n- 安全性测试\n多测领取红包\n红包过期\n未实名验证用户发送红包\n单方删除好友后发送红包\n\n用户体验测试\n\n跨平台测试\n\n性能测试\n- 高频发送红包\n- 大规模红包领取（拼手气红包）\n\n### 电影订票功能的测试样例\n功能测试\n- 检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确\n- 验证不同支付方式是否可用\n- 验证电子票是否包含必要信息、是否能通过扫描进入影院\n\n边界和异常情况测试\n- 无效的账户或者账户余额不足进行支付\n- 用户选择座位但未完成支付，座位在一定时间后能否自动释放\n\n性能测试\n- 系统负载测试：高并发访问\n- 正常负载和高负载下的响应时间是否正常\n\n兼容性测试\n\n### 电商满减优惠券测试用例设计\n设计电商满减优惠券的测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：\n\n- 正常情况\n  - 优惠券满减条件满足\n    - 用例描述：用户购物车金额为150元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为130元。\n  - 优惠券满减条件满足多张\n    - 用例描述：用户购物车金额为250元，使用两张满100减20元优惠券。\n    - 预期结果：最终支付金额为210元。\n\n- 边界情况 \n  - 刚好满足满减条件\n    - 用例描述：用户购物车金额为100元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为80元。\n  - 差一分钱满足满减条件\n    - 用例描述：用户购物车金额为99.99元，使用满100减20元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为99.99元。\n  - 超过满减条件1分钱\n    - 用例描述：用户购物车金额为100.01元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为80.01元。\n\n- 异常情况\n  - 优惠券已过期\n    - 用例描述：用户尝试使用一张已过期的满100减20元优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n  - 优惠券不适用商品\n    - 用例描述：用户购物车内商品不在优惠券适用范围，购物车金额为150元，使用满100减20元优惠券。\n    - 预期结果：提示优惠券不适用，不能使用，最终支付金额为150元。\n  - 优惠券已被使用\n    - 用例描述：用户尝试使用一张已被使用过的满100减20元优惠券。\n    - 预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。\n\n- 多重优惠情况\n  - 叠加优惠券\n    - 用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张满100减20元优惠券。\n    - 预期结果：先使用满200减50元优惠券，金额变为250元，再使用满100减20元优惠券，最终支付金额为230元。\n  - 不同优惠券叠加使用规则\n    - 用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张全场9折优惠券。\n    - 预期结果：先使用满200减50元优惠券，金额变为250元，再使用9折优惠券，最终支付金额为225元。\n\n- 优惠券优先级情况\n  - 有多张优惠券可用\n    - 用例描述：用户购物车金额为200元，有满100减20元优惠券和满150减30元优惠券。\n    - 预期结果：系统自动选择满150减30元优惠券，最终支付金额为170元。\n\n- 无法使用优惠券的情况\n  - 购物车金额不足\n    - 用例描述：用户购物车金额为50元，使用满100减20元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为50元。\n  - 优惠券被取消\n    - 用例描述：用户尝试使用被商家取消的优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n\n这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试电商平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。\n\n### 外卖优惠券测试用例设计\n设计外卖平台的满减优惠券测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：\n\n- 正常情况\n  - 优惠券满减条件满足\n    - 用例描述：用户订单金额为60元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为50元。\n  - 优惠券满减条件满足多张\n    - 用例描述：用户订单金额为120元，使用两张满50减10元优惠券。\n    - 预期结果：最终支付金额为100元。\n\n- 边界情况\n  - 刚好满足满减条件\n    - 用例描述：用户订单金额为50元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为40元。\n  - 差一分钱满足满减条件\n    - 用例描述：用户订单金额为49.99元，使用满50减10元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为49.99元。\n  - 超过满减条件1分钱\n    - 用例描述：用户订单金额为50.01元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为40.01元。\n\n- 异常情况\n  - 优惠券已过期\n    - 用例描述：用户尝试使用一张已过期的满50减10元优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n  - 优惠券不适用餐厅\n    - 用例描述：用户订单来自不适用优惠券的餐厅，订单金额为60元，使用满50减10元优惠券。\n    - 预期结果：提示优惠券不适用，不能使用，最终支付金额为60元。\n  - 优惠券已被使用\n    - 用例描述：用户尝试使用一张已被使用过的满50减10元优惠券。\n    - 预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。\n\n- 多重优惠情况\n  - 叠加优惠券\n    - 用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张满50减10元优惠券。\n    - 预期结果：先使用满80减20元优惠券，金额变为80元，再使用满50减10元优惠券，最终支付金额为70元。\n  - 不同优惠券叠加使用规则\n    - 用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张全场9折优惠券。\n    - 预期结果：先使用满80减20元优惠券，金额变为80元，再使用9折优惠券，最终支付金额为72元。\n\n- 优惠券优先级情况\n  - 有多张优惠券可用\n    - 用例描述：用户订单金额为100元，有满50减10元优惠券和满80减20元优惠券。\n    - 预期结果：系统自动选择满80减20元优惠券，最终支付金额为80元。\n\n- 无法使用优惠券的情况\n  - 订单金额不足\n    - 用例描述：用户订单金额为30元，使用满50减10元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为30元。\n  - 优惠券被取消\n    - 用例描述：用户尝试使用被商家取消的优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n\n- 特殊情况\n  - 优惠券部分使用\n    - 用例描述：用户订单金额为55元，使用满50减10元优惠券，同时使用余额支付（5元）。\n    - 预期结果：订单金额55元，使用优惠券后支付45元，再用余额支付5元，最终支付金额为40元。\n\n这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试外卖平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。\n\n\n\n### Github Workflow自动化测试\nGitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：\n\n1. 持续集成（CI）： 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。\n2. 持续部署（CD）： 自动将代码部署到生产环境或其他目标环境。\n3. 代码分析和质量检查： 运行静态代码分析工具，以检查代码质量和一致性。\n4. 构建和发布： 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。\n5. 自动化任务： 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。\n\n在 GitHub Actions 中，workflow 文件是通过 `.yml` 或 `.yaml` 文件定义的，通常放在 `.github/workflows/` 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。\n\n示例：\n\n以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：\n\n```yaml\nname: CI\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run tests\n      run: npm test\n```\n\n### 支付宝/微信转账功能测试用例\n在设计支付宝转账功能的测试用例时，应该覆盖各种正常情况、边界情况和异常情况，以确保转账功能的健壮性和可靠性。以下是详细的测试用例设计：\n\n- 正常情况\n  - 成功转账\n    - 用例描述：用户A向用户B成功转账100元。\n    - 前置条件：用户A账户余额大于等于100元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少100元，用户B账户余额增加100元。\n  - 转账金额包含小数\n    - 用例描述：用户A向用户B转账50.75元。\n    - 前置条件：用户A账户余额大于等于50.75元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额50.75元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少50.75元，用户B账户余额增加50.75元。\n\n- 边界情况\n  - 转账金额为0\n    - 用例描述：用户A向用户B转账0元。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额0元。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示转账金额无效，转账失败。\n  - 转账金额为账户余额\n    - 用例描述：用户A向用户B转账用户A的全部余额。\n    - 前置条件：用户A账户余额为200元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额200元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少200元，用户B账户余额增加200元。\n\n- 异常情况\n  - 转账金额超过账户余额\n    - 用例描述：用户A尝试向用户B转账300元，而用户A账户余额只有100元。\n    - 前置条件：用户A账户余额100元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额300元。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示余额不足，转账失败。\n  - 用户B账户无效\n    - 用例描述：用户A尝试向一个无效的用户B账户转账100元。\n    - 前置条件：用户A账户余额大于等于100元，用户B账户无效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入无效的用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示用户B账户无效，转账失败。\n  - 网络连接中断\n    - 用例描述：用户A在转账过程中网络连接中断。\n    - 前置条件：用户A账户有效，用户B账户有效，网络连接不稳定。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 确认转账时网络中断。\n    - 预期结果：系统提示网络连接问题，转账未完成。\n\n- 安全测试\n  - 防止重复提交\n    - 用例描述：用户A在确认转账后多次点击确认按钮。\n    - 前置条件：用户A账户有效，用户B账户有效，转账金额为100元。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 多次点击确认转账按钮。\n    - 预期结果：系统只执行一次转账操作，用户A账户减少100元，用户B账户增加100元。\n  - 转账金额非法字符\n    - 用例描述：用户A尝试输入非法字符作为转账金额。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入非法字符（如\"abc\"）作为转账金额。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示金额无效，转账失败。\n\n- 其他情况\n  - 跨境转账\n    - 用例描述：用户A向国外的用户B转账100美元。\n    - 前置条件：用户A账户有效且支持跨境转账，用户B账户有效，用户A有足够的美元余额。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择跨境转账功能。\n      3. 输入转账金额100美元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A美元余额减少100美元，用户B账户美元余额增加100美元。\n  - 转账备注\n    - 用例描述：用户A向用户B转账100元，并添加备注信息。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 添加转账备注信息（如“生日礼物”）。\n      6. 确认转账。\n    - 预期结果：转账成功，备注信息正确保存，用户A账户减少100元，用户B账户增加100元。\n\n这些测试用例覆盖了支付宝转账功能的主要场景，可以帮助全面测试转账功能，确保系统能够正确处理各种情况下的转账操作。\n\n\n在这个示例中，workflow 文件名为 `ci.yml`，它定义了一个名为 `build` 的 job，该 job 在 `ubuntu-latest` 的环境上运行。整个过程包括以下步骤：\n1. Checkout code：检出代码仓库。\n2. Set up Node.js：设置 Node.js 环境。\n3. Install dependencies：安装依赖。\n4. Run tests：运行测试。\n\n所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。\n\n### 测试工具\n- JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。\n- TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。\n- Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。\n- JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。\n\n\n\n\n","source":"_posts/测开面经.md","raw":"---\ntitle: 测开面经\ntags:\n  - 测试开发\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 测开面经\nabbrlink: 17768\ndate: 2024-05-27 20:15:34\nupdated: 2024-06-25 16:47:53\ntop_img: https://s2.loli.net/2024/05/27/BLZiDeVdQokmptg.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/drCF3NnMKboz1AQ.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 注：下面内容一部分来自于我舍友的博客\n\n### 测开自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 测试开发岗位。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！\n\n\n### 为什么选择测开\n之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。\n\n> 需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。\n\n### 做过哪些关于测开的工作\n之前负责给社区写一个适配器。\n\nCasbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 `SQLAlchemy` 适配器。这种适配器允许在异步环境中使用 `SQLAlchemy` 作为持久化层，管理 Casbin 的策略存储。\n\n主要工作：\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。 \n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n  - 测试添加一个策略，添加多个策略\n  - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n  - 测试更新一个策略，测试更新多个策略。\n\n还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。\n\n### 黑盒测试\n又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。\n\n### 白盒测试\n又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。\n\n### 测试用例\n描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束\n\n### 测试用例的设计方法\n- 等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。\n- 边界值分析：测试边界值\n- 决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果\n- 随机测试：随机生成输入数据进行测试\n\n### 如何理解测试开发中的开发\n- 编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。\n- 编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如`JUnit`、`TestNG`、`Selenium`等）来组织和运行测试。\n- 开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。\n- 维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。\n- 参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。\n\n### 如何测试一个Java项目？\n- 单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。\n- 集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。\n- 性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。\n- 持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。\n\n### 如何判断所写接口功能正常？\n- 功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。\n- 性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。\n- 安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。\n- 兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。\n\n### 怎么构造无用测试用例？\n- 随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。\n- 非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。\n- 重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。\n\n### 如何感知线上项目出现问题\n日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。\n性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。\n自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。\n\n### 小红书购物搜索框设计测试用例\n测试用例名称：搜索框输入有效关键词\n- 输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示与输入关键词相关的商品列表。\n\n测试用例名称：搜索框输入无效关键词\n- 输入：在搜索框中输入无效的商品关键词，例如“@@@”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面提示“未找到相关商品”。\n\n测试用例名称：搜索框输入空关键词\n- 输入：在搜索框中不输入任何内容。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示全部商品列表。\n\n测试用例名称：搜索框联想功能\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：等待几秒钟，观察搜索框下方是否出现联想词。\n- 预期结果：搜索框下方显示与输入关键词相关的联想词列表。\n\n测试用例名称：搜索框输入并选择联想词\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：从联想词列表中选择一个词，例如“连衣裙”。\n- 预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。\n\n测试用例名称：搜索框清空功能\n- 输入：在搜索框中输入关键词，例如“连衣裙”。\n- 操作：点击搜索框右侧的清空按钮。\n- 预期结果：搜索框中的文本被清空，搜索框恢复为空状态。\n\n### 登录设计测试样例\n测试用例名称：输入有效的用户名和密码登录\n- 输入：有效的用户名和密码。\n- 操作：在登录页面输入用户名和密码，点击登录按钮。\n- 预期结果：成功登录，跳转到用户的个人资料页面或首页。\n\n测试用例名称：输入无效的用户名和密码登录\n- 输入：无效的用户名和密码。\n- 操作：在登录页面输入错误的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码错误的错误信息。\n\n测试用例名称：输入不存在的用户名登录\n- 输入：不存在的用户名和有效密码。\n- 操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不存在的错误信息。\n\n测试用例名称：输入正确的用户名和空密码登录\n- 输入：有效的用户名和空密码。\n- 操作：在登录页面输入正确的用户名和空密码，点击登录按钮。\n- 预期结果：登录失败，提示密码不能为空的错误信息。\n\n测试用例名称：输入空用户名和正确密码登录\n- 输入：空用户名和有效的密码。\n- 操作：在登录页面输入空用户名和正确的密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不能为空的错误信息。\n\n测试用例名称：输入特殊字符的用户名和密码登录\n- 输入：包含特殊字符的用户名和密码。\n- 操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码格式不正确的错误信息。\n\n测试用例名称：记住登录状态\n- 输入：有效的用户名和密码。\n- 操作：在登录页面勾选“记住我”选项后登录。\n- 预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。\n\n测试用例名称：登录页链接验证\n- 输入：无。\n- 操作：检查登录页面上的链接。\n- 预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。\n\n测试用例名称：跳转到登录页面\n- 输入：未登录状态。\n- 操作：尝试访问需要登录权限的页面。\n- 预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。\n\n测试用例名称：登录界面的响应速度\n- 输入：无。\n- 操作：在不同网络环境下打开登录页面。\n- 预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。\n\n### 微信发送文件的测试用例\n功能测试\n- 正常发送文件\n- 发送支持的文件类型\n\n边界值测试\n- 发送最大允许大小的文件\n- 发送超过最大允许大小的文件\n\n异常情况测试\n- 发送空文件\n- 发送损坏文件\n- 网络中断后重新发送\n\n性能测试\n- 同时发送多个文件\n- 选择一个接近最大允许大小的文件\n\n用户体验测试\n- 发送文件时的用户提示\n- 文件发送记录\n\n安全性测试\n- 发送包含敏感信息的文件\n- 病毒文件检测\n\n跨平台测试\n\n### 微信发送红包的测试用例\n- 功能测试\n正常发送红包\n发送拼手气红包\n发送定向红包\n\n- 边界值测试\n发送最低和最高金额的红包\n发送超过最高金额的红包\n\n- 异常情况测试\n余额不足时发送红包\n网络中断后重新发送\n取消发送红包\n\n- 安全性测试\n多测领取红包\n红包过期\n未实名验证用户发送红包\n单方删除好友后发送红包\n\n用户体验测试\n\n跨平台测试\n\n性能测试\n- 高频发送红包\n- 大规模红包领取（拼手气红包）\n\n### 电影订票功能的测试样例\n功能测试\n- 检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确\n- 验证不同支付方式是否可用\n- 验证电子票是否包含必要信息、是否能通过扫描进入影院\n\n边界和异常情况测试\n- 无效的账户或者账户余额不足进行支付\n- 用户选择座位但未完成支付，座位在一定时间后能否自动释放\n\n性能测试\n- 系统负载测试：高并发访问\n- 正常负载和高负载下的响应时间是否正常\n\n兼容性测试\n\n### 电商满减优惠券测试用例设计\n设计电商满减优惠券的测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：\n\n- 正常情况\n  - 优惠券满减条件满足\n    - 用例描述：用户购物车金额为150元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为130元。\n  - 优惠券满减条件满足多张\n    - 用例描述：用户购物车金额为250元，使用两张满100减20元优惠券。\n    - 预期结果：最终支付金额为210元。\n\n- 边界情况 \n  - 刚好满足满减条件\n    - 用例描述：用户购物车金额为100元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为80元。\n  - 差一分钱满足满减条件\n    - 用例描述：用户购物车金额为99.99元，使用满100减20元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为99.99元。\n  - 超过满减条件1分钱\n    - 用例描述：用户购物车金额为100.01元，使用满100减20元优惠券。\n    - 预期结果：最终支付金额为80.01元。\n\n- 异常情况\n  - 优惠券已过期\n    - 用例描述：用户尝试使用一张已过期的满100减20元优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n  - 优惠券不适用商品\n    - 用例描述：用户购物车内商品不在优惠券适用范围，购物车金额为150元，使用满100减20元优惠券。\n    - 预期结果：提示优惠券不适用，不能使用，最终支付金额为150元。\n  - 优惠券已被使用\n    - 用例描述：用户尝试使用一张已被使用过的满100减20元优惠券。\n    - 预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。\n\n- 多重优惠情况\n  - 叠加优惠券\n    - 用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张满100减20元优惠券。\n    - 预期结果：先使用满200减50元优惠券，金额变为250元，再使用满100减20元优惠券，最终支付金额为230元。\n  - 不同优惠券叠加使用规则\n    - 用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张全场9折优惠券。\n    - 预期结果：先使用满200减50元优惠券，金额变为250元，再使用9折优惠券，最终支付金额为225元。\n\n- 优惠券优先级情况\n  - 有多张优惠券可用\n    - 用例描述：用户购物车金额为200元，有满100减20元优惠券和满150减30元优惠券。\n    - 预期结果：系统自动选择满150减30元优惠券，最终支付金额为170元。\n\n- 无法使用优惠券的情况\n  - 购物车金额不足\n    - 用例描述：用户购物车金额为50元，使用满100减20元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为50元。\n  - 优惠券被取消\n    - 用例描述：用户尝试使用被商家取消的优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n\n这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试电商平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。\n\n### 外卖优惠券测试用例设计\n设计外卖平台的满减优惠券测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：\n\n- 正常情况\n  - 优惠券满减条件满足\n    - 用例描述：用户订单金额为60元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为50元。\n  - 优惠券满减条件满足多张\n    - 用例描述：用户订单金额为120元，使用两张满50减10元优惠券。\n    - 预期结果：最终支付金额为100元。\n\n- 边界情况\n  - 刚好满足满减条件\n    - 用例描述：用户订单金额为50元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为40元。\n  - 差一分钱满足满减条件\n    - 用例描述：用户订单金额为49.99元，使用满50减10元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为49.99元。\n  - 超过满减条件1分钱\n    - 用例描述：用户订单金额为50.01元，使用满50减10元优惠券。\n    - 预期结果：最终支付金额为40.01元。\n\n- 异常情况\n  - 优惠券已过期\n    - 用例描述：用户尝试使用一张已过期的满50减10元优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n  - 优惠券不适用餐厅\n    - 用例描述：用户订单来自不适用优惠券的餐厅，订单金额为60元，使用满50减10元优惠券。\n    - 预期结果：提示优惠券不适用，不能使用，最终支付金额为60元。\n  - 优惠券已被使用\n    - 用例描述：用户尝试使用一张已被使用过的满50减10元优惠券。\n    - 预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。\n\n- 多重优惠情况\n  - 叠加优惠券\n    - 用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张满50减10元优惠券。\n    - 预期结果：先使用满80减20元优惠券，金额变为80元，再使用满50减10元优惠券，最终支付金额为70元。\n  - 不同优惠券叠加使用规则\n    - 用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张全场9折优惠券。\n    - 预期结果：先使用满80减20元优惠券，金额变为80元，再使用9折优惠券，最终支付金额为72元。\n\n- 优惠券优先级情况\n  - 有多张优惠券可用\n    - 用例描述：用户订单金额为100元，有满50减10元优惠券和满80减20元优惠券。\n    - 预期结果：系统自动选择满80减20元优惠券，最终支付金额为80元。\n\n- 无法使用优惠券的情况\n  - 订单金额不足\n    - 用例描述：用户订单金额为30元，使用满50减10元优惠券。\n    - 预期结果：不能使用优惠券，最终支付金额为30元。\n  - 优惠券被取消\n    - 用例描述：用户尝试使用被商家取消的优惠券。\n    - 预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。\n\n- 特殊情况\n  - 优惠券部分使用\n    - 用例描述：用户订单金额为55元，使用满50减10元优惠券，同时使用余额支付（5元）。\n    - 预期结果：订单金额55元，使用优惠券后支付45元，再用余额支付5元，最终支付金额为40元。\n\n这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试外卖平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。\n\n\n\n### Github Workflow自动化测试\nGitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：\n\n1. 持续集成（CI）： 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。\n2. 持续部署（CD）： 自动将代码部署到生产环境或其他目标环境。\n3. 代码分析和质量检查： 运行静态代码分析工具，以检查代码质量和一致性。\n4. 构建和发布： 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。\n5. 自动化任务： 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。\n\n在 GitHub Actions 中，workflow 文件是通过 `.yml` 或 `.yaml` 文件定义的，通常放在 `.github/workflows/` 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。\n\n示例：\n\n以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：\n\n```yaml\nname: CI\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run tests\n      run: npm test\n```\n\n### 支付宝/微信转账功能测试用例\n在设计支付宝转账功能的测试用例时，应该覆盖各种正常情况、边界情况和异常情况，以确保转账功能的健壮性和可靠性。以下是详细的测试用例设计：\n\n- 正常情况\n  - 成功转账\n    - 用例描述：用户A向用户B成功转账100元。\n    - 前置条件：用户A账户余额大于等于100元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少100元，用户B账户余额增加100元。\n  - 转账金额包含小数\n    - 用例描述：用户A向用户B转账50.75元。\n    - 前置条件：用户A账户余额大于等于50.75元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额50.75元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少50.75元，用户B账户余额增加50.75元。\n\n- 边界情况\n  - 转账金额为0\n    - 用例描述：用户A向用户B转账0元。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额0元。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示转账金额无效，转账失败。\n  - 转账金额为账户余额\n    - 用例描述：用户A向用户B转账用户A的全部余额。\n    - 前置条件：用户A账户余额为200元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额200元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A账户余额减少200元，用户B账户余额增加200元。\n\n- 异常情况\n  - 转账金额超过账户余额\n    - 用例描述：用户A尝试向用户B转账300元，而用户A账户余额只有100元。\n    - 前置条件：用户A账户余额100元，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额300元。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示余额不足，转账失败。\n  - 用户B账户无效\n    - 用例描述：用户A尝试向一个无效的用户B账户转账100元。\n    - 前置条件：用户A账户余额大于等于100元，用户B账户无效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入无效的用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示用户B账户无效，转账失败。\n  - 网络连接中断\n    - 用例描述：用户A在转账过程中网络连接中断。\n    - 前置条件：用户A账户有效，用户B账户有效，网络连接不稳定。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 确认转账时网络中断。\n    - 预期结果：系统提示网络连接问题，转账未完成。\n\n- 安全测试\n  - 防止重复提交\n    - 用例描述：用户A在确认转账后多次点击确认按钮。\n    - 前置条件：用户A账户有效，用户B账户有效，转账金额为100元。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 多次点击确认转账按钮。\n    - 预期结果：系统只执行一次转账操作，用户A账户减少100元，用户B账户增加100元。\n  - 转账金额非法字符\n    - 用例描述：用户A尝试输入非法字符作为转账金额。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入非法字符（如\"abc\"）作为转账金额。\n      4. 输入用户B的账户信息。\n      5. 尝试确认转账。\n    - 预期结果：系统提示金额无效，转账失败。\n\n- 其他情况\n  - 跨境转账\n    - 用例描述：用户A向国外的用户B转账100美元。\n    - 前置条件：用户A账户有效且支持跨境转账，用户B账户有效，用户A有足够的美元余额。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择跨境转账功能。\n      3. 输入转账金额100美元。\n      4. 输入用户B的账户信息。\n      5. 确认转账。\n    - 预期结果：转账成功，用户A美元余额减少100美元，用户B账户美元余额增加100美元。\n  - 转账备注\n    - 用例描述：用户A向用户B转账100元，并添加备注信息。\n    - 前置条件：用户A账户有效，用户B账户有效。\n    - 操作步骤：\n      1. 用户A登录支付宝账户。\n      2. 用户A选择转账功能。\n      3. 输入转账金额100元。\n      4. 输入用户B的账户信息。\n      5. 添加转账备注信息（如“生日礼物”）。\n      6. 确认转账。\n    - 预期结果：转账成功，备注信息正确保存，用户A账户减少100元，用户B账户增加100元。\n\n这些测试用例覆盖了支付宝转账功能的主要场景，可以帮助全面测试转账功能，确保系统能够正确处理各种情况下的转账操作。\n\n\n在这个示例中，workflow 文件名为 `ci.yml`，它定义了一个名为 `build` 的 job，该 job 在 `ubuntu-latest` 的环境上运行。整个过程包括以下步骤：\n1. Checkout code：检出代码仓库。\n2. Set up Node.js：设置 Node.js 环境。\n3. Install dependencies：安装依赖。\n4. Run tests：运行测试。\n\n所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。\n\n### 测试工具\n- JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。\n- TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。\n- Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。\n- JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。\n\n\n\n\n","slug":"测开面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1x002ir7gn1anhfiqu","content":"<blockquote>\n<p>注：下面内容一部分来自于我舍友的博客</p>\n</blockquote>\n<h3 id=\"测开自我介绍\"><a href=\"#测开自我介绍\" class=\"headerlink\" title=\"测开自我介绍\"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 测试开发岗位。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p>\n<h3 id=\"为什么选择测开\"><a href=\"#为什么选择测开\" class=\"headerlink\" title=\"为什么选择测开\"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p>\n<blockquote>\n<p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p>\n</blockquote>\n<h3 id=\"做过哪些关于测开的工作\"><a href=\"#做过哪些关于测开的工作\" class=\"headerlink\" title=\"做过哪些关于测开的工作\"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p>\n<p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p>\n<p>主要工作：</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p>\n<h3 id=\"黑盒测试\"><a href=\"#黑盒测试\" class=\"headerlink\" title=\"黑盒测试\"></a>黑盒测试</h3><p>又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>\n<h3 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h3><p>又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p>\n<h3 id=\"测试用例的设计方法\"><a href=\"#测试用例的设计方法\" class=\"headerlink\" title=\"测试用例的设计方法\"></a>测试用例的设计方法</h3><ul>\n<li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li>\n<li>边界值分析：测试边界值</li>\n<li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li>\n<li>随机测试：随机生成输入数据进行测试</li>\n</ul>\n<h3 id=\"如何理解测试开发中的开发\"><a href=\"#如何理解测试开发中的开发\" class=\"headerlink\" title=\"如何理解测试开发中的开发\"></a>如何理解测试开发中的开发</h3><ul>\n<li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>\n<li>编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等）来组织和运行测试。</li>\n<li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>\n<li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>\n<li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>\n</ul>\n<h3 id=\"如何测试一个Java项目？\"><a href=\"#如何测试一个Java项目？\" class=\"headerlink\" title=\"如何测试一个Java项目？\"></a>如何测试一个Java项目？</h3><ul>\n<li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>\n<li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>\n<li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>\n<li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>\n</ul>\n<h3 id=\"如何判断所写接口功能正常？\"><a href=\"#如何判断所写接口功能正常？\" class=\"headerlink\" title=\"如何判断所写接口功能正常？\"></a>如何判断所写接口功能正常？</h3><ul>\n<li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>\n<li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>\n<li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>\n<li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>\n</ul>\n<h3 id=\"怎么构造无用测试用例？\"><a href=\"#怎么构造无用测试用例？\" class=\"headerlink\" title=\"怎么构造无用测试用例？\"></a>怎么构造无用测试用例？</h3><ul>\n<li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>\n<li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>\n<li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>\n</ul>\n<h3 id=\"如何感知线上项目出现问题\"><a href=\"#如何感知线上项目出现问题\" class=\"headerlink\" title=\"如何感知线上项目出现问题\"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p>\n<h3 id=\"小红书购物搜索框设计测试用例\"><a href=\"#小红书购物搜索框设计测试用例\" class=\"headerlink\" title=\"小红书购物搜索框设计测试用例\"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p>\n<ul>\n<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入无效关键词</p>\n<ul>\n<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>\n</ul>\n<p>测试用例名称：搜索框输入空关键词</p>\n<ul>\n<li>输入：在搜索框中不输入任何内容。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示全部商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框联想功能</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>\n<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入并选择联想词</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>\n<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>\n</ul>\n<p>测试用例名称：搜索框清空功能</p>\n<ul>\n<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索框右侧的清空按钮。</li>\n<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>\n</ul>\n<h3 id=\"登录设计测试样例\"><a href=\"#登录设计测试样例\" class=\"headerlink\" title=\"登录设计测试样例\"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>\n<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>\n</ul>\n<p>测试用例名称：输入无效的用户名和密码登录</p>\n<ul>\n<li>输入：无效的用户名和密码。</li>\n<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>\n</ul>\n<p>测试用例名称：输入不存在的用户名登录</p>\n<ul>\n<li>输入：不存在的用户名和有效密码。</li>\n<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>\n</ul>\n<p>测试用例名称：输入正确的用户名和空密码登录</p>\n<ul>\n<li>输入：有效的用户名和空密码。</li>\n<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入空用户名和正确密码登录</p>\n<ul>\n<li>输入：空用户名和有效的密码。</li>\n<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入特殊字符的用户名和密码登录</p>\n<ul>\n<li>输入：包含特殊字符的用户名和密码。</li>\n<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>\n</ul>\n<p>测试用例名称：记住登录状态</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面勾选“记住我”选项后登录。</li>\n<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>\n</ul>\n<p>测试用例名称：登录页链接验证</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：检查登录页面上的链接。</li>\n<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>\n</ul>\n<p>测试用例名称：跳转到登录页面</p>\n<ul>\n<li>输入：未登录状态。</li>\n<li>操作：尝试访问需要登录权限的页面。</li>\n<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>\n</ul>\n<p>测试用例名称：登录界面的响应速度</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：在不同网络环境下打开登录页面。</li>\n<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>\n</ul>\n<h3 id=\"微信发送文件的测试用例\"><a href=\"#微信发送文件的测试用例\" class=\"headerlink\" title=\"微信发送文件的测试用例\"></a>微信发送文件的测试用例</h3><p>功能测试</p>\n<ul>\n<li>正常发送文件</li>\n<li>发送支持的文件类型</li>\n</ul>\n<p>边界值测试</p>\n<ul>\n<li>发送最大允许大小的文件</li>\n<li>发送超过最大允许大小的文件</li>\n</ul>\n<p>异常情况测试</p>\n<ul>\n<li>发送空文件</li>\n<li>发送损坏文件</li>\n<li>网络中断后重新发送</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>同时发送多个文件</li>\n<li>选择一个接近最大允许大小的文件</li>\n</ul>\n<p>用户体验测试</p>\n<ul>\n<li>发送文件时的用户提示</li>\n<li>文件发送记录</li>\n</ul>\n<p>安全性测试</p>\n<ul>\n<li>发送包含敏感信息的文件</li>\n<li>病毒文件检测</li>\n</ul>\n<p>跨平台测试</p>\n<h3 id=\"微信发送红包的测试用例\"><a href=\"#微信发送红包的测试用例\" class=\"headerlink\" title=\"微信发送红包的测试用例\"></a>微信发送红包的测试用例</h3><ul>\n<li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p>\n</li>\n<li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p>\n</li>\n<li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p>\n</li>\n<li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p>\n</li>\n</ul>\n<p>用户体验测试</p>\n<p>跨平台测试</p>\n<p>性能测试</p>\n<ul>\n<li>高频发送红包</li>\n<li>大规模红包领取（拼手气红包）</li>\n</ul>\n<h3 id=\"电影订票功能的测试样例\"><a href=\"#电影订票功能的测试样例\" class=\"headerlink\" title=\"电影订票功能的测试样例\"></a>电影订票功能的测试样例</h3><p>功能测试</p>\n<ul>\n<li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li>\n<li>验证不同支付方式是否可用</li>\n<li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li>\n</ul>\n<p>边界和异常情况测试</p>\n<ul>\n<li>无效的账户或者账户余额不足进行支付</li>\n<li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>系统负载测试：高并发访问</li>\n<li>正常负载和高负载下的响应时间是否正常</li>\n</ul>\n<p>兼容性测试</p>\n<h3 id=\"电商满减优惠券测试用例设计\"><a href=\"#电商满减优惠券测试用例设计\" class=\"headerlink\" title=\"电商满减优惠券测试用例设计\"></a>电商满减优惠券测试用例设计</h3><p>设计电商满减优惠券的测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>优惠券满减条件满足<ul>\n<li>用例描述：用户购物车金额为150元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为130元。</li>\n</ul>\n</li>\n<li>优惠券满减条件满足多张<ul>\n<li>用例描述：用户购物车金额为250元，使用两张满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为210元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况 </p>\n<ul>\n<li>刚好满足满减条件<ul>\n<li>用例描述：用户购物车金额为100元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为80元。</li>\n</ul>\n</li>\n<li>差一分钱满足满减条件<ul>\n<li>用例描述：用户购物车金额为99.99元，使用满100减20元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为99.99元。</li>\n</ul>\n</li>\n<li>超过满减条件1分钱<ul>\n<li>用例描述：用户购物车金额为100.01元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为80.01元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>优惠券已过期<ul>\n<li>用例描述：用户尝试使用一张已过期的满100减20元优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n<li>优惠券不适用商品<ul>\n<li>用例描述：用户购物车内商品不在优惠券适用范围，购物车金额为150元，使用满100减20元优惠券。</li>\n<li>预期结果：提示优惠券不适用，不能使用，最终支付金额为150元。</li>\n</ul>\n</li>\n<li>优惠券已被使用<ul>\n<li>用例描述：用户尝试使用一张已被使用过的满100减20元优惠券。</li>\n<li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多重优惠情况</p>\n<ul>\n<li>叠加优惠券<ul>\n<li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张满100减20元优惠券。</li>\n<li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用满100减20元优惠券，最终支付金额为230元。</li>\n</ul>\n</li>\n<li>不同优惠券叠加使用规则<ul>\n<li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张全场9折优惠券。</li>\n<li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用9折优惠券，最终支付金额为225元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优惠券优先级情况</p>\n<ul>\n<li>有多张优惠券可用<ul>\n<li>用例描述：用户购物车金额为200元，有满100减20元优惠券和满150减30元优惠券。</li>\n<li>预期结果：系统自动选择满150减30元优惠券，最终支付金额为170元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无法使用优惠券的情况</p>\n<ul>\n<li>购物车金额不足<ul>\n<li>用例描述：用户购物车金额为50元，使用满100减20元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为50元。</li>\n</ul>\n</li>\n<li>优惠券被取消<ul>\n<li>用例描述：用户尝试使用被商家取消的优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试电商平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p>\n<h3 id=\"外卖优惠券测试用例设计\"><a href=\"#外卖优惠券测试用例设计\" class=\"headerlink\" title=\"外卖优惠券测试用例设计\"></a>外卖优惠券测试用例设计</h3><p>设计外卖平台的满减优惠券测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>优惠券满减条件满足<ul>\n<li>用例描述：用户订单金额为60元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为50元。</li>\n</ul>\n</li>\n<li>优惠券满减条件满足多张<ul>\n<li>用例描述：用户订单金额为120元，使用两张满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为100元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况</p>\n<ul>\n<li>刚好满足满减条件<ul>\n<li>用例描述：用户订单金额为50元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为40元。</li>\n</ul>\n</li>\n<li>差一分钱满足满减条件<ul>\n<li>用例描述：用户订单金额为49.99元，使用满50减10元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为49.99元。</li>\n</ul>\n</li>\n<li>超过满减条件1分钱<ul>\n<li>用例描述：用户订单金额为50.01元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为40.01元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>优惠券已过期<ul>\n<li>用例描述：用户尝试使用一张已过期的满50减10元优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n<li>优惠券不适用餐厅<ul>\n<li>用例描述：用户订单来自不适用优惠券的餐厅，订单金额为60元，使用满50减10元优惠券。</li>\n<li>预期结果：提示优惠券不适用，不能使用，最终支付金额为60元。</li>\n</ul>\n</li>\n<li>优惠券已被使用<ul>\n<li>用例描述：用户尝试使用一张已被使用过的满50减10元优惠券。</li>\n<li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多重优惠情况</p>\n<ul>\n<li>叠加优惠券<ul>\n<li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张满50减10元优惠券。</li>\n<li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用满50减10元优惠券，最终支付金额为70元。</li>\n</ul>\n</li>\n<li>不同优惠券叠加使用规则<ul>\n<li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张全场9折优惠券。</li>\n<li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用9折优惠券，最终支付金额为72元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优惠券优先级情况</p>\n<ul>\n<li>有多张优惠券可用<ul>\n<li>用例描述：用户订单金额为100元，有满50减10元优惠券和满80减20元优惠券。</li>\n<li>预期结果：系统自动选择满80减20元优惠券，最终支付金额为80元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无法使用优惠券的情况</p>\n<ul>\n<li>订单金额不足<ul>\n<li>用例描述：用户订单金额为30元，使用满50减10元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为30元。</li>\n</ul>\n</li>\n<li>优惠券被取消<ul>\n<li>用例描述：用户尝试使用被商家取消的优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特殊情况</p>\n<ul>\n<li>优惠券部分使用<ul>\n<li>用例描述：用户订单金额为55元，使用满50减10元优惠券，同时使用余额支付（5元）。</li>\n<li>预期结果：订单金额55元，使用优惠券后支付45元，再用余额支付5元，最终支付金额为40元。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试外卖平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p>\n<h3 id=\"Github-Workflow自动化测试\"><a href=\"#Github-Workflow自动化测试\" class=\"headerlink\" title=\"Github Workflow自动化测试\"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p>\n<ol>\n<li>持续集成（CI）： 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li>\n<li>持续部署（CD）： 自动将代码部署到生产环境或其他目标环境。</li>\n<li>代码分析和质量检查： 运行静态代码分析工具，以检查代码质量和一致性。</li>\n<li>构建和发布： 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。</li>\n<li>自动化任务： 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li>\n</ol>\n<p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p>\n<p>示例：</p>\n<p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">code</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">Node.js</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;14&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Run</span> <span class=\"string\">tests</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">test</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"支付宝-微信转账功能测试用例\"><a href=\"#支付宝-微信转账功能测试用例\" class=\"headerlink\" title=\"支付宝&#x2F;微信转账功能测试用例\"></a>支付宝&#x2F;微信转账功能测试用例</h3><p>在设计支付宝转账功能的测试用例时，应该覆盖各种正常情况、边界情况和异常情况，以确保转账功能的健壮性和可靠性。以下是详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>成功转账<ul>\n<li>用例描述：用户A向用户B成功转账100元。</li>\n<li>前置条件：用户A账户余额大于等于100元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少100元，用户B账户余额增加100元。</li>\n</ul>\n</li>\n<li>转账金额包含小数<ul>\n<li>用例描述：用户A向用户B转账50.75元。</li>\n<li>前置条件：用户A账户余额大于等于50.75元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额50.75元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少50.75元，用户B账户余额增加50.75元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况</p>\n<ul>\n<li>转账金额为0<ul>\n<li>用例描述：用户A向用户B转账0元。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额0元。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示转账金额无效，转账失败。</li>\n</ul>\n</li>\n<li>转账金额为账户余额<ul>\n<li>用例描述：用户A向用户B转账用户A的全部余额。</li>\n<li>前置条件：用户A账户余额为200元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额200元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少200元，用户B账户余额增加200元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>转账金额超过账户余额<ul>\n<li>用例描述：用户A尝试向用户B转账300元，而用户A账户余额只有100元。</li>\n<li>前置条件：用户A账户余额100元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额300元。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示余额不足，转账失败。</li>\n</ul>\n</li>\n<li>用户B账户无效<ul>\n<li>用例描述：用户A尝试向一个无效的用户B账户转账100元。</li>\n<li>前置条件：用户A账户余额大于等于100元，用户B账户无效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入无效的用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示用户B账户无效，转账失败。</li>\n</ul>\n</li>\n<li>网络连接中断<ul>\n<li>用例描述：用户A在转账过程中网络连接中断。</li>\n<li>前置条件：用户A账户有效，用户B账户有效，网络连接不稳定。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账时网络中断。</li>\n</ol>\n</li>\n<li>预期结果：系统提示网络连接问题，转账未完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全测试</p>\n<ul>\n<li>防止重复提交<ul>\n<li>用例描述：用户A在确认转账后多次点击确认按钮。</li>\n<li>前置条件：用户A账户有效，用户B账户有效，转账金额为100元。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>多次点击确认转账按钮。</li>\n</ol>\n</li>\n<li>预期结果：系统只执行一次转账操作，用户A账户减少100元，用户B账户增加100元。</li>\n</ul>\n</li>\n<li>转账金额非法字符<ul>\n<li>用例描述：用户A尝试输入非法字符作为转账金额。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入非法字符（如”abc”）作为转账金额。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示金额无效，转账失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他情况</p>\n<ul>\n<li>跨境转账<ul>\n<li>用例描述：用户A向国外的用户B转账100美元。</li>\n<li>前置条件：用户A账户有效且支持跨境转账，用户B账户有效，用户A有足够的美元余额。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择跨境转账功能。</li>\n<li>输入转账金额100美元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A美元余额减少100美元，用户B账户美元余额增加100美元。</li>\n</ul>\n</li>\n<li>转账备注<ul>\n<li>用例描述：用户A向用户B转账100元，并添加备注信息。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>添加转账备注信息（如“生日礼物”）。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，备注信息正确保存，用户A账户减少100元，用户B账户增加100元。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例覆盖了支付宝转账功能的主要场景，可以帮助全面测试转账功能，确保系统能够正确处理各种情况下的转账操作。</p>\n<p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p>\n<ol>\n<li>Checkout code：检出代码仓库。</li>\n<li>Set up Node.js：设置 Node.js 环境。</li>\n<li>Install dependencies：安装依赖。</li>\n<li>Run tests：运行测试。</li>\n</ol>\n<p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p>\n<h3 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h3><ul>\n<li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>\n<li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>\n<li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>\n<li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>注：下面内容一部分来自于我舍友的博客</p>\n</blockquote>\n<h3 id=\"测开自我介绍\"><a href=\"#测开自我介绍\" class=\"headerlink\" title=\"测开自我介绍\"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 测试开发岗位。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p>\n<h3 id=\"为什么选择测开\"><a href=\"#为什么选择测开\" class=\"headerlink\" title=\"为什么选择测开\"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p>\n<blockquote>\n<p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p>\n</blockquote>\n<h3 id=\"做过哪些关于测开的工作\"><a href=\"#做过哪些关于测开的工作\" class=\"headerlink\" title=\"做过哪些关于测开的工作\"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p>\n<p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p>\n<p>主要工作：</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p>\n<h3 id=\"黑盒测试\"><a href=\"#黑盒测试\" class=\"headerlink\" title=\"黑盒测试\"></a>黑盒测试</h3><p>又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>\n<h3 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h3><p>又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p>\n<h3 id=\"测试用例的设计方法\"><a href=\"#测试用例的设计方法\" class=\"headerlink\" title=\"测试用例的设计方法\"></a>测试用例的设计方法</h3><ul>\n<li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li>\n<li>边界值分析：测试边界值</li>\n<li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li>\n<li>随机测试：随机生成输入数据进行测试</li>\n</ul>\n<h3 id=\"如何理解测试开发中的开发\"><a href=\"#如何理解测试开发中的开发\" class=\"headerlink\" title=\"如何理解测试开发中的开发\"></a>如何理解测试开发中的开发</h3><ul>\n<li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>\n<li>编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等）来组织和运行测试。</li>\n<li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>\n<li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>\n<li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>\n</ul>\n<h3 id=\"如何测试一个Java项目？\"><a href=\"#如何测试一个Java项目？\" class=\"headerlink\" title=\"如何测试一个Java项目？\"></a>如何测试一个Java项目？</h3><ul>\n<li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>\n<li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>\n<li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>\n<li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>\n</ul>\n<h3 id=\"如何判断所写接口功能正常？\"><a href=\"#如何判断所写接口功能正常？\" class=\"headerlink\" title=\"如何判断所写接口功能正常？\"></a>如何判断所写接口功能正常？</h3><ul>\n<li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>\n<li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>\n<li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>\n<li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>\n</ul>\n<h3 id=\"怎么构造无用测试用例？\"><a href=\"#怎么构造无用测试用例？\" class=\"headerlink\" title=\"怎么构造无用测试用例？\"></a>怎么构造无用测试用例？</h3><ul>\n<li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>\n<li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>\n<li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>\n</ul>\n<h3 id=\"如何感知线上项目出现问题\"><a href=\"#如何感知线上项目出现问题\" class=\"headerlink\" title=\"如何感知线上项目出现问题\"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p>\n<h3 id=\"小红书购物搜索框设计测试用例\"><a href=\"#小红书购物搜索框设计测试用例\" class=\"headerlink\" title=\"小红书购物搜索框设计测试用例\"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p>\n<ul>\n<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入无效关键词</p>\n<ul>\n<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>\n</ul>\n<p>测试用例名称：搜索框输入空关键词</p>\n<ul>\n<li>输入：在搜索框中不输入任何内容。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示全部商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框联想功能</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>\n<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入并选择联想词</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>\n<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>\n</ul>\n<p>测试用例名称：搜索框清空功能</p>\n<ul>\n<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索框右侧的清空按钮。</li>\n<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>\n</ul>\n<h3 id=\"登录设计测试样例\"><a href=\"#登录设计测试样例\" class=\"headerlink\" title=\"登录设计测试样例\"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>\n<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>\n</ul>\n<p>测试用例名称：输入无效的用户名和密码登录</p>\n<ul>\n<li>输入：无效的用户名和密码。</li>\n<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>\n</ul>\n<p>测试用例名称：输入不存在的用户名登录</p>\n<ul>\n<li>输入：不存在的用户名和有效密码。</li>\n<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>\n</ul>\n<p>测试用例名称：输入正确的用户名和空密码登录</p>\n<ul>\n<li>输入：有效的用户名和空密码。</li>\n<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入空用户名和正确密码登录</p>\n<ul>\n<li>输入：空用户名和有效的密码。</li>\n<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入特殊字符的用户名和密码登录</p>\n<ul>\n<li>输入：包含特殊字符的用户名和密码。</li>\n<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>\n</ul>\n<p>测试用例名称：记住登录状态</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面勾选“记住我”选项后登录。</li>\n<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>\n</ul>\n<p>测试用例名称：登录页链接验证</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：检查登录页面上的链接。</li>\n<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>\n</ul>\n<p>测试用例名称：跳转到登录页面</p>\n<ul>\n<li>输入：未登录状态。</li>\n<li>操作：尝试访问需要登录权限的页面。</li>\n<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>\n</ul>\n<p>测试用例名称：登录界面的响应速度</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：在不同网络环境下打开登录页面。</li>\n<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>\n</ul>\n<h3 id=\"微信发送文件的测试用例\"><a href=\"#微信发送文件的测试用例\" class=\"headerlink\" title=\"微信发送文件的测试用例\"></a>微信发送文件的测试用例</h3><p>功能测试</p>\n<ul>\n<li>正常发送文件</li>\n<li>发送支持的文件类型</li>\n</ul>\n<p>边界值测试</p>\n<ul>\n<li>发送最大允许大小的文件</li>\n<li>发送超过最大允许大小的文件</li>\n</ul>\n<p>异常情况测试</p>\n<ul>\n<li>发送空文件</li>\n<li>发送损坏文件</li>\n<li>网络中断后重新发送</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>同时发送多个文件</li>\n<li>选择一个接近最大允许大小的文件</li>\n</ul>\n<p>用户体验测试</p>\n<ul>\n<li>发送文件时的用户提示</li>\n<li>文件发送记录</li>\n</ul>\n<p>安全性测试</p>\n<ul>\n<li>发送包含敏感信息的文件</li>\n<li>病毒文件检测</li>\n</ul>\n<p>跨平台测试</p>\n<h3 id=\"微信发送红包的测试用例\"><a href=\"#微信发送红包的测试用例\" class=\"headerlink\" title=\"微信发送红包的测试用例\"></a>微信发送红包的测试用例</h3><ul>\n<li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p>\n</li>\n<li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p>\n</li>\n<li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p>\n</li>\n<li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p>\n</li>\n</ul>\n<p>用户体验测试</p>\n<p>跨平台测试</p>\n<p>性能测试</p>\n<ul>\n<li>高频发送红包</li>\n<li>大规模红包领取（拼手气红包）</li>\n</ul>\n<h3 id=\"电影订票功能的测试样例\"><a href=\"#电影订票功能的测试样例\" class=\"headerlink\" title=\"电影订票功能的测试样例\"></a>电影订票功能的测试样例</h3><p>功能测试</p>\n<ul>\n<li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li>\n<li>验证不同支付方式是否可用</li>\n<li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li>\n</ul>\n<p>边界和异常情况测试</p>\n<ul>\n<li>无效的账户或者账户余额不足进行支付</li>\n<li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>系统负载测试：高并发访问</li>\n<li>正常负载和高负载下的响应时间是否正常</li>\n</ul>\n<p>兼容性测试</p>\n<h3 id=\"电商满减优惠券测试用例设计\"><a href=\"#电商满减优惠券测试用例设计\" class=\"headerlink\" title=\"电商满减优惠券测试用例设计\"></a>电商满减优惠券测试用例设计</h3><p>设计电商满减优惠券的测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>优惠券满减条件满足<ul>\n<li>用例描述：用户购物车金额为150元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为130元。</li>\n</ul>\n</li>\n<li>优惠券满减条件满足多张<ul>\n<li>用例描述：用户购物车金额为250元，使用两张满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为210元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况 </p>\n<ul>\n<li>刚好满足满减条件<ul>\n<li>用例描述：用户购物车金额为100元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为80元。</li>\n</ul>\n</li>\n<li>差一分钱满足满减条件<ul>\n<li>用例描述：用户购物车金额为99.99元，使用满100减20元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为99.99元。</li>\n</ul>\n</li>\n<li>超过满减条件1分钱<ul>\n<li>用例描述：用户购物车金额为100.01元，使用满100减20元优惠券。</li>\n<li>预期结果：最终支付金额为80.01元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>优惠券已过期<ul>\n<li>用例描述：用户尝试使用一张已过期的满100减20元优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n<li>优惠券不适用商品<ul>\n<li>用例描述：用户购物车内商品不在优惠券适用范围，购物车金额为150元，使用满100减20元优惠券。</li>\n<li>预期结果：提示优惠券不适用，不能使用，最终支付金额为150元。</li>\n</ul>\n</li>\n<li>优惠券已被使用<ul>\n<li>用例描述：用户尝试使用一张已被使用过的满100减20元优惠券。</li>\n<li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多重优惠情况</p>\n<ul>\n<li>叠加优惠券<ul>\n<li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张满100减20元优惠券。</li>\n<li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用满100减20元优惠券，最终支付金额为230元。</li>\n</ul>\n</li>\n<li>不同优惠券叠加使用规则<ul>\n<li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张全场9折优惠券。</li>\n<li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用9折优惠券，最终支付金额为225元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优惠券优先级情况</p>\n<ul>\n<li>有多张优惠券可用<ul>\n<li>用例描述：用户购物车金额为200元，有满100减20元优惠券和满150减30元优惠券。</li>\n<li>预期结果：系统自动选择满150减30元优惠券，最终支付金额为170元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无法使用优惠券的情况</p>\n<ul>\n<li>购物车金额不足<ul>\n<li>用例描述：用户购物车金额为50元，使用满100减20元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为50元。</li>\n</ul>\n</li>\n<li>优惠券被取消<ul>\n<li>用例描述：用户尝试使用被商家取消的优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试电商平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p>\n<h3 id=\"外卖优惠券测试用例设计\"><a href=\"#外卖优惠券测试用例设计\" class=\"headerlink\" title=\"外卖优惠券测试用例设计\"></a>外卖优惠券测试用例设计</h3><p>设计外卖平台的满减优惠券测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>优惠券满减条件满足<ul>\n<li>用例描述：用户订单金额为60元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为50元。</li>\n</ul>\n</li>\n<li>优惠券满减条件满足多张<ul>\n<li>用例描述：用户订单金额为120元，使用两张满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为100元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况</p>\n<ul>\n<li>刚好满足满减条件<ul>\n<li>用例描述：用户订单金额为50元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为40元。</li>\n</ul>\n</li>\n<li>差一分钱满足满减条件<ul>\n<li>用例描述：用户订单金额为49.99元，使用满50减10元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为49.99元。</li>\n</ul>\n</li>\n<li>超过满减条件1分钱<ul>\n<li>用例描述：用户订单金额为50.01元，使用满50减10元优惠券。</li>\n<li>预期结果：最终支付金额为40.01元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>优惠券已过期<ul>\n<li>用例描述：用户尝试使用一张已过期的满50减10元优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n<li>优惠券不适用餐厅<ul>\n<li>用例描述：用户订单来自不适用优惠券的餐厅，订单金额为60元，使用满50减10元优惠券。</li>\n<li>预期结果：提示优惠券不适用，不能使用，最终支付金额为60元。</li>\n</ul>\n</li>\n<li>优惠券已被使用<ul>\n<li>用例描述：用户尝试使用一张已被使用过的满50减10元优惠券。</li>\n<li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多重优惠情况</p>\n<ul>\n<li>叠加优惠券<ul>\n<li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张满50减10元优惠券。</li>\n<li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用满50减10元优惠券，最终支付金额为70元。</li>\n</ul>\n</li>\n<li>不同优惠券叠加使用规则<ul>\n<li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张全场9折优惠券。</li>\n<li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用9折优惠券，最终支付金额为72元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优惠券优先级情况</p>\n<ul>\n<li>有多张优惠券可用<ul>\n<li>用例描述：用户订单金额为100元，有满50减10元优惠券和满80减20元优惠券。</li>\n<li>预期结果：系统自动选择满80减20元优惠券，最终支付金额为80元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无法使用优惠券的情况</p>\n<ul>\n<li>订单金额不足<ul>\n<li>用例描述：用户订单金额为30元，使用满50减10元优惠券。</li>\n<li>预期结果：不能使用优惠券，最终支付金额为30元。</li>\n</ul>\n</li>\n<li>优惠券被取消<ul>\n<li>用例描述：用户尝试使用被商家取消的优惠券。</li>\n<li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特殊情况</p>\n<ul>\n<li>优惠券部分使用<ul>\n<li>用例描述：用户订单金额为55元，使用满50减10元优惠券，同时使用余额支付（5元）。</li>\n<li>预期结果：订单金额55元，使用优惠券后支付45元，再用余额支付5元，最终支付金额为40元。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试外卖平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p>\n<h3 id=\"Github-Workflow自动化测试\"><a href=\"#Github-Workflow自动化测试\" class=\"headerlink\" title=\"Github Workflow自动化测试\"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p>\n<ol>\n<li>持续集成（CI）： 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li>\n<li>持续部署（CD）： 自动将代码部署到生产环境或其他目标环境。</li>\n<li>代码分析和质量检查： 运行静态代码分析工具，以检查代码质量和一致性。</li>\n<li>构建和发布： 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。</li>\n<li>自动化任务： 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li>\n</ol>\n<p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p>\n<p>示例：</p>\n<p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">code</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">Node.js</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;14&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Run</span> <span class=\"string\">tests</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">test</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"支付宝-微信转账功能测试用例\"><a href=\"#支付宝-微信转账功能测试用例\" class=\"headerlink\" title=\"支付宝&#x2F;微信转账功能测试用例\"></a>支付宝&#x2F;微信转账功能测试用例</h3><p>在设计支付宝转账功能的测试用例时，应该覆盖各种正常情况、边界情况和异常情况，以确保转账功能的健壮性和可靠性。以下是详细的测试用例设计：</p>\n<ul>\n<li><p>正常情况</p>\n<ul>\n<li>成功转账<ul>\n<li>用例描述：用户A向用户B成功转账100元。</li>\n<li>前置条件：用户A账户余额大于等于100元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少100元，用户B账户余额增加100元。</li>\n</ul>\n</li>\n<li>转账金额包含小数<ul>\n<li>用例描述：用户A向用户B转账50.75元。</li>\n<li>前置条件：用户A账户余额大于等于50.75元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额50.75元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少50.75元，用户B账户余额增加50.75元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>边界情况</p>\n<ul>\n<li>转账金额为0<ul>\n<li>用例描述：用户A向用户B转账0元。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额0元。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示转账金额无效，转账失败。</li>\n</ul>\n</li>\n<li>转账金额为账户余额<ul>\n<li>用例描述：用户A向用户B转账用户A的全部余额。</li>\n<li>前置条件：用户A账户余额为200元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额200元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A账户余额减少200元，用户B账户余额增加200元。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常情况</p>\n<ul>\n<li>转账金额超过账户余额<ul>\n<li>用例描述：用户A尝试向用户B转账300元，而用户A账户余额只有100元。</li>\n<li>前置条件：用户A账户余额100元，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额300元。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示余额不足，转账失败。</li>\n</ul>\n</li>\n<li>用户B账户无效<ul>\n<li>用例描述：用户A尝试向一个无效的用户B账户转账100元。</li>\n<li>前置条件：用户A账户余额大于等于100元，用户B账户无效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入无效的用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示用户B账户无效，转账失败。</li>\n</ul>\n</li>\n<li>网络连接中断<ul>\n<li>用例描述：用户A在转账过程中网络连接中断。</li>\n<li>前置条件：用户A账户有效，用户B账户有效，网络连接不稳定。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账时网络中断。</li>\n</ol>\n</li>\n<li>预期结果：系统提示网络连接问题，转账未完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全测试</p>\n<ul>\n<li>防止重复提交<ul>\n<li>用例描述：用户A在确认转账后多次点击确认按钮。</li>\n<li>前置条件：用户A账户有效，用户B账户有效，转账金额为100元。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>多次点击确认转账按钮。</li>\n</ol>\n</li>\n<li>预期结果：系统只执行一次转账操作，用户A账户减少100元，用户B账户增加100元。</li>\n</ul>\n</li>\n<li>转账金额非法字符<ul>\n<li>用例描述：用户A尝试输入非法字符作为转账金额。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入非法字符（如”abc”）作为转账金额。</li>\n<li>输入用户B的账户信息。</li>\n<li>尝试确认转账。</li>\n</ol>\n</li>\n<li>预期结果：系统提示金额无效，转账失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他情况</p>\n<ul>\n<li>跨境转账<ul>\n<li>用例描述：用户A向国外的用户B转账100美元。</li>\n<li>前置条件：用户A账户有效且支持跨境转账，用户B账户有效，用户A有足够的美元余额。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择跨境转账功能。</li>\n<li>输入转账金额100美元。</li>\n<li>输入用户B的账户信息。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，用户A美元余额减少100美元，用户B账户美元余额增加100美元。</li>\n</ul>\n</li>\n<li>转账备注<ul>\n<li>用例描述：用户A向用户B转账100元，并添加备注信息。</li>\n<li>前置条件：用户A账户有效，用户B账户有效。</li>\n<li>操作步骤：<ol>\n<li>用户A登录支付宝账户。</li>\n<li>用户A选择转账功能。</li>\n<li>输入转账金额100元。</li>\n<li>输入用户B的账户信息。</li>\n<li>添加转账备注信息（如“生日礼物”）。</li>\n<li>确认转账。</li>\n</ol>\n</li>\n<li>预期结果：转账成功，备注信息正确保存，用户A账户减少100元，用户B账户增加100元。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这些测试用例覆盖了支付宝转账功能的主要场景，可以帮助全面测试转账功能，确保系统能够正确处理各种情况下的转账操作。</p>\n<p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p>\n<ol>\n<li>Checkout code：检出代码仓库。</li>\n<li>Set up Node.js：设置 Node.js 环境。</li>\n<li>Install dependencies：安装依赖。</li>\n<li>Run tests：运行测试。</li>\n</ol>\n<p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p>\n<h3 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h3><ul>\n<li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>\n<li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>\n<li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>\n<li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>\n</ul>\n"},{"title":"框架等面经","keywords":["面经"],"description":"框架等方面的面经","abbrlink":17771,"date":"2024-06-12T14:49:36.000Z","updated":"2024-06-13T08:17:41.000Z","top_img":"https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png","comments":1,"cover":"https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n## spring boot/cloud ???\n\n\n\n## 其他\n","source":"_posts/框架等面经.md","raw":"---\ntitle: 框架等面经\ntags:\n  - 框架\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 框架等方面的面经\nabbrlink: 17771\ndate: 2024-06-12 22:49:36\nupdated: 2024-06-13 16:17:41\ntop_img: https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png\ncomments:\ncover: https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n## spring boot/cloud ???\n\n\n\n## 其他\n","slug":"框架等面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1x002kr7gn8at673q2","content":"<h2 id=\"spring-boot-cloud\"><a href=\"#spring-boot-cloud\" class=\"headerlink\" title=\"spring boot&#x2F;cloud ???\"></a>spring boot&#x2F;cloud ???</h2><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"spring-boot-cloud\"><a href=\"#spring-boot-cloud\" class=\"headerlink\" title=\"spring boot&#x2F;cloud ???\"></a>spring boot&#x2F;cloud ???</h2><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2>"},{"title":"强化学习","keywords":["强化学习"],"description":"强化学习的算法和思路总结","abbrlink":17762,"date":"2023-10-19T08:19:24.000Z","updated":"2023-10-30T09:03:11.000Z","top_img":"https://s2.loli.net/2024/02/06/T9HwPmcoaKpNXBY.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/IUOjJBRnM3Zf1Pr.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。\n\n原文： https://zhuanlan.zhihu.com/p/111895463\n\n卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！\n\n后面可能会自己写一下 `MADDPG` 和 `MATD3` 的相关内容，到时候再更新。\n\n> 2023/10/23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！\n\n学习路线：\n![学习路线](../image/强化学习/学习路线.png)\n\n## 马尔可夫树\n\n强化学习的任务：\n- 我们希望用强化学习的方式，使某个**智能体**获得**独立自主**地完成某种任务的能力。 \n- 智能体学习和工作的地方，称为**环境**。\n- 所谓独立自主，就是智能体一旦启动，就不需要人指挥了。\n\n### 经典马尔可夫链\n![马尔科夫链.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png)\n\n- 状态(state)：智能体观察到的当前环境的部分或者全部特征。\n  - 注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。\n- 动作(action)：智能体做出的具体行为。\n  - **动作空间**就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。\n- 奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。\n  - 奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。\n\n### RL一般步骤\n1. 智能体在环境中，观察到状态(S)；\n2. 状态(S)被输入到智能体，智能体经过计算，选择动作(A);\n3. 动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。\n4. 智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。\n\n### 马尔可夫树\n马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种\"不确定性\"， 即\"马尔可夫树\"。\n\n![马尔科夫树.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png)\n\n这种\"不确定性\"来自两个方面： \n- 智能体的行动选择(策略)。\n- 环境的不确定性。\n\n## RL中的Q值和V值\n\n并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。\n\n我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。\n\n- 评估动作的价值称为**Q值**：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。\n- 评估状态的价值称为**V值**：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。\n\n价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。\n\n### V值的定义\n\n![V值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n假设现在需要求某状态S的V值，可以这样：\n\n1. 从S点出发，并影分身出若干个自己;\n2. 每个分身按照当前的策略 选择行为;\n3. 每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;\n4. 计算每个影分身获得的平均值,这个平均值就是要求的V值。\n\n总结：`从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。`\n\n`V值跟选择的策略有很大的关系` 。\n\n看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。\n\n![例子1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BE%8B%E5%AD%901.png)\n\n![策略1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A51.png)\n\n![策略2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A52.png)\n\n可以看出不同的策略，计算出的V值是不一样的。\n\n### Q值的定义\n![Q值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n现在需要计算，某个状态S0下的一个动作A的Q值： \n1. 从A这个节点出发，使用影分身之术； \n2. 每个影分身走到最终状态,并记录所获得的奖励； \n3. 求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。\n\n总结：`从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。`\n\n与V值不同，Q值和策略并没有直接相关，而`与环境的状态转移概率相关，而环境的状态转移概率是不变的。`\n\n### V值和Q值关系\n`Q和V之间是可以相互换算的`。\n\n#### Q值转V值\n\n![Q值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。\n\nS状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。\n\n假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。\n\n![Q值转V值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F1.png)\n\n解释：`一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。`\n\n#### V值转Q值\n\n`Q是V的期望。`而这里不需要关注策略，这里是环境的状态转移概率决定的。\n\n![V值转Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC.png)\n\n`当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！`\n\n![V值转Q值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F2.png)\n\n> 折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。\n\n### V值转V值\n实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。\n\n![V值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n## MC\n蒙地卡罗方法(Monte-Carlo)\n\n### 蒙地卡罗算法\n\n1. 把智能体放到环境的任意状态；\n2. 从这个状态开始按照策略进行选择动作，并进入新的状态。\n3. 重复步骤2，直到最终状态；\n4. 从最终状态开始向前回溯：计算每个状态的G值。\n5. 重复1-4多次，然后平均每个状态的G值，这就是要求的V值。\n\n### G值的意义\n\n重要：`G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。`\n\n![G值的意义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FG%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png)\n\n- 第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。\n- 第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G'),乘以一定的折扣(gamma),再加上r。\n\n所以G值的意义在于，`在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。`\n\n当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。`而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。`\n\n理解：\n1. `G的意义：在某个路径上，状态S到最终状态的总收获。 `\n2. `V和G的关系：V是G的平均数。`\n\n### V和策略相关\n![策略3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A53.png)\n\n![策略4.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A54.png)\n\n由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。\n\n### 蒙地卡罗算法的缺点\n\n每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。\n\n### MC的更新公式\n上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。\n\n那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是`增量更新`。\n\n#### 增量更新\n现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 \n\n`V_new = (V_old - G) * (1 / N) + V_old`\n\n- V_old：原来的V值\n- G：这一次回溯后，计算出来的G值\n- N: 这个状态被经过多少次\n- V_new：新计算出来的V值\n\n#### 更进一步\n\n这样计算还是比较麻烦，我们甚至可以不用记录N，把(1/N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为`学习率`。\n\n这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。\n\n这里的G，也称为V的更新目标。\n\n而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。\n\n#### 两种理解方式\n\n![两种理解方式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png)\n\n## TD\n时序差分算法TD(Temporal-Difference)\n\n### TD和MC的比较\nTD算法对蒙地卡罗(MC)进行了改进：\n1. 和蒙地卡罗(MC)不同：`TD算法只需要走N步，不用走到终点，就可以开始回溯更新。` \n2. 和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 \n3. 那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。\n   - 假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. \n   - 假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。\n\n### 直观理解\n\n从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时`N = 0`，也叫做`TD(0)`。\n\n但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。\n\n![TD(0).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29.png)\n\n假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。\n\n### 更新公式\n\nTD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 `所以只需要把MC的更新目标，改为TD的更新目标即可。`\n\n`在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V`\n\n![更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n\n## Q-learning\n\n之前用TD(0)预估状态价值V:\n![TD(0)更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n图解：\n![TD(0)图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E5%9B%BE%E8%A7%A3.png)\n\nTD能够用在V值，那么也能用在计算Q值上。\n\n### TD之于Q值估算\n\n现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。 \n![用TD估计Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png)\n- V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 \n- Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。\n\n在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。\n![用下一个动作的Q代替V.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png)\n\n但是，这里就有个坑：`虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。`\n\n因为`马尔可夫树!`\n![坑的解释.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png)\n\n`在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。`\n\n虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。\n1. 在相同策略下产生的动作At+1。这就是`SARSA`。\n2. 选择能够产生最大Q值的动作At+1。这就是`Qlearning`。\n\n### SARSA\n\n![SARSA.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA.png)\n\n其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n![TD(0)与SARSA对比.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png)\n\n注意: `这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。`\n\n### Qlearning\n`Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。`\n\n![Qlearning图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%9B%BE%E8%A7%A3.png)\n\n理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。\n![Qlearning公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%85%AC%E5%BC%8F.png)\n\n`Q(S,a)的更新目标`：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n\nQleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。\n\n### 总结\n1. Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 \n2. Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 \n3. 既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 \n4. Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 \n   - SARSA 选择的是在St同一个策略产生的动作。 \n   - Qlearning 选择的是能够产生最大的Q值的动作。\n\n### Qlearning 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## 深度神经网络\n\n深度强化学习：用深度神经网络辅助强化学习。\n\n#### 原理\n假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)=y。\n\n这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。\n![Magic(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%28X%29.png)\n\n现在假设有另外一个函数Magic'(),这个函数是由深度神经网络构成。\n\n在刚开始的时候，很明显Magic'(X) 并不等于y，例如输入手写图片8，Magic'()计算后，认为数字8只有20%，但数字9有40%。\n\n...但这没所谓，因为这是刚开始。我们的任务是让Magic'(X)产生的结果y' 和 y尽量接近。\n\ny'和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic'(X)越来越靠近这个目标。\n\n衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。\n\nloss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic'(X)和Magic(X)函数非常接近，可以通过Magic'(X)计算出y。\n\n当有许许多多这样的y，经过许许多多轮后。Magic'就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。\n\n![Magic'(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%27%28X%29.png)\n\n#### 放大镜下的深度神经网络\n![数据加工厂.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png)\n\n现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。\n\n为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更`标准`一些。\n\n例如图片的尺寸大小，有多少通道的颜色等等，然后`分批(batch)`，输入工厂。\n\n在输入工厂的时候，会有一个‘大门’，称为`输入层`，去检查数据是否已经按照工厂的标准整理好。\n\n数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。\n\n一般称这些车间叫`层`。`这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了`。常用的层包括：`Dense、Conv2D、LSTM、Reshape、Flatten`等。\n\n最终，数据工厂会把原数据X，加工成产品`y'(也叫做：logits)`。从源数据加工成产品的过程，叫`正向传播`。\n\n但产品y'是否是一个合格的产品，我们还需要我们真正的`y(lables)`作为标准去鉴定。把`鉴定出来的差距就是loss`。\n\n工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y'能够对应起来。\n\n经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。\n\n\n## DQN\n> `DQN: TD + 神经网络`\n\n在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。\n\nQtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。\n\n这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。\n\n`用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。`\n\n`Deep network + Qlearning = DQN`\n\n神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。\n\n### 理解DQN中的神经网络\n\nQtable三维可视化：\n![Qtable三维可视化.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png)\n\n图中每根柱子的高度，表示状态S下，选择动作A的Q值。\n\n`现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。`\n\n![扭曲的曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png)\n\n从二维状态看：\n![二维曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png)\n\n所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。\n\n现在就很清楚了，其实Qlearning和DQN并没有根本的区别。`只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。`\n\n### 更新目标\n\n更新目标就是Magic(X)，最终要向这个Magix(X)靠近。\n\n在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。\n\nDQN和Qlearning一样：\n![DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN.png)\n假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： \n1. 执行A，往前一步，到达St+1; \n2. 把St+1输入Q网络，计算St+1下所有动作的Q值； \n3. 获得最大的Q值加上奖励R作为更新目标； \n4. 计算损失 \n   - Q(S,A)相当于有监督学习中的logits\n   - maxQ(St+1) + R 相当于有监督学习中的lables \n   - 用mse函数，得出两者的loss \n   - Loss = (Q(S, A) - [gamma * maxQ(St+1) + R])^2\n5. 用loss更新Q网络。(反向传播)\n\n> 通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。\n\n也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标\n`Target = R + gamma * maxQ(St+1)`\n\n![DQN公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E5%85%AC%E5%BC%8F.png)\n\n总结：\n1. 其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。\n2. 解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。\n3. 和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。\n\n### DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Double DQN\n\n### 经验回放\n经验回放解决了强化学习中的两个问题： `训练网络数据采集慢` 和 `过度拟合`\n\n\n当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。\n\n把每一步的s，选择的a，进入新的状态s'，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。\n当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ....\n当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。\n训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里...\n就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。\n\n使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。\n过度拟合，放到人身上就是`过度依赖局部经验`了。\n就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。\n同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。\n\n\n\n\n### DQN的问题\nDQN的目标：\n`Target = R + gamma * maxQ(St+1)`\n\n目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。\n\n如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。\n\n要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是`Fixed Q-targets`的思路。\n\n### Fixed Q-targets\n\n![fix-Q-targets.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2Ffix-Q-targets.png)\n\n其他地方和DQN一样，唯一不同是用了两个Q网络。\n\n- 原来的Q网络，用于估算Q(s);\n- targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。\n  - `y = r + gamma * max(targetQ(s'))`\n  - 进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。\n\n### Double DQN\n\nDQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s'的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值...，这就导致了Q值往往会有偏大的的情况出现。\n\n这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。\n\n另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。\n\n\n### Double DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Duel DQN\n\n### Dueling DQN原理\n回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即`Q = S + A`\n- S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。\n- A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。\n\n![Q=S+A表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%3DS%2BA%E8%A1%A8%E6%A0%BC.png)\n\n普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。\n\n![普通DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%99%AE%E9%80%9ADQN.png)\n\n普通DQN在提升某个状态下的S值时，只会提升某个动作。\n\nDueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。\n\n![DuelDQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN.png)\n\n如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。\n\n> 这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。\n\n### 网络架构\n![DuelDQN网络架构.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png)\n\n可以把dueling DQN分为三部分：\n- 第一部分：和普通DQN一样，用来处理和学习数据。\n- 第二部分：计算svalue，就是让网络预估的平均值。\n- 第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。\n  - 归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)\n\nDeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。\n\n### Duel DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PG\n策略梯度(Policy Gradient)\n\n之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。\n\n这就是`策略梯度(Policy Gradient)`\n\n### PG原理\n\n认识到：\n> `DQN: TD + 神经网络`\n> `PG: MC + 神经网络`\n\nPG中的Magic(state):\n当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： = magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。\n\n复习一下蒙地卡罗：\n从某个state出发，然后一直走，直到`最终状态`。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。\n![复习MC.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%A4%8D%E4%B9%A0MC.png)\n\n### 直观感受PG\n\n从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 = [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G = 1。\n\n![直观感受PG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png)\n\n更新策略，因为该路径选择了A而产生的，并获得G = 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 = [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G = -1。\n\n![直观感受PG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png)\n\n此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 = [55%,15%,30%]。最后随机到C，回溯计算后，计算得G = 5。\n\n![直观感受PG3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png)\n\nC比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 = [20%,5%,75%]。\n\n### PG 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## AC\n> `AC: PG + DQN(TD + 神经网络)`\n\nPG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。\n\n改为TD可以解决上面的问题。接下来又面临另一个问题：\n在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。\n\n也就是说，Actor-Critic，其实是用了两个网络：\n\n两网络都输入状态S，Critic比Actor多一个St+1: \n- 一个网络输出策略，负责选择动作，把这个网络成为Actor； \n- 一个网络负责计算每个动作的分数，把这个网络成为Critic。\n\n### TD-error\n`在DQN预估的是Q值，在AC中的Critic，估算的是V值。`不估算Q值是因为效果不好。\n![为什么不估算Q.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png)\n\n假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高...\n\n这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？\n因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。\n\n但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而`Q值的期望(均值)就是V。`\n\n![TD-error.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD-error.png)\n\n可以得到更新的权重：`Q(s,a)-V(s)`，Q(s,a)用`gamma * V(s') + r` 代替。\n得到TD-error：`TD-error = gamma * V(s') + r - V(s)`\n\n和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。\n\n至于为啥TD-error是用来更新Critic的loss呢？\n取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。\n再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。\n\n#### 总结\n1. 为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：`Q(s,a)-V(s)`\n2. 为了避免需要预估V值和Q值，把Q和V统一；由于`Q(s,a) = gamma * V(s') + r - V(s)`。所以我们得到TD-error公式： `TD-error = gamma * V(s') + r - V(s)`\n3. `TD-error就是Actor更新策略时候，带权重更新中的权重值`；\n4. 现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。\n\n### 算法\n1. 定义两个network：Actor 和 Critic\n2. 进行N次更新。\n    1. 从状态s开始，执行动作a，得到奖励r，进入状态s'\n    2. 记录的数据。\n    3. 把输入到Critic，根据公式： TD-error = gamma * V(s') + r - V(s) 求 TD-error，并缩小TD-error\n    4. 把输入到Actor，计算策略分布。\n\n![AC算法.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FAC%E7%AE%97%E6%B3%95.png)\n\n可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。\n\n### AC 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PPO\nPPO是基于AC框架的\n\n### 正态分布\n首先要想办法处理连续动作的输出问题。\n\n- 离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。\n- 连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。\n\n在离散动作空间的问题中，最终输出的策略呈现出下面形式：\n![离散动作-策略分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png)\n\n假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi = [0.4, 0.6]。\n![连续型概率分布示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P = （action）代表在策略下，选择某个action的概率P。\n\n用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。\n\n这样，只用两个参数就可以表示了。\n![正态分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png)\n\n正态分布：\n- sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。\n- mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。\n\n神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。\n\n### AC的问题\n\n上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。\n\n- 行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。\n- 目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。\n\n- 在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。\n  - 实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。\n  - 依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。\n- 离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。\n  - 离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。\n  - 无需环境互动：训练过程中不需要实时环境反馈。\n\n例子：\n如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2... 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。\n\n例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。\n\n\n**为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？**\n\n看一个例子：\n![策略P和策略B.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png)\n\n> TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大\n\n假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]\n\n现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？\n\n答案是不行，回顾PG算法，`PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。`\n\n但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。\n\n![策略P和策略B更新示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。\n\n**为什么DQN可以多次重复使用数据？**\n\n![DQN更新的是Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png)\n\n两个角度：\n- 更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。\n- 在DQN的更新中是有\"目标\"的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。\n\n> 在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。\n\n### 重要性采样技术\n\n在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。\n\n在这里`IW = P（a）/ B（a）`\n\n就是 `IW = 目标策略出现动作a的概率 / 行为策略出现a的概率`。\n- 目标策略：要更新的策略。\n- 行为策略：数据的策略。\n\n这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。\n![重要性权重表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png)\n\n现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。\n\nPPO使用重要性采样技术把AC从在线策略变成离线策略。\n\n### N步更新\n\n之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。\n\n![TD(N).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%28N%29.png)\n\n如图，实际上只需要计算最后的V(s')，根据这个估算的V(s'), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。\n\n`V = R + gamma * V(s')`\n\n\n### 总结\n实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。\n\n1. 用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； \n2. PPO延展了TD(0)，变成TD(N)的N步更新； \n3. AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。\n\n### PPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## DDPG\nDDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。\n\n- deep: 深度网络。\n- policy gradient: PG\n- deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。\n\nDDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。\n\n\n### 回顾DQN\n\n![回顾DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9B%9E%E9%A1%BEDQN.png)\n\n从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s',a')函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s',a')的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。\n\n### 理解DDPG\nDDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n\n当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n> 注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。\n\nActor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。\n\n### DDPG\n\n![DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG1.png)\n\n整理下：\n#### Critic\n1. Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；\n2. 注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；\n3. Critic网络的loss其还是和AC一样，用的是TD-error。\n\n#### Actor\n1. 和AC不同，Actor输出的是一个动作；\n2. Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。\n3. Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。\n\n和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。\n\n所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。\n\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n> 目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。\n\n### DDPG 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n\n\n## TD3\nTwin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度\n\nTD3是对DDPG的优化，三个重要优化。\n\n### double network\n\nDDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s')去代替V(s')，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。\n\n在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。\n\n回顾DDPG：\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。\n\nTD3需要用到6个网络：\n![TD3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD3.png)\n\n在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。\n\n#### Critic部分的学习\n只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A'；两个critic target Q network ,用于计算两个Q值：Q1(A') 和Q2(A')。\n\nQ1(A') 和Q2(A') 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a') 计算更新目标，也就是说： target = min(Q1,Q2) * gamma + r\n\ntarget 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。\n\n`TD-error_1 = gamma * min(Q1,Q2) + r - Q1`\n`TD-error_2 = gamma * min(Q1,Q2) + r - Q2`\n\n既然更新目标是一样的，那么为什么还需要两个网络呢?\n\n虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。\n\n\n#### Actor部分的学习\n\nDDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。\n\n而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。\n\n对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。\n\n### actor延迟更新\n\nactor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。\n\n为什么要这样做呢？\n\n回到qnet拟合出来的那块\"布\"上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。\n\n所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。\n\n### target网络噪声\n\nTD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization\n\n为什么要这样呢？\n\n回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。\n![Q'估算Q 1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E7%AE%97Q%201.png)\n\n在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。\n\n好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。\n![Q'估计Q 2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E8%AE%A1Q%202.png)\n\n这里注意三个地方：\n1. 在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。\n2. 计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。\n3. 更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。\n\n### TD3 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。\n\n\n\n## A3C\n强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。\n\n在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。\n\n由此诞生了A3C。\n\n![A3C.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C.png)\n\n注意几点：\n1. 在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。\n> 在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。\n2. worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数...... 如此循环。\n\n![A3C1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C1.png)\n\n### A3C 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## DPPO\n\nDPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。\n\n在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。\n\n但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。\n\n### DPPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## 写在最后\n\n到这里，传统强化学习的总结就结束了，后面由于我的科研方向是`多智能体强化学习`，会更新关于多智能体强化学习的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/强化学习.md","raw":"---\ntitle: 强化学习\ntags:\n  - 强化学习\n  - 算法\ncategories:\n  - 强化学习\nkeywords:\n  - 强化学习\ndescription: 强化学习的算法和思路总结\nabbrlink: 17762\ndate: 2023-10-19 16:19:24\nupdated: 2023-10-30 17:03:11\ntop_img: https://s2.loli.net/2024/02/06/T9HwPmcoaKpNXBY.png\ncomments: \ncover: https://s2.loli.net/2024/02/06/IUOjJBRnM3Zf1Pr.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。\n\n原文： https://zhuanlan.zhihu.com/p/111895463\n\n卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！\n\n后面可能会自己写一下 `MADDPG` 和 `MATD3` 的相关内容，到时候再更新。\n\n> 2023/10/23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！\n\n学习路线：\n![学习路线](../image/强化学习/学习路线.png)\n\n## 马尔可夫树\n\n强化学习的任务：\n- 我们希望用强化学习的方式，使某个**智能体**获得**独立自主**地完成某种任务的能力。 \n- 智能体学习和工作的地方，称为**环境**。\n- 所谓独立自主，就是智能体一旦启动，就不需要人指挥了。\n\n### 经典马尔可夫链\n![马尔科夫链.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png)\n\n- 状态(state)：智能体观察到的当前环境的部分或者全部特征。\n  - 注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。\n- 动作(action)：智能体做出的具体行为。\n  - **动作空间**就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。\n- 奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。\n  - 奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。\n\n### RL一般步骤\n1. 智能体在环境中，观察到状态(S)；\n2. 状态(S)被输入到智能体，智能体经过计算，选择动作(A);\n3. 动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。\n4. 智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。\n\n### 马尔可夫树\n马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种\"不确定性\"， 即\"马尔可夫树\"。\n\n![马尔科夫树.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png)\n\n这种\"不确定性\"来自两个方面： \n- 智能体的行动选择(策略)。\n- 环境的不确定性。\n\n## RL中的Q值和V值\n\n并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。\n\n我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。\n\n- 评估动作的价值称为**Q值**：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。\n- 评估状态的价值称为**V值**：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。\n\n价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。\n\n### V值的定义\n\n![V值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n假设现在需要求某状态S的V值，可以这样：\n\n1. 从S点出发，并影分身出若干个自己;\n2. 每个分身按照当前的策略 选择行为;\n3. 每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;\n4. 计算每个影分身获得的平均值,这个平均值就是要求的V值。\n\n总结：`从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。`\n\n`V值跟选择的策略有很大的关系` 。\n\n看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。\n\n![例子1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BE%8B%E5%AD%901.png)\n\n![策略1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A51.png)\n\n![策略2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A52.png)\n\n可以看出不同的策略，计算出的V值是不一样的。\n\n### Q值的定义\n![Q值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n现在需要计算，某个状态S0下的一个动作A的Q值： \n1. 从A这个节点出发，使用影分身之术； \n2. 每个影分身走到最终状态,并记录所获得的奖励； \n3. 求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。\n\n总结：`从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。`\n\n与V值不同，Q值和策略并没有直接相关，而`与环境的状态转移概率相关，而环境的状态转移概率是不变的。`\n\n### V值和Q值关系\n`Q和V之间是可以相互换算的`。\n\n#### Q值转V值\n\n![Q值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。\n\nS状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。\n\n假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。\n\n![Q值转V值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F1.png)\n\n解释：`一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。`\n\n#### V值转Q值\n\n`Q是V的期望。`而这里不需要关注策略，这里是环境的状态转移概率决定的。\n\n![V值转Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC.png)\n\n`当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！`\n\n![V值转Q值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F2.png)\n\n> 折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。\n\n### V值转V值\n实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。\n\n![V值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n## MC\n蒙地卡罗方法(Monte-Carlo)\n\n### 蒙地卡罗算法\n\n1. 把智能体放到环境的任意状态；\n2. 从这个状态开始按照策略进行选择动作，并进入新的状态。\n3. 重复步骤2，直到最终状态；\n4. 从最终状态开始向前回溯：计算每个状态的G值。\n5. 重复1-4多次，然后平均每个状态的G值，这就是要求的V值。\n\n### G值的意义\n\n重要：`G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。`\n\n![G值的意义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FG%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png)\n\n- 第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。\n- 第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G'),乘以一定的折扣(gamma),再加上r。\n\n所以G值的意义在于，`在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。`\n\n当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。`而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。`\n\n理解：\n1. `G的意义：在某个路径上，状态S到最终状态的总收获。 `\n2. `V和G的关系：V是G的平均数。`\n\n### V和策略相关\n![策略3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A53.png)\n\n![策略4.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A54.png)\n\n由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。\n\n### 蒙地卡罗算法的缺点\n\n每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。\n\n### MC的更新公式\n上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。\n\n那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是`增量更新`。\n\n#### 增量更新\n现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 \n\n`V_new = (V_old - G) * (1 / N) + V_old`\n\n- V_old：原来的V值\n- G：这一次回溯后，计算出来的G值\n- N: 这个状态被经过多少次\n- V_new：新计算出来的V值\n\n#### 更进一步\n\n这样计算还是比较麻烦，我们甚至可以不用记录N，把(1/N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为`学习率`。\n\n这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。\n\n这里的G，也称为V的更新目标。\n\n而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。\n\n#### 两种理解方式\n\n![两种理解方式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png)\n\n## TD\n时序差分算法TD(Temporal-Difference)\n\n### TD和MC的比较\nTD算法对蒙地卡罗(MC)进行了改进：\n1. 和蒙地卡罗(MC)不同：`TD算法只需要走N步，不用走到终点，就可以开始回溯更新。` \n2. 和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 \n3. 那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。\n   - 假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. \n   - 假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。\n\n### 直观理解\n\n从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时`N = 0`，也叫做`TD(0)`。\n\n但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。\n\n![TD(0).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29.png)\n\n假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。\n\n### 更新公式\n\nTD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 `所以只需要把MC的更新目标，改为TD的更新目标即可。`\n\n`在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V`\n\n![更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n\n## Q-learning\n\n之前用TD(0)预估状态价值V:\n![TD(0)更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n图解：\n![TD(0)图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E5%9B%BE%E8%A7%A3.png)\n\nTD能够用在V值，那么也能用在计算Q值上。\n\n### TD之于Q值估算\n\n现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。 \n![用TD估计Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png)\n- V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 \n- Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。\n\n在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。\n![用下一个动作的Q代替V.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png)\n\n但是，这里就有个坑：`虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。`\n\n因为`马尔可夫树!`\n![坑的解释.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png)\n\n`在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。`\n\n虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。\n1. 在相同策略下产生的动作At+1。这就是`SARSA`。\n2. 选择能够产生最大Q值的动作At+1。这就是`Qlearning`。\n\n### SARSA\n\n![SARSA.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA.png)\n\n其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n![TD(0)与SARSA对比.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png)\n\n注意: `这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。`\n\n### Qlearning\n`Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。`\n\n![Qlearning图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%9B%BE%E8%A7%A3.png)\n\n理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。\n![Qlearning公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%85%AC%E5%BC%8F.png)\n\n`Q(S,a)的更新目标`：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n\nQleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。\n\n### 总结\n1. Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 \n2. Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 \n3. 既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 \n4. Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 \n   - SARSA 选择的是在St同一个策略产生的动作。 \n   - Qlearning 选择的是能够产生最大的Q值的动作。\n\n### Qlearning 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## 深度神经网络\n\n深度强化学习：用深度神经网络辅助强化学习。\n\n#### 原理\n假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)=y。\n\n这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。\n![Magic(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%28X%29.png)\n\n现在假设有另外一个函数Magic'(),这个函数是由深度神经网络构成。\n\n在刚开始的时候，很明显Magic'(X) 并不等于y，例如输入手写图片8，Magic'()计算后，认为数字8只有20%，但数字9有40%。\n\n...但这没所谓，因为这是刚开始。我们的任务是让Magic'(X)产生的结果y' 和 y尽量接近。\n\ny'和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic'(X)越来越靠近这个目标。\n\n衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。\n\nloss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic'(X)和Magic(X)函数非常接近，可以通过Magic'(X)计算出y。\n\n当有许许多多这样的y，经过许许多多轮后。Magic'就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。\n\n![Magic'(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%27%28X%29.png)\n\n#### 放大镜下的深度神经网络\n![数据加工厂.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png)\n\n现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。\n\n为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更`标准`一些。\n\n例如图片的尺寸大小，有多少通道的颜色等等，然后`分批(batch)`，输入工厂。\n\n在输入工厂的时候，会有一个‘大门’，称为`输入层`，去检查数据是否已经按照工厂的标准整理好。\n\n数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。\n\n一般称这些车间叫`层`。`这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了`。常用的层包括：`Dense、Conv2D、LSTM、Reshape、Flatten`等。\n\n最终，数据工厂会把原数据X，加工成产品`y'(也叫做：logits)`。从源数据加工成产品的过程，叫`正向传播`。\n\n但产品y'是否是一个合格的产品，我们还需要我们真正的`y(lables)`作为标准去鉴定。把`鉴定出来的差距就是loss`。\n\n工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y'能够对应起来。\n\n经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。\n\n\n## DQN\n> `DQN: TD + 神经网络`\n\n在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。\n\nQtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。\n\n这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。\n\n`用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。`\n\n`Deep network + Qlearning = DQN`\n\n神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。\n\n### 理解DQN中的神经网络\n\nQtable三维可视化：\n![Qtable三维可视化.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png)\n\n图中每根柱子的高度，表示状态S下，选择动作A的Q值。\n\n`现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。`\n\n![扭曲的曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png)\n\n从二维状态看：\n![二维曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png)\n\n所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。\n\n现在就很清楚了，其实Qlearning和DQN并没有根本的区别。`只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。`\n\n### 更新目标\n\n更新目标就是Magic(X)，最终要向这个Magix(X)靠近。\n\n在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。\n\nDQN和Qlearning一样：\n![DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN.png)\n假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： \n1. 执行A，往前一步，到达St+1; \n2. 把St+1输入Q网络，计算St+1下所有动作的Q值； \n3. 获得最大的Q值加上奖励R作为更新目标； \n4. 计算损失 \n   - Q(S,A)相当于有监督学习中的logits\n   - maxQ(St+1) + R 相当于有监督学习中的lables \n   - 用mse函数，得出两者的loss \n   - Loss = (Q(S, A) - [gamma * maxQ(St+1) + R])^2\n5. 用loss更新Q网络。(反向传播)\n\n> 通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。\n\n也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标\n`Target = R + gamma * maxQ(St+1)`\n\n![DQN公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E5%85%AC%E5%BC%8F.png)\n\n总结：\n1. 其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。\n2. 解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。\n3. 和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。\n\n### DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Double DQN\n\n### 经验回放\n经验回放解决了强化学习中的两个问题： `训练网络数据采集慢` 和 `过度拟合`\n\n\n当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。\n\n把每一步的s，选择的a，进入新的状态s'，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。\n当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ....\n当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。\n训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里...\n就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。\n\n使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。\n过度拟合，放到人身上就是`过度依赖局部经验`了。\n就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。\n同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。\n\n\n\n\n### DQN的问题\nDQN的目标：\n`Target = R + gamma * maxQ(St+1)`\n\n目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。\n\n如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。\n\n要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是`Fixed Q-targets`的思路。\n\n### Fixed Q-targets\n\n![fix-Q-targets.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2Ffix-Q-targets.png)\n\n其他地方和DQN一样，唯一不同是用了两个Q网络。\n\n- 原来的Q网络，用于估算Q(s);\n- targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。\n  - `y = r + gamma * max(targetQ(s'))`\n  - 进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。\n\n### Double DQN\n\nDQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s'的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值...，这就导致了Q值往往会有偏大的的情况出现。\n\n这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。\n\n另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。\n\n\n### Double DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Duel DQN\n\n### Dueling DQN原理\n回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即`Q = S + A`\n- S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。\n- A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。\n\n![Q=S+A表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%3DS%2BA%E8%A1%A8%E6%A0%BC.png)\n\n普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。\n\n![普通DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%99%AE%E9%80%9ADQN.png)\n\n普通DQN在提升某个状态下的S值时，只会提升某个动作。\n\nDueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。\n\n![DuelDQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN.png)\n\n如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。\n\n> 这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。\n\n### 网络架构\n![DuelDQN网络架构.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png)\n\n可以把dueling DQN分为三部分：\n- 第一部分：和普通DQN一样，用来处理和学习数据。\n- 第二部分：计算svalue，就是让网络预估的平均值。\n- 第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。\n  - 归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)\n\nDeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。\n\n### Duel DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PG\n策略梯度(Policy Gradient)\n\n之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。\n\n这就是`策略梯度(Policy Gradient)`\n\n### PG原理\n\n认识到：\n> `DQN: TD + 神经网络`\n> `PG: MC + 神经网络`\n\nPG中的Magic(state):\n当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： = magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。\n\n复习一下蒙地卡罗：\n从某个state出发，然后一直走，直到`最终状态`。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。\n![复习MC.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%A4%8D%E4%B9%A0MC.png)\n\n### 直观感受PG\n\n从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 = [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G = 1。\n\n![直观感受PG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png)\n\n更新策略，因为该路径选择了A而产生的，并获得G = 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 = [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G = -1。\n\n![直观感受PG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png)\n\n此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 = [55%,15%,30%]。最后随机到C，回溯计算后，计算得G = 5。\n\n![直观感受PG3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png)\n\nC比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 = [20%,5%,75%]。\n\n### PG 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## AC\n> `AC: PG + DQN(TD + 神经网络)`\n\nPG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。\n\n改为TD可以解决上面的问题。接下来又面临另一个问题：\n在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。\n\n也就是说，Actor-Critic，其实是用了两个网络：\n\n两网络都输入状态S，Critic比Actor多一个St+1: \n- 一个网络输出策略，负责选择动作，把这个网络成为Actor； \n- 一个网络负责计算每个动作的分数，把这个网络成为Critic。\n\n### TD-error\n`在DQN预估的是Q值，在AC中的Critic，估算的是V值。`不估算Q值是因为效果不好。\n![为什么不估算Q.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png)\n\n假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高...\n\n这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？\n因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。\n\n但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而`Q值的期望(均值)就是V。`\n\n![TD-error.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD-error.png)\n\n可以得到更新的权重：`Q(s,a)-V(s)`，Q(s,a)用`gamma * V(s') + r` 代替。\n得到TD-error：`TD-error = gamma * V(s') + r - V(s)`\n\n和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。\n\n至于为啥TD-error是用来更新Critic的loss呢？\n取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。\n再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。\n\n#### 总结\n1. 为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：`Q(s,a)-V(s)`\n2. 为了避免需要预估V值和Q值，把Q和V统一；由于`Q(s,a) = gamma * V(s') + r - V(s)`。所以我们得到TD-error公式： `TD-error = gamma * V(s') + r - V(s)`\n3. `TD-error就是Actor更新策略时候，带权重更新中的权重值`；\n4. 现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。\n\n### 算法\n1. 定义两个network：Actor 和 Critic\n2. 进行N次更新。\n    1. 从状态s开始，执行动作a，得到奖励r，进入状态s'\n    2. 记录的数据。\n    3. 把输入到Critic，根据公式： TD-error = gamma * V(s') + r - V(s) 求 TD-error，并缩小TD-error\n    4. 把输入到Actor，计算策略分布。\n\n![AC算法.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FAC%E7%AE%97%E6%B3%95.png)\n\n可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。\n\n### AC 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PPO\nPPO是基于AC框架的\n\n### 正态分布\n首先要想办法处理连续动作的输出问题。\n\n- 离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。\n- 连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。\n\n在离散动作空间的问题中，最终输出的策略呈现出下面形式：\n![离散动作-策略分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png)\n\n假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi = [0.4, 0.6]。\n![连续型概率分布示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P = （action）代表在策略下，选择某个action的概率P。\n\n用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。\n\n这样，只用两个参数就可以表示了。\n![正态分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png)\n\n正态分布：\n- sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。\n- mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。\n\n神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。\n\n### AC的问题\n\n上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。\n\n- 行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。\n- 目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。\n\n- 在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。\n  - 实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。\n  - 依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。\n- 离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。\n  - 离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。\n  - 无需环境互动：训练过程中不需要实时环境反馈。\n\n例子：\n如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2... 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。\n\n例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。\n\n\n**为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？**\n\n看一个例子：\n![策略P和策略B.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png)\n\n> TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大\n\n假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]\n\n现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？\n\n答案是不行，回顾PG算法，`PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。`\n\n但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。\n\n![策略P和策略B更新示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。\n\n**为什么DQN可以多次重复使用数据？**\n\n![DQN更新的是Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png)\n\n两个角度：\n- 更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。\n- 在DQN的更新中是有\"目标\"的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。\n\n> 在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。\n\n### 重要性采样技术\n\n在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。\n\n在这里`IW = P（a）/ B（a）`\n\n就是 `IW = 目标策略出现动作a的概率 / 行为策略出现a的概率`。\n- 目标策略：要更新的策略。\n- 行为策略：数据的策略。\n\n这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。\n![重要性权重表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png)\n\n现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。\n\nPPO使用重要性采样技术把AC从在线策略变成离线策略。\n\n### N步更新\n\n之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。\n\n![TD(N).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%28N%29.png)\n\n如图，实际上只需要计算最后的V(s')，根据这个估算的V(s'), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。\n\n`V = R + gamma * V(s')`\n\n\n### 总结\n实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。\n\n1. 用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； \n2. PPO延展了TD(0)，变成TD(N)的N步更新； \n3. AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。\n\n### PPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## DDPG\nDDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。\n\n- deep: 深度网络。\n- policy gradient: PG\n- deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。\n\nDDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。\n\n\n### 回顾DQN\n\n![回顾DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9B%9E%E9%A1%BEDQN.png)\n\n从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s',a')函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s',a')的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。\n\n### 理解DDPG\nDDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n\n当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n> 注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。\n\nActor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。\n\n### DDPG\n\n![DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG1.png)\n\n整理下：\n#### Critic\n1. Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；\n2. 注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；\n3. Critic网络的loss其还是和AC一样，用的是TD-error。\n\n#### Actor\n1. 和AC不同，Actor输出的是一个动作；\n2. Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。\n3. Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。\n\n和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。\n\n所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。\n\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n> 目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。\n\n### DDPG 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n\n\n## TD3\nTwin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度\n\nTD3是对DDPG的优化，三个重要优化。\n\n### double network\n\nDDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s')去代替V(s')，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。\n\n在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。\n\n回顾DDPG：\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。\n\nTD3需要用到6个网络：\n![TD3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD3.png)\n\n在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。\n\n#### Critic部分的学习\n只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A'；两个critic target Q network ,用于计算两个Q值：Q1(A') 和Q2(A')。\n\nQ1(A') 和Q2(A') 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a') 计算更新目标，也就是说： target = min(Q1,Q2) * gamma + r\n\ntarget 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。\n\n`TD-error_1 = gamma * min(Q1,Q2) + r - Q1`\n`TD-error_2 = gamma * min(Q1,Q2) + r - Q2`\n\n既然更新目标是一样的，那么为什么还需要两个网络呢?\n\n虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。\n\n\n#### Actor部分的学习\n\nDDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。\n\n而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。\n\n对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。\n\n### actor延迟更新\n\nactor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。\n\n为什么要这样做呢？\n\n回到qnet拟合出来的那块\"布\"上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。\n\n所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。\n\n### target网络噪声\n\nTD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization\n\n为什么要这样呢？\n\n回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。\n![Q'估算Q 1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E7%AE%97Q%201.png)\n\n在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。\n\n好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。\n![Q'估计Q 2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E8%AE%A1Q%202.png)\n\n这里注意三个地方：\n1. 在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。\n2. 计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。\n3. 更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。\n\n### TD3 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。\n\n\n\n## A3C\n强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。\n\n在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。\n\n由此诞生了A3C。\n\n![A3C.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C.png)\n\n注意几点：\n1. 在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。\n> 在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。\n2. worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数...... 如此循环。\n\n![A3C1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C1.png)\n\n### A3C 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## DPPO\n\nDPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。\n\n在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。\n\n但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。\n\n### DPPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## 写在最后\n\n到这里，传统强化学习的总结就结束了，后面由于我的科研方向是`多智能体强化学习`，会更新关于多智能体强化学习的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"强化学习","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1x002lr7gn1scvhhgt","content":"<blockquote>\n<p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p>\n</blockquote>\n<p>原文： <a href=\"https://zhuanlan.zhihu.com/p/111895463\">https://zhuanlan.zhihu.com/p/111895463</a></p>\n<p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p>\n<p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p>\n<blockquote>\n<p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p>\n</blockquote>\n<p>学习路线：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png\" alt=\"学习路线\"></p>\n<h2 id=\"马尔可夫树\"><a href=\"#马尔可夫树\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h2><p>强化学习的任务：</p>\n<ul>\n<li>我们希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li>\n<li>智能体学习和工作的地方，称为<strong>环境</strong>。</li>\n<li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li>\n</ul>\n<h3 id=\"经典马尔可夫链\"><a href=\"#经典马尔可夫链\" class=\"headerlink\" title=\"经典马尔可夫链\"></a>经典马尔可夫链</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png\" alt=\"马尔科夫链.png\"></p>\n<ul>\n<li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul>\n<li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li>\n</ul>\n</li>\n<li>动作(action)：智能体做出的具体行为。<ul>\n<li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。</li>\n</ul>\n</li>\n<li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul>\n<li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RL一般步骤\"><a href=\"#RL一般步骤\" class=\"headerlink\" title=\"RL一般步骤\"></a>RL一般步骤</h3><ol>\n<li>智能体在环境中，观察到状态(S)；</li>\n<li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li>\n<li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li>\n<li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li>\n</ol>\n<h3 id=\"马尔可夫树-1\"><a href=\"#马尔可夫树-1\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h3><p>马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png\" alt=\"马尔科夫树.png\"></p>\n<p>这种”不确定性”来自两个方面： </p>\n<ul>\n<li>智能体的行动选择(策略)。</li>\n<li>环境的不确定性。</li>\n</ul>\n<h2 id=\"RL中的Q值和V值\"><a href=\"#RL中的Q值和V值\" class=\"headerlink\" title=\"RL中的Q值和V值\"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p>\n<p>我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p>\n<ul>\n<li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li>\n<li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li>\n</ul>\n<p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p>\n<h3 id=\"V值的定义\"><a href=\"#V值的定义\" class=\"headerlink\" title=\"V值的定义\"></a>V值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"V值的定义.png\"></p>\n<p>假设现在需要求某状态S的V值，可以这样：</p>\n<ol>\n<li>从S点出发，并影分身出若干个自己;</li>\n<li>每个分身按照当前的策略 选择行为;</li>\n<li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li>\n<li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li>\n</ol>\n<p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p>\n<p><code>V值跟选择的策略有很大的关系</code> 。</p>\n<p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png\" alt=\"例子1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png\" alt=\"策略1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png\" alt=\"策略2.png\"></p>\n<p>可以看出不同的策略，计算出的V值是不一样的。</p>\n<h3 id=\"Q值的定义\"><a href=\"#Q值的定义\" class=\"headerlink\" title=\"Q值的定义\"></a>Q值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"Q值的定义.png\"></p>\n<p>现在需要计算，某个状态S0下的一个动作A的Q值： </p>\n<ol>\n<li>从A这个节点出发，使用影分身之术； </li>\n<li>每个影分身走到最终状态,并记录所获得的奖励； </li>\n<li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li>\n</ol>\n<p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p>\n<p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p>\n<h3 id=\"V值和Q值关系\"><a href=\"#V值和Q值关系\" class=\"headerlink\" title=\"V值和Q值关系\"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p>\n<h4 id=\"Q值转V值\"><a href=\"#Q值转V值\" class=\"headerlink\" title=\"Q值转V值\"></a>Q值转V值</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"Q值转V值.png\"></p>\n<p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p>\n<p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p>\n<p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png\" alt=\"Q值转V值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png\" alt=\"公式1.png\"></p>\n<p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p>\n<h4 id=\"V值转Q值\"><a href=\"#V值转Q值\" class=\"headerlink\" title=\"V值转Q值\"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png\" alt=\"V值转Q值.png\"></p>\n<p><code>当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png\" alt=\"V值转Q值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png\" alt=\"公式2.png\"></p>\n<blockquote>\n<p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。</p>\n</blockquote>\n<h3 id=\"V值转V值\"><a href=\"#V值转V值\" class=\"headerlink\" title=\"V值转V值\"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"V值转V值.png\"></p>\n<h2 id=\"MC\"><a href=\"#MC\" class=\"headerlink\" title=\"MC\"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p>\n<h3 id=\"蒙地卡罗算法\"><a href=\"#蒙地卡罗算法\" class=\"headerlink\" title=\"蒙地卡罗算法\"></a>蒙地卡罗算法</h3><ol>\n<li>把智能体放到环境的任意状态；</li>\n<li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li>\n<li>重复步骤2，直到最终状态；</li>\n<li>从最终状态开始向前回溯：计算每个状态的G值。</li>\n<li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li>\n</ol>\n<h3 id=\"G值的意义\"><a href=\"#G值的意义\" class=\"headerlink\" title=\"G值的意义\"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png\" alt=\"G值的意义.png\"></p>\n<ul>\n<li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li>\n<li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li>\n</ul>\n<p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p>\n<p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p>\n<p>理解：</p>\n<ol>\n<li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li>\n<li><code>V和G的关系：V是G的平均数。</code></li>\n</ol>\n<h3 id=\"V和策略相关\"><a href=\"#V和策略相关\" class=\"headerlink\" title=\"V和策略相关\"></a>V和策略相关</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png\" alt=\"策略3.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png\" alt=\"策略4.png\"></p>\n<p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p>\n<h3 id=\"蒙地卡罗算法的缺点\"><a href=\"#蒙地卡罗算法的缺点\" class=\"headerlink\" title=\"蒙地卡罗算法的缺点\"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p>\n<h3 id=\"MC的更新公式\"><a href=\"#MC的更新公式\" class=\"headerlink\" title=\"MC的更新公式\"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p>\n<p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p>\n<h4 id=\"增量更新\"><a href=\"#增量更新\" class=\"headerlink\" title=\"增量更新\"></a>增量更新</h4><p>现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p>\n<p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p>\n<ul>\n<li>V_old：原来的V值</li>\n<li>G：这一次回溯后，计算出来的G值</li>\n<li>N: 这个状态被经过多少次</li>\n<li>V_new：新计算出来的V值</li>\n</ul>\n<h4 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h4><p>这样计算还是比较麻烦，我们甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<code>学习率</code>。</p>\n<p>这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p>\n<p>这里的G，也称为V的更新目标。</p>\n<p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p>\n<h4 id=\"两种理解方式\"><a href=\"#两种理解方式\" class=\"headerlink\" title=\"两种理解方式\"></a>两种理解方式</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png\" alt=\"两种理解方式.png\"></p>\n<h2 id=\"TD\"><a href=\"#TD\" class=\"headerlink\" title=\"TD\"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p>\n<h3 id=\"TD和MC的比较\"><a href=\"#TD和MC的比较\" class=\"headerlink\" title=\"TD和MC的比较\"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p>\n<ol>\n<li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li>\n<li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li>\n<li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul>\n<li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. </li>\n<li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"直观理解\"><a href=\"#直观理解\" class=\"headerlink\" title=\"直观理解\"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p>\n<p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png\" alt=\"TD(0).png\"></p>\n<p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p>\n<h3 id=\"更新公式\"><a href=\"#更新公式\" class=\"headerlink\" title=\"更新公式\"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p>\n<p><code>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"更新公式.png\"></p>\n<h2 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"TD(0)更新公式.png\"></p>\n<p>图解：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png\" alt=\"TD(0)图解.png\"></p>\n<p>TD能够用在V值，那么也能用在计算Q值上。</p>\n<h3 id=\"TD之于Q值估算\"><a href=\"#TD之于Q值估算\" class=\"headerlink\" title=\"TD之于Q值估算\"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png\" alt=\"用TD估计Q值.png\"></p>\n<ul>\n<li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li>\n<li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li>\n</ul>\n<p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png\" alt=\"用下一个动作的Q代替V.png\"></p>\n<p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p>\n<p>因为<code>马尔可夫树!</code><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png\" alt=\"坑的解释.png\"></p>\n<p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p>\n<p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p>\n<ol>\n<li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li>\n<li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li>\n</ol>\n<h3 id=\"SARSA\"><a href=\"#SARSA\" class=\"headerlink\" title=\"SARSA\"></a>SARSA</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png\" alt=\"SARSA.png\"></p>\n<p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png\" alt=\"TD(0)与SARSA对比.png\"></p>\n<p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p>\n<h3 id=\"Qlearning\"><a href=\"#Qlearning\" class=\"headerlink\" title=\"Qlearning\"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png\" alt=\"Qlearning图解.png\"></p>\n<p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png\" alt=\"Qlearning公式.png\"></p>\n<p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"></p>\n<p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li>\n<li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li>\n<li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li>\n<li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul>\n<li>SARSA 选择的是在St同一个策略产生的动作。 </li>\n<li>Qlearning 选择的是能够产生最大的Q值的动作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Qlearning-实现\"><a href=\"#Qlearning-实现\" class=\"headerlink\" title=\"Qlearning 实现\"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"深度神经网络\"><a href=\"#深度神经网络\" class=\"headerlink\" title=\"深度神经网络\"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p>\n<p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png\" alt=\"Magic(X).png\"></p>\n<p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p>\n<p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p>\n<p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p>\n<p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p>\n<p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p>\n<p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p>\n<p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png\" alt=\"Magic&#39;(X).png\"></p>\n<h4 id=\"放大镜下的深度神经网络\"><a href=\"#放大镜下的深度神经网络\" class=\"headerlink\" title=\"放大镜下的深度神经网络\"></a>放大镜下的深度神经网络</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png\" alt=\"数据加工厂.png\"></p>\n<p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p>\n<p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p>\n<p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p>\n<p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p>\n<p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p>\n<p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p>\n<p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p>\n<p>但产品y’是否是一个合格的产品，我们还需要我们真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p>\n<p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p>\n<p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p>\n<h2 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h2><blockquote>\n<p><code>DQN: TD + 神经网络</code></p>\n</blockquote>\n<p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p>\n<p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p>\n<p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p>\n<p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p>\n<p><code>Deep network + Qlearning = DQN</code></p>\n<p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p>\n<h3 id=\"理解DQN中的神经网络\"><a href=\"#理解DQN中的神经网络\" class=\"headerlink\" title=\"理解DQN中的神经网络\"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png\" alt=\"Qtable三维可视化.png\"></p>\n<p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p>\n<p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png\" alt=\"扭曲的曲线.png\"></p>\n<p>从二维状态看：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png\" alt=\"二维曲线.png\"></p>\n<p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p>\n<p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p>\n<h3 id=\"更新目标\"><a href=\"#更新目标\" class=\"headerlink\" title=\"更新目标\"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p>\n<p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p>\n<p>DQN和Qlearning一样：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png\" alt=\"DQN.png\"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p>\n<ol>\n<li>执行A，往前一步，到达St+1; </li>\n<li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li>\n<li>获得最大的Q值加上奖励R作为更新目标； </li>\n<li>计算损失 <ul>\n<li>Q(S,A)相当于有监督学习中的logits</li>\n<li>maxQ(St+1) + R 相当于有监督学习中的lables </li>\n<li>用mse函数，得出两者的loss </li>\n<li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li>\n</ul>\n</li>\n<li>用loss更新Q网络。(反向传播)</li>\n</ol>\n<blockquote>\n<p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p>\n</blockquote>\n<p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png\" alt=\"DQN公式.png\"></p>\n<p>总结：</p>\n<ol>\n<li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li>\n<li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li>\n<li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li>\n</ol>\n<h3 id=\"DQN-实现\"><a href=\"#DQN-实现\" class=\"headerlink\" title=\"DQN 实现\"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Double-DQN\"><a href=\"#Double-DQN\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h2><h3 id=\"经验回放\"><a href=\"#经验回放\" class=\"headerlink\" title=\"经验回放\"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p>\n<p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p>\n<p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p>\n<p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p>\n<h3 id=\"DQN的问题\"><a href=\"#DQN的问题\" class=\"headerlink\" title=\"DQN的问题\"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p>\n<p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p>\n<p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p>\n<h3 id=\"Fixed-Q-targets\"><a href=\"#Fixed-Q-targets\" class=\"headerlink\" title=\"Fixed Q-targets\"></a>Fixed Q-targets</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png\" alt=\"fix-Q-targets.png\"></p>\n<p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p>\n<ul>\n<li>原来的Q网络，用于估算Q(s);</li>\n<li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul>\n<li><code>y = r + gamma * max(targetQ(s&#39;))</code></li>\n<li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Double-DQN-1\"><a href=\"#Double-DQN-1\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p>\n<p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p>\n<p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p>\n<h3 id=\"Double-DQN-实现\"><a href=\"#Double-DQN-实现\" class=\"headerlink\" title=\"Double DQN 实现\"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Duel-DQN\"><a href=\"#Duel-DQN\" class=\"headerlink\" title=\"Duel DQN\"></a>Duel DQN</h2><h3 id=\"Dueling-DQN原理\"><a href=\"#Dueling-DQN原理\" class=\"headerlink\" title=\"Dueling DQN原理\"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p>\n<ul>\n<li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li>\n<li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li>\n</ul>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png\" alt=\"Q=S+A表格.png\"></p>\n<p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png\" alt=\"普通DQN.png\"></p>\n<p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p>\n<p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png\" alt=\"DuelDQN.png\"></p>\n<p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p>\n<blockquote>\n<p>这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。</p>\n</blockquote>\n<h3 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png\" alt=\"DuelDQN网络架构.png\"></p>\n<p>可以把dueling DQN分为三部分：</p>\n<ul>\n<li>第一部分：和普通DQN一样，用来处理和学习数据。</li>\n<li>第二部分：计算svalue，就是让网络预估的平均值。</li>\n<li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul>\n<li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li>\n</ul>\n</li>\n</ul>\n<p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p>\n<h3 id=\"Duel-DQN-实现\"><a href=\"#Duel-DQN-实现\" class=\"headerlink\" title=\"Duel DQN 实现\"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>策略梯度(Policy Gradient)</p>\n<p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。</p>\n<p>这就是<code>策略梯度(Policy Gradient)</code></p>\n<h3 id=\"PG原理\"><a href=\"#PG原理\" class=\"headerlink\" title=\"PG原理\"></a>PG原理</h3><p>认识到：</p>\n<blockquote>\n<p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p>\n</blockquote>\n<p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p>\n<p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png\" alt=\"复习MC.png\"></p>\n<h3 id=\"直观感受PG\"><a href=\"#直观感受PG\" class=\"headerlink\" title=\"直观感受PG\"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png\" alt=\"直观感受PG1.png\"></p>\n<p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png\" alt=\"直观感受PG2.png\"></p>\n<p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png\" alt=\"直观感受PG3.png\"></p>\n<p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p>\n<h3 id=\"PG-实现\"><a href=\"#PG-实现\" class=\"headerlink\" title=\"PG 实现\"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"AC\"><a href=\"#AC\" class=\"headerlink\" title=\"AC\"></a>AC</h2><blockquote>\n<p><code>AC: PG + DQN(TD + 神经网络)</code></p>\n</blockquote>\n<p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p>\n<p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。</p>\n<p>也就是说，Actor-Critic，其实是用了两个网络：</p>\n<p>两网络都输入状态S，Critic比Actor多一个St+1: </p>\n<ul>\n<li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li>\n<li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li>\n</ul>\n<h3 id=\"TD-error\"><a href=\"#TD-error\" class=\"headerlink\" title=\"TD-error\"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png\" alt=\"为什么不估算Q.png\"></p>\n<p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p>\n<p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p>\n<p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png\" alt=\"TD-error.png\"></p>\n<p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p>\n<p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p>\n<p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li>\n<li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以我们得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li>\n<li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li>\n<li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li>\n</ol>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ol>\n<li>定义两个network：Actor 和 Critic</li>\n<li>进行N次更新。<ol>\n<li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li>\n<li>记录的数据。</li>\n<li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li>\n<li>把输入到Actor，计算策略分布。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png\" alt=\"AC算法.png\"></p>\n<p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p>\n<h3 id=\"AC-实现\"><a href=\"#AC-实现\" class=\"headerlink\" title=\"AC 实现\"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PPO\"><a href=\"#PPO\" class=\"headerlink\" title=\"PPO\"></a>PPO</h2><p>PPO是基于AC框架的</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p>\n<ul>\n<li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li>\n<li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li>\n</ul>\n<p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png\" alt=\"离散动作-策略分布.png\"></p>\n<p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"连续型概率分布示意图.png\"></p>\n<p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; （action）代表在策略下，选择某个action的概率P。</p>\n<p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p>\n<p>这样，只用两个参数就可以表示了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png\" alt=\"正态分布.png\"></p>\n<p>正态分布：</p>\n<ul>\n<li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li>\n<li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li>\n</ul>\n<p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p>\n<h3 id=\"AC的问题\"><a href=\"#AC的问题\" class=\"headerlink\" title=\"AC的问题\"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p>\n<ul>\n<li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p>\n</li>\n<li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p>\n</li>\n<li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p>\n<ul>\n<li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li>\n<li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li>\n</ul>\n</li>\n<li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p>\n<ul>\n<li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li>\n<li>无需环境互动：训练过程中不需要实时环境反馈。</li>\n</ul>\n</li>\n</ul>\n<p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p>\n<p>例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p>\n<p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p>\n<p>看一个例子：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png\" alt=\"策略P和策略B.png\"></p>\n<blockquote>\n<p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p>\n</blockquote>\n<p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p>\n<p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p>\n<p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p>\n<p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"策略P和策略B更新示意图.png\"></p>\n<p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p>\n<p><strong>为什么DQN可以多次重复使用数据？</strong></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png\" alt=\"DQN更新的是Q值.png\"></p>\n<p>两个角度：</p>\n<ul>\n<li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li>\n<li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li>\n</ul>\n<blockquote>\n<p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。</p>\n</blockquote>\n<h3 id=\"重要性采样技术\"><a href=\"#重要性采样技术\" class=\"headerlink\" title=\"重要性采样技术\"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p>\n<p>在这里<code>IW = P（a）/ B（a）</code></p>\n<p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p>\n<ul>\n<li>目标策略：要更新的策略。</li>\n<li>行为策略：数据的策略。</li>\n</ul>\n<p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png\" alt=\"重要性权重表格.png\"></p>\n<p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p>\n<p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p>\n<h3 id=\"N步更新\"><a href=\"#N步更新\" class=\"headerlink\" title=\"N步更新\"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png\" alt=\"TD(N).png\"></p>\n<p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p>\n<p><code>V = R + gamma * V(s&#39;)</code></p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p>\n<ol>\n<li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li>\n<li>PPO延展了TD(0)，变成TD(N)的N步更新； </li>\n<li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li>\n</ol>\n<h3 id=\"PPO-实现\"><a href=\"#PPO-实现\" class=\"headerlink\" title=\"PPO 实现\"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DDPG\"><a href=\"#DDPG\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p>\n<ul>\n<li>deep: 深度网络。</li>\n<li>policy gradient: PG</li>\n<li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li>\n</ul>\n<p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p>\n<h3 id=\"回顾DQN\"><a href=\"#回顾DQN\" class=\"headerlink\" title=\"回顾DQN\"></a>回顾DQN</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png\" alt=\"回顾DQN.png\"></p>\n<p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。</p>\n<h3 id=\"理解DDPG\"><a href=\"#理解DDPG\" class=\"headerlink\" title=\"理解DDPG\"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"></p>\n<p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<blockquote>\n<p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p>\n</blockquote>\n<p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p>\n<h3 id=\"DDPG-1\"><a href=\"#DDPG-1\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png\" alt=\"DDPG1.png\"></p>\n<p>整理下：</p>\n<h4 id=\"Critic\"><a href=\"#Critic\" class=\"headerlink\" title=\"Critic\"></a>Critic</h4><ol>\n<li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li>\n<li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li>\n<li>Critic网络的loss其还是和AC一样，用的是TD-error。</li>\n</ol>\n<h4 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h4><ol>\n<li>和AC不同，Actor输出的是一个动作；</li>\n<li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li>\n<li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li>\n</ol>\n<p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p>\n<p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<blockquote>\n<p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p>\n</blockquote>\n<h3 id=\"DDPG-实现\"><a href=\"#DDPG-实现\" class=\"headerlink\" title=\"DDPG 实现\"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"TD3\"><a href=\"#TD3\" class=\"headerlink\" title=\"TD3\"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p>\n<p>TD3是对DDPG的优化，三个重要优化。</p>\n<h3 id=\"double-network\"><a href=\"#double-network\" class=\"headerlink\" title=\"double network\"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p>\n<p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p>\n<p>回顾DDPG：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p>\n<p>TD3需要用到6个网络：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png\" alt=\"TD3.png\"></p>\n<p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p>\n<h4 id=\"Critic部分的学习\"><a href=\"#Critic部分的学习\" class=\"headerlink\" title=\"Critic部分的学习\"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p>\n<p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p>\n<p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p>\n<p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p>\n<p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p>\n<p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p>\n<h4 id=\"Actor部分的学习\"><a href=\"#Actor部分的学习\" class=\"headerlink\" title=\"Actor部分的学习\"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p>\n<p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p>\n<p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p>\n<h3 id=\"actor延迟更新\"><a href=\"#actor延迟更新\" class=\"headerlink\" title=\"actor延迟更新\"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p>\n<p>为什么要这样做呢？</p>\n<p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p>\n<p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p>\n<h3 id=\"target网络噪声\"><a href=\"#target网络噪声\" class=\"headerlink\" title=\"target网络噪声\"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p>\n<p>为什么要这样呢？</p>\n<p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png\" alt=\"Q&#39;估算Q 1.png\"></p>\n<p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p>\n<p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png\" alt=\"Q&#39;估计Q 2.png\"></p>\n<p>这里注意三个地方：</p>\n<ol>\n<li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li>\n<li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li>\n<li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li>\n</ol>\n<h3 id=\"TD3-实现\"><a href=\"#TD3-实现\" class=\"headerlink\" title=\"TD3 实现\"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p>\n<h2 id=\"A3C\"><a href=\"#A3C\" class=\"headerlink\" title=\"A3C\"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p>\n<p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p>\n<p>由此诞生了A3C。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png\" alt=\"A3C.png\"></p>\n<p>注意几点：</p>\n<ol>\n<li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote>\n<p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p>\n</blockquote>\n</li>\n<li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png\" alt=\"A3C1.png\"></p>\n<h3 id=\"A3C-实现\"><a href=\"#A3C-实现\" class=\"headerlink\" title=\"A3C 实现\"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DPPO\"><a href=\"#DPPO\" class=\"headerlink\" title=\"DPPO\"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p>\n<p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p>\n<p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p>\n<h3 id=\"DPPO-实现\"><a href=\"#DPPO-实现\" class=\"headerlink\" title=\"DPPO 实现\"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p>\n</blockquote>\n<p>原文： <a href=\"https://zhuanlan.zhihu.com/p/111895463\">https://zhuanlan.zhihu.com/p/111895463</a></p>\n<p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p>\n<p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p>\n<blockquote>\n<p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p>\n</blockquote>\n<p>学习路线：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png\" alt=\"学习路线\"></p>\n<h2 id=\"马尔可夫树\"><a href=\"#马尔可夫树\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h2><p>强化学习的任务：</p>\n<ul>\n<li>我们希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li>\n<li>智能体学习和工作的地方，称为<strong>环境</strong>。</li>\n<li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li>\n</ul>\n<h3 id=\"经典马尔可夫链\"><a href=\"#经典马尔可夫链\" class=\"headerlink\" title=\"经典马尔可夫链\"></a>经典马尔可夫链</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png\" alt=\"马尔科夫链.png\"></p>\n<ul>\n<li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul>\n<li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li>\n</ul>\n</li>\n<li>动作(action)：智能体做出的具体行为。<ul>\n<li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。</li>\n</ul>\n</li>\n<li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul>\n<li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RL一般步骤\"><a href=\"#RL一般步骤\" class=\"headerlink\" title=\"RL一般步骤\"></a>RL一般步骤</h3><ol>\n<li>智能体在环境中，观察到状态(S)；</li>\n<li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li>\n<li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li>\n<li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li>\n</ol>\n<h3 id=\"马尔可夫树-1\"><a href=\"#马尔可夫树-1\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h3><p>马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png\" alt=\"马尔科夫树.png\"></p>\n<p>这种”不确定性”来自两个方面： </p>\n<ul>\n<li>智能体的行动选择(策略)。</li>\n<li>环境的不确定性。</li>\n</ul>\n<h2 id=\"RL中的Q值和V值\"><a href=\"#RL中的Q值和V值\" class=\"headerlink\" title=\"RL中的Q值和V值\"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p>\n<p>我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p>\n<ul>\n<li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li>\n<li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li>\n</ul>\n<p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p>\n<h3 id=\"V值的定义\"><a href=\"#V值的定义\" class=\"headerlink\" title=\"V值的定义\"></a>V值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"V值的定义.png\"></p>\n<p>假设现在需要求某状态S的V值，可以这样：</p>\n<ol>\n<li>从S点出发，并影分身出若干个自己;</li>\n<li>每个分身按照当前的策略 选择行为;</li>\n<li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li>\n<li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li>\n</ol>\n<p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p>\n<p><code>V值跟选择的策略有很大的关系</code> 。</p>\n<p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png\" alt=\"例子1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png\" alt=\"策略1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png\" alt=\"策略2.png\"></p>\n<p>可以看出不同的策略，计算出的V值是不一样的。</p>\n<h3 id=\"Q值的定义\"><a href=\"#Q值的定义\" class=\"headerlink\" title=\"Q值的定义\"></a>Q值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"Q值的定义.png\"></p>\n<p>现在需要计算，某个状态S0下的一个动作A的Q值： </p>\n<ol>\n<li>从A这个节点出发，使用影分身之术； </li>\n<li>每个影分身走到最终状态,并记录所获得的奖励； </li>\n<li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li>\n</ol>\n<p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p>\n<p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p>\n<h3 id=\"V值和Q值关系\"><a href=\"#V值和Q值关系\" class=\"headerlink\" title=\"V值和Q值关系\"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p>\n<h4 id=\"Q值转V值\"><a href=\"#Q值转V值\" class=\"headerlink\" title=\"Q值转V值\"></a>Q值转V值</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"Q值转V值.png\"></p>\n<p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p>\n<p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p>\n<p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png\" alt=\"Q值转V值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png\" alt=\"公式1.png\"></p>\n<p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p>\n<h4 id=\"V值转Q值\"><a href=\"#V值转Q值\" class=\"headerlink\" title=\"V值转Q值\"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png\" alt=\"V值转Q值.png\"></p>\n<p><code>当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png\" alt=\"V值转Q值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png\" alt=\"公式2.png\"></p>\n<blockquote>\n<p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。</p>\n</blockquote>\n<h3 id=\"V值转V值\"><a href=\"#V值转V值\" class=\"headerlink\" title=\"V值转V值\"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"V值转V值.png\"></p>\n<h2 id=\"MC\"><a href=\"#MC\" class=\"headerlink\" title=\"MC\"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p>\n<h3 id=\"蒙地卡罗算法\"><a href=\"#蒙地卡罗算法\" class=\"headerlink\" title=\"蒙地卡罗算法\"></a>蒙地卡罗算法</h3><ol>\n<li>把智能体放到环境的任意状态；</li>\n<li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li>\n<li>重复步骤2，直到最终状态；</li>\n<li>从最终状态开始向前回溯：计算每个状态的G值。</li>\n<li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li>\n</ol>\n<h3 id=\"G值的意义\"><a href=\"#G值的意义\" class=\"headerlink\" title=\"G值的意义\"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png\" alt=\"G值的意义.png\"></p>\n<ul>\n<li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li>\n<li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li>\n</ul>\n<p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p>\n<p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p>\n<p>理解：</p>\n<ol>\n<li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li>\n<li><code>V和G的关系：V是G的平均数。</code></li>\n</ol>\n<h3 id=\"V和策略相关\"><a href=\"#V和策略相关\" class=\"headerlink\" title=\"V和策略相关\"></a>V和策略相关</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png\" alt=\"策略3.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png\" alt=\"策略4.png\"></p>\n<p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p>\n<h3 id=\"蒙地卡罗算法的缺点\"><a href=\"#蒙地卡罗算法的缺点\" class=\"headerlink\" title=\"蒙地卡罗算法的缺点\"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p>\n<h3 id=\"MC的更新公式\"><a href=\"#MC的更新公式\" class=\"headerlink\" title=\"MC的更新公式\"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p>\n<p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p>\n<h4 id=\"增量更新\"><a href=\"#增量更新\" class=\"headerlink\" title=\"增量更新\"></a>增量更新</h4><p>现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p>\n<p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p>\n<ul>\n<li>V_old：原来的V值</li>\n<li>G：这一次回溯后，计算出来的G值</li>\n<li>N: 这个状态被经过多少次</li>\n<li>V_new：新计算出来的V值</li>\n</ul>\n<h4 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h4><p>这样计算还是比较麻烦，我们甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<code>学习率</code>。</p>\n<p>这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p>\n<p>这里的G，也称为V的更新目标。</p>\n<p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p>\n<h4 id=\"两种理解方式\"><a href=\"#两种理解方式\" class=\"headerlink\" title=\"两种理解方式\"></a>两种理解方式</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png\" alt=\"两种理解方式.png\"></p>\n<h2 id=\"TD\"><a href=\"#TD\" class=\"headerlink\" title=\"TD\"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p>\n<h3 id=\"TD和MC的比较\"><a href=\"#TD和MC的比较\" class=\"headerlink\" title=\"TD和MC的比较\"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p>\n<ol>\n<li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li>\n<li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li>\n<li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul>\n<li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. </li>\n<li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"直观理解\"><a href=\"#直观理解\" class=\"headerlink\" title=\"直观理解\"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p>\n<p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png\" alt=\"TD(0).png\"></p>\n<p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p>\n<h3 id=\"更新公式\"><a href=\"#更新公式\" class=\"headerlink\" title=\"更新公式\"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p>\n<p><code>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"更新公式.png\"></p>\n<h2 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"TD(0)更新公式.png\"></p>\n<p>图解：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png\" alt=\"TD(0)图解.png\"></p>\n<p>TD能够用在V值，那么也能用在计算Q值上。</p>\n<h3 id=\"TD之于Q值估算\"><a href=\"#TD之于Q值估算\" class=\"headerlink\" title=\"TD之于Q值估算\"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png\" alt=\"用TD估计Q值.png\"></p>\n<ul>\n<li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li>\n<li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li>\n</ul>\n<p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png\" alt=\"用下一个动作的Q代替V.png\"></p>\n<p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p>\n<p>因为<code>马尔可夫树!</code><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png\" alt=\"坑的解释.png\"></p>\n<p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p>\n<p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p>\n<ol>\n<li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li>\n<li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li>\n</ol>\n<h3 id=\"SARSA\"><a href=\"#SARSA\" class=\"headerlink\" title=\"SARSA\"></a>SARSA</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png\" alt=\"SARSA.png\"></p>\n<p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png\" alt=\"TD(0)与SARSA对比.png\"></p>\n<p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p>\n<h3 id=\"Qlearning\"><a href=\"#Qlearning\" class=\"headerlink\" title=\"Qlearning\"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png\" alt=\"Qlearning图解.png\"></p>\n<p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png\" alt=\"Qlearning公式.png\"></p>\n<p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"></p>\n<p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li>\n<li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li>\n<li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li>\n<li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul>\n<li>SARSA 选择的是在St同一个策略产生的动作。 </li>\n<li>Qlearning 选择的是能够产生最大的Q值的动作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Qlearning-实现\"><a href=\"#Qlearning-实现\" class=\"headerlink\" title=\"Qlearning 实现\"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"深度神经网络\"><a href=\"#深度神经网络\" class=\"headerlink\" title=\"深度神经网络\"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p>\n<p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png\" alt=\"Magic(X).png\"></p>\n<p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p>\n<p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p>\n<p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p>\n<p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p>\n<p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p>\n<p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p>\n<p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png\" alt=\"Magic&#39;(X).png\"></p>\n<h4 id=\"放大镜下的深度神经网络\"><a href=\"#放大镜下的深度神经网络\" class=\"headerlink\" title=\"放大镜下的深度神经网络\"></a>放大镜下的深度神经网络</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png\" alt=\"数据加工厂.png\"></p>\n<p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p>\n<p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p>\n<p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p>\n<p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p>\n<p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p>\n<p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p>\n<p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p>\n<p>但产品y’是否是一个合格的产品，我们还需要我们真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p>\n<p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p>\n<p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p>\n<h2 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h2><blockquote>\n<p><code>DQN: TD + 神经网络</code></p>\n</blockquote>\n<p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p>\n<p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p>\n<p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p>\n<p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p>\n<p><code>Deep network + Qlearning = DQN</code></p>\n<p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p>\n<h3 id=\"理解DQN中的神经网络\"><a href=\"#理解DQN中的神经网络\" class=\"headerlink\" title=\"理解DQN中的神经网络\"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png\" alt=\"Qtable三维可视化.png\"></p>\n<p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p>\n<p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png\" alt=\"扭曲的曲线.png\"></p>\n<p>从二维状态看：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png\" alt=\"二维曲线.png\"></p>\n<p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p>\n<p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p>\n<h3 id=\"更新目标\"><a href=\"#更新目标\" class=\"headerlink\" title=\"更新目标\"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p>\n<p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p>\n<p>DQN和Qlearning一样：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png\" alt=\"DQN.png\"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p>\n<ol>\n<li>执行A，往前一步，到达St+1; </li>\n<li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li>\n<li>获得最大的Q值加上奖励R作为更新目标； </li>\n<li>计算损失 <ul>\n<li>Q(S,A)相当于有监督学习中的logits</li>\n<li>maxQ(St+1) + R 相当于有监督学习中的lables </li>\n<li>用mse函数，得出两者的loss </li>\n<li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li>\n</ul>\n</li>\n<li>用loss更新Q网络。(反向传播)</li>\n</ol>\n<blockquote>\n<p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p>\n</blockquote>\n<p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png\" alt=\"DQN公式.png\"></p>\n<p>总结：</p>\n<ol>\n<li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li>\n<li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li>\n<li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li>\n</ol>\n<h3 id=\"DQN-实现\"><a href=\"#DQN-实现\" class=\"headerlink\" title=\"DQN 实现\"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Double-DQN\"><a href=\"#Double-DQN\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h2><h3 id=\"经验回放\"><a href=\"#经验回放\" class=\"headerlink\" title=\"经验回放\"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p>\n<p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p>\n<p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p>\n<p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p>\n<h3 id=\"DQN的问题\"><a href=\"#DQN的问题\" class=\"headerlink\" title=\"DQN的问题\"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p>\n<p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p>\n<p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p>\n<h3 id=\"Fixed-Q-targets\"><a href=\"#Fixed-Q-targets\" class=\"headerlink\" title=\"Fixed Q-targets\"></a>Fixed Q-targets</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png\" alt=\"fix-Q-targets.png\"></p>\n<p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p>\n<ul>\n<li>原来的Q网络，用于估算Q(s);</li>\n<li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul>\n<li><code>y = r + gamma * max(targetQ(s&#39;))</code></li>\n<li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Double-DQN-1\"><a href=\"#Double-DQN-1\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p>\n<p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p>\n<p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p>\n<h3 id=\"Double-DQN-实现\"><a href=\"#Double-DQN-实现\" class=\"headerlink\" title=\"Double DQN 实现\"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Duel-DQN\"><a href=\"#Duel-DQN\" class=\"headerlink\" title=\"Duel DQN\"></a>Duel DQN</h2><h3 id=\"Dueling-DQN原理\"><a href=\"#Dueling-DQN原理\" class=\"headerlink\" title=\"Dueling DQN原理\"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p>\n<ul>\n<li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li>\n<li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li>\n</ul>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png\" alt=\"Q=S+A表格.png\"></p>\n<p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png\" alt=\"普通DQN.png\"></p>\n<p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p>\n<p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png\" alt=\"DuelDQN.png\"></p>\n<p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p>\n<blockquote>\n<p>这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。</p>\n</blockquote>\n<h3 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png\" alt=\"DuelDQN网络架构.png\"></p>\n<p>可以把dueling DQN分为三部分：</p>\n<ul>\n<li>第一部分：和普通DQN一样，用来处理和学习数据。</li>\n<li>第二部分：计算svalue，就是让网络预估的平均值。</li>\n<li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul>\n<li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li>\n</ul>\n</li>\n</ul>\n<p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p>\n<h3 id=\"Duel-DQN-实现\"><a href=\"#Duel-DQN-实现\" class=\"headerlink\" title=\"Duel DQN 实现\"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>策略梯度(Policy Gradient)</p>\n<p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。</p>\n<p>这就是<code>策略梯度(Policy Gradient)</code></p>\n<h3 id=\"PG原理\"><a href=\"#PG原理\" class=\"headerlink\" title=\"PG原理\"></a>PG原理</h3><p>认识到：</p>\n<blockquote>\n<p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p>\n</blockquote>\n<p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p>\n<p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png\" alt=\"复习MC.png\"></p>\n<h3 id=\"直观感受PG\"><a href=\"#直观感受PG\" class=\"headerlink\" title=\"直观感受PG\"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png\" alt=\"直观感受PG1.png\"></p>\n<p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png\" alt=\"直观感受PG2.png\"></p>\n<p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png\" alt=\"直观感受PG3.png\"></p>\n<p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p>\n<h3 id=\"PG-实现\"><a href=\"#PG-实现\" class=\"headerlink\" title=\"PG 实现\"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"AC\"><a href=\"#AC\" class=\"headerlink\" title=\"AC\"></a>AC</h2><blockquote>\n<p><code>AC: PG + DQN(TD + 神经网络)</code></p>\n</blockquote>\n<p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p>\n<p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。</p>\n<p>也就是说，Actor-Critic，其实是用了两个网络：</p>\n<p>两网络都输入状态S，Critic比Actor多一个St+1: </p>\n<ul>\n<li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li>\n<li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li>\n</ul>\n<h3 id=\"TD-error\"><a href=\"#TD-error\" class=\"headerlink\" title=\"TD-error\"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png\" alt=\"为什么不估算Q.png\"></p>\n<p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p>\n<p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p>\n<p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png\" alt=\"TD-error.png\"></p>\n<p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p>\n<p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p>\n<p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li>\n<li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以我们得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li>\n<li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li>\n<li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li>\n</ol>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ol>\n<li>定义两个network：Actor 和 Critic</li>\n<li>进行N次更新。<ol>\n<li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li>\n<li>记录的数据。</li>\n<li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li>\n<li>把输入到Actor，计算策略分布。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png\" alt=\"AC算法.png\"></p>\n<p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p>\n<h3 id=\"AC-实现\"><a href=\"#AC-实现\" class=\"headerlink\" title=\"AC 实现\"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PPO\"><a href=\"#PPO\" class=\"headerlink\" title=\"PPO\"></a>PPO</h2><p>PPO是基于AC框架的</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p>\n<ul>\n<li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li>\n<li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li>\n</ul>\n<p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png\" alt=\"离散动作-策略分布.png\"></p>\n<p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"连续型概率分布示意图.png\"></p>\n<p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; （action）代表在策略下，选择某个action的概率P。</p>\n<p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p>\n<p>这样，只用两个参数就可以表示了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png\" alt=\"正态分布.png\"></p>\n<p>正态分布：</p>\n<ul>\n<li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li>\n<li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li>\n</ul>\n<p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p>\n<h3 id=\"AC的问题\"><a href=\"#AC的问题\" class=\"headerlink\" title=\"AC的问题\"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p>\n<ul>\n<li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p>\n</li>\n<li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p>\n</li>\n<li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p>\n<ul>\n<li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li>\n<li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li>\n</ul>\n</li>\n<li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p>\n<ul>\n<li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li>\n<li>无需环境互动：训练过程中不需要实时环境反馈。</li>\n</ul>\n</li>\n</ul>\n<p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p>\n<p>例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p>\n<p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p>\n<p>看一个例子：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png\" alt=\"策略P和策略B.png\"></p>\n<blockquote>\n<p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p>\n</blockquote>\n<p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p>\n<p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p>\n<p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p>\n<p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"策略P和策略B更新示意图.png\"></p>\n<p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p>\n<p><strong>为什么DQN可以多次重复使用数据？</strong></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png\" alt=\"DQN更新的是Q值.png\"></p>\n<p>两个角度：</p>\n<ul>\n<li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li>\n<li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li>\n</ul>\n<blockquote>\n<p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。</p>\n</blockquote>\n<h3 id=\"重要性采样技术\"><a href=\"#重要性采样技术\" class=\"headerlink\" title=\"重要性采样技术\"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p>\n<p>在这里<code>IW = P（a）/ B（a）</code></p>\n<p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p>\n<ul>\n<li>目标策略：要更新的策略。</li>\n<li>行为策略：数据的策略。</li>\n</ul>\n<p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png\" alt=\"重要性权重表格.png\"></p>\n<p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p>\n<p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p>\n<h3 id=\"N步更新\"><a href=\"#N步更新\" class=\"headerlink\" title=\"N步更新\"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png\" alt=\"TD(N).png\"></p>\n<p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p>\n<p><code>V = R + gamma * V(s&#39;)</code></p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p>\n<ol>\n<li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li>\n<li>PPO延展了TD(0)，变成TD(N)的N步更新； </li>\n<li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li>\n</ol>\n<h3 id=\"PPO-实现\"><a href=\"#PPO-实现\" class=\"headerlink\" title=\"PPO 实现\"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DDPG\"><a href=\"#DDPG\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p>\n<ul>\n<li>deep: 深度网络。</li>\n<li>policy gradient: PG</li>\n<li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li>\n</ul>\n<p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p>\n<h3 id=\"回顾DQN\"><a href=\"#回顾DQN\" class=\"headerlink\" title=\"回顾DQN\"></a>回顾DQN</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png\" alt=\"回顾DQN.png\"></p>\n<p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。</p>\n<h3 id=\"理解DDPG\"><a href=\"#理解DDPG\" class=\"headerlink\" title=\"理解DDPG\"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"></p>\n<p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<blockquote>\n<p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p>\n</blockquote>\n<p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p>\n<h3 id=\"DDPG-1\"><a href=\"#DDPG-1\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png\" alt=\"DDPG1.png\"></p>\n<p>整理下：</p>\n<h4 id=\"Critic\"><a href=\"#Critic\" class=\"headerlink\" title=\"Critic\"></a>Critic</h4><ol>\n<li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li>\n<li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li>\n<li>Critic网络的loss其还是和AC一样，用的是TD-error。</li>\n</ol>\n<h4 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h4><ol>\n<li>和AC不同，Actor输出的是一个动作；</li>\n<li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li>\n<li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li>\n</ol>\n<p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p>\n<p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<blockquote>\n<p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p>\n</blockquote>\n<h3 id=\"DDPG-实现\"><a href=\"#DDPG-实现\" class=\"headerlink\" title=\"DDPG 实现\"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"TD3\"><a href=\"#TD3\" class=\"headerlink\" title=\"TD3\"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p>\n<p>TD3是对DDPG的优化，三个重要优化。</p>\n<h3 id=\"double-network\"><a href=\"#double-network\" class=\"headerlink\" title=\"double network\"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p>\n<p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p>\n<p>回顾DDPG：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p>\n<p>TD3需要用到6个网络：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png\" alt=\"TD3.png\"></p>\n<p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p>\n<h4 id=\"Critic部分的学习\"><a href=\"#Critic部分的学习\" class=\"headerlink\" title=\"Critic部分的学习\"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p>\n<p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p>\n<p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p>\n<p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p>\n<p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p>\n<p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p>\n<h4 id=\"Actor部分的学习\"><a href=\"#Actor部分的学习\" class=\"headerlink\" title=\"Actor部分的学习\"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p>\n<p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p>\n<p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p>\n<h3 id=\"actor延迟更新\"><a href=\"#actor延迟更新\" class=\"headerlink\" title=\"actor延迟更新\"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p>\n<p>为什么要这样做呢？</p>\n<p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p>\n<p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p>\n<h3 id=\"target网络噪声\"><a href=\"#target网络噪声\" class=\"headerlink\" title=\"target网络噪声\"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p>\n<p>为什么要这样呢？</p>\n<p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png\" alt=\"Q&#39;估算Q 1.png\"></p>\n<p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p>\n<p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png\" alt=\"Q&#39;估计Q 2.png\"></p>\n<p>这里注意三个地方：</p>\n<ol>\n<li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li>\n<li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li>\n<li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li>\n</ol>\n<h3 id=\"TD3-实现\"><a href=\"#TD3-实现\" class=\"headerlink\" title=\"TD3 实现\"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p>\n<h2 id=\"A3C\"><a href=\"#A3C\" class=\"headerlink\" title=\"A3C\"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p>\n<p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p>\n<p>由此诞生了A3C。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png\" alt=\"A3C.png\"></p>\n<p>注意几点：</p>\n<ol>\n<li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote>\n<p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p>\n</blockquote>\n</li>\n<li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png\" alt=\"A3C1.png\"></p>\n<h3 id=\"A3C-实现\"><a href=\"#A3C-实现\" class=\"headerlink\" title=\"A3C 实现\"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DPPO\"><a href=\"#DPPO\" class=\"headerlink\" title=\"DPPO\"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p>\n<p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p>\n<p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p>\n<h3 id=\"DPPO-实现\"><a href=\"#DPPO-实现\" class=\"headerlink\" title=\"DPPO 实现\"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>\n"},{"title":"数据库","keywords":["面经"],"description":"数据库面经","abbrlink":17769,"date":"2024-06-12T14:47:36.000Z","updated":"2024-06-22T10:28:16.000Z","top_img":"https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png","comments":1,"cover":"https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## SQL/NoSQL基础\n\n### 什么是SQL\nSQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。\n\n### DB/DBMS/DBS/DBA\n- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。\n- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。\n- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。\n\n\n### 数据库术语\n- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。\n- 数据表(`table`)：某种特定类型数据的结构化清单。\n- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。\n- 行(`row`)：表中的一个记录。\n- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。\n\n### 元组/码/候选码/主码/外码/主属性/非主属性概念\n- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。\n- 码：码就是能唯一标识实体的属性，对应表中的列。\n- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。\n- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n### ER图\nER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：\n- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。\n- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。\n- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。\n\n### 数据库三范式\n数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：\n- 1NF(第一范式)：属性不可再分。\n  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。\n- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。\n- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。\n  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。\n\n> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。\n>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；\n> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。\n>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；\n> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。\n> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**\n>   - 例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\n\n### 主键/外键区别\n主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n### 为什么不推荐使用外键和级联操作\n以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**\n\n- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；\n- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；\n- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。\n\n**外键好处**\n- 保证了数据库数据的一致性和完整性；\n- 级联操作方便，减轻了程序代码量；\n\n### 存储过程\n可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。\n\n存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n\n### DROP/TRUNCATE/DELETE区别\n1. 用法不同\n- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。\n- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\n- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。\n\n`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。\n\n2. 属于不同的数据库语言\n- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。\n\n3. 执行速度不同：`DROP > TRUNCATE > DELETE`。\n- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。\n- `DROP`命令会把表占用的空间全部释放掉。\n\n### 数据库设计分为哪几个步\n1. 需求分析：分析用户的需求，包括数据、功能和性能需求。\n2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。\n3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。\n5. 数据库实施：包括编程、测试和试运行\n6. 数据库的运行和维护：系统的运行与数据库的日常维护。\n\n### 什么是NoSQL\n`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\n一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。\n\n> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。\n\n### SQL/NoSQL区别\n\n|         | SQL 数据库                                      | NoSQL 数据库                                                                                |\n|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|\n| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |\n| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |\n| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |\n| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |\n| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |\n| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |\n| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |\n| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |\n\n### NoSQL优劣\n**优点**\n- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。\n- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。\n- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。\n\n**缺点**\n- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。\n- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。\n\n### NoSQL分类\n- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。\n- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。\n- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。\n- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。\n\n### 数据库分类\n`DDL/DML/DCL/TCL`\n- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。\n- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。\n- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### SQL三种注释方式\n- 单行注释：`-- 注释内容` 或 `# 注释内容`。\n- 多行注释：`/* 注释内容 */`。\n- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。\n\n### DML语句✅\n`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n\n### 增删改查CRUD\n增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n\n**插入数据**\n`INSERT INTO` 语句用于向表中插入新记录。\n\n```sql\n-- 插入完整的行\n-- 插入一行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com');\n-- 插入多行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');\n\n-- 插入行的一部分\nINSERT INTO user(username, password, email)\nVALUES ('admin', 'admin', 'xxxx@163.com');\n\n-- 插入查询出来的数据\nINSERT INTO user(username)\nSELECT name\nFROM account;\n```\n\n**更新数据**\n`UPDATE` 语句用于更新表中的记录。\n\n```sql\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n```\n\n**删除数据**\n- `DELETE` 语句用于删除表中的记录。\n- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。\n\n```sql\n-- 删除表中的指定数据\nDELETE FROM user\nWHERE username = 'robot';\n\n-- 清空表中的数据\nTRUNCATE TABLE user;\n```\n\n**查询数据**\n- `SELECT` 语句用于从数据库中查询数据。\n- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n- `ASC`：升序(默认)\n- `DESC`：降序\n\n```sql\n-- 查询单列\nSELECT prod_name\nFROM products;\n\n-- 查询多列\nSELECT prod_id, prod_name, prod_price\nFROM products;\n\n-- 查询所有列\nSELECT *\nFROM products;\n\n-- 查询不同的值\nSELECT DISTINCT\nvend_id FROM products;\n\n-- 限制查询结果\n-- 返回前 5 行\nSELECT * FROM mytable LIMIT 5;\nSELECT * FROM mytable LIMIT 0, 5;\n-- 返回第 3 ~ 5 行\nSELECT * FROM mytable LIMIT 2, 3;\n```\n\n### 排序\n- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。\n- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。\n\n```sql\nSELECT * FROM products\nORDER BY prod_price DESC, prod_name ASC;\n```\n\n### 分组\n**`GROUP BY`**：\n\n- `GROUP BY` 子句将记录分组到汇总行中。\n- `GROUP BY` 为每个组返回一个记录。\n- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。\n- `GROUP BY` 可以按一列或多列进行分组。\n- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。\n\n```sql\n-- 分组\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name;\n\n-- 分组后排序\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name\nORDER BY cust_name DESC;\n```\n\n### HAVING\n\n- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。\n- `HAVING` 一般都是和 `GROUP BY` 连用。\n- `WHERE` 和 `HAVING` 可以在相同的查询中。\n\n```sql\n-- 使用 WHERE 和 HAVING 过滤数据\nSELECT cust_name, COUNT(*) AS NumberOfOrders\nFROM Customers\nWHERE cust_email IS NOT NULL\nGROUP BY cust_name\nHAVING COUNT(*) > 1;\n```\n\n### WHERE/HAVING对比\n- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。\n- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。\n\n### 子查询\nMYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)\n\n子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。\n\n子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。\n\n子查询常用在 `WHERE` 子句和 `FROM` 子句后边：\n- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。\n```sql\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  column_name operator\n    (SELECT column_name [, column_name ]\n    FROM table1 [, table2 ]\n    [WHERE])\n```\n- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。\n```sql\nSELECT column_name [, column_name ]\nFROM (SELECT column_name [, column_name ]\n      FROM table1 [, table2 ]\n      [WHERE]) as temp_table_name\nWHERE  condition\n```\n\n**子查询的子查询**\n首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。\n```sql\nSELECT cust_name, cust_contact\nFROM customers\nWHERE cust_id IN (SELECT cust_id\n                  FROM orders\n                  WHERE order_num IN (SELECT order_num\n                                      FROM orderitems\n                                      WHERE prod_id = 'RGAN01'));\n```\n\n### WHERE\n- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。\n- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。\n- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。\n```sql\n-- SELECT语句中的WHERE\nSELECT * FROM Customers\nWHERE cust_name = 'Kids Place';\n\n-- UPDATE语句中的WHERE\nUPDATE Customers\nSET cust_name = 'Jack Jones'\nWHERE cust_name = 'Kids Place';\n\n-- DELETE语句中的WHERE\nDELETE FROM Customers\nWHERE cust_name = 'Kids Place';\n```\n- 可以在 `WHERE` 子句中使用的操作符。\n| 运算符       | 描述                                |\n|-----------|-----------------------------------|\n| `=`       | 等于                                |\n| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |\n| `>`       | 大于                                |\n| `<`       | 小于                                |\n| `>=`      | 大于等于                              |\n| `<=`      | 小于等于                              |\n| `BETWEEN` | 在某个范围内                            |\n| `LIKE`    | 搜索某种模式                            |\n| `IN`      | 指定针对某个列的多个可能值                     |\n\n### IN/BETWEEN\n- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。\n- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。\n\n```sql\n-- IN示例\nSELECT *\nFROM products\nWHERE vend_id IN ('DLL01', 'BRS01');\n\n-- BETWEEN示例\nSELECT *\nFROM products\nWHERE prod_price BETWEEN 3 AND 5;\n```\n\n### AND/OR/NOT\n- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。\n- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。\n- `AND` 操作符表示左右条件都要满足。\n- `OR` 操作符表示左右条件满足任意一个即可。\n- `NOT` 操作符用于否定一个条件。\n\n```sql\n-- AND示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' AND prod_price <= 4;\n\n-- OR示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' OR vend_id = 'BRS01';\n\n-- NOT示例\nSELECT *\nFROM products\nWHERE prod_price NOT BETWEEN 3 AND 5;\n```\n\n### LIKE\n- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。\n- 只有字段是文本值时才使用 `LIKE`。\n- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。\n- 不要滥用通配符，通配符位于开头处匹配会非常慢。\n- `%` 表示任何字符出现任意次数。\n- `_` 表示任何字符出现一次。\n\n```sql\n-- %示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '%bean bag%';\n\n-- _示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '__ inch teddy bear';\n```\n\n### 连接JOIN\n`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。\n\n语法：\n```sql\nSELECT table1.column1, table2.column2...\nFROM table1\nJOIN table2\nON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not\n```\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n\n如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。\n```sql\n# JOIN....ON\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nON c.cust_id = o.cust_id\n-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()\n-- using(cust_id) 代替 ON c.cust_id = o.cust_id\nORDER BY c.cust_name;\n```\n\n### 内连接/外连接\n- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。\n- `外连接`：\n  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。\n  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。\n  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。\n\n\n```sql\n/* \nstudent表\nstudent_id\tname\n1\t        Alice\n2\t        Bob\n3\t        Carol\n\ncourses表\ncourse_id\tstudent_id\tcourse_name\n101\t        1\t        Math\n102\t        2\t        Science\n103\t        4\t        History\n*/\n\n-- 内连接\nSELECT students.name, courses.course_name\nFROM students\nINNER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\n*/\n\n-- 左外连接\nSELECT students.name, courses.course_name\nFROM students\nLEFT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\n*/\n\n-- 右外连接\nSELECT students.name, courses.course_name\nFROM students\nRIGHT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nNULL\tHistory\n*/\n\n-- 全外连接\nSELECT students.name, courses.course_name\nFROM students\nFULL OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\nNULL\tHistory\n*/\n```\n\n### ON/WHERE区别\n- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。\n- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。\n\n### 组合UNION\n`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。\n\n`UNION` 基本规则：\n- 所有查询的列数和列顺序必须相同。\n- 每个查询中涉及表的列的数据类型必须相同或兼容。\n- 通常返回的列名取自第一个查询。\n- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。\n\n```sql\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n```\n\n### DDL语言✅\n`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n\n### 数据库DATABSE\n- 创建数据库：`CREATE DATABASE 数据库名;`\n- 删除数据库：`DROP DATABASE 数据库名;`\n- 选择数据库：`USE 数据库名;`\n- 查看数据库：`SHOW DATABASES;`\n\n### 数据表TABLE\n```sql\n-- 普通创建\nCREATE TABLE user (\nid int(10) unsigned NOT NULL COMMENT 'Id',\nusername varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',\npassword varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',\nemail varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'\n) COMMENT='用户表';\n\n-- 根据已有表创建\nCREATE TABLE vip_user AS\nSELECT * FROM user;\n\n-- 删除表\nDROP TABLE user;\n\n-- 查看表\nSHOW TABLES;\n\n-- 添加列\nALTER TABLE user -- ALTER用于修改表\nADD age int(3);\n\n-- 删除列\nALTER TABLE user\nDROP COLUMN age;\n\n-- 修改列\nALTER TABLE `user`\nMODIFY COLUMN age tinyint;\n\n-- 添加主键\nALTER TABLE user\nADD PRIMARY KEY (id);\n\n-- 删除主键\nALTER TABLE user\nDROP PRIMARY KEY;\n```\n\n### 视图VIEW\n在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。\n\n作用：\n- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。\n- 提高数据安全性：用来限制用户访问敏感数据。\n- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。\n- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。\n\n```sql\n-- 创建视图\nCREATE VIEW top_10_user_view AS\nSELECT id, username\nFROM user\nWHERE id < 10;\n\n-- 删除视图\nDROP VIEW top_10_user_view;\n```\n\n### 索引INDEX\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n**优点**\n- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n```sql\n-- 创建索引\nCREATE INDEX user_index\nON user (id);\n\n-- 添加索引\nALTER table user ADD INDEX user_index(id)\n\n-- 创建唯一索引\nCREATE UNIQUE INDEX user_index\nON user (id);\n\n-- 删除索引\nALTER TABLE user\nDROP INDEX user_index;\n```\n\n### 约束\nSQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。\n\n**约束类型**\n- `NOT NULL`：指示某列不能存储 `NULL` 值。\n- `UNIQUE`：保证某列的每行必须有唯一的值。\n- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。\n- `CHECK`：保证列中的值符合指定的条件。\n- `DEFAULT`：规定没有给列赋值时的默认值。\n\n```sql\nCREATE TABLE Users (\n  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',\n  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',\n  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',\n  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',\n  PRIMARY KEY (Id)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n```\n\n\n### TCL语句✅\n`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n\n### 事务TRANSACTION\n事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。\n\n**事务的四个特性(ACID)**\n- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- `一致性(Consistency)`：执行事务前后，数据保持一致。\n- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。\n\n> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。\n\n```sql\n-- 开始事务\nSTART TRANSACTION;\n\n-- 插入操作 A\nINSERT INTO `user`\nVALUES (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updateA\nSAVEPOINT updateA;\n\n-- 插入操作 B\nINSERT INTO `user`\nVALUES (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updateA\nROLLBACK TO updateA;\n\n-- 提交事务，只有操作 A 生效\nCOMMIT;\n```\n\n### DCL语句✅\n`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### 权限管理\n- 授予用户帐户权限，用`GRANT`命令。\n  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。\n  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。\n  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。\n  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。\n  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。\n- 撤销用户的权限，用`REVOKE`命令。\n  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。\n  - 指定在 `ON` 子句中撤销特权的特权级别。\n  - 指定要撤消 `FROM` 子句中的权限的用户帐户。\n\n`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：\n- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；\n- 整个数据库，使用 `ON database.*`；\n- 特定的表，使用 `ON database.table`；\n- 特定的列；\n- 特定的存储过程。\n\n```sql\n-- GRANT用法\nGRANT privilege,[privilege],.. ON privilege_level\nTO user [IDENTIFIED BY password]\n[REQUIRE tsl_option]\n[WITH [GRANT_OPTION | resource_option]];\n\n-- REVOKE用法\nREVOKE privilege_type [(column_list)]\n       [, priv_type [(column_list)]]...\nON [object_type] privilege_level\nFROM user [, user]...\n\n-- 创建账户\nCREATE USER myuser IDENTIFIED BY 'mypassword';\n-- 修改账户名\nUPDATE user SET user='newuser' WHERE user='myuser';\nFLUSH PRIVILEGES;\n-- 删除账户\nDROP USER myuser;\n-- 查看权限\nSHOW GRANTS FOR myuser;\n-- 授予权限\nGRANT SELECT, INSERT ON *.* TO myuser;\n-- 删除权限\nREVOKE SELECT, INSERT ON *.* FROM myuser;\n-- 更改密码\nSET PASSWORD FOR myuser = 'mypass';\n```\n\n### 游标CURSOR\n游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。\n\n### 触发器TRIGGER\n触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。\n\n**优点**\n- SQL 触发器提供了另一种检查数据完整性的方法。\n- SQL 触发器可以捕获数据库层中业务逻辑中的错误。\n- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。\n- SQL 触发器对于审计表中数据的更改非常有用。\n\n**缺点**\n- SQL 触发器可能会增加数据库服务器的开销。\n- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。\n\n在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。\n- `BEFORE INSERT`：在将数据插入表格之前激活。\n- `AFTER INSERT`：将数据插入表格后激活。\n- `BEFORE UPDATE`：在更新表中的数据之前激活。\n- `AFTER UPDATE`：更新表中的数据后激活。\n- `BEFORE DELETE`：在从表中删除数据之前激活。\n- `AFTER DELETE`：从表中删除数据后激活。\n\n`NEW` 和 `OLD`：\n- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；\n- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；\n- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；\n- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)\n\n### 触发器语法\n\n```sql\n-- 创建触发器\nCREATE TRIGGER trigger_name\ntrigger_time\ntrigger_event\nON table_name\nFOR EACH ROW\nBEGIN\ntrigger_statements\nEND;\n```\n\n说明：\n- `trigger_name`：触发器名\n- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。\n- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。\n- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。\n- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。\n- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。\n\n当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。\n\n```sql\n-- 创建触发器\nDELIMITER $\nCREATE TRIGGER `trigger_insert_user`\nAFTER INSERT ON `user`\nFOR EACH ROW\nBEGIN\n    INSERT INTO `user_history`(user_id, operate_type, operate_time)\n    VALUES (NEW.id, 'add a user',  now());\nEND $\nDELIMITER ;\n\n-- 查看触发器\nSHOW TRIGGERS;\n\n-- 删除触发器\nDROP TRIGGER trigger_insert_user;\n```\n\n## MySQL\nMySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是`3306`。\n\n### MySQL基础✅\n\n### MySQL优点\n- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。\n- 开箱即用，操作简单，维护成本低。\n- 兼容性好，支持常见的操作系统，支持多种开发语言。\n- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。\n- 支持分库分表、读写分离、高可用。\n\n### 什么是关系型数据库\n关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。\n\n大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……\n\n### MySQL字段类型\n简单分为三大类：数值类型、字符串类型、日期和时间类型。\n- 数值类型：\n  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。\n  - 浮点型：`FLOAT`、`DOUBLE`。\n  - 定点数：`DECIMAL`。\n- 字符串类型：\n  - 常用：`CHAR`、`VARCHAR`、`TEXT`。\n  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。\n- 日期和时间类型：\n  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。\n\n### 整数类型的UNSIGNED属性\n整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。\n\n> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。\n> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。\n\n对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。\n\n### CHAR/VARCHAR区别\n- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。\n- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。\n- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。\n- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。\n\n### VARCHAR(100)/VARCHAR(10)区别\n- 前者最大长度为 100，后者最大长度为 10。\n- 二者存储相同的字符串所占用的存储空间是一样的。\n- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。\n\n### DECIMAL和FLOAT/DOUBLE区别\n`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。\n\n### 为什么没不推荐使用TEXT/BLOB类型\n- `TEXT`用于存储长文本数据，如博客数据。\n- `BLOB`用于存储二进制大对象，例如图片、音视频等文件。\n\n这两种类型有如下缺陷：\n- 不能有默认值。\n- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。\n- 检索效率较低。\n- 不能直接创建索引，需要指定前缀长度。\n- 可能会消耗大量的网络和 IO 带宽。\n- 可能导致表上的 DML 操作变慢。\n\n### DATETIME/TIMESTAMP区别\n- `DATETIME`没有时区信息，`TIMESTAMP` 和时区有关。\n- `TIMESTAMP` 只需要使用 4 个字节的存储空间，但是 `DATETIME` 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，`TIMESTAMP` 表示的时间范围更小。\n  - `DATETIME`：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n  - `TIMESTAMP`：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC\n- `TIMESTAMP` 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。\n\n### NULL和''区别\n- `NULL` 表示未知的值，`''` 表示空字符串。\n  - `SELECT NULL=NULL`的结果为 `false`，但在使用`DISTINCT`,`GROUP BY`,`ORDER BY`时又认为`NULL`是相等的。\n- `''`长度为0，不占用空间，`NULL`占用空间。\n- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 `=`、`!=`、 `<`、`>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。\n- `NULL` 会影响聚合函数的结果。\n  - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。`COUNT` 的处理方式取决于参数的类型。如果参数是 `*(COUNT(*))`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名`(COUNT(列名))`，则会忽略 `NULL` 值，只统计非空值的个数。\n\n不推荐使用`NULL`作为列默认值。\n\n### Boolean类型如何在MySQL中存储\nMySQL 中没有布尔类型，可以使用 `TINYINT` 类型来存储布尔值。`TINYINT(1)` 可以存储 0 或 1，分别表示 `false` 和 `true`。\n\n### MySQL基础架构✅\n\nMySQL 基础架构主要分为 Server 层和存储引擎层：\n- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。\n- 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 `InnoDB`、`MyISAM`、`Memory` 等多个存储引擎，其中 `InnoDB` 引擎有自有的日志模块 `redolog` 模块。现在最常用的存储引擎是 `InnoDB`，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。\n\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\n- 连接器：身份认证和权限相关(登录 MySQL 的时候)。\n- 查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。\n- 分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\n- 优化器：按照 MySQL 认为最优的方案去执行。\n- 执行器：执行语句，然后从存储引擎返回数据。\n- 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。\n\n1. 连接器。\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。\n\n2. 查询缓存(MySQL 8.0 版本后移除)。\n主要用来缓存所执行的 `SELECT` 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 `Key-Value` 的形式缓存在内存中，`Key` 是查询语句，`Value` 是结果集。如果缓存 `Key` 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\n\n3. 分析器。\nMySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：\n   - 第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 SELECT，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\n   - 第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\n\n4. 优化器。\n优化器以它认为的最优的执行方案去执行(有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解)，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\n\n5. 执行器。\n当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\n\n### SQL语句在MySQL中的执行过程\n\n**查询语句**\n查询语句的执行流程如下：权限校验(如果命中缓存)--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\n```sql\nSELECT * FROM tb_student  A WHERE A.age='18' AND A.name='张三';\n```\n1. 检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 `key` 在内存中查询是否有结果，如果有直接返回，如果没有，执行下一步。\n2. 通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询`SELECT`，提取需要查询的表名为 `tb_student`，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\n3. 优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：\n   - a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n   - b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。\n4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\n\n**更新语句(增加，修改，删除)**\n更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---`redo log`(`prepare` 状态)--->`binlog`--->`redo log`(`commit` 状态)\n```sql\nUPDATE tb_student A SET A.age='19' WHERE A.name=' 张三 ';\n```\nMySQL自带的日志模块是 `binlog`，以 `InnoDB` 作为存储引擎介绍，其自带了一个`redo log` 日志模块，用来保证数据的一致性的。\n1. 先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。\n2. 拿到查询的语句，把 `age` 改为 19，然后调用引擎 API 接口，写入这一行数据，`InnoDB` 引擎把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，执行完成了，随时可以提交。\n3. 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log` 为提交状态。\n4. 更新完成。\n\n### MySQL存储引擎✅\n\n### MySQL支持哪些存储引擎？\nMySQL 支持多种存储引擎，常见的存储引擎有 `InnoDB`、`MyISAM`、`Memory`、`CSV`、`Archive`、`Blackhole`、`NDB`、`Merge`、`Federated`、`Example` 等。\n\nMySQL 5.5.5 之前，`MyISAM` 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。\n\n### MyISAM/InnoDB存储引擎区别\n- `MyISAM`只支持表级锁，而 `InnoDB` 支持行级锁和表级锁，默认为行级锁。\n- `MyISAM` 不提供事务支持。`InnoDB` 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(`commit`)和回滚(`rollback`)事务的能力。并且，`InnoDB` 默认使用的 `REPEATABLE-READ`(可重读)隔离级别是可以解决幻读问题发生的(基于 `MVCC` 和 `Next-Key Lock`)。\n- `MyISAM` 不支持外键，而 `InnoDB` 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。\n- `MyISAM` 不支持数据库异常崩溃后的安全恢复，而 `InnoDB` 支持，恢复过程依赖于`redo log`。\n- `InnoDB`支持 `MVCC`，`MyISAM` 不支持。`MVCC` 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n- `InnoDB`和`MyISAM`都使用`B+Tree` 作为索引结构，但二者实现方式不一样。`InnoDB` 引擎中，其数据文件本身就是索引文件。相比 `MyISAM`，索引文件和数据文件是分离的，其表数据文件本身就是按 `B+Tree` 组织的一个索引结构，树的叶节点 `data` 域保存了完整的数据记录。\n- `InnoDB` 的性能比 `MyISAM` 更强大，随着 CPU 核数的增加，`InnoDB` 的读写能力呈线性增长。\n- 数据缓存策略和机制实现不同。`InnoDB` 使用缓冲池(`Buffer Pool`)缓存数据页和索引页，`MyISAM` 使用键缓存(`Key Cache`)仅缓存索引页而不缓存数据页。\n\n### MySQL索引✅\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 `Innodb` 还是 `MyIsam`，都使用了 **B+树**作为索引结构。\n\n**优点**\n- 大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n### 索引底层数据类型选型\n1. `Hash`索引\n`InnoDB` 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(`Adaptive Hash Index`)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 `B+Tree` 结构(不是传统的链表+红黑树)，这个 `B+Tree` 结构可以存储多个键值对，而不仅仅是一个键。`Hash` 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。\n\n2. 二叉查找树\n二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。\n当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 `O(N)`。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。\n\n3. AVL树\nAVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。\n\n4. 红黑树\n红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致**一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因**。红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 `O(logn)` 次数的旋转操作，其插入和删除操作效率大大提高。\n\n5. B树&B+树\nB 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced (平衡)的意思。\n目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。\n**B树&B+树区别**\n- B 树的所有节点既存放键(`key`) 也存放数据(`data`)，而 B+树只有叶子节点存放 `key` 和 `data`，其他内节点只存放 `key`。\n- B 树的叶子节点都是独立的;\n- B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。\n\n综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。\n\n### MyISAM/InnoDB索引区别\n`MyISAM` 引擎和 `InnoDB` 引擎都是使用 `B+Tree` 作为索引结构，但实现方式不太一样：\n- `MyISAM` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按照 `B+Tree` 搜索算法搜索索引，如果指定的 `Key` 存在，则取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。\n- `InnoDB` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 `InnoDB` 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。\n\n### 索引分类\n\n按照数据结构维度划分：\n- `BTree` 索引：MySQL 里默认和最常用的索引类型。\n- 哈希索引：类似键值对的形式，一次即可定位。\n\n按照底层存储方式角度划分：\n- 聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\n- 非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。`MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n按照应用维度划分：\n- 主键索引：加速查询 + 列值唯一(不可以有 `NULL`)+ 表中只有一个。\n- 普通索引：仅加速查询。\n- 唯一索引：加速查询 + 列值唯一(可以有 `NULL`)。\n- 覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 `ElasticSearch` 代替。\n\nMySQL 8.x 中实现的索引新特性：\n- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。\n- 降序索引：之前的版本就支持通过 `DESC` 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 `GROUP BY` 语句进行隐式排序。\n- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。\n\n### 主键索引\n数据表的主键列使用的就是主键索引(主键索引的 `data` 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。\n\n在 MySQL 的 `InnoDB` 的表中，当没有显示的指定表的主键时，`InnoDB` 会自动先检查表中是否有唯一索引且不允许存在 `null` 值的字段，如果有，则选择该字段为默认的主键，否则 `InnoDB` 将会自动创建一个 6Byte 的自增主键。\n\n### 二级索引\n二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。\n\n唯一索引，普通索引，前缀索引等索引都属于二级索引。\n- 唯一索引(`Unique Key`)：唯一索引的属性列不能出现重复的数据，但是允许数据为 `NULL`，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n- 普通索引(`Index`)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 `NULL`。\n- 前缀索引(`Prefix`)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。\n- 全文索引(`Full Text`)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 `MYISAM` 引擎支持全文索引，5.6 之后 `InnoDB` 也支持了全文索引。\n\n### 聚簇索引/非聚簇索引\n聚簇索引(聚集索引)：索引结构和数据一起存放的索引，`InnoDB` 中的主键索引就属于聚簇索引。\n\n**优点**：\n- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。\n- 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。\n\n**缺点**：\n- 依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串/UUID这类又长又难比较的数据，插入/查找的速度较慢。\n- 更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。\n\n非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 `MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n**优点**：\n更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。\n\n**缺点**：\n- 依赖于有序的数据\n- 可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。\n\n### 回表\n在 `InnoDB` 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。\n\n### 覆盖索引/联合索引\n- 覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n\n### 联合索引最左前缀匹配原则\n在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n### 索引下推ICP\n索引下推(`Index Condition Pushdown,ICP`) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`语句中的判断条件，直接过滤掉不满足条件的记录，从而**减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量**。\n\n**原理**\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\nMySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。\n\n索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。\n\n```sql\nSELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;\n```\n- 没有索引下推，存储引擎层`zipcode` 字段利用索引可以快速定位到 `zipcode = '431200'`的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。\n- 有索引下推，存储引擎层根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。\n\n索引下推适用于 `InnoDB` 引擎和 `MyISAM` 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。\n\n### MySQL查询缓存✅\n执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用\n\n查询缓存不命中的情况：\n- 两个查询在任何字符上的不同都会导致缓存不命中。\n- 若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。\n- 缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。\n\n### MySQL三大日志✅\nMySQL比较重要的日志有二进制日志 `binlog`(归档日志)和事务日志 `redo log`(重做日志)和 `undo log`(回滚日志)。\n\nMySQL `InnoDB` 引擎使用 `redo log`(重做日志) 保证事务的持久性，使用 `undo log`(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### redo log\n`redo log`(重做日志)是 `InnoDB` 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，保证数据的持久性与完整性。\n\n查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 `Buffer Pool`中，后续查找先查找`Buffer Pool`，如果没有找到再去硬盘加载。更新数据的时候，若 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(`redo log buffer`)里，接着刷盘到 `redo log` 文件里。\n\n### 刷盘时机\n`InnoDB` 在多种情况下将 `redo log` 刷到磁盘上，以保证数据的持久性和一致性。\n- 事务提交：当事务提交时，`redo log buffer` 里的 `redo log` 会被刷新到磁盘的 `redo log` 文件里。\n- `redo log buffer` 空间不足时：`redo log buffer` 中缓存的 `redo log` 已占了 `redo log buffer` 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。\n- `Checkpoint`(检查点)：`InnoDB` 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。\n- 正常关闭服务器：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去。\n- 后台线程：`InnoDB` 有一个后台线程，每隔1 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存(`page cache`)，然后调用 `fsync` 刷盘。\n\n### 刷盘策略\n`innodb_flush_log_at_trx_commit`参数设置三种刷盘策略：\n- 0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。\n- 1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。\n- 2，每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`(文件系统缓存)。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n默认策略为第二种。\n\n### binlog\n`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志，且是顺序写。\n\nMySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### 记录格式\n`binlog` 有三种记录格式：\n- `Statement`：记录的是 SQL 语句，如 `UPDATE t SET c=c+1 WHERE id=2`。\n  - 同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。\n- `Row`：记录的是行数据，如 `id=2 c=2`。\n  - 这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。\n- `Mixed`：记录的是上面两种的混合模式。\n  - MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。\n\n### 写入机制\n事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中。一个事务的 `binlog` 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。\n\n通过 `write` 将`binlog cache`中的 `binlog`写入文件系统缓存(`page cache`)，然后调用 `fsync` 刷盘。\n\n**`write` 和 `fsync` 时机** 由参数`sync_binlog`控制，默认是1。\n- 0，每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。\n  - 虽然性能最高，但是机器宕机，`page cache`里面的 `binlog` 会丢失。\n- 1，每次提交事务都会执行`write`+`fsync`，和 `redo log` 日志刷盘流程一样。\n- N(>1)，每次提交事务都会执行`write`，但是累计 `N`次事务后才执行 `fsync`。\n  - 在出现 IO 瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近`N`个事务的 `binlog` 日志。\n\n### 两阶段提交\n`redo log`(重做日志)让 `InnoDB` 存储引擎拥有了崩溃恢复能力。`binlog`(归档日志)保证了 MySQL 集群架构的数据一致性。\n\n`redo log` 与 `binlog` 的写入时机不一样，`redo log` 是事务执行过程中写入，`binlog` 是事务提交后写入。\n\n写入机制不一样会导致日志不一致：\n若某一事务(更新某一行的a值，从 0->1)执行过程中写完 `redo log` 日志后，`binlog` 日志写期间发生了异常，写入失败。此时使用`redo log`恢复的数据中，a值已经变为1，而`binlog`中记录的是a值为0，这样就导致了数据不一致。\n\n为了解决数据不一致问题，`InnoDB` 存储引擎使用两阶段提交：将 `redo log` 的写入拆成了两个步骤`prepare`和`commit`。\n- `prepare`：在事务执行过程中，先写入 `redo log`，但是不提交事务。\n- `commit`：在事务提交后，再写入 `binlog`，然后提交`redo log`。\n\n使用两阶段提交后，写入 `binlog` 时发生异常也不会有影响。此时 MySQL 根据 `redo log` 日志恢复数据时，发现 `redo log` 还处于`prepare`阶段，并且没有对应 `binlog` 日志，就会回滚该事务。\n\n如果`redo log` 在 `commit`阶段发生异常，虽然 `redo log` 处于`prepare`阶段，但是能通过事务id找到对应的 `binlog` 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n\n### undo log\n`undo log` 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 `DELETE` 语句，那 `undo log` 就会记录一条相对应的 `INSERT` 语句。每一个事务对数据的修改都会被记录到 `undo log` ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 `undo log` 将数据恢复到事务开始之前的状态。\n\n`undo log` 本身是会被删除清理的，例如 `INSERT` 操作，在事务提交之后就可以清除掉了；`UPDATE/DELETE` 操作在事务提交不会立即删除，会加入 `history list`，由后台线程 `purge` 进行清理。\n\n`undo log` 采用 `segment`(段)进行记录，事务开始时，需要为其分配一个 `rollback segment`。每个 `rollback segment` 有 1024 个 `undo log segment`(每个 `undo` 操作在记录的时候占用一个 `undo log segment`，多个有助于管理多个并发事务) 和 一个 `rollback segment header`(负责管理`rollback segment`)，`history list` 是`rollback segment header`的一部分，它的主要作用是记录所有已经提交但还没有被清理(`purge`)的事务的 `undo log`，`history list`列表使得 `purge` 线程能够找到并清理那些不再需要的 `undo log` 记录。\n\n### MySQL事务✅\n事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n### 事务的四大特性\n- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- 一致性(Consistency)：执行事务前后，数据保持一致。\n- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\n> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\n\n### 并发事务存在的问题\n\n### 脏读\n一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。\n\n一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。\n\n解决：\n- 设置事务隔离级别为 `Read Committed` 或更高。`Read Committed` 确保事务只能读取已经提交的数据，从而避免脏读。\n\n### 丢失修改\n两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。\n\n在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n\n解决：\n- 乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。\n- 悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。\n\n### 不可重复读\n一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。\n\n一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。\n\n解决：\n- 执行 `DELETE` 和 `UPDATE` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。\n\n### 幻读\n一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。\n\n一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n解决：\n- 执行 `INDERT` 操作的时候，由于记录锁(`Record Lock`)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(`Gap Lock`)。也就是说执行 `INDERT` 操作的时候需要依赖 `Next-Key Lock(Record Lock+Gap Lock)` 进行加锁来保证不出现幻读。\n- 事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。\n\n### 不可重复读和幻读有什么区别\n- 不可重复读：多次读取同一数据，发现数据不一致。\n- 幻读：多次执行同一条查询语句，发现查到的记录增加了。\n\n幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。\n- 解决不可重复读：执行 `DELETE` 和 `UPDATE` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 解决幻读：执行 `INDERT` 操作的时候，由于记录锁(`Record Lock`)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(`Gap Lock`)。也就是说执行 `INDERT` 操作的时候需要依赖 `Next-Key Lock(Record Lock+Gap Lock)` 进行加锁来保证不出现幻读。\n\n### 并发事务的控制方式有哪些\nMySQL 中并发事务的控制方式无非就两种：锁 和 `MVCC`。锁可以看作是悲观控制的模式，多版本并发控制(`MVCC，Multiversion concurrency control`)可以看作是乐观控制的模式。\n\n- 锁：\n  - 共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。\n  - 排他锁(X 锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。\n- `MVCC` 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\n\n读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(`table-level locking`) 和 行级锁(`row-level locking`) 。`InnoDB` 默认为行级锁，也支持表级锁，所以并发性能比较高。\n\n> 注意：不论是表级锁还是行级锁，都存在共享锁(`Share Lock`，S 锁)和排他锁(`Exclusive Lock`，X 锁)这两类。\n\nMVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、`read view`、`undo log`。\n- `undo log`：`undo log` 用于记录某行数据的多个版本的数据。\n- `read view` 和 隐藏字段： 用来判断当前版本数据的可见性。\n\n### 事务隔离级别\n`READ-UNCOMMITTED`(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n`READ-COMMITTED`(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n`REPEATABLE-READ`(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n`SERIALIZABLE`(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n|     隔离级别     | 脏读 | 不可重复读 | 幻读 | 实现方式 |\n| :--------------: | :--: | :--------: | :--: | :------: |\n| READ-UNCOMMITTED |  √   |     √      |  √   | /        |\n|  READ-COMMITTED  |  ×   |     √      |  √   | 基于 MVCC/锁 |\n| REPEATABLE-READ  |  ×   |     ×      |  √   | 基于 MVCC/锁(当前读情况下需要使用加锁读来保证不会出现幻读) |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   | 基于 锁 |\n\nMySQL默认隔离级别是 `REPEATABLE-READ`。\n\n`InnoDB` 实现的 `REPEATABLE-READ` 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：\n- 快照读：由 `MVCC` 机制来保证不出现幻读。\n- 当前读：使用 `Next-Key Lock` 进行加锁来保证不出现幻读，`Next-Key Lock` 是行锁(`Record Lock`)和间隙锁(`Gap Lock`)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 `READ-COMMITTED` ，不过 `InnoDB` 存储引擎默认使用 `REPEATABLE-READ`，这并不会有任何性能损失。`InnoDB` 存储引擎在分布式事务的情况下一般会用到 `SERIALIZABLE` 隔离级别。\n\n### MVCC✅\n多版本并发控制(`Multi-Version Concurrency Control, MVCC`) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，`MVCC` 会为该事务创建一个数据快照，而不是直接修改实际的数据行。\n\n1. 读操作(`SELECT`)\n当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：\n   - 对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。\n   - 如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。\n   - 事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。\n\n2. 写操作(`INSERT`、`UPDATE`、`DELETE`)\n当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：\n   - 对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。\n   - 新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。\n   - 原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。\n\n3. 事务提交和回滚\n   - 当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。\n   - 当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。\n\n4. 版本回收\n为了防止数据库中的版本无限增长，`MVCC` 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。\n\n`MVCC` 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。\n\n### 一致性非锁定读\n一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。\n\n`InnoDB`中，`MVCC`就是对一致性非锁定读的实现。如果读取的行正在执行 `DELETE` 或 `UPDATE` 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(`snapshot read`)。\n\n在 `Repeatable Read` 和 `Read Committed` 两个隔离级别下，如果是执行普通的 `SELECT` 语句(不包括 `SELECT ... lock in share mode` ，`SELECT ... FOR UPDATE`)则会使用一致性非锁定读(`MVCC`)。`Repeatable Read` 下 `MVCC` 实现了可重复读和防止部分幻读。\n\n### 锁定读/当前读\n在锁定读下，读取的是数据的最新版本。下面语句都是锁定读/当前读，会对读取到的记录加锁。\n- `SELECT ... lock in share mode`： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。\n- `SELECT ... FOR UPDATE`： 对读取到记录加排他锁，其他事务不能任何锁。\n- `INDERT`、`UPDATE`、`DELETE` 操作：对读取到记录加排他锁，其他事务不能任何锁。\n\n当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以`InnoDB` 在实现`Repeatable Read` 时，如果执行的是当前读，则会对读取的记录使用 `Next-key Lock` ，来防止其它事务在间隙间插入数据。\n\n### InnoDB的MVCC实现\n`MVCC` 的实现依赖于：隐藏字段、`Read View`、`undo log`。在内部实现中，`InnoDB` 通过数据行隐藏字段的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改。\n\n**隐藏字段**\nInnoDB为每行数据添加了三个隐藏字段：\n- `DB_TRX_ID`：表示最后一次更新或插入操作的事务ID。`DELETE`操作也被视为更新。\n- `DB_ROLL_PTR`：指向该行`undo log` 日志的指针。\n- `DB_ROW_ID`：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 `DB_ROW_ID` 作为聚簇索引。\n\n**Read View**\n`Read View` 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。\n- `m_low_limit_id`(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见\n- `m_up_limit_id`(上限事务ID)：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见\n- `m_ids`(活跃事务列表)：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务(正在内存中)\n- `m_creator_trx_id`：创建该 `Read View` 的事务 ID\n\n**undo log**\n其有两个作用：\n- 事务回滚时用于将数据恢复到修改前的样子\n- `MVCC` ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前版本的快照数据，以此实现非锁定读\n\n### RC和RR隔离级别下MVCC的差异\n- `Read Committed`：`MVCC` 会在每次`SELECT`读取数据时创建一个新的 `Read View`(`m_ids`列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 `Read View`，因此会导致一些不可重复读问题。\n- `Repeatable Read`：`MVCC` 会在事务开始后第一次 `SELECT`创建一个 `Read View`，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。\n\n### RR隔离级别下的MVCC如何解决幻读\n`MVCC`+`Next-key-Lock` 防止幻读\n\n- 执行普通 `SELECT`，此时会以 `MVCC` 快照读的方式读取数据\n  - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”\n- 执行 `SELECT...FOR UPDATE/lock in share mode`、`INDERT`、`UPDATE`、`DELETE` 等当前读\n  - 当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 `Next-key Lock`来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。\n\n### MySQL锁✅\n\n### 表级锁/行级锁区别\n- 表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，`MyISAM` 和 `InnoDB` 引擎都支持表级锁。\n- 行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n- `MyISAM` 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。\n- `InnoDB` 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 `InnoDB`的并发性能更高\n\n### InnoDB的行级锁\n- 记录锁(`Record Lock`)：也被称为记录锁，属于单个行记录上的锁。\n- 间隙锁(`Gap Lock`)：锁定一个范围，不包括记录本身。\n- 临键锁(`Next-Key Lock`)：`Record Lock`+`Gap Lock`，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\n\n### 共享锁/排他锁\n表级锁和行级锁都存在共享锁(`Share Lock`，S 锁)和排他锁(`Exclusive Lock`，X 锁)两类。\n- 共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。\n- 排他锁(X 锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。\n\n排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 \n\n由于有`MVCC`机制，对于一般的 `SELECT` 语句，`InnoDB` 不会加任何锁。\n\n### 意向锁\n意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。\n\n意向锁是表级锁，有两种：\n- 意向共享锁(`Intention Shared Lock`，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。\n- 意向排他锁(`Intention Exclusive Lock`，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。\n\n意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，`InnoDB` 会先获取该数据行所在在数据表的对应意向锁。\n\n意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。\n\n### 当前读/快照读区别\n- 当前读(一致性锁定读)：执行 `SELECT...FOR UPDATE/lock in share mode`、`INDERT`、`UPDATE`、`DELETE`\n  - 当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 `Next-key Lock`来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。\n- 快照读(一致性非锁定读)：执行普通 `SELECT`，此时会以 `MVCC` 快照读的方式读取数据\n  - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”\n\n### MySQL性能优化✅\n\n### 可以用MySQL存储文件吗？\n可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。\n\n### MySQL如何存储IP地址\n可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：\n- `INET_ATON()`：把 ip 转为无符号整型 (4-8 位)\n- `INET_NTOA()`：把整型的 ip 转为地址\n\n存储数据前，先用 `INET_ATON()` 把 ip 地址转为整型，取出数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可。\n\n### 如何分析SQL性能\n使用 `EXPLAIN` 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 **查询优化器** 对语句进行分析，找出最优的查询方案，并显示对应的信息。\n\n### MySQL执行计划✅\n执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\n```sql\nmysql> EXPLAIN SELECT * FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)>1);\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref  | rows   | filtered | Extra       |\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n|  1 | PRIMARY     | dept_emp | NULL       | ALL   | NULL            | NULL    | NULL    | NULL | 331143 |   100.00 | Using where |\n|  2 | SUBQUERY    | dept_emp | NULL       | index | PRIMARY,dept_no | PRIMARY | 16      | NULL | 331143 |   100.00 | Using index |\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n```\n各列含义如下：\n| **列名**      | **含义**                                     |\n| ------------- | -------------------------------------------- |\n| id            | SELECT 查询的序列标识符                      |\n| select_type   | SELECT 关键字对应的查询类型                  |\n| table         | 用到的表名                                   |\n| partitions    | 匹配的分区，对于未分区的表，值为 NULL        |\n| type          | 表的访问方法                                 |\n| possible_keys | 可能用到的索引                               |\n| key           | 实际用到的索引                               |\n| key_len       | 所选索引的长度                               |\n| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |\n| rows          | 预计要读取的行数                             |\n| filtered      | 按表条件过滤后，留存的记录数的百分比         |\n| Extra         | 附加信息                                     |\n\n**type(重要)**\n查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：`system` > `const` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL`\n常见的几种类型具体含义如下：\n- `system`：如果表使用的引擎对于表行数统计是精确的(如：`MyISAM`)，且表中只有一行记录的情况下，访问方法是 `system`，是 `const` 的一种特例。\n- `const`：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。\n- `eq_ref`：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 `system` 与 `const` 之外最好的 `JOIN` 方式，常用于使用主键或唯一索引的所有字段作为连表条件。\n- `ref`：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。\n- `index_merge`：当查询条件使用了多个索引时，表示开启了 `Index Merge` 优化，此时执行计划中的 `key` 列列出了使用到的索引。\n- `range`：对索引列进行范围查询，执行计划中的 `key` 列表示哪个索引被使用了。\n- `index`：查询遍历了整棵索引树，与 `ALL` 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。\n- `ALL`：全表扫描。\n\n**key(重要)**\n`key` 列表示 MySQL 实际使用到的索引。如果为 `NULL`，则表示未用到索引。\n\n**Extra(重要)**\n\n这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：\n- `Using filesort`：在排序时使用了外部的索引排序，没有用到表内索引进行排序。\n- `Using temporary`：MySQL 需要创建临时表来存储查询的结果，常见于 `ORDER BY` 和 `GROUP BY`。\n- `Using index`：表明查询使用了覆盖索引，不用回表，查询效率非常高。\n- `Using index condition`：表示查询优化器选择使用了索引条件下推这个特性。\n- `Using where`：表明查询使用了 `WHERE` 子句进行条件过滤。一般在没有使用到索引的时候会出现。\n- `Using join buffer (Block Nested Loop)`：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 `join buffer` 中，再遍历被驱动表与驱动表进行查询。\n\n当 `Extra` 列包含 `Using filesort` 或 `Using temporary` 时，MySQL 的性能可能会存在问题，需要尽可能避免。\n\n### MySQL读写分离✅\n读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。\n\n一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。\n\n### 如何实现读写分离\n1. 部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。\n2. 保证主数据库和从数据库之间的数据是实时同步的，即主从复制。\n3. 系统将写请求交给主数据库处理，读请求交给从数据库处理。\n\n基于项目层面有两种方案：\n1. 代理方式\n可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。\n2. 组件方式\n可以通过引入第三方组件来实现读写分离，例如使用 `sharding-jdbc` ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。\n\n### 主从复制原理\nMySQL 主从复制是依赖于 `binlog` 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 `canal`)的底层一般也是依赖 `binlog`。具体如下：\n1. 主库将数据库中数据的变化写入到 `binlog`\n2. 从库连接主库\n3. 从库创建一个 I/O 线程向主库请求更新的 `binlog`\n4. 主库创建一个 `binlog dump` 线程来发送 `binlog`，从库中的 I/O 线程负责接收\n5. 从库的 I/O 线程将接收的 `binlog` 写入到中继日志`relay log` 中。\n6. 从库的 SQL 线程读取中继日志`relay log` 同步数据到本地(也就是再执行一遍 SQL )。\n\n> `binlog`主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)\n> `relay log` 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。\n\n### 如何避免主从延迟\n主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。\n- 强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。\n- 延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。\n\n### 什么情况下会出现主从延迟\n主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：\n- 从库 I/O 线程接收 `binlog` 的速度跟不上主库写入 `binlog` 的速度，导致从库 `relay log` 的数据滞后于主库 `binlog` 的数据；\n- 从库 SQL 线程执行 `relay log` 的速度跟不上从库 I/O 线程接收 `binlog` 的速度，导致从库的数据滞后于从库 `relay log` 的数据。\n\n下面是一些可能导致主从延迟的原因及解决方案：\n1. 从库机器性能比主库差：从库接收 `binlog` 写入 `relay log` 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 \n2. 从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 `binlog` 接入到 `Hadoop`、`Elasticsearch` 等系统中。\n3. 大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。\n4. 从库太多：主库需要将 `binlog` 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。\n5. 网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 `binlog` 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。\n6. 单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。\n7. 复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 `semi-sync` 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。\n\n### MySQL分库分表✅\n分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。\n**分库**\n分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。\n- 垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。\n  - 如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。\n- 水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。\n  - 订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。\n\n**分表**\n分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。\n- 垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。\n- 水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。\n\n### 什么情况下需要分库分表\n- 单表的数据达到千万级别以上，数据库读写速度比较缓慢。\n- 数据库中的数据占用的空间越来越大，备份时间越来越长。\n- 应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。\n\n### 分片算法\n分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。\n\n常见的分片算法有：\n- 范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1~299999 的记录分到第一个表， 300000~599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。\n- 哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。\n- 地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。\n- 一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。\n\n### 分片键\n分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。\n\n### 分库分表会带来什么问题\n- 事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。\n- 跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 `GROUP BY`，`ORDER BY` 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。\n- 数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。\n- 。。。\n\n### 分库分表中数据如何迁移\n- 停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。\n- 双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。\n\n### MySQL数据冷热分离✅\n数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。\n\n**优缺点**\n- 优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)\n- 缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。\n\n### 冷数据和热数据\n- 热数据是指经常被访问和修改且需要快速访问的数据。\n- 冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。\n\n**冷热数据如何区分**\n1. 时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。\n   - 例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。\n2. 访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。\n   - 例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。\n\n### 冷数据如何迁移\n- 任务调度：可以利用 `xxl-job` 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。\n- 监听数据库的变更日志 `binlog` ：将满足冷数据条件的数据从 `binlog` 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。\n\n### 冷数据如何存储\n冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：\n- 中小厂：直接使用 MySQL/PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)\n- 大厂：Hbase(常用)、RocksDB、Doris、Cassandra\n\n### MySQL字符集\nMySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`\n\n### MySQL字符集层次级别\n- MySQL 中的字符集分为四个层次：\n  - server(MySQL 实例级别)\n  - database(库级别)\n  - table(表级别)\n  - column(字段级别)\n\n其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。\n\nMySQL 字符编码集中有两套 UTF-8 编码实现：\n- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n## Redis\nRedisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。\n\n### Redis为什么这么快\n- Redis 基于内存，内存的访问速度比磁盘快很多；\n- Redis 基于 `Reactor` 模式设计开发了一套高效的事件处理模型，主要是**单线程事件循环**和 **IO 多路复用**\n- Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。\n- Redis 通信协议实现简单且解析高效。\n\n### Redis/Memcached\n共同点：\n- 都是基于内存的数据库，一般都用来当做缓存使用。\n- 都有过期策略。\n- 两者的性能都非常高。\n\n区别：\n- Redis 支持更丰富的数据结构，如 `string`、`list`、`set`、`zset`、`hash` 等，而 Memcached 只支持 `key-value` 的数据结构。\n- Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。\n- Redis 支持集群模式，而 Memcached 不支持集群模式。\n- Redis 支持事务，而 Memcached 不支持事务。\n- Redis 支持发布订阅，而 Memcached 不支持发布订阅。\n- Redis 是单线程，而 Memcached 是多线程。\n\n### 为什么用Redis\n1. 高性能：Redis 是基于内存的，读写速度非常快。\n2. 高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。\n3. 功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！\n\n### 三种常用缓存读写策略\n**旁路缓存模式**(`Cache Aside Pattern`)\n适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n读：\n- 从 cache 中读取数据，读取到就直接返回\n- cache 中读取不到的话，就从 db 中读取数据返回\n- 把 db 中读取到的数据写入 cache 中。\n\n写：\n- 先更新 db\n- 再删除 cache 中的数据\n\n> 在写的过程中可以先删除cache，再更新 db 吗？\n> 不可以。这样可能会造成 数据库(db)和缓存(Cache)数据不一致的问题。\n> 如场景：请求 1 先写数据 A，请求 2 随后读数据 A。\n> 执行过程为：请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新\n> \n> 在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？\n> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\n> 如场景：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。\n> 执行过程为：请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A(此时缓存中无数据 A ，故不用执行删除缓存操作 ) -> 请求 1 将数据 A 写入 cache\n\n这种策略有一些缺陷：\n- 首次请求数据一定不在 cache 的问题\n  - 解决办法：可以将热点数据可以提前放入 cache 中。\n- 写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\n  - 解决办法：可以使用Write Through 或者 Write Behind 策略。\n**读写穿透**(`Read/Write Through Pattern`)\n服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n\n读：\n- 从 cache 中读取数据，读取到就直接返回。\n- 读取不到的话，先从 db 读取数据然后写入到cache 中，再返回。\n\n写：\n- 先查 cache，cache 中不存在，直接更新 db。\n- cache 中存在，则先更新 cache，然后 cache 服务自己更新 db(同步更新 cache 和 db)\n\n> 该模式也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\n\n**异步缓存写入**(`Write Behind Pattern`)\n\n`Write Behind Pattern` 和 `Read/Write Through Pattern` 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：`Read/Write Through` 是同步更新 cache 和 db，而 `Write Behind` 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\n\n> 应用场景：消息队列中消息的异步写入磁盘、MySQL 的 `Innodb Buffer Pool `机制都用到了这种策略。\n\n### Redis除了做缓存还有哪些应用场景\n- 分布式锁：基于 `Redisson` 来实现分布式锁。\n- 限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 `Redisson` 中的 `RRateLimiter` 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。\n- 消息队列：Redis 自带的 `List` 数据结构可以作为一个简单的队列使用。\n- 延时队列：`Redisson` 内置了延时队列(基于 `Sorted Set` 实现的)。\n- 分布式 `Session` ：利用 `String` 或者 `Hash` 数据类型保存 `Session` 数据，所有的服务器都可以访问。\n- 热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。\n\n### Redis可以做消息队列吗\n可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 `List` 来实现。Redis 2.0 之后，Redis 提供了 `PUBLISH` 和 `SUBSCRIBE` 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。\n\n和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。\n\n### Redis可以做搜索引擎吗\nRedis 是可以实现全文搜索引擎功能的，需要借助 `RediSearch`，这是一个基于 Redis 的搜索引擎模块。\n\n`RediSearch` 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 `Elasticsearch` 来说，`RediSearch` 有如下优势：\n- 性能更优秀：依赖 Redis 自身的高性能，基于内存操作(`Elasticsearch` 基于磁盘)。\n- 较低内存占用实现快速索引：`RediSearch` 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。\n\n`RediSearch` 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 `Elasticsearch`。\n- 数据量限制：`RedisSearch` 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。\n- 分布式能力较差：`RedisSearch` 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。`Elasticsearch` 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。\n- `RediSearch`聚合功能相较于 `Elasticsearch` 功能较弱。\n- 生态较差：`Elasticsearch` 可以轻松和常见的一些系统/软件集成比如 `Hadoop`、`Spark`、`Kibana`，而 `RedisSearch` 则不具备该优势。\n\n### 基于Redis实现延时任务✅\n> 类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？\n\n两种方案：\n1. Redis 过期事件监听 \n2. `Redisson` 内置的延时队列\n\nRedis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。\n`Redisson` 内置的延时队列具备下面这些优势：\n- 减少了丢消息的可能：`DelayedQueue` 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。\n- 消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。\n\n### Redis过期事件监听实现延时任务的原理\nRedis 2.0 引入了发布订阅 (`pub/sub`) 功能(其中有一个叫做 `channel`的概念)，涉及发布者(`publisher`)和订阅者(`subscriber`，也叫消费者)两个角色：\n- 发布者通过 `PUBLISH` 投递消息给指定 `channel`。\n- 订阅者通过`SUBSCRIBE`订阅它关心的 `channel`。并且，订阅者可以订阅一个或者多个 `channel`。\n\n在 `pub/sub` 模式下，生产者需要指定消息发送到哪个 `channel` 中，而消费者则订阅对应的 `channel` 以获取消息。\n\nRedis 中有很多默认的 `channel`，Redis 本身向它们发送一些消息，比如 `__keyevent@0__:expired`，这个 `channel` 用来监听 Redis 中的 key 过期事件。\n\n实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 `key` 过期时，Redis 会向 `__keyevent@0__:expired` 这个`channel`发送一条消息，这时候就可以在这个 `channel` 上监听到这个消息，从而实现延时任务。\n\n### Redis过期事件监听实现延时任务有什么缺陷\n1. 时效性差：过期事件消息是在 Redis 服务器删除 `key` 时发布的，而不是一个 `key` 过期之后就会就会直接发布。Redis 采用**定期删除+惰性/懒汉式删除**。 因此会存在设置了 `key` 的过期时间，但到了指定时间 `key` 还未被删除，进而没有发布过期事件的情况。\n2. 丢消息：Redis 的 `pub/sub` 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。\n3. 多服务实例下消息重复消费：pub/sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。\n\n### Redisson内置的延时队列实现延时任务的原理及优势\n可以借助 `Redisson` 内置的延时队列 `RDelayedQueue` 来实现延时任务功能。`RDelayedQueue` 基于 Redis 的 `SortedSet` 来实现，`SortedSet` 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 `SortedSet` 中，使用`zrangebyscore` 命令扫描 `SortedSet` 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 `SortedSet` 的轮询，提高了执行效率。\n\n`Redisson` 内置的延时队列具备下面这些优势：\n- 减少了丢消息的可能：`DelayedQueue` 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。\n- 消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。\n\n### Redis数据类型✅\n- 5种基本数据类型：\n| 数据类型 | 底层实现 |\n| :-------| :----- |\n| `String`(字符串) | `SDS`(简单动态字符串) |\n| `List`(列表) | `LinkedList`(双向链表)、`ZipList`(压缩列表)、`QuickList`(快速列表) |\n| `Hash`(哈希) | `Dict`(哈希表/字典)、`ZipList`(压缩列表) |\n| `Set`(集合) | `Dict`(哈希表/字典)、`Intset`(整数集合) |\n| `Zset`(有序集合) | `ZipList`(压缩列表)、`SkipList`(跳表) |\n- 3种特殊数据类型：\n    - `Bitmap`：位图\n    - `HyperLogLog`：基数统计\n    - `Geo`：地理位置\n\n\n### String\n`String` 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(`Simple Dynamic String，SDS`)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\n\n**常用命令**\n| 命令                            | 介绍                             |\n| ------------------------------- | -------------------------------- |\n| SET key value                   | 设置指定 key 的值                |\n| SETNX key value                 | 只有在 key 不存在时设置 key 的值 |\n| GET key                         | 获取指定 key 的值                |\n| MSET key1 value1 key2 value2 …… | 设置一个或多个指定 key 的值      |\n| MGET key1 key2 ...              | 获取一个或多个指定 key 的值      |\n| STRLEN key                      | 返回 key 所储存的字符串值的长度  |\n| INCR key                        | 将 key 中储存的数字值增一        |\n| DECR key                        | 将 key 中储存的数字值减一        |\n| EXISTS key                      | 判断指定 key 是否存在            |\n| DEL key(通用)                 | 删除指定的 key                   |\n| EXPIRE key seconds(通用)      | 给指定 key 设置过期时间          |\n\n**应用场景**\n`String` 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 `base64` 编码或者解码或者图片的路径)、序列化后的对象。\n\n### List\nRedis 的 `List` 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\n\n**常用命令**\n| 命令                        | 介绍                                       |\n| --------------------------- | ------------------------------------------ |\n| RPUSH key value1 value2 ... | 在指定列表的尾部(右边)添加一个或多个元素 |\n| LPUSH key value1 value2 ... | 在指定列表的头部(左边)添加一个或多个元素 |\n| LSET key index value        | 将指定列表索引 index 位置的值设置为 value  |\n| LPOP key                    | 移除并获取指定列表的第一个元素(最左边)     |\n| RPOP key                    | 移除并获取指定列表的最后一个元素(最右边)   |\n| LLEN key                    | 获取列表元素数量                           |\n| LRANGE key start end        | 获取列表 start 和 end 之间 的元素          |\n\n**应用场景**\n- 信息流展示，如最新文章、最新动态。\n- 消息队列，只是与专业的消息队列相比，`List` 功能较弱。\n\n### Hash\n `Hash` 是一个 `String` 类型的 `field-value`(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。\n\n`Hash` 类似于 JDK1.8 前的 `HashMap`，内部实现也差不多(数组 + 链表)，不过做了更多优化。\n\n**常用命令**\n| 命令                                      | 介绍                                                     |\n| ----------------------------------------- | -------------------------------------------------------- |\n| HSET key field value                      | 设置指定哈希表中指定字段的值                             |\n| HSETNX key field value                    | 只有指定字段不存在时设置指定字段的值                     |\n| HMSET key field1 value1 field2 value2 ... | 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 |\n| HGET key field                            | 获取指定哈希表中指定字段的值                             |\n| HMGET key field1 field2 ...               | 获取指定哈希表中一个或者多个指定字段的值                 |\n| HGETALL key                               | 获取指定哈希表中所有的键值对                             |\n| HEXISTS key field                         | 查看指定哈希表中指定的字段是否存在                       |\n| HDEL key field1 field2 ...                | 删除一个或多个哈希表字段                                 |\n| HLEN key                                  | 获取指定哈希表中字段的数量                               |\n| HINCRBY key field increment               | 对指定哈希中的指定字段做运算操作(正数为加，负数为减)   |\n\n**应用场景**\n- 存储对象，如用户信息、商品信息、文章信息、购物车信息.\n\n### Set\nSet 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 `HashSet` 。当需要存储无重复列表数据时，`Set` 是一个很好的选择，且 `Set` 提供了判断某个元素是否在其内的重要接口，这个也是 `List` 所不能提供的。\n\n**常用命令**\n| 命令                                  | 介绍                                      |\n| ------------------------------------- | ----------------------------------------- |\n| SADD key member1 member2 ...          | 向指定集合添加一个或多个元素              |\n| SMEMBERS key                          | 获取指定集合中的所有元素                  |\n| SCARD key                             | 获取指定集合的元素数量                    |\n| SISMEMBER key member                  | 判断指定元素是否在指定集合中              |\n| SINTER key1 key2 ...                  | 获取给定所有集合的交集                    |\n| SINTERSTORE destination key1 key2 ... | 将给定所有集合的交集存储在 destination 中 |\n| SUNION key1 key2 ...                  | 获取给定所有集合的并集                    |\n| SUNIONSTORE destination key1 key2 ... | 将给定所有集合的并集存储在 destination 中 |\n| SDIFF key1 key2 ...                   | 获取给定所有集合的差集                    |\n| SDIFFSTORE destination key1 key2 ...  | 将给定所有集合的差集存储在 destination 中 |\n| SPOP key count                        | 随机移除并获取指定集合中一个或多个元素    |\n| SRANDMEMBER key count                 | 随机获取指定集合中指定数量的元素          |\n\n**应用场景**\n- 存放无重复数据：如文章点赞、用户收藏、共同好友等。\n- 需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。\n- 随机获取数据源：如抽奖、随机推荐等。\n\n### Zset\n`Zset`相较于`Set`增加了一个权重参数 `score`，使得集合中的元素能够按 `score` 进行有序排列，还可以通过 `score` 的范围来获取元素的列表。\n\n**常用命令**\n| 命令                                          | 介绍                                                                                                          |\n| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| ZADD key score1 member1 score2 member2 ...    | 向指定有序集合添加一个或多个元素                                                                              |\n| ZCARD KEY                                     | 获取指定有序集合的元素数量                                                                                    |\n| ZSCORE key member                             | 获取指定有序集合中指定元素的 score 值                                                                         |\n| ZINTERSTORE destination numkeys key1 key2 ... | 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 |\n| ZUNIONSTORE destination numkeys key1 key2 ... | 求并集，其它和 ZINTERSTORE 类似                                                                               |\n| ZDIFFSTORE destination numkeys key1 key2 ...  | 求差集，其它和 ZINTERSTORE 类似                                                                               |\n| ZRANGE key start end                          | 获取指定有序集合 start 和 end 之间的元素(score 从低到高)                                                    |\n| ZREVRANGE key start end                       | 获取指定有序集合 start 和 end 之间的元素(score 从高到底)                                                    |\n| ZREVRANK key member                           | 获取指定有序集合中指定元素的排名(score 从大到小排序)                                                          |\n\n**应用场景**\n- 需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\n- 需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。\n\n### Bitmap\n`Bitmap`存储的是连续的二进制数据(1/0)，只需要一个 `bit` 位来表示某个元素对应的值或者状态，非常节省内存。可以将`Bitmap` 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 `offset`(偏移量)。\n\n**常用命令**\n| 命令                                  | 介绍                                                             |\n| ------------------------------------- | ---------------------------------------------------------------- |\n| SETBIT key offset value               | 设置指定 offset 位置的值                                         |\n| GETBIT key offset                     | 获取指定 offset 位置的值                                         |\n| BITCOUNT key start end                | 获取 start 和 end 之前值为 1 的元素个数                          |\n| BITOP operation destkey key1 key2 ... | 对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT |\n\n**应用场景**\n- 用户签到：每天签到的用户用一个 `bit` 位来表示，`offset` 为用户的 `id`，`value` 为签到状态(1/0)。\n- 用户在线状态：用一个 `bit` 位来表示用户的在线状态，`offset` 为用户的 `id`，`value` 为在线状态(1/0)。\n\n### HyperLogLog\n`HyperLogLog` 是一种基数统计算法，用于估计一个集合中不重复元素的个数。`HyperLogLog` 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。\n\n**常用命令**\n| 命令                                      | 介绍                                                                             |\n| ----------------------------------------- | -------------------------------------------------------------------------------- |\n| PFADD key element1 element2 ...           | 添加一个或多个元素到 HyperLogLog 中                                              |\n| PFCOUNT key1 key2                         | 获取一个或者多个 HyperLogLog 的唯一计数。                                        |\n| PFMERGE destkey sourcekey1 sourcekey2 ... | 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。 |\n\n**应用场景**\n- 数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。\n\n### Geospatial\n`Geospatial index`(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 `Sorted Set` 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\n\n**常用命令**\n| 命令                                             | 介绍                                                                                                 |\n| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------- |\n| GEOADD key longitude1 latitude1 member1 ...      | 添加一个或多个元素对应的经纬度信息到 GEO 中                                                          |\n| GEOPOS key member1 member2 ...                   | 返回给定元素的经纬度信息                                                                             |\n| GEODIST key member1 member2 M/KM/FT/MI           | 返回两个给定元素之间的距离                                                                           |\n| GEORADIUS key longitude latitude radius distance | 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数 |\n| GEORADIUSBYMEMBER key member radius distance     | 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素                                               |\n\n**应用场景**\n- 附近的人：根据用户的经纬度信息，获取附近的人。\n- 附近的商家：根据用户的经纬度信息，获取附近的商家。\n- 附近的车辆：根据用户的经纬度信息，获取附近的车辆。\n\n### 使用String存储对象还是Hash\n- `String` 存储的是序列化后的对象数据，存放的是整个对象。`Hash` 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 `Hash`。\n- `String` 存储相对来说更加节省内存，缓存相同数量的对象数据，`String` 消耗的内存约是 `Hash` 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用`String`。\n\n### 购物车信息用String还是Hash存储\n购物车中的商品频繁修改和变动，建议使用 `Hash`储存。\n- 用户 id 为 `key`\n- 商品 id 为 `field`，商品数量为 `value`\n\n具体维护：\n- 用户添加商品就是往 Hash 里面增加新的 field 与 value；\n- 查询购物车信息就是遍历对应的 Hash；\n- 更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；\n- 删除商品就是删除 Hash 中对应的 field；\n- 清空购物车直接删除对应的 key 即可。\n\n### Zset为什么要用跳表\n- 跳表 vs 平衡树\n  - 跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。\n- 跳表 vs 红黑树\n  - 跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。\n- 跳表 vs B+ 树\n  - B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。\n\n### 用Set实现抽奖系统\n- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。\n- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\n- `SRANDMEMBER key count`： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\n\n### Bitmap统计活跃用户\n用日期(精确到天)作为 `key`，用户 ID 为 `offset`，如果当日活跃过就设置为 1，否则为 0。通过 `BITCOUNT` 命令统计某个时间段内的活跃用户数。\n\n### HyperLogLog统计网站 UV\n- `PFADD PAGE_1:UV USER1 USER2 ...... USERn`：将访问指定页面的每个用户 ID 添加到 `HyperLogLog` 中。\n- `PFCOUNT PAGE_1:UV`：统计指定页面的 UV。\n\n### Redis持久化机制✅\n使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。\n\n### 为什么要持久化\n\n- 重用数据(比如重启机器、机器故障之后恢复数据)\n- 数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。\n\n### 三种持久化方式\n- 快照(`snapshotting`, RDB)\n- 只追加文件(`append-only file`, AOF)\n- RDB 和 AOF 的混合持久化(Redis 4.0 新增)\n\n### RDB持久化\nRedis通过创建快照获取存储在内存里面的数据在 **某个时间点** 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。\n\n### RDB创建时会阻塞主线程吗\n有两个命令生成 RDB 快照文件\n- `save`：同步保存操作，会阻塞 Redis 主线程； \n- `bgsave`：`fork` 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\n\n### AOF持久化\n与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 `server.aof_buf` 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(`fsync`策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。\n\n只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。\n\n### AOF工作流程\n1. 命令追加(`append`)：所有的写命令会追加到 AOF 缓冲区中。\n2. 文件写入(`write`)：将 AOF 缓冲区的数据写入到**系统内核缓冲区**中。这一步系统调用`write`函数，将数据写入到了**系统内核缓冲区**之后直接返回(延迟写)。\n3. 文件同步(`fsync`)：**系统内核缓冲区**根据对应的持久化方式(`fsync`策略)向硬盘做同步操作。这一步系统调用 `fsync` 函数， `fsync` 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。\n4. 文件重写(`rewrite`)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。\n5. 重启加载(`load`)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。\n\n![AOF工作流程](./image/Database-Interview/aof-work-process.png)\n\n### AOF持久化的三种同步策略\n即 `fsync` 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。\n- `appendfsync always`：主线程调用 `write` 执行写操作后，后台线程( `aof_fsync` 线程)立即会调用 `fsync` 函数同步 AOF 文件(刷盘)，`fsync` 完成后线程返回，这样会严重降低 Redis 的性能(`write + fsync`)。\n- `appendfsync everysec`：主线程调用 `write` 执行写操作后立即返回，由后台线程( `aof_fsync` 线程)每秒钟调用 `fsync` 函数同步一次 AOF 文件(`write+fsync`，`fsync`间隔为 1 秒)\n- `appendfsync no`：主线程调用 `write` 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(`write`但不`fsync`，`fsync` 的时机由操作系统决定)。\n\n> 刷盘：将内存中的数据写入到磁盘中。\n\n### AOF为什么是执行完命令后记录日志\n不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。\n- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；\n- 在命令执行完之后再记录，不会阻塞当前的命令执行。\n\n但也存在风险：\n- 如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； \n- 可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。\n\n### AOF重写\n当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\n\n重写期间，AOF维护一个**AOF重写缓冲区**，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将**AOF重写缓冲区**内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。\n\n可以配置如下参数：\n`auto-aof-rewrite-min-size`：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;\n`auto-aof-rewrite-percentage`：执行 AOF 重写时，当前 AOF 大小(`aof_current_size`)和上一次重写时 AOF 大小(`aof_base_size`)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。\n\n### AOF校验机制\nRedis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 `CRC64` 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。\n\nRedis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。\n\n### Redis4.0对持久化的优化\nRedis 4.0 开始支持 RDB 和 AOF 的混合持久化。\n\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。\n\n### 如何选择RDB和AOF\nRDB优势：\n- RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。\n- RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。\n\nAOF优势：\n- RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。\n- RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。\n- AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。\n\n综上：\n- Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。\n- 如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。\n- 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。\n\n### Redis单线程模型✅\nRedis 基于 `Reactor` 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(`file event handler`)，是单线程方式运行的，所以说 Redis 是单线程模型。\n\n### 如何监听大量客户端链接\n通过 **IO 多路复用程序** 来监听来自客户端的大量连接(或者说是监听多个 `socket`)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。\n\nI/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。\n\n文件事件处理器主要是包含 4 个部分：\n- 多个 socket(客户端连接)\n- IO 多路复用程序(支持多个客户端连接的关键)\n- 文件事件分派器(将 `socket` 关联到相应的事件处理器)\n- 事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)\n\n![文件事件处理器](./image/Database-Interview/redis-event-handler.png)\n\n### Redis4.0多线程\n在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。\n\n异步命令：\n- `UNLINK`：可以看作是 `DEL` 命令的异步版本。\n- `FLUSHALL ASYNC`：用于清空所有数据库的所有键，不限于当前 `SELECT` 的数据库。\n- `FLUSHDB ASYNC`：用于清空当前 `SELECT` 数据库中的所有键。\n\n总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。\n\n### Redis6.0之前为什么不用多线程\n- 单线程编程容易并且更容易维护；\n- Redis 的性能瓶颈不在 CPU ，主要在内存和网络；\n- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。\n\n### Redis6.0之后为何引入多线程\nRedis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。\n\n### Redis后台线程\nRedis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：\n- 通过 `bio_close_file` 后台线程来释放 AOF/RDB 等过程中产生的临时文件资源。\n- 通过 `bio_aof_fsync` 后台线程调用 `fsync` 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。\n- 通过 `bio_lazy_free`后台线程释放大对象(已删除)占用的内存空间.\n\n### Redis内存管理✅\n\n### Redis给缓存数据设置过期时间有啥用\n- 因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。\n- 某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。\n\n### Redis如何判断数据过期\nRedis 通过一个叫做**过期字典**(可以看作是 `hash` 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 `key`(键)，过期字典的值是一个 `long long` 类型的整数，这个整数保存了 `key` 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。\n\n在查询一个 `key` 的时候，Redis 首先检查该 `key` 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 `key` 是否过期，过期直接删除 `key` 然后返回 `null`。\n\n### Redis过期key删除策略\n- 惰性删除：只会在取出/查询 `key` 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 `key` 没有删除。\n- 定期删除：周期性地随机从设置了过期时间的 `key` 中抽查一批，然后逐个检查这些 `key` 是否过期，过期就删除 `key`。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。\n- 延迟队列：把设置过期时间的 `key` 放到一个延迟队列里，到期之后就删除 `key`。这样可保证每个过期 `key` 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。\n- 定时删除：每个设置了过期时间的 `key` 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。\n\nRedis 采用的是 **定期删除+惰性/懒汉式删除** 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。\n\n### 定期删除策略详细细节\n- Redis 默认每 100ms 检查 20 个随机的过期 `key`，如果有过期的 `key` 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 `key` 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。\n\n**大量key集中过期如何处理**\n如果大量 `key` 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：\n- 尽量避免 `key` 集中过期，在设置键的过期时间时尽量随机一点。\n- 对过期的 `key` 开启 `lazyfree` 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。\n\n### Redis内存淘汰策略✅\n当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：\n- `volatile-lru`(least recently used)：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最近最少使用的数据淘汰。\n- `volatile-ttl`：从已设置过期时间的数据集(`server.db[i].expires`)中挑选将要过期的数据淘汰。\n- `volatile-random`：从已设置过期时间的数据集(`server.db[i].expires`)中任意选择数据淘汰。\n- `allkeys-lru`(least recently used)：从数据集(`server.db[i].dict`)中移除最近最少使用的数据淘汰。\n- `allkeys-random`：从数据集(`server.db[i].dict`)中任意选择数据淘汰。\n- `no-eviction`(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。\n\n4.0 版本后增加以下两种：\n- `volatile-lfu`(least frequently used)：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最不经常使用的数据淘汰。\n- `allkeys-lfu`(least frequently used)：从数据集(`server.db[i].dict`)中移除最不经常使用的数据淘汰。\n\n`allkeys-xxx` 表示从所有的键值中淘汰数据，而 `volatile-xxx` 表示从设置了过期时间的键值中淘汰数据。\n\n### Redis事务\nRedis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。\n\n### 如何解决Redis事务的缺陷\n可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。\n\n### Redis性能优化✅\n\n### 批量操作减少网络传输\nRedis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。\n\n批量操作的三种方式\n- 原生批量操作：Redis 提供了一些原生的批量操作命令，如 `MSET`、`MGET`、`DEL` 等。\n- Pipeline：通过 `pipeline` 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。\n- Lua脚本：\n\n### 大量key集中过期\nRedis采用**定期删除+惰性/懒汉式删除**清理过期`key`。如果大量 `key` 集中过期的问题，客户端请求必须等待定期清理过期 `key` 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：\n- 给 `key` 设置随机过期时间。\n- 开启 `lazy-free`(惰性删除/延迟释放)，让 Redis 采用异步方式延迟释放 `key` 使用的内存，将删除`key`的操作该操作交给单独的子线程处理，避免阻塞主线程。\n\n### bigkey(大key)\n如果一个 `key` 对应的 `value` 所占用的内存比较大，那这个 `key` 就可以看作是 `bigkey`。`bigkey`的标准：\n- `String` 类型的 `value` 超过 1MB\n- 复合类型(`List`、`Hash`、`Set`、`Sorted Set` 等)的 `value` 包含的元素超过 5000 个(不过，对于复合类型的 `value` 来说，不一定包含的元素越多，占用的内存就越多)。\n\n**产生原因**\n- 程序设计不当，比如直接使用 `String` 类型存储较大的文件对应的二进制数据。\n- 对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。\n- 未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。\n\n**危害**\n- 单线程的Redis 在操作`bigkey` 时候比较耗时，造成客户端超时阻塞。\n- 网络拥塞：获取`bigkey`需要较多的流量。\n- 工作线程阻塞：如果使用 `del` 删除大 `key` 时，会阻塞工作线程，这样就没办法处理后续的命令。\n- `bigkey`会进一步影响主从同步。\n\n**bigkey发现**\n- `--bigkeys`：执行`redis-cli -p 6379 --bigkeys`扫描所有key，只能找到`top 1 bigkey`(占用内存最大的 `String` 数据类型，包含元素最多的复合数据类型)。\n- `SCAN+STRLEN/HLEN/LLEN`：Redis 自带的 `SCAN` 命令按指定模式扫描匹配的`key`，然后结合`STRLEN/HLEN/LLEN`返回`key`的长度或者成员数量。\n- 集合类型可以使用`MEMORY USAGE`\n- 借助开源工具分析 RDB 文件。如`redis-rdb-tools`、`rdb_bigkeys`\n- 使用公有云的 Redis 分析服务，如阿里云、腾讯云等。\n\n**处理bigkey**\n- 分割 `bigkey`：将`bigkey`分割为多个小 `key`。例如，将一个含有上万字段数量的 `Hash` 按照一定策略(比如二次哈希)拆分为多个 `Hash`。\n- 手动清理：Redis 4.0+ 可以使用 `UNLINK` 命令来异步删除一个或多个指定的 `key`。Redis 4.0 以下可以考虑使用 `SCAN` 命令结合 `DEL` 命令来分批次删除。\n- 采用合适的数据结构：例如，文件二进制数据不使用 `String` 保存、使用 `HyperLogLog` 统计页面 `UV`、`Bitmap` 保存状态信息(0/1)。\n- 开启 `lazy-free`(惰性删除/延迟释放)：`lazy-free` 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 `key` 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n也可以配合使用上述方法\n\n### hotkey(热key)\n如果一个 `key` 的访问次数比较多且明显多于其他 `key`，就可以看作是 `hotkey`。\n\n**产生原因**\n某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\n\n**危害**\n- `hotkey` 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。\n- 如果突然访问 `hotkey` 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n\n`hotkey` 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\n\n**发现hotkey**\n- `--hotkeys`：执行`redis-cli -p 6379 --hotkeys`命令\n- `MONITOR`： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。\n  - 可在合适的时机短暂执行 `MONITOR` 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 `hotkey`。\n- 根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 `hotkey`，比如突发的热点新闻事件等。\n- 使用公有云的 Redis 分析服务，如阿里云、腾讯云等。\n\n**处理hotkey**\n- 读写分离：主节点处理写请求，从节点处理读请求。\n- 使用 `Redis Cluster`：将热点数据分散存储在多个 Redis 节点上。\n- 二级缓存：`hotkey` 采用二级缓存的方式进行处理，将 `hotkey` 存放一份到 JVM 本地内存中(可以用 Caffeine)。\n- 使用公有云的 Redis 服务中的解决方案。\n\n也可以配合使用上述方法。\n\n### 慢查询命令\nRedis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如`KEYS *`、`HGETALL`等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。\n\n### Redis内存碎片✅\nRedis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。\n\n### 内存碎片产生原因\n1. Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n   - Redis 采用多种内存分配器分配内存，默认采用 `jemalloc`，其按照 2 的幂次方分配内存，可能会导致内存浪费。\n2. 频繁修改 Redis 中的数据也会产生内存碎片。\n\n### 查看内存碎片率\n使用 `info memory` 命令查看 Redis 内存碎片率。\n\n`mem_fragmentation_ratio` (内存碎片率)= `used_memory_rss` (操作系统实际分配给 Redis 的物理内存空间大小)/ `used_memory`(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)\n\n内粗碎片率越大，说明 Redis 中的内存碎片越多。`used_memory_rss` 减去 `used_memory` 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。\n\n通常内存碎片率`mem_fragmentation_ratio` > 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了\n\n### Redis内存碎片清理\n1. 重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。\n2. Redis4.0-RC3可以通过`config set activedefrag yes`开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。\n```bash\nconfig set activedefrag yes # 开启主动碎片整理功能\n\nconfig set active-defrag-ignore-bytes 500mb # 内存碎片占用空间达到 500mb 的时候开始清理\nconfig set active-defrag-threshold-lower 50 # 内存碎片率大于 1.5 的时候开始清理\n\nconfig set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不低于 20%\nconfig set active-defrag-cycle-max 50 # 内存碎片清理所占用 CPU 时间的比例不高于 50%\n```\n\n### Redis生产问题✅\n\n### 缓存穿透\n缓存穿透是大量请求的 `key` 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n**举例**\n某个黑客故意制造一些非法的 `key` 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n1. 做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n2. 缓存无效 `key`。短暂地缓存无效`key`，并设置一个较短的过期时间，这样就可以防止缓存穿透。\n3. 布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 `hash` 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。\n4. 接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。\n\n### 缓存击穿\n缓存击穿中，请求的 `key` 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n**举例**\n秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n1. 永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。\n2. 提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n3. 加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。\n\n### 缓存雪崩\n缓存雪崩是缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\n\n缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。\n\n**举例**\n数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n针对大量缓存同时失效的情况：\n1. 设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。\n2. 提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n3. 持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。\n\n针对 Redis 服务不可用的情况：\n1. Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。\n2. 多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。\n\n### 缓存穿透/缓存击穿区别\n- 缓存穿透中，请求的 `key` 既不存在于缓存中，也不存在于数据库中。\n- 缓存击穿中，请求的 `key` 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。\n\n### 缓存预热如何实现\n1. 使用定时任务，比如 `xxl-job`，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。\n2. 使用消息队列，比如 `Kafka`，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。\n\n### 缓存击穿/缓存雪崩区别\n缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。\n\n### Redis常见阻塞原因\n1. O(n)命令：如`KEYS *`(返回所有符合规则的 `key`)、`HGETALL`(会返回一个 `Hash` 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。\n2. `Save`创建RDB快照：`save` 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。\n3. AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。\n4. AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会`append`到AOF缓冲区，然后`write` 到系统内核缓冲区，最后 `fsync` 刷到磁盘。当磁盘压力太大的时候，会导致 `fsync` 操作发生阻塞，主线程调用 `write` 函数时也会被阻塞。\n5. AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。\n6. 查找和删除`bigkey`：查找`bigkey`时，Redis 会遍历所有的 `key`，这个操作是阻塞的。删除`bigkey`时，会先释放`bigkey`内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的`bigkey`，空闲内存块插入链表的操作就会阻塞主线程。\n7. 清空数据库：`flushall` 和 `flushdb` 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。\n8. CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\n9. 网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\n\n## mongodb\n\nMongoDB 是一个基于 **分布式文件存储** 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供**面向文档**的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 **文档类型数据库**。\n\n在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。\n\n### mongodb的存储结构是什么\n主要由三个单元组成：\n- 数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。\n- 集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(`Table`)。\n- 文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(`key-value`)组成，类似于关系型数据库中的行(`Row`)。\n\n**SQL 与 MongoDB 常见术语对比**：\n| SQL                      | MongoDB                         |\n| ------------------------ | ------------------------------- |\n| 表(Table)              | 集合(Collection)              |\n| 行(Row)                | 文档(Document)                |\n| 列(Col)                | 字段(Field)                   |\n| 主键(Primary Key)      | 对象 ID(Objectid)             |\n| 索引(Index)            | 索引(Index)                   |\n| 嵌套表(Embedded Table) | 嵌入式文档(Embedded Document) |\n| 数组(Array)            | 数组(Array)                   |\n\n**集合**\n集合存储于数据库中，**没有固定的结构**，也就是 **无模式** 的，这意味着可以往集合插入不同格式和类型的数据。\n\n集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。\n\n**文档**\nBSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。\n\n### mongodb特点\n- 数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。\n- 数据模型自由：不需要设计表结构，可以存储不同结构的文档。\n- 支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。\n- 支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。\n- 高效的二进制存储：文档以键值对的形式存储在集合中，键(`ObjectId`类型)唯一标识文件，值是以 BSON 形式存在。\n- 自带数据压缩功能：MongoDB 3.0 版本开始支持 `WiredTiger` 存储引擎，支持数据压缩，减少磁盘空间占用。\n- 支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。\n- 支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。\n- 支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。\n- 支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 `GridFS` 存储。\n\n### mongodb适合什么场景\nMongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。\n\n### mongodb存储引擎\nMongoDB 采用的是 **插件式的存储引擎架构**，现在主要使用两种存储引擎：\n- `MMAPv1` 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。\n- `WiredTiger` 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 `WiredTiger` 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。\n- `In-Memory` 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。\n\n### WiredTiger存储引擎\n`WiredTiger` 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。\n\n使用 B+ 树时，`WiredTiger` 以 `page` 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 `page`，共有三种类型的 `page`：\n- `root page`(根节点)：B+ 树的根节点。\n- `internal page`(内部节点)：不实际存储数据的中间索引节点。\n- `leaf page`(叶子节点)：真正存储数据的叶子节点，包含一个页头(`page header`)、块头(`block header`)和真正的数据(`key/value`)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 `checksum`、块在磁盘上的寻址位置等信息。\n\n### mongodb聚合\n将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：\n- 将来自多个文档的值组合在一起。 \n- 对集合中的数据进行的一系列运算。 \n- 分析数据随时间的变化。\n\n两种聚合方法：\n- 聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。\n- 单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 `count()`、`distinct()`、`estimatedDocumentCount()`。\n\n聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：\n- 接受一系列原始数据文档\n- 对这些文档进行一系列运算\n- 结果文档输出给下一个阶段\n\n### mongodb事务\n支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。\n\n### mongodb数据压缩\n借助 `WiredTiger` 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。`WiredTiger` 存储引擎支持以下压缩算法：\n- `snappy`：快速压缩算法，压缩比(3～5倍)较低，但速度快。\n- `zlib`：压缩比(5～7倍)较高，但速度较慢。\n- `Zstandard`：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。\n\n`WiredTiger` 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。\n\n### mongodb索引\n索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。\n\n索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。\n\n**索引类型**\n- 单字段索引：建立在单个字段上的索引。\n- 复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。\n- 多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。\n- 哈希索引：按数据的哈希值索引，用在哈希分片集群上。\n- 文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。\n- 地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。\n- 唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。\n- TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.\n\n### 复合索引中字段顺序\n复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。\n\n复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。\n\n> 有一个类似 `{a: 1, b: 1, c: 1, ..., z: 1}` 这样的索引，那么实际上也等于有了 `{a: 1}`、`{a: 1, b: 1}`、`{a: 1, b: 1, c: 1}` 等一系列索引，但是不会有 `{b: 1}` 这样的非左前缀的索引。\n\n### TTL索引\nTTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 `expireAfterSeconds`，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 `expireAfterSeconds` 属性外，和普通索引一样。\n\n数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。\n\n**原理**\n- MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。\n- 对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 `oplog` 做同步。\n\n**TTL索引限制**\n- TTL 索引是单字段索引。复合索引不支持 TTL\n- 如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。\n\n\n\n\n\n\n","source":"_posts/数据库.md","raw":"---\ntitle: 数据库\ntags:\n  - 数据库\n  - SQL\n  - NoSQL\n  - MySQL\n  - mongodb\n  - Redis\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 数据库面经\nabbrlink: 17769\ndate: 2024-06-12 22:47:36\nupdated: 2024-06-22 18:28:16\ntop_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png\ncomments:\ncover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## SQL/NoSQL基础\n\n### 什么是SQL\nSQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。\n\n### DB/DBMS/DBS/DBA\n- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。\n- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。\n- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。\n\n\n### 数据库术语\n- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。\n- 数据表(`table`)：某种特定类型数据的结构化清单。\n- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。\n- 行(`row`)：表中的一个记录。\n- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。\n\n### 元组/码/候选码/主码/外码/主属性/非主属性概念\n- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。\n- 码：码就是能唯一标识实体的属性，对应表中的列。\n- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。\n- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n### ER图\nER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：\n- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。\n- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。\n- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。\n\n### 数据库三范式\n数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：\n- 1NF(第一范式)：属性不可再分。\n  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。\n- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。\n- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。\n  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。\n\n> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。\n>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；\n> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。\n>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；\n> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。\n> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**\n>   - 例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\n\n### 主键/外键区别\n主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n### 为什么不推荐使用外键和级联操作\n以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**\n\n- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；\n- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；\n- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。\n\n**外键好处**\n- 保证了数据库数据的一致性和完整性；\n- 级联操作方便，减轻了程序代码量；\n\n### 存储过程\n可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。\n\n存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n\n### DROP/TRUNCATE/DELETE区别\n1. 用法不同\n- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。\n- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\n- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。\n\n`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。\n\n2. 属于不同的数据库语言\n- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。\n\n3. 执行速度不同：`DROP > TRUNCATE > DELETE`。\n- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。\n- `DROP`命令会把表占用的空间全部释放掉。\n\n### 数据库设计分为哪几个步\n1. 需求分析：分析用户的需求，包括数据、功能和性能需求。\n2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。\n3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。\n5. 数据库实施：包括编程、测试和试运行\n6. 数据库的运行和维护：系统的运行与数据库的日常维护。\n\n### 什么是NoSQL\n`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\n一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。\n\n> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。\n\n### SQL/NoSQL区别\n\n|         | SQL 数据库                                      | NoSQL 数据库                                                                                |\n|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|\n| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |\n| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |\n| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |\n| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |\n| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |\n| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |\n| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |\n| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |\n\n### NoSQL优劣\n**优点**\n- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。\n- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。\n- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。\n\n**缺点**\n- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。\n- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。\n\n### NoSQL分类\n- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。\n- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。\n- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。\n- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。\n\n### 数据库分类\n`DDL/DML/DCL/TCL`\n- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。\n- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。\n- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### SQL三种注释方式\n- 单行注释：`-- 注释内容` 或 `# 注释内容`。\n- 多行注释：`/* 注释内容 */`。\n- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。\n\n### DML语句✅\n`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n\n### 增删改查CRUD\n增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n\n**插入数据**\n`INSERT INTO` 语句用于向表中插入新记录。\n\n```sql\n-- 插入完整的行\n-- 插入一行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com');\n-- 插入多行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');\n\n-- 插入行的一部分\nINSERT INTO user(username, password, email)\nVALUES ('admin', 'admin', 'xxxx@163.com');\n\n-- 插入查询出来的数据\nINSERT INTO user(username)\nSELECT name\nFROM account;\n```\n\n**更新数据**\n`UPDATE` 语句用于更新表中的记录。\n\n```sql\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n```\n\n**删除数据**\n- `DELETE` 语句用于删除表中的记录。\n- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。\n\n```sql\n-- 删除表中的指定数据\nDELETE FROM user\nWHERE username = 'robot';\n\n-- 清空表中的数据\nTRUNCATE TABLE user;\n```\n\n**查询数据**\n- `SELECT` 语句用于从数据库中查询数据。\n- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n- `ASC`：升序(默认)\n- `DESC`：降序\n\n```sql\n-- 查询单列\nSELECT prod_name\nFROM products;\n\n-- 查询多列\nSELECT prod_id, prod_name, prod_price\nFROM products;\n\n-- 查询所有列\nSELECT *\nFROM products;\n\n-- 查询不同的值\nSELECT DISTINCT\nvend_id FROM products;\n\n-- 限制查询结果\n-- 返回前 5 行\nSELECT * FROM mytable LIMIT 5;\nSELECT * FROM mytable LIMIT 0, 5;\n-- 返回第 3 ~ 5 行\nSELECT * FROM mytable LIMIT 2, 3;\n```\n\n### 排序\n- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。\n- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。\n\n```sql\nSELECT * FROM products\nORDER BY prod_price DESC, prod_name ASC;\n```\n\n### 分组\n**`GROUP BY`**：\n\n- `GROUP BY` 子句将记录分组到汇总行中。\n- `GROUP BY` 为每个组返回一个记录。\n- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。\n- `GROUP BY` 可以按一列或多列进行分组。\n- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。\n\n```sql\n-- 分组\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name;\n\n-- 分组后排序\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name\nORDER BY cust_name DESC;\n```\n\n### HAVING\n\n- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。\n- `HAVING` 一般都是和 `GROUP BY` 连用。\n- `WHERE` 和 `HAVING` 可以在相同的查询中。\n\n```sql\n-- 使用 WHERE 和 HAVING 过滤数据\nSELECT cust_name, COUNT(*) AS NumberOfOrders\nFROM Customers\nWHERE cust_email IS NOT NULL\nGROUP BY cust_name\nHAVING COUNT(*) > 1;\n```\n\n### WHERE/HAVING对比\n- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。\n- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。\n\n### 子查询\nMYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)\n\n子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。\n\n子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。\n\n子查询常用在 `WHERE` 子句和 `FROM` 子句后边：\n- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。\n```sql\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  column_name operator\n    (SELECT column_name [, column_name ]\n    FROM table1 [, table2 ]\n    [WHERE])\n```\n- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。\n```sql\nSELECT column_name [, column_name ]\nFROM (SELECT column_name [, column_name ]\n      FROM table1 [, table2 ]\n      [WHERE]) as temp_table_name\nWHERE  condition\n```\n\n**子查询的子查询**\n首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。\n```sql\nSELECT cust_name, cust_contact\nFROM customers\nWHERE cust_id IN (SELECT cust_id\n                  FROM orders\n                  WHERE order_num IN (SELECT order_num\n                                      FROM orderitems\n                                      WHERE prod_id = 'RGAN01'));\n```\n\n### WHERE\n- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。\n- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。\n- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。\n```sql\n-- SELECT语句中的WHERE\nSELECT * FROM Customers\nWHERE cust_name = 'Kids Place';\n\n-- UPDATE语句中的WHERE\nUPDATE Customers\nSET cust_name = 'Jack Jones'\nWHERE cust_name = 'Kids Place';\n\n-- DELETE语句中的WHERE\nDELETE FROM Customers\nWHERE cust_name = 'Kids Place';\n```\n- 可以在 `WHERE` 子句中使用的操作符。\n| 运算符       | 描述                                |\n|-----------|-----------------------------------|\n| `=`       | 等于                                |\n| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |\n| `>`       | 大于                                |\n| `<`       | 小于                                |\n| `>=`      | 大于等于                              |\n| `<=`      | 小于等于                              |\n| `BETWEEN` | 在某个范围内                            |\n| `LIKE`    | 搜索某种模式                            |\n| `IN`      | 指定针对某个列的多个可能值                     |\n\n### IN/BETWEEN\n- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。\n- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。\n\n```sql\n-- IN示例\nSELECT *\nFROM products\nWHERE vend_id IN ('DLL01', 'BRS01');\n\n-- BETWEEN示例\nSELECT *\nFROM products\nWHERE prod_price BETWEEN 3 AND 5;\n```\n\n### AND/OR/NOT\n- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。\n- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。\n- `AND` 操作符表示左右条件都要满足。\n- `OR` 操作符表示左右条件满足任意一个即可。\n- `NOT` 操作符用于否定一个条件。\n\n```sql\n-- AND示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' AND prod_price <= 4;\n\n-- OR示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' OR vend_id = 'BRS01';\n\n-- NOT示例\nSELECT *\nFROM products\nWHERE prod_price NOT BETWEEN 3 AND 5;\n```\n\n### LIKE\n- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。\n- 只有字段是文本值时才使用 `LIKE`。\n- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。\n- 不要滥用通配符，通配符位于开头处匹配会非常慢。\n- `%` 表示任何字符出现任意次数。\n- `_` 表示任何字符出现一次。\n\n```sql\n-- %示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '%bean bag%';\n\n-- _示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '__ inch teddy bear';\n```\n\n### 连接JOIN\n`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。\n\n语法：\n```sql\nSELECT table1.column1, table2.column2...\nFROM table1\nJOIN table2\nON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not\n```\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n\n如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。\n```sql\n# JOIN....ON\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nON c.cust_id = o.cust_id\n-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()\n-- using(cust_id) 代替 ON c.cust_id = o.cust_id\nORDER BY c.cust_name;\n```\n\n### 内连接/外连接\n- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。\n- `外连接`：\n  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。\n  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。\n  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。\n\n\n```sql\n/* \nstudent表\nstudent_id\tname\n1\t        Alice\n2\t        Bob\n3\t        Carol\n\ncourses表\ncourse_id\tstudent_id\tcourse_name\n101\t        1\t        Math\n102\t        2\t        Science\n103\t        4\t        History\n*/\n\n-- 内连接\nSELECT students.name, courses.course_name\nFROM students\nINNER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\n*/\n\n-- 左外连接\nSELECT students.name, courses.course_name\nFROM students\nLEFT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\n*/\n\n-- 右外连接\nSELECT students.name, courses.course_name\nFROM students\nRIGHT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nNULL\tHistory\n*/\n\n-- 全外连接\nSELECT students.name, courses.course_name\nFROM students\nFULL OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\nNULL\tHistory\n*/\n```\n\n### ON/WHERE区别\n- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。\n- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。\n\n### 组合UNION\n`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。\n\n`UNION` 基本规则：\n- 所有查询的列数和列顺序必须相同。\n- 每个查询中涉及表的列的数据类型必须相同或兼容。\n- 通常返回的列名取自第一个查询。\n- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。\n\n```sql\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n```\n\n### DDL语言✅\n`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n\n### 数据库DATABSE\n- 创建数据库：`CREATE DATABASE 数据库名;`\n- 删除数据库：`DROP DATABASE 数据库名;`\n- 选择数据库：`USE 数据库名;`\n- 查看数据库：`SHOW DATABASES;`\n\n### 数据表TABLE\n```sql\n-- 普通创建\nCREATE TABLE user (\nid int(10) unsigned NOT NULL COMMENT 'Id',\nusername varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',\npassword varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',\nemail varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'\n) COMMENT='用户表';\n\n-- 根据已有表创建\nCREATE TABLE vip_user AS\nSELECT * FROM user;\n\n-- 删除表\nDROP TABLE user;\n\n-- 查看表\nSHOW TABLES;\n\n-- 添加列\nALTER TABLE user -- ALTER用于修改表\nADD age int(3);\n\n-- 删除列\nALTER TABLE user\nDROP COLUMN age;\n\n-- 修改列\nALTER TABLE `user`\nMODIFY COLUMN age tinyint;\n\n-- 添加主键\nALTER TABLE user\nADD PRIMARY KEY (id);\n\n-- 删除主键\nALTER TABLE user\nDROP PRIMARY KEY;\n```\n\n### 视图VIEW\n在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。\n\n作用：\n- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。\n- 提高数据安全性：用来限制用户访问敏感数据。\n- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。\n- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。\n\n```sql\n-- 创建视图\nCREATE VIEW top_10_user_view AS\nSELECT id, username\nFROM user\nWHERE id < 10;\n\n-- 删除视图\nDROP VIEW top_10_user_view;\n```\n\n### 索引INDEX\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n**优点**\n- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n```sql\n-- 创建索引\nCREATE INDEX user_index\nON user (id);\n\n-- 添加索引\nALTER table user ADD INDEX user_index(id)\n\n-- 创建唯一索引\nCREATE UNIQUE INDEX user_index\nON user (id);\n\n-- 删除索引\nALTER TABLE user\nDROP INDEX user_index;\n```\n\n### 约束\nSQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。\n\n**约束类型**\n- `NOT NULL`：指示某列不能存储 `NULL` 值。\n- `UNIQUE`：保证某列的每行必须有唯一的值。\n- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。\n- `CHECK`：保证列中的值符合指定的条件。\n- `DEFAULT`：规定没有给列赋值时的默认值。\n\n```sql\nCREATE TABLE Users (\n  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',\n  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',\n  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',\n  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',\n  PRIMARY KEY (Id)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n```\n\n\n### TCL语句✅\n`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n\n### 事务TRANSACTION\n事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。\n\n**事务的四个特性(ACID)**\n- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- `一致性(Consistency)`：执行事务前后，数据保持一致。\n- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。\n\n> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。\n\n```sql\n-- 开始事务\nSTART TRANSACTION;\n\n-- 插入操作 A\nINSERT INTO `user`\nVALUES (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updateA\nSAVEPOINT updateA;\n\n-- 插入操作 B\nINSERT INTO `user`\nVALUES (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updateA\nROLLBACK TO updateA;\n\n-- 提交事务，只有操作 A 生效\nCOMMIT;\n```\n\n### DCL语句✅\n`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### 权限管理\n- 授予用户帐户权限，用`GRANT`命令。\n  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。\n  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。\n  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。\n  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。\n  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。\n- 撤销用户的权限，用`REVOKE`命令。\n  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。\n  - 指定在 `ON` 子句中撤销特权的特权级别。\n  - 指定要撤消 `FROM` 子句中的权限的用户帐户。\n\n`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：\n- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；\n- 整个数据库，使用 `ON database.*`；\n- 特定的表，使用 `ON database.table`；\n- 特定的列；\n- 特定的存储过程。\n\n```sql\n-- GRANT用法\nGRANT privilege,[privilege],.. ON privilege_level\nTO user [IDENTIFIED BY password]\n[REQUIRE tsl_option]\n[WITH [GRANT_OPTION | resource_option]];\n\n-- REVOKE用法\nREVOKE privilege_type [(column_list)]\n       [, priv_type [(column_list)]]...\nON [object_type] privilege_level\nFROM user [, user]...\n\n-- 创建账户\nCREATE USER myuser IDENTIFIED BY 'mypassword';\n-- 修改账户名\nUPDATE user SET user='newuser' WHERE user='myuser';\nFLUSH PRIVILEGES;\n-- 删除账户\nDROP USER myuser;\n-- 查看权限\nSHOW GRANTS FOR myuser;\n-- 授予权限\nGRANT SELECT, INSERT ON *.* TO myuser;\n-- 删除权限\nREVOKE SELECT, INSERT ON *.* FROM myuser;\n-- 更改密码\nSET PASSWORD FOR myuser = 'mypass';\n```\n\n### 游标CURSOR\n游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。\n\n### 触发器TRIGGER\n触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。\n\n**优点**\n- SQL 触发器提供了另一种检查数据完整性的方法。\n- SQL 触发器可以捕获数据库层中业务逻辑中的错误。\n- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。\n- SQL 触发器对于审计表中数据的更改非常有用。\n\n**缺点**\n- SQL 触发器可能会增加数据库服务器的开销。\n- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。\n\n在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。\n- `BEFORE INSERT`：在将数据插入表格之前激活。\n- `AFTER INSERT`：将数据插入表格后激活。\n- `BEFORE UPDATE`：在更新表中的数据之前激活。\n- `AFTER UPDATE`：更新表中的数据后激活。\n- `BEFORE DELETE`：在从表中删除数据之前激活。\n- `AFTER DELETE`：从表中删除数据后激活。\n\n`NEW` 和 `OLD`：\n- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；\n- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；\n- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；\n- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)\n\n### 触发器语法\n\n```sql\n-- 创建触发器\nCREATE TRIGGER trigger_name\ntrigger_time\ntrigger_event\nON table_name\nFOR EACH ROW\nBEGIN\ntrigger_statements\nEND;\n```\n\n说明：\n- `trigger_name`：触发器名\n- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。\n- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。\n- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。\n- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。\n- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。\n\n当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。\n\n```sql\n-- 创建触发器\nDELIMITER $\nCREATE TRIGGER `trigger_insert_user`\nAFTER INSERT ON `user`\nFOR EACH ROW\nBEGIN\n    INSERT INTO `user_history`(user_id, operate_type, operate_time)\n    VALUES (NEW.id, 'add a user',  now());\nEND $\nDELIMITER ;\n\n-- 查看触发器\nSHOW TRIGGERS;\n\n-- 删除触发器\nDROP TRIGGER trigger_insert_user;\n```\n\n## MySQL\nMySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是`3306`。\n\n### MySQL基础✅\n\n### MySQL优点\n- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。\n- 开箱即用，操作简单，维护成本低。\n- 兼容性好，支持常见的操作系统，支持多种开发语言。\n- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。\n- 支持分库分表、读写分离、高可用。\n\n### 什么是关系型数据库\n关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。\n\n大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……\n\n### MySQL字段类型\n简单分为三大类：数值类型、字符串类型、日期和时间类型。\n- 数值类型：\n  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。\n  - 浮点型：`FLOAT`、`DOUBLE`。\n  - 定点数：`DECIMAL`。\n- 字符串类型：\n  - 常用：`CHAR`、`VARCHAR`、`TEXT`。\n  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。\n- 日期和时间类型：\n  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。\n\n### 整数类型的UNSIGNED属性\n整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。\n\n> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。\n> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。\n\n对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。\n\n### CHAR/VARCHAR区别\n- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。\n- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。\n- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。\n- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。\n\n### VARCHAR(100)/VARCHAR(10)区别\n- 前者最大长度为 100，后者最大长度为 10。\n- 二者存储相同的字符串所占用的存储空间是一样的。\n- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。\n\n### DECIMAL和FLOAT/DOUBLE区别\n`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。\n\n### 为什么没不推荐使用TEXT/BLOB类型\n- `TEXT`用于存储长文本数据，如博客数据。\n- `BLOB`用于存储二进制大对象，例如图片、音视频等文件。\n\n这两种类型有如下缺陷：\n- 不能有默认值。\n- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。\n- 检索效率较低。\n- 不能直接创建索引，需要指定前缀长度。\n- 可能会消耗大量的网络和 IO 带宽。\n- 可能导致表上的 DML 操作变慢。\n\n### DATETIME/TIMESTAMP区别\n- `DATETIME`没有时区信息，`TIMESTAMP` 和时区有关。\n- `TIMESTAMP` 只需要使用 4 个字节的存储空间，但是 `DATETIME` 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，`TIMESTAMP` 表示的时间范围更小。\n  - `DATETIME`：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n  - `TIMESTAMP`：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC\n- `TIMESTAMP` 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。\n\n### NULL和''区别\n- `NULL` 表示未知的值，`''` 表示空字符串。\n  - `SELECT NULL=NULL`的结果为 `false`，但在使用`DISTINCT`,`GROUP BY`,`ORDER BY`时又认为`NULL`是相等的。\n- `''`长度为0，不占用空间，`NULL`占用空间。\n- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 `=`、`!=`、 `<`、`>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。\n- `NULL` 会影响聚合函数的结果。\n  - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。`COUNT` 的处理方式取决于参数的类型。如果参数是 `*(COUNT(*))`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名`(COUNT(列名))`，则会忽略 `NULL` 值，只统计非空值的个数。\n\n不推荐使用`NULL`作为列默认值。\n\n### Boolean类型如何在MySQL中存储\nMySQL 中没有布尔类型，可以使用 `TINYINT` 类型来存储布尔值。`TINYINT(1)` 可以存储 0 或 1，分别表示 `false` 和 `true`。\n\n### MySQL基础架构✅\n\nMySQL 基础架构主要分为 Server 层和存储引擎层：\n- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。\n- 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 `InnoDB`、`MyISAM`、`Memory` 等多个存储引擎，其中 `InnoDB` 引擎有自有的日志模块 `redolog` 模块。现在最常用的存储引擎是 `InnoDB`，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。\n\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\n- 连接器：身份认证和权限相关(登录 MySQL 的时候)。\n- 查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。\n- 分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\n- 优化器：按照 MySQL 认为最优的方案去执行。\n- 执行器：执行语句，然后从存储引擎返回数据。\n- 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。\n\n1. 连接器。\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。\n\n2. 查询缓存(MySQL 8.0 版本后移除)。\n主要用来缓存所执行的 `SELECT` 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 `Key-Value` 的形式缓存在内存中，`Key` 是查询语句，`Value` 是结果集。如果缓存 `Key` 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\n\n3. 分析器。\nMySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：\n   - 第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 SELECT，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\n   - 第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\n\n4. 优化器。\n优化器以它认为的最优的执行方案去执行(有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解)，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\n\n5. 执行器。\n当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\n\n### SQL语句在MySQL中的执行过程\n\n**查询语句**\n查询语句的执行流程如下：权限校验(如果命中缓存)--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\n```sql\nSELECT * FROM tb_student  A WHERE A.age='18' AND A.name='张三';\n```\n1. 检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 `key` 在内存中查询是否有结果，如果有直接返回，如果没有，执行下一步。\n2. 通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询`SELECT`，提取需要查询的表名为 `tb_student`，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\n3. 优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：\n   - a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n   - b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。\n4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\n\n**更新语句(增加，修改，删除)**\n更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---`redo log`(`prepare` 状态)--->`binlog`--->`redo log`(`commit` 状态)\n```sql\nUPDATE tb_student A SET A.age='19' WHERE A.name=' 张三 ';\n```\nMySQL自带的日志模块是 `binlog`，以 `InnoDB` 作为存储引擎介绍，其自带了一个`redo log` 日志模块，用来保证数据的一致性的。\n1. 先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。\n2. 拿到查询的语句，把 `age` 改为 19，然后调用引擎 API 接口，写入这一行数据，`InnoDB` 引擎把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，执行完成了，随时可以提交。\n3. 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log` 为提交状态。\n4. 更新完成。\n\n### MySQL存储引擎✅\n\n### MySQL支持哪些存储引擎？\nMySQL 支持多种存储引擎，常见的存储引擎有 `InnoDB`、`MyISAM`、`Memory`、`CSV`、`Archive`、`Blackhole`、`NDB`、`Merge`、`Federated`、`Example` 等。\n\nMySQL 5.5.5 之前，`MyISAM` 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。\n\n### MyISAM/InnoDB存储引擎区别\n- `MyISAM`只支持表级锁，而 `InnoDB` 支持行级锁和表级锁，默认为行级锁。\n- `MyISAM` 不提供事务支持。`InnoDB` 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(`commit`)和回滚(`rollback`)事务的能力。并且，`InnoDB` 默认使用的 `REPEATABLE-READ`(可重读)隔离级别是可以解决幻读问题发生的(基于 `MVCC` 和 `Next-Key Lock`)。\n- `MyISAM` 不支持外键，而 `InnoDB` 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。\n- `MyISAM` 不支持数据库异常崩溃后的安全恢复，而 `InnoDB` 支持，恢复过程依赖于`redo log`。\n- `InnoDB`支持 `MVCC`，`MyISAM` 不支持。`MVCC` 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n- `InnoDB`和`MyISAM`都使用`B+Tree` 作为索引结构，但二者实现方式不一样。`InnoDB` 引擎中，其数据文件本身就是索引文件。相比 `MyISAM`，索引文件和数据文件是分离的，其表数据文件本身就是按 `B+Tree` 组织的一个索引结构，树的叶节点 `data` 域保存了完整的数据记录。\n- `InnoDB` 的性能比 `MyISAM` 更强大，随着 CPU 核数的增加，`InnoDB` 的读写能力呈线性增长。\n- 数据缓存策略和机制实现不同。`InnoDB` 使用缓冲池(`Buffer Pool`)缓存数据页和索引页，`MyISAM` 使用键缓存(`Key Cache`)仅缓存索引页而不缓存数据页。\n\n### MySQL索引✅\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 `Innodb` 还是 `MyIsam`，都使用了 **B+树**作为索引结构。\n\n**优点**\n- 大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n### 索引底层数据类型选型\n1. `Hash`索引\n`InnoDB` 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(`Adaptive Hash Index`)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 `B+Tree` 结构(不是传统的链表+红黑树)，这个 `B+Tree` 结构可以存储多个键值对，而不仅仅是一个键。`Hash` 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。\n\n2. 二叉查找树\n二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。\n当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 `O(N)`。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。\n\n3. AVL树\nAVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。\n\n4. 红黑树\n红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致**一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因**。红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 `O(logn)` 次数的旋转操作，其插入和删除操作效率大大提高。\n\n5. B树&B+树\nB 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced (平衡)的意思。\n目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。\n**B树&B+树区别**\n- B 树的所有节点既存放键(`key`) 也存放数据(`data`)，而 B+树只有叶子节点存放 `key` 和 `data`，其他内节点只存放 `key`。\n- B 树的叶子节点都是独立的;\n- B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。\n\n综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。\n\n### MyISAM/InnoDB索引区别\n`MyISAM` 引擎和 `InnoDB` 引擎都是使用 `B+Tree` 作为索引结构，但实现方式不太一样：\n- `MyISAM` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按照 `B+Tree` 搜索算法搜索索引，如果指定的 `Key` 存在，则取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。\n- `InnoDB` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 `InnoDB` 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。\n\n### 索引分类\n\n按照数据结构维度划分：\n- `BTree` 索引：MySQL 里默认和最常用的索引类型。\n- 哈希索引：类似键值对的形式，一次即可定位。\n\n按照底层存储方式角度划分：\n- 聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\n- 非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。`MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n按照应用维度划分：\n- 主键索引：加速查询 + 列值唯一(不可以有 `NULL`)+ 表中只有一个。\n- 普通索引：仅加速查询。\n- 唯一索引：加速查询 + 列值唯一(可以有 `NULL`)。\n- 覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 `ElasticSearch` 代替。\n\nMySQL 8.x 中实现的索引新特性：\n- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。\n- 降序索引：之前的版本就支持通过 `DESC` 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 `GROUP BY` 语句进行隐式排序。\n- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。\n\n### 主键索引\n数据表的主键列使用的就是主键索引(主键索引的 `data` 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。\n\n在 MySQL 的 `InnoDB` 的表中，当没有显示的指定表的主键时，`InnoDB` 会自动先检查表中是否有唯一索引且不允许存在 `null` 值的字段，如果有，则选择该字段为默认的主键，否则 `InnoDB` 将会自动创建一个 6Byte 的自增主键。\n\n### 二级索引\n二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。\n\n唯一索引，普通索引，前缀索引等索引都属于二级索引。\n- 唯一索引(`Unique Key`)：唯一索引的属性列不能出现重复的数据，但是允许数据为 `NULL`，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n- 普通索引(`Index`)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 `NULL`。\n- 前缀索引(`Prefix`)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。\n- 全文索引(`Full Text`)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 `MYISAM` 引擎支持全文索引，5.6 之后 `InnoDB` 也支持了全文索引。\n\n### 聚簇索引/非聚簇索引\n聚簇索引(聚集索引)：索引结构和数据一起存放的索引，`InnoDB` 中的主键索引就属于聚簇索引。\n\n**优点**：\n- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。\n- 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。\n\n**缺点**：\n- 依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串/UUID这类又长又难比较的数据，插入/查找的速度较慢。\n- 更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。\n\n非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 `MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n**优点**：\n更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。\n\n**缺点**：\n- 依赖于有序的数据\n- 可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。\n\n### 回表\n在 `InnoDB` 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。\n\n### 覆盖索引/联合索引\n- 覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n\n### 联合索引最左前缀匹配原则\n在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n### 索引下推ICP\n索引下推(`Index Condition Pushdown,ICP`) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`语句中的判断条件，直接过滤掉不满足条件的记录，从而**减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量**。\n\n**原理**\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\nMySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。\n\n索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。\n\n```sql\nSELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;\n```\n- 没有索引下推，存储引擎层`zipcode` 字段利用索引可以快速定位到 `zipcode = '431200'`的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。\n- 有索引下推，存储引擎层根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。\n\n索引下推适用于 `InnoDB` 引擎和 `MyISAM` 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。\n\n### MySQL查询缓存✅\n执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用\n\n查询缓存不命中的情况：\n- 两个查询在任何字符上的不同都会导致缓存不命中。\n- 若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。\n- 缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。\n\n### MySQL三大日志✅\nMySQL比较重要的日志有二进制日志 `binlog`(归档日志)和事务日志 `redo log`(重做日志)和 `undo log`(回滚日志)。\n\nMySQL `InnoDB` 引擎使用 `redo log`(重做日志) 保证事务的持久性，使用 `undo log`(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### redo log\n`redo log`(重做日志)是 `InnoDB` 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，保证数据的持久性与完整性。\n\n查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 `Buffer Pool`中，后续查找先查找`Buffer Pool`，如果没有找到再去硬盘加载。更新数据的时候，若 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(`redo log buffer`)里，接着刷盘到 `redo log` 文件里。\n\n### 刷盘时机\n`InnoDB` 在多种情况下将 `redo log` 刷到磁盘上，以保证数据的持久性和一致性。\n- 事务提交：当事务提交时，`redo log buffer` 里的 `redo log` 会被刷新到磁盘的 `redo log` 文件里。\n- `redo log buffer` 空间不足时：`redo log buffer` 中缓存的 `redo log` 已占了 `redo log buffer` 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。\n- `Checkpoint`(检查点)：`InnoDB` 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。\n- 正常关闭服务器：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去。\n- 后台线程：`InnoDB` 有一个后台线程，每隔1 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存(`page cache`)，然后调用 `fsync` 刷盘。\n\n### 刷盘策略\n`innodb_flush_log_at_trx_commit`参数设置三种刷盘策略：\n- 0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。\n- 1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。\n- 2，每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`(文件系统缓存)。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n默认策略为第二种。\n\n### binlog\n`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志，且是顺序写。\n\nMySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### 记录格式\n`binlog` 有三种记录格式：\n- `Statement`：记录的是 SQL 语句，如 `UPDATE t SET c=c+1 WHERE id=2`。\n  - 同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。\n- `Row`：记录的是行数据，如 `id=2 c=2`。\n  - 这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。\n- `Mixed`：记录的是上面两种的混合模式。\n  - MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。\n\n### 写入机制\n事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中。一个事务的 `binlog` 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。\n\n通过 `write` 将`binlog cache`中的 `binlog`写入文件系统缓存(`page cache`)，然后调用 `fsync` 刷盘。\n\n**`write` 和 `fsync` 时机** 由参数`sync_binlog`控制，默认是1。\n- 0，每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。\n  - 虽然性能最高，但是机器宕机，`page cache`里面的 `binlog` 会丢失。\n- 1，每次提交事务都会执行`write`+`fsync`，和 `redo log` 日志刷盘流程一样。\n- N(>1)，每次提交事务都会执行`write`，但是累计 `N`次事务后才执行 `fsync`。\n  - 在出现 IO 瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近`N`个事务的 `binlog` 日志。\n\n### 两阶段提交\n`redo log`(重做日志)让 `InnoDB` 存储引擎拥有了崩溃恢复能力。`binlog`(归档日志)保证了 MySQL 集群架构的数据一致性。\n\n`redo log` 与 `binlog` 的写入时机不一样，`redo log` 是事务执行过程中写入，`binlog` 是事务提交后写入。\n\n写入机制不一样会导致日志不一致：\n若某一事务(更新某一行的a值，从 0->1)执行过程中写完 `redo log` 日志后，`binlog` 日志写期间发生了异常，写入失败。此时使用`redo log`恢复的数据中，a值已经变为1，而`binlog`中记录的是a值为0，这样就导致了数据不一致。\n\n为了解决数据不一致问题，`InnoDB` 存储引擎使用两阶段提交：将 `redo log` 的写入拆成了两个步骤`prepare`和`commit`。\n- `prepare`：在事务执行过程中，先写入 `redo log`，但是不提交事务。\n- `commit`：在事务提交后，再写入 `binlog`，然后提交`redo log`。\n\n使用两阶段提交后，写入 `binlog` 时发生异常也不会有影响。此时 MySQL 根据 `redo log` 日志恢复数据时，发现 `redo log` 还处于`prepare`阶段，并且没有对应 `binlog` 日志，就会回滚该事务。\n\n如果`redo log` 在 `commit`阶段发生异常，虽然 `redo log` 处于`prepare`阶段，但是能通过事务id找到对应的 `binlog` 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n\n### undo log\n`undo log` 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 `DELETE` 语句，那 `undo log` 就会记录一条相对应的 `INSERT` 语句。每一个事务对数据的修改都会被记录到 `undo log` ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 `undo log` 将数据恢复到事务开始之前的状态。\n\n`undo log` 本身是会被删除清理的，例如 `INSERT` 操作，在事务提交之后就可以清除掉了；`UPDATE/DELETE` 操作在事务提交不会立即删除，会加入 `history list`，由后台线程 `purge` 进行清理。\n\n`undo log` 采用 `segment`(段)进行记录，事务开始时，需要为其分配一个 `rollback segment`。每个 `rollback segment` 有 1024 个 `undo log segment`(每个 `undo` 操作在记录的时候占用一个 `undo log segment`，多个有助于管理多个并发事务) 和 一个 `rollback segment header`(负责管理`rollback segment`)，`history list` 是`rollback segment header`的一部分，它的主要作用是记录所有已经提交但还没有被清理(`purge`)的事务的 `undo log`，`history list`列表使得 `purge` 线程能够找到并清理那些不再需要的 `undo log` 记录。\n\n### MySQL事务✅\n事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n### 事务的四大特性\n- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- 一致性(Consistency)：执行事务前后，数据保持一致。\n- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\n> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\n\n### 并发事务存在的问题\n\n### 脏读\n一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。\n\n一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。\n\n解决：\n- 设置事务隔离级别为 `Read Committed` 或更高。`Read Committed` 确保事务只能读取已经提交的数据，从而避免脏读。\n\n### 丢失修改\n两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。\n\n在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n\n解决：\n- 乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。\n- 悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。\n\n### 不可重复读\n一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。\n\n一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。\n\n解决：\n- 执行 `DELETE` 和 `UPDATE` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。\n\n### 幻读\n一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。\n\n一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n解决：\n- 执行 `INDERT` 操作的时候，由于记录锁(`Record Lock`)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(`Gap Lock`)。也就是说执行 `INDERT` 操作的时候需要依赖 `Next-Key Lock(Record Lock+Gap Lock)` 进行加锁来保证不出现幻读。\n- 事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。\n\n### 不可重复读和幻读有什么区别\n- 不可重复读：多次读取同一数据，发现数据不一致。\n- 幻读：多次执行同一条查询语句，发现查到的记录增加了。\n\n幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。\n- 解决不可重复读：执行 `DELETE` 和 `UPDATE` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 解决幻读：执行 `INDERT` 操作的时候，由于记录锁(`Record Lock`)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(`Gap Lock`)。也就是说执行 `INDERT` 操作的时候需要依赖 `Next-Key Lock(Record Lock+Gap Lock)` 进行加锁来保证不出现幻读。\n\n### 并发事务的控制方式有哪些\nMySQL 中并发事务的控制方式无非就两种：锁 和 `MVCC`。锁可以看作是悲观控制的模式，多版本并发控制(`MVCC，Multiversion concurrency control`)可以看作是乐观控制的模式。\n\n- 锁：\n  - 共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。\n  - 排他锁(X 锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。\n- `MVCC` 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\n\n读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(`table-level locking`) 和 行级锁(`row-level locking`) 。`InnoDB` 默认为行级锁，也支持表级锁，所以并发性能比较高。\n\n> 注意：不论是表级锁还是行级锁，都存在共享锁(`Share Lock`，S 锁)和排他锁(`Exclusive Lock`，X 锁)这两类。\n\nMVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、`read view`、`undo log`。\n- `undo log`：`undo log` 用于记录某行数据的多个版本的数据。\n- `read view` 和 隐藏字段： 用来判断当前版本数据的可见性。\n\n### 事务隔离级别\n`READ-UNCOMMITTED`(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n`READ-COMMITTED`(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n`REPEATABLE-READ`(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n`SERIALIZABLE`(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n|     隔离级别     | 脏读 | 不可重复读 | 幻读 | 实现方式 |\n| :--------------: | :--: | :--------: | :--: | :------: |\n| READ-UNCOMMITTED |  √   |     √      |  √   | /        |\n|  READ-COMMITTED  |  ×   |     √      |  √   | 基于 MVCC/锁 |\n| REPEATABLE-READ  |  ×   |     ×      |  √   | 基于 MVCC/锁(当前读情况下需要使用加锁读来保证不会出现幻读) |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   | 基于 锁 |\n\nMySQL默认隔离级别是 `REPEATABLE-READ`。\n\n`InnoDB` 实现的 `REPEATABLE-READ` 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：\n- 快照读：由 `MVCC` 机制来保证不出现幻读。\n- 当前读：使用 `Next-Key Lock` 进行加锁来保证不出现幻读，`Next-Key Lock` 是行锁(`Record Lock`)和间隙锁(`Gap Lock`)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 `READ-COMMITTED` ，不过 `InnoDB` 存储引擎默认使用 `REPEATABLE-READ`，这并不会有任何性能损失。`InnoDB` 存储引擎在分布式事务的情况下一般会用到 `SERIALIZABLE` 隔离级别。\n\n### MVCC✅\n多版本并发控制(`Multi-Version Concurrency Control, MVCC`) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，`MVCC` 会为该事务创建一个数据快照，而不是直接修改实际的数据行。\n\n1. 读操作(`SELECT`)\n当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：\n   - 对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。\n   - 如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。\n   - 事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。\n\n2. 写操作(`INSERT`、`UPDATE`、`DELETE`)\n当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：\n   - 对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。\n   - 新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。\n   - 原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。\n\n3. 事务提交和回滚\n   - 当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。\n   - 当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。\n\n4. 版本回收\n为了防止数据库中的版本无限增长，`MVCC` 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。\n\n`MVCC` 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。\n\n### 一致性非锁定读\n一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。\n\n`InnoDB`中，`MVCC`就是对一致性非锁定读的实现。如果读取的行正在执行 `DELETE` 或 `UPDATE` 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(`snapshot read`)。\n\n在 `Repeatable Read` 和 `Read Committed` 两个隔离级别下，如果是执行普通的 `SELECT` 语句(不包括 `SELECT ... lock in share mode` ，`SELECT ... FOR UPDATE`)则会使用一致性非锁定读(`MVCC`)。`Repeatable Read` 下 `MVCC` 实现了可重复读和防止部分幻读。\n\n### 锁定读/当前读\n在锁定读下，读取的是数据的最新版本。下面语句都是锁定读/当前读，会对读取到的记录加锁。\n- `SELECT ... lock in share mode`： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。\n- `SELECT ... FOR UPDATE`： 对读取到记录加排他锁，其他事务不能任何锁。\n- `INDERT`、`UPDATE`、`DELETE` 操作：对读取到记录加排他锁，其他事务不能任何锁。\n\n当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以`InnoDB` 在实现`Repeatable Read` 时，如果执行的是当前读，则会对读取的记录使用 `Next-key Lock` ，来防止其它事务在间隙间插入数据。\n\n### InnoDB的MVCC实现\n`MVCC` 的实现依赖于：隐藏字段、`Read View`、`undo log`。在内部实现中，`InnoDB` 通过数据行隐藏字段的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改。\n\n**隐藏字段**\nInnoDB为每行数据添加了三个隐藏字段：\n- `DB_TRX_ID`：表示最后一次更新或插入操作的事务ID。`DELETE`操作也被视为更新。\n- `DB_ROLL_PTR`：指向该行`undo log` 日志的指针。\n- `DB_ROW_ID`：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 `DB_ROW_ID` 作为聚簇索引。\n\n**Read View**\n`Read View` 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。\n- `m_low_limit_id`(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见\n- `m_up_limit_id`(上限事务ID)：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见\n- `m_ids`(活跃事务列表)：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务(正在内存中)\n- `m_creator_trx_id`：创建该 `Read View` 的事务 ID\n\n**undo log**\n其有两个作用：\n- 事务回滚时用于将数据恢复到修改前的样子\n- `MVCC` ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前版本的快照数据，以此实现非锁定读\n\n### RC和RR隔离级别下MVCC的差异\n- `Read Committed`：`MVCC` 会在每次`SELECT`读取数据时创建一个新的 `Read View`(`m_ids`列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 `Read View`，因此会导致一些不可重复读问题。\n- `Repeatable Read`：`MVCC` 会在事务开始后第一次 `SELECT`创建一个 `Read View`，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。\n\n### RR隔离级别下的MVCC如何解决幻读\n`MVCC`+`Next-key-Lock` 防止幻读\n\n- 执行普通 `SELECT`，此时会以 `MVCC` 快照读的方式读取数据\n  - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”\n- 执行 `SELECT...FOR UPDATE/lock in share mode`、`INDERT`、`UPDATE`、`DELETE` 等当前读\n  - 当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 `Next-key Lock`来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。\n\n### MySQL锁✅\n\n### 表级锁/行级锁区别\n- 表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，`MyISAM` 和 `InnoDB` 引擎都支持表级锁。\n- 行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n- `MyISAM` 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。\n- `InnoDB` 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 `InnoDB`的并发性能更高\n\n### InnoDB的行级锁\n- 记录锁(`Record Lock`)：也被称为记录锁，属于单个行记录上的锁。\n- 间隙锁(`Gap Lock`)：锁定一个范围，不包括记录本身。\n- 临键锁(`Next-Key Lock`)：`Record Lock`+`Gap Lock`，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\n\n### 共享锁/排他锁\n表级锁和行级锁都存在共享锁(`Share Lock`，S 锁)和排他锁(`Exclusive Lock`，X 锁)两类。\n- 共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。\n- 排他锁(X 锁)：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。\n\n排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 \n\n由于有`MVCC`机制，对于一般的 `SELECT` 语句，`InnoDB` 不会加任何锁。\n\n### 意向锁\n意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。\n\n意向锁是表级锁，有两种：\n- 意向共享锁(`Intention Shared Lock`，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。\n- 意向排他锁(`Intention Exclusive Lock`，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。\n\n意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，`InnoDB` 会先获取该数据行所在在数据表的对应意向锁。\n\n意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。\n\n### 当前读/快照读区别\n- 当前读(一致性锁定读)：执行 `SELECT...FOR UPDATE/lock in share mode`、`INDERT`、`UPDATE`、`DELETE`\n  - 当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 `Next-key Lock`来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。\n- 快照读(一致性非锁定读)：执行普通 `SELECT`，此时会以 `MVCC` 快照读的方式读取数据\n  - 在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”\n\n### MySQL性能优化✅\n\n### 可以用MySQL存储文件吗？\n可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。\n\n### MySQL如何存储IP地址\n可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：\n- `INET_ATON()`：把 ip 转为无符号整型 (4-8 位)\n- `INET_NTOA()`：把整型的 ip 转为地址\n\n存储数据前，先用 `INET_ATON()` 把 ip 地址转为整型，取出数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可。\n\n### 如何分析SQL性能\n使用 `EXPLAIN` 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 **查询优化器** 对语句进行分析，找出最优的查询方案，并显示对应的信息。\n\n### MySQL执行计划✅\n执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\n```sql\nmysql> EXPLAIN SELECT * FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)>1);\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref  | rows   | filtered | Extra       |\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n|  1 | PRIMARY     | dept_emp | NULL       | ALL   | NULL            | NULL    | NULL    | NULL | 331143 |   100.00 | Using where |\n|  2 | SUBQUERY    | dept_emp | NULL       | index | PRIMARY,dept_no | PRIMARY | 16      | NULL | 331143 |   100.00 | Using index |\n+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+\n```\n各列含义如下：\n| **列名**      | **含义**                                     |\n| ------------- | -------------------------------------------- |\n| id            | SELECT 查询的序列标识符                      |\n| select_type   | SELECT 关键字对应的查询类型                  |\n| table         | 用到的表名                                   |\n| partitions    | 匹配的分区，对于未分区的表，值为 NULL        |\n| type          | 表的访问方法                                 |\n| possible_keys | 可能用到的索引                               |\n| key           | 实际用到的索引                               |\n| key_len       | 所选索引的长度                               |\n| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |\n| rows          | 预计要读取的行数                             |\n| filtered      | 按表条件过滤后，留存的记录数的百分比         |\n| Extra         | 附加信息                                     |\n\n**type(重要)**\n查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：`system` > `const` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL`\n常见的几种类型具体含义如下：\n- `system`：如果表使用的引擎对于表行数统计是精确的(如：`MyISAM`)，且表中只有一行记录的情况下，访问方法是 `system`，是 `const` 的一种特例。\n- `const`：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。\n- `eq_ref`：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 `system` 与 `const` 之外最好的 `JOIN` 方式，常用于使用主键或唯一索引的所有字段作为连表条件。\n- `ref`：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。\n- `index_merge`：当查询条件使用了多个索引时，表示开启了 `Index Merge` 优化，此时执行计划中的 `key` 列列出了使用到的索引。\n- `range`：对索引列进行范围查询，执行计划中的 `key` 列表示哪个索引被使用了。\n- `index`：查询遍历了整棵索引树，与 `ALL` 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。\n- `ALL`：全表扫描。\n\n**key(重要)**\n`key` 列表示 MySQL 实际使用到的索引。如果为 `NULL`，则表示未用到索引。\n\n**Extra(重要)**\n\n这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：\n- `Using filesort`：在排序时使用了外部的索引排序，没有用到表内索引进行排序。\n- `Using temporary`：MySQL 需要创建临时表来存储查询的结果，常见于 `ORDER BY` 和 `GROUP BY`。\n- `Using index`：表明查询使用了覆盖索引，不用回表，查询效率非常高。\n- `Using index condition`：表示查询优化器选择使用了索引条件下推这个特性。\n- `Using where`：表明查询使用了 `WHERE` 子句进行条件过滤。一般在没有使用到索引的时候会出现。\n- `Using join buffer (Block Nested Loop)`：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 `join buffer` 中，再遍历被驱动表与驱动表进行查询。\n\n当 `Extra` 列包含 `Using filesort` 或 `Using temporary` 时，MySQL 的性能可能会存在问题，需要尽可能避免。\n\n### MySQL读写分离✅\n读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。\n\n一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。\n\n### 如何实现读写分离\n1. 部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。\n2. 保证主数据库和从数据库之间的数据是实时同步的，即主从复制。\n3. 系统将写请求交给主数据库处理，读请求交给从数据库处理。\n\n基于项目层面有两种方案：\n1. 代理方式\n可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。\n2. 组件方式\n可以通过引入第三方组件来实现读写分离，例如使用 `sharding-jdbc` ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。\n\n### 主从复制原理\nMySQL 主从复制是依赖于 `binlog` 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 `canal`)的底层一般也是依赖 `binlog`。具体如下：\n1. 主库将数据库中数据的变化写入到 `binlog`\n2. 从库连接主库\n3. 从库创建一个 I/O 线程向主库请求更新的 `binlog`\n4. 主库创建一个 `binlog dump` 线程来发送 `binlog`，从库中的 I/O 线程负责接收\n5. 从库的 I/O 线程将接收的 `binlog` 写入到中继日志`relay log` 中。\n6. 从库的 SQL 线程读取中继日志`relay log` 同步数据到本地(也就是再执行一遍 SQL )。\n\n> `binlog`主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)\n> `relay log` 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。\n\n### 如何避免主从延迟\n主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。\n- 强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。\n- 延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。\n\n### 什么情况下会出现主从延迟\n主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：\n- 从库 I/O 线程接收 `binlog` 的速度跟不上主库写入 `binlog` 的速度，导致从库 `relay log` 的数据滞后于主库 `binlog` 的数据；\n- 从库 SQL 线程执行 `relay log` 的速度跟不上从库 I/O 线程接收 `binlog` 的速度，导致从库的数据滞后于从库 `relay log` 的数据。\n\n下面是一些可能导致主从延迟的原因及解决方案：\n1. 从库机器性能比主库差：从库接收 `binlog` 写入 `relay log` 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 \n2. 从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 `binlog` 接入到 `Hadoop`、`Elasticsearch` 等系统中。\n3. 大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。\n4. 从库太多：主库需要将 `binlog` 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。\n5. 网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 `binlog` 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。\n6. 单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。\n7. 复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 `semi-sync` 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。\n\n### MySQL分库分表✅\n分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。\n**分库**\n分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。\n- 垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。\n  - 如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。\n- 水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。\n  - 订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。\n\n**分表**\n分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。\n- 垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。\n- 水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。\n\n### 什么情况下需要分库分表\n- 单表的数据达到千万级别以上，数据库读写速度比较缓慢。\n- 数据库中的数据占用的空间越来越大，备份时间越来越长。\n- 应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。\n\n### 分片算法\n分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。\n\n常见的分片算法有：\n- 范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1~299999 的记录分到第一个表， 300000~599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。\n- 哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。\n- 地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。\n- 一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。\n\n### 分片键\n分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。\n\n### 分库分表会带来什么问题\n- 事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。\n- 跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 `GROUP BY`，`ORDER BY` 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。\n- 数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。\n- 。。。\n\n### 分库分表中数据如何迁移\n- 停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。\n- 双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。\n\n### MySQL数据冷热分离✅\n数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。\n\n**优缺点**\n- 优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)\n- 缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。\n\n### 冷数据和热数据\n- 热数据是指经常被访问和修改且需要快速访问的数据。\n- 冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。\n\n**冷热数据如何区分**\n1. 时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。\n   - 例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。\n2. 访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。\n   - 例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。\n\n### 冷数据如何迁移\n- 任务调度：可以利用 `xxl-job` 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。\n- 监听数据库的变更日志 `binlog` ：将满足冷数据条件的数据从 `binlog` 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。\n\n### 冷数据如何存储\n冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：\n- 中小厂：直接使用 MySQL/PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)\n- 大厂：Hbase(常用)、RocksDB、Doris、Cassandra\n\n### MySQL字符集\nMySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`\n\n### MySQL字符集层次级别\n- MySQL 中的字符集分为四个层次：\n  - server(MySQL 实例级别)\n  - database(库级别)\n  - table(表级别)\n  - column(字段级别)\n\n其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。\n\nMySQL 字符编码集中有两套 UTF-8 编码实现：\n- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n## Redis\nRedisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。\n\n### Redis为什么这么快\n- Redis 基于内存，内存的访问速度比磁盘快很多；\n- Redis 基于 `Reactor` 模式设计开发了一套高效的事件处理模型，主要是**单线程事件循环**和 **IO 多路复用**\n- Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。\n- Redis 通信协议实现简单且解析高效。\n\n### Redis/Memcached\n共同点：\n- 都是基于内存的数据库，一般都用来当做缓存使用。\n- 都有过期策略。\n- 两者的性能都非常高。\n\n区别：\n- Redis 支持更丰富的数据结构，如 `string`、`list`、`set`、`zset`、`hash` 等，而 Memcached 只支持 `key-value` 的数据结构。\n- Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。\n- Redis 支持集群模式，而 Memcached 不支持集群模式。\n- Redis 支持事务，而 Memcached 不支持事务。\n- Redis 支持发布订阅，而 Memcached 不支持发布订阅。\n- Redis 是单线程，而 Memcached 是多线程。\n\n### 为什么用Redis\n1. 高性能：Redis 是基于内存的，读写速度非常快。\n2. 高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。\n3. 功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！\n\n### 三种常用缓存读写策略\n**旁路缓存模式**(`Cache Aside Pattern`)\n适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n读：\n- 从 cache 中读取数据，读取到就直接返回\n- cache 中读取不到的话，就从 db 中读取数据返回\n- 把 db 中读取到的数据写入 cache 中。\n\n写：\n- 先更新 db\n- 再删除 cache 中的数据\n\n> 在写的过程中可以先删除cache，再更新 db 吗？\n> 不可以。这样可能会造成 数据库(db)和缓存(Cache)数据不一致的问题。\n> 如场景：请求 1 先写数据 A，请求 2 随后读数据 A。\n> 执行过程为：请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新\n> \n> 在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？\n> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\n> 如场景：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。\n> 执行过程为：请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A(此时缓存中无数据 A ，故不用执行删除缓存操作 ) -> 请求 1 将数据 A 写入 cache\n\n这种策略有一些缺陷：\n- 首次请求数据一定不在 cache 的问题\n  - 解决办法：可以将热点数据可以提前放入 cache 中。\n- 写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\n  - 解决办法：可以使用Write Through 或者 Write Behind 策略。\n**读写穿透**(`Read/Write Through Pattern`)\n服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n\n读：\n- 从 cache 中读取数据，读取到就直接返回。\n- 读取不到的话，先从 db 读取数据然后写入到cache 中，再返回。\n\n写：\n- 先查 cache，cache 中不存在，直接更新 db。\n- cache 中存在，则先更新 cache，然后 cache 服务自己更新 db(同步更新 cache 和 db)\n\n> 该模式也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\n\n**异步缓存写入**(`Write Behind Pattern`)\n\n`Write Behind Pattern` 和 `Read/Write Through Pattern` 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：`Read/Write Through` 是同步更新 cache 和 db，而 `Write Behind` 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\n\n> 应用场景：消息队列中消息的异步写入磁盘、MySQL 的 `Innodb Buffer Pool `机制都用到了这种策略。\n\n### Redis除了做缓存还有哪些应用场景\n- 分布式锁：基于 `Redisson` 来实现分布式锁。\n- 限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 `Redisson` 中的 `RRateLimiter` 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。\n- 消息队列：Redis 自带的 `List` 数据结构可以作为一个简单的队列使用。\n- 延时队列：`Redisson` 内置了延时队列(基于 `Sorted Set` 实现的)。\n- 分布式 `Session` ：利用 `String` 或者 `Hash` 数据类型保存 `Session` 数据，所有的服务器都可以访问。\n- 热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。\n\n### Redis可以做消息队列吗\n可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 `List` 来实现。Redis 2.0 之后，Redis 提供了 `PUBLISH` 和 `SUBSCRIBE` 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。\n\n和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。\n\n### Redis可以做搜索引擎吗\nRedis 是可以实现全文搜索引擎功能的，需要借助 `RediSearch`，这是一个基于 Redis 的搜索引擎模块。\n\n`RediSearch` 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 `Elasticsearch` 来说，`RediSearch` 有如下优势：\n- 性能更优秀：依赖 Redis 自身的高性能，基于内存操作(`Elasticsearch` 基于磁盘)。\n- 较低内存占用实现快速索引：`RediSearch` 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。\n\n`RediSearch` 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 `Elasticsearch`。\n- 数据量限制：`RedisSearch` 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。\n- 分布式能力较差：`RedisSearch` 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。`Elasticsearch` 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。\n- `RediSearch`聚合功能相较于 `Elasticsearch` 功能较弱。\n- 生态较差：`Elasticsearch` 可以轻松和常见的一些系统/软件集成比如 `Hadoop`、`Spark`、`Kibana`，而 `RedisSearch` 则不具备该优势。\n\n### 基于Redis实现延时任务✅\n> 类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？\n\n两种方案：\n1. Redis 过期事件监听 \n2. `Redisson` 内置的延时队列\n\nRedis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。\n`Redisson` 内置的延时队列具备下面这些优势：\n- 减少了丢消息的可能：`DelayedQueue` 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。\n- 消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。\n\n### Redis过期事件监听实现延时任务的原理\nRedis 2.0 引入了发布订阅 (`pub/sub`) 功能(其中有一个叫做 `channel`的概念)，涉及发布者(`publisher`)和订阅者(`subscriber`，也叫消费者)两个角色：\n- 发布者通过 `PUBLISH` 投递消息给指定 `channel`。\n- 订阅者通过`SUBSCRIBE`订阅它关心的 `channel`。并且，订阅者可以订阅一个或者多个 `channel`。\n\n在 `pub/sub` 模式下，生产者需要指定消息发送到哪个 `channel` 中，而消费者则订阅对应的 `channel` 以获取消息。\n\nRedis 中有很多默认的 `channel`，Redis 本身向它们发送一些消息，比如 `__keyevent@0__:expired`，这个 `channel` 用来监听 Redis 中的 key 过期事件。\n\n实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 `key` 过期时，Redis 会向 `__keyevent@0__:expired` 这个`channel`发送一条消息，这时候就可以在这个 `channel` 上监听到这个消息，从而实现延时任务。\n\n### Redis过期事件监听实现延时任务有什么缺陷\n1. 时效性差：过期事件消息是在 Redis 服务器删除 `key` 时发布的，而不是一个 `key` 过期之后就会就会直接发布。Redis 采用**定期删除+惰性/懒汉式删除**。 因此会存在设置了 `key` 的过期时间，但到了指定时间 `key` 还未被删除，进而没有发布过期事件的情况。\n2. 丢消息：Redis 的 `pub/sub` 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。\n3. 多服务实例下消息重复消费：pub/sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。\n\n### Redisson内置的延时队列实现延时任务的原理及优势\n可以借助 `Redisson` 内置的延时队列 `RDelayedQueue` 来实现延时任务功能。`RDelayedQueue` 基于 Redis 的 `SortedSet` 来实现，`SortedSet` 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 `SortedSet` 中，使用`zrangebyscore` 命令扫描 `SortedSet` 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 `SortedSet` 的轮询，提高了执行效率。\n\n`Redisson` 内置的延时队列具备下面这些优势：\n- 减少了丢消息的可能：`DelayedQueue` 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。\n- 消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。\n\n### Redis数据类型✅\n- 5种基本数据类型：\n| 数据类型 | 底层实现 |\n| :-------| :----- |\n| `String`(字符串) | `SDS`(简单动态字符串) |\n| `List`(列表) | `LinkedList`(双向链表)、`ZipList`(压缩列表)、`QuickList`(快速列表) |\n| `Hash`(哈希) | `Dict`(哈希表/字典)、`ZipList`(压缩列表) |\n| `Set`(集合) | `Dict`(哈希表/字典)、`Intset`(整数集合) |\n| `Zset`(有序集合) | `ZipList`(压缩列表)、`SkipList`(跳表) |\n- 3种特殊数据类型：\n    - `Bitmap`：位图\n    - `HyperLogLog`：基数统计\n    - `Geo`：地理位置\n\n\n### String\n`String` 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(`Simple Dynamic String，SDS`)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\n\n**常用命令**\n| 命令                            | 介绍                             |\n| ------------------------------- | -------------------------------- |\n| SET key value                   | 设置指定 key 的值                |\n| SETNX key value                 | 只有在 key 不存在时设置 key 的值 |\n| GET key                         | 获取指定 key 的值                |\n| MSET key1 value1 key2 value2 …… | 设置一个或多个指定 key 的值      |\n| MGET key1 key2 ...              | 获取一个或多个指定 key 的值      |\n| STRLEN key                      | 返回 key 所储存的字符串值的长度  |\n| INCR key                        | 将 key 中储存的数字值增一        |\n| DECR key                        | 将 key 中储存的数字值减一        |\n| EXISTS key                      | 判断指定 key 是否存在            |\n| DEL key(通用)                 | 删除指定的 key                   |\n| EXPIRE key seconds(通用)      | 给指定 key 设置过期时间          |\n\n**应用场景**\n`String` 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 `base64` 编码或者解码或者图片的路径)、序列化后的对象。\n\n### List\nRedis 的 `List` 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\n\n**常用命令**\n| 命令                        | 介绍                                       |\n| --------------------------- | ------------------------------------------ |\n| RPUSH key value1 value2 ... | 在指定列表的尾部(右边)添加一个或多个元素 |\n| LPUSH key value1 value2 ... | 在指定列表的头部(左边)添加一个或多个元素 |\n| LSET key index value        | 将指定列表索引 index 位置的值设置为 value  |\n| LPOP key                    | 移除并获取指定列表的第一个元素(最左边)     |\n| RPOP key                    | 移除并获取指定列表的最后一个元素(最右边)   |\n| LLEN key                    | 获取列表元素数量                           |\n| LRANGE key start end        | 获取列表 start 和 end 之间 的元素          |\n\n**应用场景**\n- 信息流展示，如最新文章、最新动态。\n- 消息队列，只是与专业的消息队列相比，`List` 功能较弱。\n\n### Hash\n `Hash` 是一个 `String` 类型的 `field-value`(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。\n\n`Hash` 类似于 JDK1.8 前的 `HashMap`，内部实现也差不多(数组 + 链表)，不过做了更多优化。\n\n**常用命令**\n| 命令                                      | 介绍                                                     |\n| ----------------------------------------- | -------------------------------------------------------- |\n| HSET key field value                      | 设置指定哈希表中指定字段的值                             |\n| HSETNX key field value                    | 只有指定字段不存在时设置指定字段的值                     |\n| HMSET key field1 value1 field2 value2 ... | 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 |\n| HGET key field                            | 获取指定哈希表中指定字段的值                             |\n| HMGET key field1 field2 ...               | 获取指定哈希表中一个或者多个指定字段的值                 |\n| HGETALL key                               | 获取指定哈希表中所有的键值对                             |\n| HEXISTS key field                         | 查看指定哈希表中指定的字段是否存在                       |\n| HDEL key field1 field2 ...                | 删除一个或多个哈希表字段                                 |\n| HLEN key                                  | 获取指定哈希表中字段的数量                               |\n| HINCRBY key field increment               | 对指定哈希中的指定字段做运算操作(正数为加，负数为减)   |\n\n**应用场景**\n- 存储对象，如用户信息、商品信息、文章信息、购物车信息.\n\n### Set\nSet 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 `HashSet` 。当需要存储无重复列表数据时，`Set` 是一个很好的选择，且 `Set` 提供了判断某个元素是否在其内的重要接口，这个也是 `List` 所不能提供的。\n\n**常用命令**\n| 命令                                  | 介绍                                      |\n| ------------------------------------- | ----------------------------------------- |\n| SADD key member1 member2 ...          | 向指定集合添加一个或多个元素              |\n| SMEMBERS key                          | 获取指定集合中的所有元素                  |\n| SCARD key                             | 获取指定集合的元素数量                    |\n| SISMEMBER key member                  | 判断指定元素是否在指定集合中              |\n| SINTER key1 key2 ...                  | 获取给定所有集合的交集                    |\n| SINTERSTORE destination key1 key2 ... | 将给定所有集合的交集存储在 destination 中 |\n| SUNION key1 key2 ...                  | 获取给定所有集合的并集                    |\n| SUNIONSTORE destination key1 key2 ... | 将给定所有集合的并集存储在 destination 中 |\n| SDIFF key1 key2 ...                   | 获取给定所有集合的差集                    |\n| SDIFFSTORE destination key1 key2 ...  | 将给定所有集合的差集存储在 destination 中 |\n| SPOP key count                        | 随机移除并获取指定集合中一个或多个元素    |\n| SRANDMEMBER key count                 | 随机获取指定集合中指定数量的元素          |\n\n**应用场景**\n- 存放无重复数据：如文章点赞、用户收藏、共同好友等。\n- 需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。\n- 随机获取数据源：如抽奖、随机推荐等。\n\n### Zset\n`Zset`相较于`Set`增加了一个权重参数 `score`，使得集合中的元素能够按 `score` 进行有序排列，还可以通过 `score` 的范围来获取元素的列表。\n\n**常用命令**\n| 命令                                          | 介绍                                                                                                          |\n| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| ZADD key score1 member1 score2 member2 ...    | 向指定有序集合添加一个或多个元素                                                                              |\n| ZCARD KEY                                     | 获取指定有序集合的元素数量                                                                                    |\n| ZSCORE key member                             | 获取指定有序集合中指定元素的 score 值                                                                         |\n| ZINTERSTORE destination numkeys key1 key2 ... | 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 |\n| ZUNIONSTORE destination numkeys key1 key2 ... | 求并集，其它和 ZINTERSTORE 类似                                                                               |\n| ZDIFFSTORE destination numkeys key1 key2 ...  | 求差集，其它和 ZINTERSTORE 类似                                                                               |\n| ZRANGE key start end                          | 获取指定有序集合 start 和 end 之间的元素(score 从低到高)                                                    |\n| ZREVRANGE key start end                       | 获取指定有序集合 start 和 end 之间的元素(score 从高到底)                                                    |\n| ZREVRANK key member                           | 获取指定有序集合中指定元素的排名(score 从大到小排序)                                                          |\n\n**应用场景**\n- 需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\n- 需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。\n\n### Bitmap\n`Bitmap`存储的是连续的二进制数据(1/0)，只需要一个 `bit` 位来表示某个元素对应的值或者状态，非常节省内存。可以将`Bitmap` 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 `offset`(偏移量)。\n\n**常用命令**\n| 命令                                  | 介绍                                                             |\n| ------------------------------------- | ---------------------------------------------------------------- |\n| SETBIT key offset value               | 设置指定 offset 位置的值                                         |\n| GETBIT key offset                     | 获取指定 offset 位置的值                                         |\n| BITCOUNT key start end                | 获取 start 和 end 之前值为 1 的元素个数                          |\n| BITOP operation destkey key1 key2 ... | 对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT |\n\n**应用场景**\n- 用户签到：每天签到的用户用一个 `bit` 位来表示，`offset` 为用户的 `id`，`value` 为签到状态(1/0)。\n- 用户在线状态：用一个 `bit` 位来表示用户的在线状态，`offset` 为用户的 `id`，`value` 为在线状态(1/0)。\n\n### HyperLogLog\n`HyperLogLog` 是一种基数统计算法，用于估计一个集合中不重复元素的个数。`HyperLogLog` 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。\n\n**常用命令**\n| 命令                                      | 介绍                                                                             |\n| ----------------------------------------- | -------------------------------------------------------------------------------- |\n| PFADD key element1 element2 ...           | 添加一个或多个元素到 HyperLogLog 中                                              |\n| PFCOUNT key1 key2                         | 获取一个或者多个 HyperLogLog 的唯一计数。                                        |\n| PFMERGE destkey sourcekey1 sourcekey2 ... | 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。 |\n\n**应用场景**\n- 数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。\n\n### Geospatial\n`Geospatial index`(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 `Sorted Set` 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\n\n**常用命令**\n| 命令                                             | 介绍                                                                                                 |\n| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------- |\n| GEOADD key longitude1 latitude1 member1 ...      | 添加一个或多个元素对应的经纬度信息到 GEO 中                                                          |\n| GEOPOS key member1 member2 ...                   | 返回给定元素的经纬度信息                                                                             |\n| GEODIST key member1 member2 M/KM/FT/MI           | 返回两个给定元素之间的距离                                                                           |\n| GEORADIUS key longitude latitude radius distance | 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数 |\n| GEORADIUSBYMEMBER key member radius distance     | 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素                                               |\n\n**应用场景**\n- 附近的人：根据用户的经纬度信息，获取附近的人。\n- 附近的商家：根据用户的经纬度信息，获取附近的商家。\n- 附近的车辆：根据用户的经纬度信息，获取附近的车辆。\n\n### 使用String存储对象还是Hash\n- `String` 存储的是序列化后的对象数据，存放的是整个对象。`Hash` 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 `Hash`。\n- `String` 存储相对来说更加节省内存，缓存相同数量的对象数据，`String` 消耗的内存约是 `Hash` 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用`String`。\n\n### 购物车信息用String还是Hash存储\n购物车中的商品频繁修改和变动，建议使用 `Hash`储存。\n- 用户 id 为 `key`\n- 商品 id 为 `field`，商品数量为 `value`\n\n具体维护：\n- 用户添加商品就是往 Hash 里面增加新的 field 与 value；\n- 查询购物车信息就是遍历对应的 Hash；\n- 更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；\n- 删除商品就是删除 Hash 中对应的 field；\n- 清空购物车直接删除对应的 key 即可。\n\n### Zset为什么要用跳表\n- 跳表 vs 平衡树\n  - 跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。\n- 跳表 vs 红黑树\n  - 跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。\n- 跳表 vs B+ 树\n  - B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。\n\n### 用Set实现抽奖系统\n- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。\n- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\n- `SRANDMEMBER key count`： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\n\n### Bitmap统计活跃用户\n用日期(精确到天)作为 `key`，用户 ID 为 `offset`，如果当日活跃过就设置为 1，否则为 0。通过 `BITCOUNT` 命令统计某个时间段内的活跃用户数。\n\n### HyperLogLog统计网站 UV\n- `PFADD PAGE_1:UV USER1 USER2 ...... USERn`：将访问指定页面的每个用户 ID 添加到 `HyperLogLog` 中。\n- `PFCOUNT PAGE_1:UV`：统计指定页面的 UV。\n\n### Redis持久化机制✅\n使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。\n\n### 为什么要持久化\n\n- 重用数据(比如重启机器、机器故障之后恢复数据)\n- 数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。\n\n### 三种持久化方式\n- 快照(`snapshotting`, RDB)\n- 只追加文件(`append-only file`, AOF)\n- RDB 和 AOF 的混合持久化(Redis 4.0 新增)\n\n### RDB持久化\nRedis通过创建快照获取存储在内存里面的数据在 **某个时间点** 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。\n\n### RDB创建时会阻塞主线程吗\n有两个命令生成 RDB 快照文件\n- `save`：同步保存操作，会阻塞 Redis 主线程； \n- `bgsave`：`fork` 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\n\n### AOF持久化\n与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 `server.aof_buf` 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(`fsync`策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。\n\n只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。\n\n### AOF工作流程\n1. 命令追加(`append`)：所有的写命令会追加到 AOF 缓冲区中。\n2. 文件写入(`write`)：将 AOF 缓冲区的数据写入到**系统内核缓冲区**中。这一步系统调用`write`函数，将数据写入到了**系统内核缓冲区**之后直接返回(延迟写)。\n3. 文件同步(`fsync`)：**系统内核缓冲区**根据对应的持久化方式(`fsync`策略)向硬盘做同步操作。这一步系统调用 `fsync` 函数， `fsync` 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。\n4. 文件重写(`rewrite`)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。\n5. 重启加载(`load`)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。\n\n![AOF工作流程](./image/Database-Interview/aof-work-process.png)\n\n### AOF持久化的三种同步策略\n即 `fsync` 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。\n- `appendfsync always`：主线程调用 `write` 执行写操作后，后台线程( `aof_fsync` 线程)立即会调用 `fsync` 函数同步 AOF 文件(刷盘)，`fsync` 完成后线程返回，这样会严重降低 Redis 的性能(`write + fsync`)。\n- `appendfsync everysec`：主线程调用 `write` 执行写操作后立即返回，由后台线程( `aof_fsync` 线程)每秒钟调用 `fsync` 函数同步一次 AOF 文件(`write+fsync`，`fsync`间隔为 1 秒)\n- `appendfsync no`：主线程调用 `write` 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(`write`但不`fsync`，`fsync` 的时机由操作系统决定)。\n\n> 刷盘：将内存中的数据写入到磁盘中。\n\n### AOF为什么是执行完命令后记录日志\n不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。\n- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；\n- 在命令执行完之后再记录，不会阻塞当前的命令执行。\n\n但也存在风险：\n- 如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； \n- 可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。\n\n### AOF重写\n当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\n\n重写期间，AOF维护一个**AOF重写缓冲区**，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将**AOF重写缓冲区**内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。\n\n可以配置如下参数：\n`auto-aof-rewrite-min-size`：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;\n`auto-aof-rewrite-percentage`：执行 AOF 重写时，当前 AOF 大小(`aof_current_size`)和上一次重写时 AOF 大小(`aof_base_size`)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。\n\n### AOF校验机制\nRedis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 `CRC64` 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。\n\nRedis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。\n\n### Redis4.0对持久化的优化\nRedis 4.0 开始支持 RDB 和 AOF 的混合持久化。\n\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。\n\n### 如何选择RDB和AOF\nRDB优势：\n- RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。\n- RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。\n\nAOF优势：\n- RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。\n- RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。\n- AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。\n\n综上：\n- Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。\n- 如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。\n- 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。\n\n### Redis单线程模型✅\nRedis 基于 `Reactor` 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(`file event handler`)，是单线程方式运行的，所以说 Redis 是单线程模型。\n\n### 如何监听大量客户端链接\n通过 **IO 多路复用程序** 来监听来自客户端的大量连接(或者说是监听多个 `socket`)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。\n\nI/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。\n\n文件事件处理器主要是包含 4 个部分：\n- 多个 socket(客户端连接)\n- IO 多路复用程序(支持多个客户端连接的关键)\n- 文件事件分派器(将 `socket` 关联到相应的事件处理器)\n- 事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)\n\n![文件事件处理器](./image/Database-Interview/redis-event-handler.png)\n\n### Redis4.0多线程\n在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。\n\n异步命令：\n- `UNLINK`：可以看作是 `DEL` 命令的异步版本。\n- `FLUSHALL ASYNC`：用于清空所有数据库的所有键，不限于当前 `SELECT` 的数据库。\n- `FLUSHDB ASYNC`：用于清空当前 `SELECT` 数据库中的所有键。\n\n总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。\n\n### Redis6.0之前为什么不用多线程\n- 单线程编程容易并且更容易维护；\n- Redis 的性能瓶颈不在 CPU ，主要在内存和网络；\n- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。\n\n### Redis6.0之后为何引入多线程\nRedis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。\n\n### Redis后台线程\nRedis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：\n- 通过 `bio_close_file` 后台线程来释放 AOF/RDB 等过程中产生的临时文件资源。\n- 通过 `bio_aof_fsync` 后台线程调用 `fsync` 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。\n- 通过 `bio_lazy_free`后台线程释放大对象(已删除)占用的内存空间.\n\n### Redis内存管理✅\n\n### Redis给缓存数据设置过期时间有啥用\n- 因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。\n- 某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。\n\n### Redis如何判断数据过期\nRedis 通过一个叫做**过期字典**(可以看作是 `hash` 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 `key`(键)，过期字典的值是一个 `long long` 类型的整数，这个整数保存了 `key` 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。\n\n在查询一个 `key` 的时候，Redis 首先检查该 `key` 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 `key` 是否过期，过期直接删除 `key` 然后返回 `null`。\n\n### Redis过期key删除策略\n- 惰性删除：只会在取出/查询 `key` 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 `key` 没有删除。\n- 定期删除：周期性地随机从设置了过期时间的 `key` 中抽查一批，然后逐个检查这些 `key` 是否过期，过期就删除 `key`。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。\n- 延迟队列：把设置过期时间的 `key` 放到一个延迟队列里，到期之后就删除 `key`。这样可保证每个过期 `key` 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。\n- 定时删除：每个设置了过期时间的 `key` 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。\n\nRedis 采用的是 **定期删除+惰性/懒汉式删除** 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。\n\n### 定期删除策略详细细节\n- Redis 默认每 100ms 检查 20 个随机的过期 `key`，如果有过期的 `key` 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 `key` 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。\n\n**大量key集中过期如何处理**\n如果大量 `key` 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：\n- 尽量避免 `key` 集中过期，在设置键的过期时间时尽量随机一点。\n- 对过期的 `key` 开启 `lazyfree` 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。\n\n### Redis内存淘汰策略✅\n当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：\n- `volatile-lru`(least recently used)：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最近最少使用的数据淘汰。\n- `volatile-ttl`：从已设置过期时间的数据集(`server.db[i].expires`)中挑选将要过期的数据淘汰。\n- `volatile-random`：从已设置过期时间的数据集(`server.db[i].expires`)中任意选择数据淘汰。\n- `allkeys-lru`(least recently used)：从数据集(`server.db[i].dict`)中移除最近最少使用的数据淘汰。\n- `allkeys-random`：从数据集(`server.db[i].dict`)中任意选择数据淘汰。\n- `no-eviction`(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。\n\n4.0 版本后增加以下两种：\n- `volatile-lfu`(least frequently used)：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最不经常使用的数据淘汰。\n- `allkeys-lfu`(least frequently used)：从数据集(`server.db[i].dict`)中移除最不经常使用的数据淘汰。\n\n`allkeys-xxx` 表示从所有的键值中淘汰数据，而 `volatile-xxx` 表示从设置了过期时间的键值中淘汰数据。\n\n### Redis事务\nRedis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。\n\n### 如何解决Redis事务的缺陷\n可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。\n\n### Redis性能优化✅\n\n### 批量操作减少网络传输\nRedis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。\n\n批量操作的三种方式\n- 原生批量操作：Redis 提供了一些原生的批量操作命令，如 `MSET`、`MGET`、`DEL` 等。\n- Pipeline：通过 `pipeline` 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。\n- Lua脚本：\n\n### 大量key集中过期\nRedis采用**定期删除+惰性/懒汉式删除**清理过期`key`。如果大量 `key` 集中过期的问题，客户端请求必须等待定期清理过期 `key` 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：\n- 给 `key` 设置随机过期时间。\n- 开启 `lazy-free`(惰性删除/延迟释放)，让 Redis 采用异步方式延迟释放 `key` 使用的内存，将删除`key`的操作该操作交给单独的子线程处理，避免阻塞主线程。\n\n### bigkey(大key)\n如果一个 `key` 对应的 `value` 所占用的内存比较大，那这个 `key` 就可以看作是 `bigkey`。`bigkey`的标准：\n- `String` 类型的 `value` 超过 1MB\n- 复合类型(`List`、`Hash`、`Set`、`Sorted Set` 等)的 `value` 包含的元素超过 5000 个(不过，对于复合类型的 `value` 来说，不一定包含的元素越多，占用的内存就越多)。\n\n**产生原因**\n- 程序设计不当，比如直接使用 `String` 类型存储较大的文件对应的二进制数据。\n- 对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。\n- 未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。\n\n**危害**\n- 单线程的Redis 在操作`bigkey` 时候比较耗时，造成客户端超时阻塞。\n- 网络拥塞：获取`bigkey`需要较多的流量。\n- 工作线程阻塞：如果使用 `del` 删除大 `key` 时，会阻塞工作线程，这样就没办法处理后续的命令。\n- `bigkey`会进一步影响主从同步。\n\n**bigkey发现**\n- `--bigkeys`：执行`redis-cli -p 6379 --bigkeys`扫描所有key，只能找到`top 1 bigkey`(占用内存最大的 `String` 数据类型，包含元素最多的复合数据类型)。\n- `SCAN+STRLEN/HLEN/LLEN`：Redis 自带的 `SCAN` 命令按指定模式扫描匹配的`key`，然后结合`STRLEN/HLEN/LLEN`返回`key`的长度或者成员数量。\n- 集合类型可以使用`MEMORY USAGE`\n- 借助开源工具分析 RDB 文件。如`redis-rdb-tools`、`rdb_bigkeys`\n- 使用公有云的 Redis 分析服务，如阿里云、腾讯云等。\n\n**处理bigkey**\n- 分割 `bigkey`：将`bigkey`分割为多个小 `key`。例如，将一个含有上万字段数量的 `Hash` 按照一定策略(比如二次哈希)拆分为多个 `Hash`。\n- 手动清理：Redis 4.0+ 可以使用 `UNLINK` 命令来异步删除一个或多个指定的 `key`。Redis 4.0 以下可以考虑使用 `SCAN` 命令结合 `DEL` 命令来分批次删除。\n- 采用合适的数据结构：例如，文件二进制数据不使用 `String` 保存、使用 `HyperLogLog` 统计页面 `UV`、`Bitmap` 保存状态信息(0/1)。\n- 开启 `lazy-free`(惰性删除/延迟释放)：`lazy-free` 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 `key` 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n也可以配合使用上述方法\n\n### hotkey(热key)\n如果一个 `key` 的访问次数比较多且明显多于其他 `key`，就可以看作是 `hotkey`。\n\n**产生原因**\n某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\n\n**危害**\n- `hotkey` 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。\n- 如果突然访问 `hotkey` 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n\n`hotkey` 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\n\n**发现hotkey**\n- `--hotkeys`：执行`redis-cli -p 6379 --hotkeys`命令\n- `MONITOR`： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。\n  - 可在合适的时机短暂执行 `MONITOR` 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 `hotkey`。\n- 根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 `hotkey`，比如突发的热点新闻事件等。\n- 使用公有云的 Redis 分析服务，如阿里云、腾讯云等。\n\n**处理hotkey**\n- 读写分离：主节点处理写请求，从节点处理读请求。\n- 使用 `Redis Cluster`：将热点数据分散存储在多个 Redis 节点上。\n- 二级缓存：`hotkey` 采用二级缓存的方式进行处理，将 `hotkey` 存放一份到 JVM 本地内存中(可以用 Caffeine)。\n- 使用公有云的 Redis 服务中的解决方案。\n\n也可以配合使用上述方法。\n\n### 慢查询命令\nRedis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如`KEYS *`、`HGETALL`等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。\n\n### Redis内存碎片✅\nRedis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。\n\n### 内存碎片产生原因\n1. Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n   - Redis 采用多种内存分配器分配内存，默认采用 `jemalloc`，其按照 2 的幂次方分配内存，可能会导致内存浪费。\n2. 频繁修改 Redis 中的数据也会产生内存碎片。\n\n### 查看内存碎片率\n使用 `info memory` 命令查看 Redis 内存碎片率。\n\n`mem_fragmentation_ratio` (内存碎片率)= `used_memory_rss` (操作系统实际分配给 Redis 的物理内存空间大小)/ `used_memory`(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)\n\n内粗碎片率越大，说明 Redis 中的内存碎片越多。`used_memory_rss` 减去 `used_memory` 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。\n\n通常内存碎片率`mem_fragmentation_ratio` > 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了\n\n### Redis内存碎片清理\n1. 重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。\n2. Redis4.0-RC3可以通过`config set activedefrag yes`开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。\n```bash\nconfig set activedefrag yes # 开启主动碎片整理功能\n\nconfig set active-defrag-ignore-bytes 500mb # 内存碎片占用空间达到 500mb 的时候开始清理\nconfig set active-defrag-threshold-lower 50 # 内存碎片率大于 1.5 的时候开始清理\n\nconfig set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不低于 20%\nconfig set active-defrag-cycle-max 50 # 内存碎片清理所占用 CPU 时间的比例不高于 50%\n```\n\n### Redis生产问题✅\n\n### 缓存穿透\n缓存穿透是大量请求的 `key` 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n**举例**\n某个黑客故意制造一些非法的 `key` 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n1. 做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n2. 缓存无效 `key`。短暂地缓存无效`key`，并设置一个较短的过期时间，这样就可以防止缓存穿透。\n3. 布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 `hash` 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。\n4. 接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。\n\n### 缓存击穿\n缓存击穿中，请求的 `key` 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n**举例**\n秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n1. 永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。\n2. 提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n3. 加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。\n\n### 缓存雪崩\n缓存雪崩是缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\n\n缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。\n\n**举例**\n数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。\n\n**解决方案**\n针对大量缓存同时失效的情况：\n1. 设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。\n2. 提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n3. 持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。\n\n针对 Redis 服务不可用的情况：\n1. Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。\n2. 多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。\n\n### 缓存穿透/缓存击穿区别\n- 缓存穿透中，请求的 `key` 既不存在于缓存中，也不存在于数据库中。\n- 缓存击穿中，请求的 `key` 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。\n\n### 缓存预热如何实现\n1. 使用定时任务，比如 `xxl-job`，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。\n2. 使用消息队列，比如 `Kafka`，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。\n\n### 缓存击穿/缓存雪崩区别\n缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。\n\n### Redis常见阻塞原因\n1. O(n)命令：如`KEYS *`(返回所有符合规则的 `key`)、`HGETALL`(会返回一个 `Hash` 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。\n2. `Save`创建RDB快照：`save` 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。\n3. AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。\n4. AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会`append`到AOF缓冲区，然后`write` 到系统内核缓冲区，最后 `fsync` 刷到磁盘。当磁盘压力太大的时候，会导致 `fsync` 操作发生阻塞，主线程调用 `write` 函数时也会被阻塞。\n5. AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。\n6. 查找和删除`bigkey`：查找`bigkey`时，Redis 会遍历所有的 `key`，这个操作是阻塞的。删除`bigkey`时，会先释放`bigkey`内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的`bigkey`，空闲内存块插入链表的操作就会阻塞主线程。\n7. 清空数据库：`flushall` 和 `flushdb` 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。\n8. CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\n9. 网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\n\n## mongodb\n\nMongoDB 是一个基于 **分布式文件存储** 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供**面向文档**的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 **文档类型数据库**。\n\n在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。\n\n### mongodb的存储结构是什么\n主要由三个单元组成：\n- 数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。\n- 集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(`Table`)。\n- 文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(`key-value`)组成，类似于关系型数据库中的行(`Row`)。\n\n**SQL 与 MongoDB 常见术语对比**：\n| SQL                      | MongoDB                         |\n| ------------------------ | ------------------------------- |\n| 表(Table)              | 集合(Collection)              |\n| 行(Row)                | 文档(Document)                |\n| 列(Col)                | 字段(Field)                   |\n| 主键(Primary Key)      | 对象 ID(Objectid)             |\n| 索引(Index)            | 索引(Index)                   |\n| 嵌套表(Embedded Table) | 嵌入式文档(Embedded Document) |\n| 数组(Array)            | 数组(Array)                   |\n\n**集合**\n集合存储于数据库中，**没有固定的结构**，也就是 **无模式** 的，这意味着可以往集合插入不同格式和类型的数据。\n\n集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。\n\n**文档**\nBSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。\n\n### mongodb特点\n- 数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。\n- 数据模型自由：不需要设计表结构，可以存储不同结构的文档。\n- 支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。\n- 支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。\n- 高效的二进制存储：文档以键值对的形式存储在集合中，键(`ObjectId`类型)唯一标识文件，值是以 BSON 形式存在。\n- 自带数据压缩功能：MongoDB 3.0 版本开始支持 `WiredTiger` 存储引擎，支持数据压缩，减少磁盘空间占用。\n- 支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。\n- 支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。\n- 支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。\n- 支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 `GridFS` 存储。\n\n### mongodb适合什么场景\nMongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。\n\n### mongodb存储引擎\nMongoDB 采用的是 **插件式的存储引擎架构**，现在主要使用两种存储引擎：\n- `MMAPv1` 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。\n- `WiredTiger` 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 `WiredTiger` 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。\n- `In-Memory` 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。\n\n### WiredTiger存储引擎\n`WiredTiger` 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。\n\n使用 B+ 树时，`WiredTiger` 以 `page` 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 `page`，共有三种类型的 `page`：\n- `root page`(根节点)：B+ 树的根节点。\n- `internal page`(内部节点)：不实际存储数据的中间索引节点。\n- `leaf page`(叶子节点)：真正存储数据的叶子节点，包含一个页头(`page header`)、块头(`block header`)和真正的数据(`key/value`)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 `checksum`、块在磁盘上的寻址位置等信息。\n\n### mongodb聚合\n将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：\n- 将来自多个文档的值组合在一起。 \n- 对集合中的数据进行的一系列运算。 \n- 分析数据随时间的变化。\n\n两种聚合方法：\n- 聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。\n- 单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 `count()`、`distinct()`、`estimatedDocumentCount()`。\n\n聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：\n- 接受一系列原始数据文档\n- 对这些文档进行一系列运算\n- 结果文档输出给下一个阶段\n\n### mongodb事务\n支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。\n\n### mongodb数据压缩\n借助 `WiredTiger` 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。`WiredTiger` 存储引擎支持以下压缩算法：\n- `snappy`：快速压缩算法，压缩比(3～5倍)较低，但速度快。\n- `zlib`：压缩比(5～7倍)较高，但速度较慢。\n- `Zstandard`：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。\n\n`WiredTiger` 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。\n\n### mongodb索引\n索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。\n\n索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。\n\n**索引类型**\n- 单字段索引：建立在单个字段上的索引。\n- 复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。\n- 多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。\n- 哈希索引：按数据的哈希值索引，用在哈希分片集群上。\n- 文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。\n- 地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。\n- 唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。\n- TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.\n\n### 复合索引中字段顺序\n复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。\n\n复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。\n\n> 有一个类似 `{a: 1, b: 1, c: 1, ..., z: 1}` 这样的索引，那么实际上也等于有了 `{a: 1}`、`{a: 1, b: 1}`、`{a: 1, b: 1, c: 1}` 等一系列索引，但是不会有 `{b: 1}` 这样的非左前缀的索引。\n\n### TTL索引\nTTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 `expireAfterSeconds`，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 `expireAfterSeconds` 属性外，和普通索引一样。\n\n数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。\n\n**原理**\n- MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。\n- 对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 `oplog` 做同步。\n\n**TTL索引限制**\n- TTL 索引是单字段索引。复合索引不支持 TTL\n- 如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。\n\n\n\n\n\n\n","slug":"数据库","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1y002nr7gn1lkie2gy","content":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"SQL-NoSQL基础\"><a href=\"#SQL-NoSQL基础\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL基础\"></a>SQL&#x2F;NoSQL基础</h2><h3 id=\"什么是SQL\"><a href=\"#什么是SQL\" class=\"headerlink\" title=\"什么是SQL\"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p>\n<h3 id=\"DB-DBMS-DBS-DBA\"><a href=\"#DB-DBMS-DBS-DBA\" class=\"headerlink\" title=\"DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA\"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul>\n<li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li>\n<li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"数据库术语\"><a href=\"#数据库术语\" class=\"headerlink\" title=\"数据库术语\"></a>数据库术语</h3><ul>\n<li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li>\n<li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li>\n<li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li>行(<code>row</code>)：表中的一个记录。</li>\n<li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性概念\"><a href=\"#元组-码-候选码-主码-外码-主属性-非主属性概念\" class=\"headerlink\" title=\"元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念\"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul>\n<li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p>\n<ul>\n<li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li>\n<li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<h3 id=\"数据库三范式\"><a href=\"#数据库三范式\" class=\"headerlink\" title=\"数据库三范式\"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。<ul>\n<li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li>\n</ul>\n</li>\n<li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li>\n<li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul>\n<li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul>\n<li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li>\n</ul>\n</li>\n<li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul>\n<li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li>\n</ul>\n</li>\n<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li>\n<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul>\n<li>例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主键-外键区别\"><a href=\"#主键-外键区别\" class=\"headerlink\" title=\"主键&#x2F;外键区别\"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>\n<h3 id=\"为什么不推荐使用外键和级联操作\"><a href=\"#为什么不推荐使用外键和级联操作\" class=\"headerlink\" title=\"为什么不推荐使用外键和级联操作\"></a>为什么不推荐使用外键和级联操作</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p>\n<ul>\n<li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；</li>\n<li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li>\n<li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li>\n</ul>\n<p><strong>外键好处</strong></p>\n<ul>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n</ul>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p>\n<p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<h3 id=\"DROP-TRUNCATE-DELETE区别\"><a href=\"#DROP-TRUNCATE-DELETE区别\" class=\"headerlink\" title=\"DROP&#x2F;TRUNCATE&#x2F;DELETE区别\"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol>\n<li>用法不同</li>\n</ol>\n<ul>\n<li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li>\n</ul>\n<p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p>\n<ol start=\"2\">\n<li>属于不同的数据库语言</li>\n</ol>\n<ul>\n<li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li>\n</ul>\n<ol start=\"3\">\n<li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li>\n</ol>\n<ul>\n<li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>DROP</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<h3 id=\"数据库设计分为哪几个步\"><a href=\"#数据库设计分为哪几个步\" class=\"headerlink\" title=\"数据库设计分为哪几个步\"></a>数据库设计分为哪几个步</h3><ol>\n<li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li>\n<li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li>数据库实施：包括编程、测试和试运行</li>\n<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>\n</ol>\n<h3 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p>\n<blockquote>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n</blockquote>\n<h3 id=\"SQL-NoSQL区别\"><a href=\"#SQL-NoSQL区别\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL区别\"></a>SQL&#x2F;NoSQL区别</h3><p>|         | SQL 数据库                                      | NoSQL 数据库                                                                                |<br>|：——–|———————————————-|——————————————————————————————|<br>| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |<br>| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |<br>| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |<br>| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |<br>| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |<br>| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |<br>| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |<br>| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |</p>\n<h3 id=\"NoSQL优劣\"><a href=\"#NoSQL优劣\" class=\"headerlink\" title=\"NoSQL优劣\"></a>NoSQL优劣</h3><p><strong>优点</strong></p>\n<ul>\n<li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li>\n<li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li>\n<li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li>\n<li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li>\n</ul>\n<h3 id=\"NoSQL分类\"><a href=\"#NoSQL分类\" class=\"headerlink\" title=\"NoSQL分类\"></a>NoSQL分类</h3><ul>\n<li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<h3 id=\"数据库分类\"><a href=\"#数据库分类\" class=\"headerlink\" title=\"数据库分类\"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p>\n<ul>\n<li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul>\n<li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li>\n</ul>\n</li>\n<li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul>\n<li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li>\n</ul>\n</li>\n<li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li>\n<li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li>\n</ul>\n<h3 id=\"SQL三种注释方式\"><a href=\"#SQL三种注释方式\" class=\"headerlink\" title=\"SQL三种注释方式\"></a>SQL三种注释方式</h3><ul>\n<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li>\n<li>多行注释：<code>/* 注释内容 */</code>。</li>\n<li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li>\n</ul>\n<h3 id=\"DML语句✅\"><a href=\"#DML语句✅\" class=\"headerlink\" title=\"DML语句✅\"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p>\n<h3 id=\"增删改查CRUD\"><a href=\"#增删改查CRUD\" class=\"headerlink\" title=\"增删改查CRUD\"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入完整的行</span></span><br><span class=\"line\"><span class=\"comment\">-- 插入一行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 插入多行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">12</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">18</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入行的一部分</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username, password, email)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入查询出来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> account;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> username<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span>, password<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 删除表中的指定数据</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;robot&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表中的数据</span></span><br><span class=\"line\"><span class=\"keyword\">TRUNCATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询数据</strong></p>\n<ul>\n<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>\n<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>\n<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>\n<li><code>ASC</code>：升序(默认)</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询单列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询多列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询所有列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询不同的值</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">vend_id <span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 限制查询结果</span></span><br><span class=\"line\"><span class=\"comment\">-- 返回前 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">0</span>, <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 返回第 3 ~ 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">2</span>, <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li>\n<li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> prod_price <span class=\"keyword\">DESC</span>, prod_name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>**<code>GROUP BY</code>**：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分组</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 分组后排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cust_name <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> NumberOfOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_email <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE-HAVING对比\"><a href=\"#WHERE-HAVING对比\" class=\"headerlink\" title=\"WHERE&#x2F;HAVING对比\"></a>WHERE&#x2F;HAVING对比</h3><ul>\n<li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li>\n<li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li>\n</ul>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>MYSQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   table1 [, table2 ]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  column_name operator</span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">    [<span class=\"keyword\">WHERE</span>])</span><br></pre></td></tr></table></figure></li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">      <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">      [<span class=\"keyword\">WHERE</span>]) <span class=\"keyword\">as</span> temp_table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  <span class=\"keyword\">condition</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, cust_contact</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> cust_id</span><br><span class=\"line\">                  <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\">                  <span class=\"keyword\">WHERE</span> order_num <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> order_num</span><br><span class=\"line\">                                      <span class=\"keyword\">FROM</span> orderitems</span><br><span class=\"line\">                                      <span class=\"keyword\">WHERE</span> prod_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SELECT语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">SET</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jack Jones&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- DELETE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>&lt;&gt;</code></td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>BETWEEN</code></td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td><code>LIKE</code></td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td><code>IN</code></td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"IN-BETWEEN\"><a href=\"#IN-BETWEEN\" class=\"headerlink\" title=\"IN&#x2F;BETWEEN\"></a>IN&#x2F;BETWEEN</h3><ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- IN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"keyword\">IN</span> (<span class=\"string\">&#x27;DLL01&#x27;</span>, <span class=\"string\">&#x27;BRS01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- BETWEEN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AND-OR-NOT\"><a href=\"#AND-OR-NOT\" class=\"headerlink\" title=\"AND&#x2F;OR&#x2F;NOT\"></a>AND&#x2F;OR&#x2F;NOT</h3><ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- AND示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">AND</span> prod_price <span class=\"operator\">&lt;=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- OR示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">OR</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;BRS01&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- NOT示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">NOT</span> <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- %示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%bean bag%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- _示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接JOIN\"><a href=\"#连接JOIN\" class=\"headerlink\" title=\"连接JOIN\"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> table1.column1, table2.column2...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> table2</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table1.common_column1 <span class=\"operator\">=</span> table2.common_column2; <span class=\"comment\">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JOIN....ON</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> c.cust_name, o.order_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers c</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Orders o</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.cust_id <span class=\"operator\">=</span> o.cust_id</span><br><span class=\"line\"><span class=\"comment\">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class=\"line\"><span class=\"comment\">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内连接-外连接\"><a href=\"#内连接-外连接\" class=\"headerlink\" title=\"内连接&#x2F;外连接\"></a>内连接&#x2F;外连接</h3><ul>\n<li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li>\n<li><code>外连接</code>：<ul>\n<li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li>\n<li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li>\n<li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">student表</span></span><br><span class=\"line\"><span class=\"comment\">student_id\tname</span></span><br><span class=\"line\"><span class=\"comment\">1\t        Alice</span></span><br><span class=\"line\"><span class=\"comment\">2\t        Bob</span></span><br><span class=\"line\"><span class=\"comment\">3\t        Carol</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">courses表</span></span><br><span class=\"line\"><span class=\"comment\">course_id\tstudent_id\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">101\t        1\t        Math</span></span><br><span class=\"line\"><span class=\"comment\">102\t        2\t        Science</span></span><br><span class=\"line\"><span class=\"comment\">103\t        4\t        History</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 内连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 左外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 右外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 全外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">FULL</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ON-WHERE区别\"><a href=\"#ON-WHERE区别\" class=\"headerlink\" title=\"ON&#x2F;WHERE区别\"></a>ON&#x2F;WHERE区别</h3><ul>\n<li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li>\n<li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li>\n</ul>\n<h3 id=\"组合UNION\"><a href=\"#组合UNION\" class=\"headerlink\" title=\"组合UNION\"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n<li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DDL语言✅\"><a href=\"#DDL语言✅\" class=\"headerlink\" title=\"DDL语言✅\"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p>\n<h3 id=\"数据库DATABSE\"><a href=\"#数据库DATABSE\" class=\"headerlink\" title=\"数据库DATABSE\"></a>数据库DATABSE</h3><ul>\n<li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li>\n<li>删除数据库：<code>DROP DATABASE 数据库名;</code></li>\n<li>选择数据库：<code>USE 数据库名;</code></li>\n<li>查看数据库：<code>SHOW DATABASES;</code></li>\n</ul>\n<h3 id=\"数据表TABLE\"><a href=\"#数据表TABLE\" class=\"headerlink\" title=\"数据表TABLE\"></a>数据表TABLE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 普通创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> (</span><br><span class=\"line\">id <span class=\"type\">int</span>(<span class=\"number\">10</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;Id&#x27;</span>,</span><br><span class=\"line\">username <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">password <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">email <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱&#x27;</span></span><br><span class=\"line\">) COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 根据已有表创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> vip_user <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"comment\">-- ALTER用于修改表</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> age <span class=\"type\">int</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\">MODIFY <span class=\"keyword\">COLUMN</span> age tinyint;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"视图VIEW\"><a href=\"#视图VIEW\" class=\"headerlink\" title=\"视图VIEW\"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p>\n<p>作用：</p>\n<ul>\n<li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li>\n<li>提高数据安全性：用来限制用户访问敏感数据。</li>\n<li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li>\n<li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> top_10_user_view <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, username</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">&lt;</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除视图</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引INDEX\"><a href=\"#索引INDEX\" class=\"headerlink\" title=\"索引INDEX\"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">table</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX user_index(id)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p>\n<p><strong>约束类型</strong></p>\n<ul>\n<li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li>\n<li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>：保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Users (</span><br><span class=\"line\">  Id <span class=\"type\">INT</span>(<span class=\"number\">10</span>) UNSIGNED <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增Id&#x27;</span>,</span><br><span class=\"line\">  Username <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">  Password <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">  Email <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱地址&#x27;</span>,</span><br><span class=\"line\">  Enabled TINYINT(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;是否有效&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (Id)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"TCL语句✅\"><a href=\"#TCL语句✅\" class=\"headerlink\" title=\"TCL语句✅\"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h3 id=\"事务TRANSACTION\"><a href=\"#事务TRANSACTION\" class=\"headerlink\" title=\"事务TRANSACTION\"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p>\n<p><strong>事务的四个特性(ACID)</strong></p>\n<ul>\n<li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li>\n<li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<blockquote>\n<p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开始事务</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 A</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">SAVEPOINT</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 B</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 回滚到保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> <span class=\"keyword\">TO</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务，只有操作 A 生效</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DCL语句✅\"><a href=\"#DCL语句✅\" class=\"headerlink\" title=\"DCL语句✅\"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p>\n<h3 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h3><ul>\n<li>授予用户帐户权限，用<code>GRANT</code>命令。<ul>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ul>\n</li>\n<li>撤销用户的权限，用<code>REVOKE</code>命令。<ul>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ul>\n</li>\n</ul>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- GRANT用法</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> privilege,[privilege],.. <span class=\"keyword\">ON</span> privilege_level</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span> [IDENTIFIED <span class=\"keyword\">BY</span> password]</span><br><span class=\"line\">[REQUIRE tsl_option]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> [GRANT_OPTION <span class=\"operator\">|</span> resource_option]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- REVOKE用法</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> privilege_type [(column_list)]</span><br><span class=\"line\">       [, priv_type [(column_list)]]...</span><br><span class=\"line\"><span class=\"keyword\">ON</span> [object_type] privilege_level</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> [, <span class=\"keyword\">user</span>]...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建账户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> myuser IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;mypassword&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 修改账户名</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;newuser&#x27;</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;myuser&#x27;</span>;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"><span class=\"comment\">-- 删除账户</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 查看权限</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> GRANTS <span class=\"keyword\">FOR</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 授予权限</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 更改密码</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> PASSWORD <span class=\"keyword\">FOR</span> myuser <span class=\"operator\">=</span> <span class=\"string\">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"游标CURSOR\"><a href=\"#游标CURSOR\" class=\"headerlink\" title=\"游标CURSOR\"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<h3 id=\"触发器TRIGGER\"><a href=\"#触发器TRIGGER\" class=\"headerlink\" title=\"触发器TRIGGER\"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n</ul>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>：将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>：从表中删除数据后激活。</li>\n</ul>\n<p><code>NEW</code> 和 <code>OLD</code>：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li>\n</ul>\n<h3 id=\"触发器语法\"><a href=\"#触发器语法\" class=\"headerlink\" title=\"触发器语法\"></a>触发器语法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name</span><br><span class=\"line\">trigger_time</span><br><span class=\"line\">trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">trigger_statements</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li><code>trigger_name</code>：触发器名</li>\n<li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\">DELIMITER $</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> `trigger_insert_user`</span><br><span class=\"line\">AFTER <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (NEW.id, <span class=\"string\">&#x27;add a user&#x27;</span>,  now());</span><br><span class=\"line\"><span class=\"keyword\">END</span> $</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看触发器</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TRIGGERS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p>\n<h3 id=\"MySQL基础✅\"><a href=\"#MySQL基础✅\" class=\"headerlink\" title=\"MySQL基础✅\"></a>MySQL基础✅</h3><h3 id=\"MySQL优点\"><a href=\"#MySQL优点\" class=\"headerlink\" title=\"MySQL优点\"></a>MySQL优点</h3><ul>\n<li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ul>\n<h3 id=\"什么是关系型数据库\"><a href=\"#什么是关系型数据库\" class=\"headerlink\" title=\"什么是关系型数据库\"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p>\n<h3 id=\"MySQL字段类型\"><a href=\"#MySQL字段类型\" class=\"headerlink\" title=\"MySQL字段类型\"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p>\n<ul>\n<li>数值类型：<ul>\n<li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li>\n<li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li>\n<li>定点数：<code>DECIMAL</code>。</li>\n</ul>\n</li>\n<li>字符串类型：<ul>\n<li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li>\n<li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li>\n</ul>\n</li>\n<li>日期和时间类型：<ul>\n<li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"整数类型的UNSIGNED属性\"><a href=\"#整数类型的UNSIGNED属性\" class=\"headerlink\" title=\"整数类型的UNSIGNED属性\"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>\n<blockquote>\n<p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p>\n</blockquote>\n<p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h3 id=\"CHAR-VARCHAR区别\"><a href=\"#CHAR-VARCHAR区别\" class=\"headerlink\" title=\"CHAR&#x2F;VARCHAR区别\"></a>CHAR&#x2F;VARCHAR区别</h3><ul>\n<li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li>\n<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li>\n<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>\n<li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li>\n</ul>\n<h3 id=\"VARCHAR-100-VARCHAR-10-区别\"><a href=\"#VARCHAR-100-VARCHAR-10-区别\" class=\"headerlink\" title=\"VARCHAR(100)&#x2F;VARCHAR(10)区别\"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul>\n<li>前者最大长度为 100，后者最大长度为 10。</li>\n<li>二者存储相同的字符串所占用的存储空间是一样的。</li>\n<li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li>\n</ul>\n<h3 id=\"DECIMAL和FLOAT-DOUBLE区别\"><a href=\"#DECIMAL和FLOAT-DOUBLE区别\" class=\"headerlink\" title=\"DECIMAL和FLOAT&#x2F;DOUBLE区别\"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p>\n<h3 id=\"为什么没不推荐使用TEXT-BLOB类型\"><a href=\"#为什么没不推荐使用TEXT-BLOB类型\" class=\"headerlink\" title=\"为什么没不推荐使用TEXT&#x2F;BLOB类型\"></a>为什么没不推荐使用TEXT&#x2F;BLOB类型</h3><ul>\n<li><code>TEXT</code>用于存储长文本数据，如博客数据。</li>\n<li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li>\n</ul>\n<p>这两种类型有如下缺陷：</p>\n<ul>\n<li>不能有默认值。</li>\n<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。</li>\n<li>检索效率较低。</li>\n<li>不能直接创建索引，需要指定前缀长度。</li>\n<li>可能会消耗大量的网络和 IO 带宽。</li>\n<li>可能导致表上的 DML 操作变慢。</li>\n</ul>\n<h3 id=\"DATETIME-TIMESTAMP区别\"><a href=\"#DATETIME-TIMESTAMP区别\" class=\"headerlink\" title=\"DATETIME&#x2F;TIMESTAMP区别\"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul>\n<li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li>\n<li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul>\n<li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li>\n</ul>\n</li>\n<li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li>\n</ul>\n<h3 id=\"NULL和’’区别\"><a href=\"#NULL和’’区别\" class=\"headerlink\" title=\"NULL和’’区别\"></a>NULL和’’区别</h3><ul>\n<li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul>\n<li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li>\n</ul>\n</li>\n<li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li>\n<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>\n<li><code>NULL</code> 会影响聚合函数的结果。<ul>\n<li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>\n</ul>\n</li>\n</ul>\n<p>不推荐使用<code>NULL</code>作为列默认值。</p>\n<h3 id=\"Boolean类型如何在MySQL中存储\"><a href=\"#Boolean类型如何在MySQL中存储\" class=\"headerlink\" title=\"Boolean类型如何在MySQL中存储\"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p>\n<h3 id=\"MySQL基础架构✅\"><a href=\"#MySQL基础架构✅\" class=\"headerlink\" title=\"MySQL基础架构✅\"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li>\n<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎，其中 <code>InnoDB</code> 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 <code>InnoDB</code>，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li>\n</ul>\n<p><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<ul>\n<li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li>查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。</li>\n<li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li>优化器：按照 MySQL 认为最优的方案去执行。</li>\n<li>执行器：执行语句，然后从存储引擎返回数据。</li>\n<li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<ol>\n<li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>\n</li>\n<li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n</li>\n<li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p>\n<ul>\n<li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 SELECT，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>\n<li>第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</li>\n</ul>\n</li>\n<li><p>优化器。<br>优化器以它认为的最优的执行方案去执行(有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解)，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n</li>\n<li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n</li>\n</ol>\n<h3 id=\"SQL语句在MySQL中的执行过程\"><a href=\"#SQL语句在MySQL中的执行过程\" class=\"headerlink\" title=\"SQL语句在MySQL中的执行过程\"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验(如果命中缓存)—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tb_student  A <span class=\"keyword\">WHERE</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;18&#x27;</span> <span class=\"keyword\">AND</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接返回，如果没有，执行下一步。</li>\n<li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询<code>SELECT</code>，提取需要查询的表名为 <code>tb_student</code>，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n<li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul>\n<li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li>\n<li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。</li>\n</ul>\n</li>\n<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>\n</ol>\n<p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—<code>redo log</code>(<code>prepare</code> 状态)—&gt;<code>binlog</code>—&gt;<code>redo log</code>(<code>commit</code> 状态)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> tb_student A <span class=\"keyword\">SET</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;19&#x27;</span> <span class=\"keyword\">WHERE</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p>\n<ol>\n<li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li>\n<li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li>\n<li>更新完成。</li>\n</ol>\n<h3 id=\"MySQL存储引擎✅\"><a href=\"#MySQL存储引擎✅\" class=\"headerlink\" title=\"MySQL存储引擎✅\"></a>MySQL存储引擎✅</h3><h3 id=\"MySQL支持哪些存储引擎？\"><a href=\"#MySQL支持哪些存储引擎？\" class=\"headerlink\" title=\"MySQL支持哪些存储引擎？\"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p>\n<p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p>\n<h3 id=\"MySQL存储引擎架构\"><a href=\"#MySQL存储引擎架构\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。</p>\n<h3 id=\"MyISAM-InnoDB存储引擎区别\"><a href=\"#MyISAM-InnoDB存储引擎区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB存储引擎区别\"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul>\n<li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>\n<li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>(可重读)隔离级别是可以解决幻读问题发生的(基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>)。</li>\n<li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li>\n<li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li>\n<li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li>\n<li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li>\n<li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li>\n<li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池(<code>Buffer Pool</code>)缓存数据页和索引页，<code>MyISAM</code> 使用键缓存(<code>Key Cache</code>)仅缓存索引页而不缓存数据页。</li>\n</ul>\n<h3 id=\"MySQL索引✅\"><a href=\"#MySQL索引✅\" class=\"headerlink\" title=\"MySQL索引✅\"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyIsam</code>，都使用了 <strong>B+树</strong>作为索引结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h3 id=\"索引底层数据类型选型\"><a href=\"#索引底层数据类型选型\" class=\"headerlink\" title=\"索引底层数据类型选型\"></a>索引底层数据类型选型</h3><ol>\n<li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(<code>Adaptive Hash Index</code>)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p>\n</li>\n<li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p>\n</li>\n<li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p>\n</li>\n<li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p>\n</li>\n<li><p>B树&amp;B+树<br>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced (平衡)的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br><strong>B树&amp;B+树区别</strong></p>\n</li>\n</ol>\n<ul>\n<li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li>\n<li>B 树的叶子节点都是独立的;</li>\n<li>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>\n</ul>\n<p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>\n<h3 id=\"MyISAM-InnoDB索引区别\"><a href=\"#MyISAM-InnoDB索引区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB索引区别\"></a>MyISAM&#x2F;InnoDB索引区别</h3><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p>\n<ul>\n<li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。</li>\n<li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>按照数据结构维度划分：</p>\n<ul>\n<li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li>\n<li>哈希索引：类似键值对的形式，一次即可定位。</li>\n</ul>\n<p>按照底层存储方式角度划分：</p>\n<ul>\n<li>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>\n<li>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。<code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>\n</ul>\n<p>按照应用维度划分：</p>\n<ul>\n<li>主键索引：加速查询 + 列值唯一(不可以有 <code>NULL</code>)+ 表中只有一个。</li>\n<li>普通索引：仅加速查询。</li>\n<li>唯一索引：加速查询 + 列值唯一(可以有 <code>NULL</code>)。</li>\n<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的索引新特性：</p>\n<ul>\n<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。</li>\n<li>降序索引：之前的版本就支持通过 <code>DESC</code> 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 <code>GROUP BY</code> 语句进行隐式排序。</li>\n<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p>\n<p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p>\n<h3 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h3><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p>\n<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>\n<ul>\n<li>唯一索引(<code>Unique Key</code>)：唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li>普通索引(<code>Index</code>)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li>\n<li>前缀索引(<code>Prefix</code>)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>\n<li>全文索引(<code>Full Text</code>)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li>\n</ul>\n<h3 id=\"聚簇索引-非聚簇索引\"><a href=\"#聚簇索引-非聚簇索引\" class=\"headerlink\" title=\"聚簇索引&#x2F;非聚簇索引\"></a>聚簇索引&#x2F;非聚簇索引</h3><p>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>\n<li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li>\n<li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<p>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>\n<p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据</li>\n<li>可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ul>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p>\n<h3 id=\"覆盖索引-联合索引\"><a href=\"#覆盖索引-联合索引\" class=\"headerlink\" title=\"覆盖索引&#x2F;联合索引\"></a>覆盖索引&#x2F;联合索引</h3><ul>\n<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n</ul>\n<h3 id=\"联合索引最左前缀匹配原则\"><a href=\"#联合索引最左前缀匹配原则\" class=\"headerlink\" title=\"联合索引最左前缀匹配原则\"></a>联合索引最左前缀匹配原则</h3><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>\n<h3 id=\"索引下推ICP\"><a href=\"#索引下推ICP\" class=\"headerlink\" title=\"索引下推ICP\"></a>索引下推ICP</h3><p>索引下推(<code>Index Condition Pushdown,ICP</code>) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p>\n<p><strong>原理</strong><br><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p>\n<p>索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> zipcode <span class=\"operator\">=</span> <span class=\"string\">&#x27;431200&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span>(birthdate) <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li>\n<li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li>\n</ul>\n<p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p>\n<h3 id=\"MySQL查询缓存✅\"><a href=\"#MySQL查询缓存✅\" class=\"headerlink\" title=\"MySQL查询缓存✅\"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p>查询缓存不命中的情况：</p>\n<ul>\n<li>两个查询在任何字符上的不同都会导致缓存不命中。</li>\n<li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n</ul>\n<p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p>\n<h3 id=\"MySQL三大日志✅\"><a href=\"#MySQL三大日志✅\" class=\"headerlink\" title=\"MySQL三大日志✅\"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>(归档日志)和事务日志 <code>redo log</code>(重做日志)和 <code>undo log</code>(回滚日志)。</p>\n<p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h3><p><code>redo log</code>(重做日志)是 <code>InnoDB</code> 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p>\n<p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(<code>redo log buffer</code>)里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<h3 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h3><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p>\n<ul>\n<li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li>\n<li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>\n<li><code>Checkpoint</code>(检查点)：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>\n<li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li>\n<li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</li>\n</ul>\n<h3 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h3><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p>\n<ul>\n<li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li>\n<li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li>\n<li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>(文件系统缓存)。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>默认策略为第二种。</p>\n<h3 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p>\n<p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h3><p><code>binlog</code> 有三种记录格式：</p>\n<ul>\n<li><code>Statement</code>：记录的是 SQL 语句，如 <code>UPDATE t SET c=c+1 WHERE id=2</code>。<ul>\n<li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li>\n</ul>\n</li>\n<li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul>\n<li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li>\n</ul>\n</li>\n<li><code>Mixed</code>：记录的是上面两种的混合模式。<ul>\n<li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</p>\n<p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p>\n<ul>\n<li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul>\n<li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li>\n</ul>\n</li>\n<li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li>\n<li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul>\n<li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p><code>redo log</code>(重做日志)让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>(归档日志)保证了 MySQL 集群架构的数据一致性。</p>\n<p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p>\n<p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p>\n<p>为了解决数据不一致问题，<code>InnoDB</code> 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p>\n<ul>\n<li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li>\n<li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li>\n</ul>\n<p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p>\n<p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p><code>undo log</code> 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p>\n<p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p>\n<p><code>undo log</code> 采用 <code>segment</code>(段)进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理(<code>purge</code>)的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p>\n<h3 id=\"MySQL事务✅\"><a href=\"#MySQL事务✅\" class=\"headerlink\" title=\"MySQL事务✅\"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<h3 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h3><ul>\n<li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性(Consistency)：执行事务前后，数据保持一致。</li>\n<li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<blockquote>\n<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>\n</blockquote>\n<h3 id=\"并发事务存在的问题\"><a href=\"#并发事务存在的问题\" class=\"headerlink\" title=\"并发事务存在的问题\"></a>并发事务存在的问题</h3><h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p>\n<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>解决：</p>\n<ul>\n<li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li>\n</ul>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>解决：</p>\n<ul>\n<li>乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li>\n<li>悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li>\n</ul>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p>\n<p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li>\n</ul>\n<h3 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h3><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p>\n<p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>\n<li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li>\n</ul>\n<h3 id=\"不可重复读和幻读有什么区别\"><a href=\"#不可重复读和幻读有什么区别\" class=\"headerlink\" title=\"不可重复读和幻读有什么区别\"></a>不可重复读和幻读有什么区别</h3><ul>\n<li>不可重复读：多次读取同一数据，发现数据不一致。</li>\n<li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p>\n<ul>\n<li>解决不可重复读：执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>解决幻读：执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>\n</ul>\n<h3 id=\"并发事务的控制方式有哪些\"><a href=\"#并发事务的控制方式有哪些\" class=\"headerlink\" title=\"并发事务的控制方式有哪些\"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制(<code>MVCC，Multiversion concurrency control</code>)可以看作是乐观控制的模式。</p>\n<ul>\n<li>锁：<ul>\n<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>\n<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>\n</ul>\n</li>\n<li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p>\n<blockquote>\n<p>注意：不论是表级锁还是行级锁，都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)这两类。</p>\n</blockquote>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、<code>read view</code>、<code>undo log</code>。</p>\n<ul>\n<li><code>undo log</code>：<code>undo log</code> 用于记录某行数据的多个版本的数据。</li>\n<li><code>read view</code> 和 隐藏字段： 用来判断当前版本数据的可见性。</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n<th align=\"center\">实现方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">READ-UNCOMMITTED</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">READ-COMMITTED</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁</td>\n</tr>\n<tr>\n<td align=\"center\">REPEATABLE-READ</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td>\n</tr>\n<tr>\n<td align=\"center\">SERIALIZABLE</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">基于 锁</td>\n</tr>\n</tbody></table>\n<p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p>\n<p><code>InnoDB</code> 实现的 <code>REPEATABLE-READ</code> 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p>\n<ul>\n<li>快照读：由 <code>MVCC</code> 机制来保证不出现幻读。</li>\n<li>当前读：使用 <code>Next-Key Lock</code> 进行加锁来保证不出现幻读，<code>Next-Key Lock</code> 是行锁(<code>Record Lock</code>)和间隙锁(<code>Gap Lock</code>)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li>\n</ul>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code> ，不过 <code>InnoDB</code> 存储引擎默认使用 <code>REPEATABLE-READ</code>，这并不会有任何性能损失。<code>InnoDB</code> 存储引擎在分布式事务的情况下一般会用到 <code>SERIALIZABLE</code> 隔离级别。</p>\n<h3 id=\"MVCC✅\"><a href=\"#MVCC✅\" class=\"headerlink\" title=\"MVCC✅\"></a>MVCC✅</h3><p>多版本并发控制(<code>Multi-Version Concurrency Control, MVCC</code>) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，<code>MVCC</code> 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>\n<ol>\n<li><p>读操作(<code>SELECT</code>)<br>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：</p>\n<ul>\n<li>对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li>\n<li>如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li>\n<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li>\n</ul>\n</li>\n<li><p>写操作(<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>)<br>当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：</p>\n<ul>\n<li>对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>\n<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li>\n<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li>\n</ul>\n</li>\n<li><p>事务提交和回滚</p>\n<ul>\n<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>\n<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>\n</ul>\n</li>\n<li><p>版本回收<br>为了防止数据库中的版本无限增长，<code>MVCC</code> 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p>\n</li>\n</ol>\n<p><code>MVCC</code> 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>\n<h3 id=\"一致性非锁定读\"><a href=\"#一致性非锁定读\" class=\"headerlink\" title=\"一致性非锁定读\"></a>一致性非锁定读</h3><p>一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。</p>\n<p><code>InnoDB</code>中，<code>MVCC</code>就是对一致性非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(<code>snapshot read</code>)。</p>\n<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>SELECT</code> 语句(不包括 <code>SELECT ... lock in share mode</code> ，<code>SELECT ... FOR UPDATE</code>)则会使用一致性非锁定读(<code>MVCC</code>)。<code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p>\n<h3 id=\"锁定读-当前读\"><a href=\"#锁定读-当前读\" class=\"headerlink\" title=\"锁定读&#x2F;当前读\"></a>锁定读&#x2F;当前读</h3><p>在锁定读下，读取的是数据的最新版本。下面语句都是锁定读&#x2F;当前读，会对读取到的记录加锁。</p>\n<ul>\n<li><code>SELECT ... lock in share mode</code>： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。</li>\n<li><code>SELECT ... FOR UPDATE</code>： 对读取到记录加排他锁，其他事务不能任何锁。</li>\n<li><code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作：对读取到记录加排他锁，其他事务不能任何锁。</li>\n</ul>\n<p>当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以<code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据。</p>\n<h3 id=\"InnoDB的MVCC实现\"><a href=\"#InnoDB的MVCC实现\" class=\"headerlink\" title=\"InnoDB的MVCC实现\"></a>InnoDB的MVCC实现</h3><p><code>MVCC</code> 的实现依赖于：隐藏字段、<code>Read View</code>、<code>undo log</code>。在内部实现中，<code>InnoDB</code> 通过数据行隐藏字段的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p>\n<p><strong>隐藏字段</strong><br>InnoDB为每行数据添加了三个隐藏字段：</p>\n<ul>\n<li><code>DB_TRX_ID</code>：表示最后一次更新或插入操作的事务ID。<code>DELETE</code>操作也被视为更新。</li>\n<li><code>DB_ROLL_PTR</code>：指向该行<code>undo log</code> 日志的指针。</li>\n<li><code>DB_ROW_ID</code>：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 <code>DB_ROW_ID</code> 作为聚簇索引。</li>\n</ul>\n<p><strong>Read View</strong><br><code>Read View</code> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。</p>\n<ul>\n<li><code>m_low_limit_id</code>(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>\n<li><code>m_up_limit_id</code>(上限事务ID)：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>\n<li><code>m_ids</code>(活跃事务列表)：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务(正在内存中)</li>\n<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>\n</ul>\n<p><strong>undo log</strong><br>其有两个作用：</p>\n<ul>\n<li>事务回滚时用于将数据恢复到修改前的样子</li>\n<li><code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前版本的快照数据，以此实现非锁定读</li>\n</ul>\n<h3 id=\"RC和RR隔离级别下MVCC的差异\"><a href=\"#RC和RR隔离级别下MVCC的差异\" class=\"headerlink\" title=\"RC和RR隔离级别下MVCC的差异\"></a>RC和RR隔离级别下MVCC的差异</h3><ul>\n<li><code>Read Committed</code>：<code>MVCC</code> 会在每次<code>SELECT</code>读取数据时创建一个新的 <code>Read View</code>(<code>m_ids</code>列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 <code>Read View</code>，因此会导致一些不可重复读问题。</li>\n<li><code>Repeatable Read</code>：<code>MVCC</code> 会在事务开始后第一次 <code>SELECT</code>创建一个 <code>Read View</code>，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。</li>\n</ul>\n<h3 id=\"RR隔离级别下的MVCC如何解决幻读\"><a href=\"#RR隔离级别下的MVCC如何解决幻读\" class=\"headerlink\" title=\"RR隔离级别下的MVCC如何解决幻读\"></a>RR隔离级别下的MVCC如何解决幻读</h3><p><code>MVCC</code>+<code>Next-key-Lock</code> 防止幻读</p>\n<ul>\n<li>执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>\n<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>\n</ul>\n</li>\n<li>执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等当前读<ul>\n<li>当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL锁✅\"><a href=\"#MySQL锁✅\" class=\"headerlink\" title=\"MySQL锁✅\"></a>MySQL锁✅</h3><h3 id=\"表级锁-行级锁区别\"><a href=\"#表级锁-行级锁区别\" class=\"headerlink\" title=\"表级锁&#x2F;行级锁区别\"></a>表级锁&#x2F;行级锁区别</h3><ul>\n<li><p>表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，<code>MyISAM</code> 和 <code>InnoDB</code> 引擎都支持表级锁。</p>\n</li>\n<li><p>行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p>\n</li>\n<li><p><code>MyISAM</code> 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p>\n</li>\n<li><p><code>InnoDB</code> 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 <code>InnoDB</code>的并发性能更高</p>\n</li>\n</ul>\n<h3 id=\"InnoDB的行级锁\"><a href=\"#InnoDB的行级锁\" class=\"headerlink\" title=\"InnoDB的行级锁\"></a>InnoDB的行级锁</h3><ul>\n<li>记录锁(<code>Record Lock</code>)：也被称为记录锁，属于单个行记录上的锁。</li>\n<li>间隙锁(<code>Gap Lock</code>)：锁定一个范围，不包括记录本身。</li>\n<li>临键锁(<code>Next-Key Lock</code>)：<code>Record Lock</code>+<code>Gap Lock</code>，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>\n</ul>\n<h3 id=\"共享锁-排他锁\"><a href=\"#共享锁-排他锁\" class=\"headerlink\" title=\"共享锁&#x2F;排他锁\"></a>共享锁&#x2F;排他锁</h3><p>表级锁和行级锁都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)两类。</p>\n<ul>\n<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>\n<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>\n</ul>\n<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 </p>\n<p>由于有<code>MVCC</code>机制，对于一般的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加任何锁。</p>\n<h3 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h3><p>意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。</p>\n<p>意向锁是表级锁，有两种：</p>\n<ul>\n<li>意向共享锁(<code>Intention Shared Lock</code>，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。</li>\n<li>意向排他锁(<code>Intention Exclusive Lock</code>，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。</li>\n</ul>\n<p>意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，<code>InnoDB</code> 会先获取该数据行所在在数据表的对应意向锁。</p>\n<p>意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。</p>\n<h3 id=\"当前读-快照读区别\"><a href=\"#当前读-快照读区别\" class=\"headerlink\" title=\"当前读&#x2F;快照读区别\"></a>当前读&#x2F;快照读区别</h3><ul>\n<li>当前读(一致性锁定读)：执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code><ul>\n<li>当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>\n</ul>\n</li>\n<li>快照读(一致性非锁定读)：执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>\n<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL性能优化✅\"><a href=\"#MySQL性能优化✅\" class=\"headerlink\" title=\"MySQL性能优化✅\"></a>MySQL性能优化✅</h3><h3 id=\"可以用MySQL存储文件吗？\"><a href=\"#可以用MySQL存储文件吗？\" class=\"headerlink\" title=\"可以用MySQL存储文件吗？\"></a>可以用MySQL存储文件吗？</h3><p>可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。</p>\n<h3 id=\"MySQL如何存储IP地址\"><a href=\"#MySQL如何存储IP地址\" class=\"headerlink\" title=\"MySQL如何存储IP地址\"></a>MySQL如何存储IP地址</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：</p>\n<ul>\n<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code>：把整型的 ip 转为地址</li>\n</ul>\n<p>存储数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，取出数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>\n<h3 id=\"如何分析SQL性能\"><a href=\"#如何分析SQL性能\" class=\"headerlink\" title=\"如何分析SQL性能\"></a>如何分析SQL性能</h3><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<h3 id=\"MySQL执行计划✅\"><a href=\"#MySQL执行计划✅\" class=\"headerlink\" title=\"MySQL执行计划✅\"></a>MySQL执行计划✅</h3><p>执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> dept_emp <span class=\"keyword\">WHERE</span> emp_no <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> emp_no <span class=\"keyword\">FROM</span> dept_emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> emp_no <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(emp_no)<span class=\"operator\">&gt;</span><span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> id <span class=\"operator\">|</span> select_type <span class=\"operator\">|</span> <span class=\"keyword\">table</span>    <span class=\"operator\">|</span> partitions <span class=\"operator\">|</span> type  <span class=\"operator\">|</span> possible_keys   <span class=\"operator\">|</span> key     <span class=\"operator\">|</span> key_len <span class=\"operator\">|</span> <span class=\"keyword\">ref</span>  <span class=\"operator\">|</span> <span class=\"keyword\">rows</span>   <span class=\"operator\">|</span> filtered <span class=\"operator\">|</span> Extra       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">1</span> <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span>     <span class=\"operator\">|</span> dept_emp <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>       <span class=\"operator\">|</span> <span class=\"keyword\">ALL</span>   <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>            <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"number\">331143</span> <span class=\"operator\">|</span>   <span class=\"number\">100.00</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> <span class=\"keyword\">where</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">2</span> <span class=\"operator\">|</span> SUBQUERY    <span class=\"operator\">|</span> dept_emp <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>       <span class=\"operator\">|</span> index <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span>,dept_no <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> <span class=\"operator\">|</span> <span class=\"number\">16</span>      <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"number\">331143</span> <span class=\"operator\">|</span>   <span class=\"number\">100.00</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> index <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>\n<p>各列含义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>SELECT 查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT 关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>所选索引的长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>附加信息</td>\n</tr>\n</tbody></table>\n<p><strong>type(重要)</strong><br>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code><br>常见的几种类型具体含义如下：</p>\n<ul>\n<li><code>system</code>：如果表使用的引擎对于表行数统计是精确的(如：<code>MyISAM</code>)，且表中只有一行记录的情况下，访问方法是 <code>system</code>，是 <code>const</code> 的一种特例。</li>\n<li><code>const</code>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>\n<li><code>eq_ref</code>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 <code>system</code> 与 <code>const</code> 之外最好的 <code>JOIN</code> 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>\n<li><code>ref</code>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>\n<li><code>index_merge</code>：当查询条件使用了多个索引时，表示开启了 <code>Index Merge</code> 优化，此时执行计划中的 <code>key</code> 列列出了使用到的索引。</li>\n<li><code>range</code>：对索引列进行范围查询，执行计划中的 <code>key</code> 列表示哪个索引被使用了。</li>\n<li><code>index</code>：查询遍历了整棵索引树，与 <code>ALL</code> 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>\n<li><code>ALL</code>：全表扫描。</li>\n</ul>\n<p><strong>key(重要)</strong><br><code>key</code> 列表示 MySQL 实际使用到的索引。如果为 <code>NULL</code>，则表示未用到索引。</p>\n<p><strong>Extra(重要)</strong></p>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><code>Using filesort</code>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><code>Using temporary</code>：MySQL 需要创建临时表来存储查询的结果，常见于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</li>\n<li><code>Using index</code>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><code>Using index condition</code>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><code>Using where</code>：表明查询使用了 <code>WHERE</code> 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><code>Using join buffer (Block Nested Loop)</code>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 <code>join buffer</code> 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>当 <code>Extra</code> 列包含 <code>Using filesort</code> 或 <code>Using temporary</code> 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h3 id=\"MySQL读写分离✅\"><a href=\"#MySQL读写分离✅\" class=\"headerlink\" title=\"MySQL读写分离✅\"></a>MySQL读写分离✅</h3><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。</p>\n<p>一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>\n<h3 id=\"如何实现读写分离\"><a href=\"#如何实现读写分离\" class=\"headerlink\" title=\"如何实现读写分离\"></a>如何实现读写分离</h3><ol>\n<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>\n<li>保证主数据库和从数据库之间的数据是实时同步的，即主从复制。</li>\n<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>\n</ol>\n<p>基于项目层面有两种方案：</p>\n<ol>\n<li>代理方式<br>可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。</li>\n<li>组件方式<br>可以通过引入第三方组件来实现读写分离，例如使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</li>\n</ol>\n<h3 id=\"主从复制原理\"><a href=\"#主从复制原理\" class=\"headerlink\" title=\"主从复制原理\"></a>主从复制原理</h3><p>MySQL 主从复制是依赖于 <code>binlog</code> 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 <code>canal</code>)的底层一般也是依赖 <code>binlog</code>。具体如下：</p>\n<ol>\n<li>主库将数据库中数据的变化写入到 <code>binlog</code></li>\n<li>从库连接主库</li>\n<li>从库创建一个 I&#x2F;O 线程向主库请求更新的 <code>binlog</code></li>\n<li>主库创建一个 <code>binlog dump</code> 线程来发送 <code>binlog</code>，从库中的 I&#x2F;O 线程负责接收</li>\n<li>从库的 I&#x2F;O 线程将接收的 <code>binlog</code> 写入到中继日志<code>relay log</code> 中。</li>\n<li>从库的 SQL 线程读取中继日志<code>relay log</code> 同步数据到本地(也就是再执行一遍 SQL )。</li>\n</ol>\n<blockquote>\n<p><code>binlog</code>主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)<br><code>relay log</code> 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。</p>\n</blockquote>\n<h3 id=\"如何避免主从延迟\"><a href=\"#如何避免主从延迟\" class=\"headerlink\" title=\"如何避免主从延迟\"></a>如何避免主从延迟</h3><p>主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。</p>\n<ul>\n<li>强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。</li>\n<li>延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。</li>\n</ul>\n<h3 id=\"什么情况下会出现主从延迟\"><a href=\"#什么情况下会出现主从延迟\" class=\"headerlink\" title=\"什么情况下会出现主从延迟\"></a>什么情况下会出现主从延迟</h3><p>主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：</p>\n<ul>\n<li>从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度跟不上主库写入 <code>binlog</code> 的速度，导致从库 <code>relay log</code> 的数据滞后于主库 <code>binlog</code> 的数据；</li>\n<li>从库 SQL 线程执行 <code>relay log</code> 的速度跟不上从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度，导致从库的数据滞后于从库 <code>relay log</code> 的数据。</li>\n</ul>\n<p>下面是一些可能导致主从延迟的原因及解决方案：</p>\n<ol>\n<li>从库机器性能比主库差：从库接收 <code>binlog</code> 写入 <code>relay log</code> 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 </li>\n<li>从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 <code>binlog</code> 接入到 <code>Hadoop</code>、<code>Elasticsearch</code> 等系统中。</li>\n<li>大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。</li>\n<li>从库太多：主库需要将 <code>binlog</code> 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。</li>\n<li>网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 <code>binlog</code> 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。</li>\n<li>单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。</li>\n<li>复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 <code>semi-sync</code> 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。</li>\n</ol>\n<h3 id=\"MySQL分库分表✅\"><a href=\"#MySQL分库分表✅\" class=\"headerlink\" title=\"MySQL分库分表✅\"></a>MySQL分库分表✅</h3><p>分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。<br><strong>分库</strong><br>分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>\n<ul>\n<li>垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。<ul>\n<li>如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</li>\n</ul>\n</li>\n<li>水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。<ul>\n<li>订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。</li>\n</ul>\n</li>\n</ul>\n<p><strong>分表</strong><br>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>\n<ul>\n<li>垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。</li>\n<li>水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</li>\n</ul>\n<h3 id=\"什么情况下需要分库分表\"><a href=\"#什么情况下需要分库分表\" class=\"headerlink\" title=\"什么情况下需要分库分表\"></a>什么情况下需要分库分表</h3><ul>\n<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>\n<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>\n<li>应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。</li>\n</ul>\n<h3 id=\"分片算法\"><a href=\"#分片算法\" class=\"headerlink\" title=\"分片算法\"></a>分片算法</h3><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>\n<p>常见的分片算法有：</p>\n<ul>\n<li>范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1<del>299999 的记录分到第一个表， 300000</del>599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。</li>\n<li>哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。</li>\n<li>地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。</li>\n<li>一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</li>\n</ul>\n<h3 id=\"分片键\"><a href=\"#分片键\" class=\"headerlink\" title=\"分片键\"></a>分片键</h3><p>分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。</p>\n<h3 id=\"分库分表会带来什么问题\"><a href=\"#分库分表会带来什么问题\" class=\"headerlink\" title=\"分库分表会带来什么问题\"></a>分库分表会带来什么问题</h3><ul>\n<li>事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。</li>\n<li>跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 <code>GROUP BY</code>，<code>ORDER BY</code> 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。</li>\n<li>数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。</li>\n<li>。。。</li>\n</ul>\n<h3 id=\"分库分表中数据如何迁移\"><a href=\"#分库分表中数据如何迁移\" class=\"headerlink\" title=\"分库分表中数据如何迁移\"></a>分库分表中数据如何迁移</h3><ul>\n<li>停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。</li>\n<li>双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。</li>\n</ul>\n<h3 id=\"MySQL数据冷热分离✅\"><a href=\"#MySQL数据冷热分离✅\" class=\"headerlink\" title=\"MySQL数据冷热分离✅\"></a>MySQL数据冷热分离✅</h3><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>\n<p><strong>优缺点</strong></p>\n<ul>\n<li>优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)</li>\n<li>缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。</li>\n</ul>\n<h3 id=\"冷数据和热数据\"><a href=\"#冷数据和热数据\" class=\"headerlink\" title=\"冷数据和热数据\"></a>冷数据和热数据</h3><ul>\n<li>热数据是指经常被访问和修改且需要快速访问的数据。</li>\n<li>冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</li>\n</ul>\n<p><strong>冷热数据如何区分</strong></p>\n<ol>\n<li>时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。<ul>\n<li>例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li>\n</ul>\n</li>\n<li>访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。<ul>\n<li>例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"冷数据如何迁移\"><a href=\"#冷数据如何迁移\" class=\"headerlink\" title=\"冷数据如何迁移\"></a>冷数据如何迁移</h3><ul>\n<li>任务调度：可以利用 <code>xxl-job</code> 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li>\n<li>监听数据库的变更日志 <code>binlog</code> ：将满足冷数据条件的数据从 <code>binlog</code> 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li>\n</ul>\n<h3 id=\"冷数据如何存储\"><a href=\"#冷数据如何存储\" class=\"headerlink\" title=\"冷数据如何存储\"></a>冷数据如何存储</h3><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：</p>\n<ul>\n<li>中小厂：直接使用 MySQL&#x2F;PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)</li>\n<li>大厂：Hbase(常用)、RocksDB、Doris、Cassandra</li>\n</ul>\n<h3 id=\"MySQL字符集\"><a href=\"#MySQL字符集\" class=\"headerlink\" title=\"MySQL字符集\"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p>\n<h3 id=\"MySQL字符集层次级别\"><a href=\"#MySQL字符集层次级别\" class=\"headerlink\" title=\"MySQL字符集层次级别\"></a>MySQL字符集层次级别</h3><ul>\n<li>MySQL 中的字符集分为四个层次：<ul>\n<li>server(MySQL 实例级别)</li>\n<li>database(库级别)</li>\n<li>table(表级别)</li>\n<li>column(字段级别)</li>\n</ul>\n</li>\n</ul>\n<p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>\n<h3 id=\"Redis为什么这么快\"><a href=\"#Redis为什么这么快\" class=\"headerlink\" title=\"Redis为什么这么快\"></a>Redis为什么这么快</h3><ul>\n<li>Redis 基于内存，内存的访问速度比磁盘快很多；</li>\n<li>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环</strong>和 <strong>IO 多路复用</strong></li>\n<li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li>\n<li>Redis 通信协议实现简单且解析高效。</li>\n</ul>\n<h3 id=\"Redis-Memcached\"><a href=\"#Redis-Memcached\" class=\"headerlink\" title=\"Redis&#x2F;Memcached\"></a>Redis&#x2F;Memcached</h3><p>共同点：</p>\n<ul>\n<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>Redis 支持更丰富的数据结构，如 <code>string</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code> 等，而 Memcached 只支持 <code>key-value</code> 的数据结构。</li>\n<li>Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。</li>\n<li>Redis 支持集群模式，而 Memcached 不支持集群模式。</li>\n<li>Redis 支持事务，而 Memcached 不支持事务。</li>\n<li>Redis 支持发布订阅，而 Memcached 不支持发布订阅。</li>\n<li>Redis 是单线程，而 Memcached 是多线程。</li>\n</ul>\n<h3 id=\"为什么用Redis\"><a href=\"#为什么用Redis\" class=\"headerlink\" title=\"为什么用Redis\"></a>为什么用Redis</h3><ol>\n<li>高性能：Redis 是基于内存的，读写速度非常快。</li>\n<li>高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。</li>\n<li>功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</li>\n</ol>\n<h3 id=\"三种常用缓存读写策略\"><a href=\"#三种常用缓存读写策略\" class=\"headerlink\" title=\"三种常用缓存读写策略\"></a>三种常用缓存读写策略</h3><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。<br>读：</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回</li>\n<li>cache 中读取不到的话，就从 db 中读取数据返回</li>\n<li>把 db 中读取到的数据写入 cache 中。</li>\n</ul>\n<p>写：</p>\n<ul>\n<li>先更新 db</li>\n<li>再删除 cache 中的数据</li>\n</ul>\n<blockquote>\n<p>在写的过程中可以先删除cache，再更新 db 吗？<br>不可以。这样可能会造成 数据库(db)和缓存(Cache)数据不一致的问题。<br>如场景：请求 1 先写数据 A，请求 2 随后读数据 A。<br>执行过程为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>\n<p>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？<br>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。<br>如场景：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。<br>执行过程为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A(此时缓存中无数据 A ，故不用执行删除缓存操作 ) -&gt; 请求 1 将数据 A 写入 cache</p>\n</blockquote>\n<p>这种策略有一些缺陷：</p>\n<ul>\n<li>首次请求数据一定不在 cache 的问题<ul>\n<li>解决办法：可以将热点数据可以提前放入 cache 中。</li>\n</ul>\n</li>\n<li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。<ul>\n<li>解决办法：可以使用Write Through 或者 Write Behind 策略。<br><strong>读写穿透</strong>(<code>Read/Write Through Pattern</code>)<br>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li>\n</ul>\n</li>\n</ul>\n<p>读：</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回。</li>\n<li>读取不到的话，先从 db 读取数据然后写入到cache 中，再返回。</li>\n</ul>\n<p>写：</p>\n<ul>\n<li>先查 cache，cache 中不存在，直接更新 db。</li>\n<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db(同步更新 cache 和 db)</li>\n</ul>\n<blockquote>\n<p>该模式也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>\n</blockquote>\n<p><strong>异步缓存写入</strong>(<code>Write Behind Pattern</code>)</p>\n<p><code>Write Behind Pattern</code> 和 <code>Read/Write Through Pattern</code> 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：<code>Read/Write Through</code> 是同步更新 cache 和 db，而 <code>Write Behind</code> 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>\n<blockquote>\n<p>应用场景：消息队列中消息的异步写入磁盘、MySQL 的 <code>Innodb Buffer Pool </code>机制都用到了这种策略。</p>\n</blockquote>\n<h3 id=\"Redis除了做缓存还有哪些应用场景\"><a href=\"#Redis除了做缓存还有哪些应用场景\" class=\"headerlink\" title=\"Redis除了做缓存还有哪些应用场景\"></a>Redis除了做缓存还有哪些应用场景</h3><ul>\n<li>分布式锁：基于 <code>Redisson</code> 来实现分布式锁。</li>\n<li>限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 <code>Redisson</code> 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>\n<li>消息队列：Redis 自带的 <code>List</code> 数据结构可以作为一个简单的队列使用。</li>\n<li>延时队列：<code>Redisson</code> 内置了延时队列(基于 <code>Sorted Set</code> 实现的)。</li>\n<li>分布式 <code>Session</code> ：利用 <code>String</code> 或者 <code>Hash</code> 数据类型保存 <code>Session</code> 数据，所有的服务器都可以访问。</li>\n<li>热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。</li>\n</ul>\n<h3 id=\"Redis可以做消息队列吗\"><a href=\"#Redis可以做消息队列吗\" class=\"headerlink\" title=\"Redis可以做消息队列吗\"></a>Redis可以做消息队列吗</h3><p>可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 <code>List</code> 来实现。Redis 2.0 之后，Redis 提供了 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。</p>\n<p>和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>\n<h3 id=\"Redis可以做搜索引擎吗\"><a href=\"#Redis可以做搜索引擎吗\" class=\"headerlink\" title=\"Redis可以做搜索引擎吗\"></a>Redis可以做搜索引擎吗</h3><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <code>RediSearch</code>，这是一个基于 Redis 的搜索引擎模块。</p>\n<p><code>RediSearch</code> 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 <code>Elasticsearch</code> 来说，<code>RediSearch</code> 有如下优势：</p>\n<ul>\n<li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作(<code>Elasticsearch</code> 基于磁盘)。</li>\n<li>较低内存占用实现快速索引：<code>RediSearch</code> 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li>\n</ul>\n<p><code>RediSearch</code> 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 <code>Elasticsearch</code>。</p>\n<ul>\n<li>数据量限制：<code>RedisSearch</code> 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。</li>\n<li>分布式能力较差：<code>RedisSearch</code> 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。<code>Elasticsearch</code> 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。</li>\n<li><code>RediSearch</code>聚合功能相较于 <code>Elasticsearch</code> 功能较弱。</li>\n<li>生态较差：<code>Elasticsearch</code> 可以轻松和常见的一些系统&#x2F;软件集成比如 <code>Hadoop</code>、<code>Spark</code>、<code>Kibana</code>，而 <code>RedisSearch</code> 则不具备该优势。</li>\n</ul>\n<h3 id=\"基于Redis实现延时任务✅\"><a href=\"#基于Redis实现延时任务✅\" class=\"headerlink\" title=\"基于Redis实现延时任务✅\"></a>基于Redis实现延时任务✅</h3><blockquote>\n<p>类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？</p>\n</blockquote>\n<p>两种方案：</p>\n<ol>\n<li>Redis 过期事件监听 </li>\n<li><code>Redisson</code> 内置的延时队列</li>\n</ol>\n<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。<br><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>\n<ul>\n<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>\n<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>\n</ul>\n<h3 id=\"Redis过期事件监听实现延时任务的原理\"><a href=\"#Redis过期事件监听实现延时任务的原理\" class=\"headerlink\" title=\"Redis过期事件监听实现延时任务的原理\"></a>Redis过期事件监听实现延时任务的原理</h3><p>Redis 2.0 引入了发布订阅 (<code>pub/sub</code>) 功能(其中有一个叫做 <code>channel</code>的概念)，涉及发布者(<code>publisher</code>)和订阅者(<code>subscriber</code>，也叫消费者)两个角色：</p>\n<ul>\n<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 <code>channel</code>。</li>\n<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 <code>channel</code>。并且，订阅者可以订阅一个或者多个 <code>channel</code>。</li>\n</ul>\n<p>在 <code>pub/sub</code> 模式下，生产者需要指定消息发送到哪个 <code>channel</code> 中，而消费者则订阅对应的 <code>channel</code> 以获取消息。</p>\n<p>Redis 中有很多默认的 <code>channel</code>，Redis 本身向它们发送一些消息，比如 <code>__keyevent@0__:expired</code>，这个 <code>channel</code> 用来监听 Redis 中的 key 过期事件。</p>\n<p>实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 <code>key</code> 过期时，Redis 会向 <code>__keyevent@0__:expired</code> 这个<code>channel</code>发送一条消息，这时候就可以在这个 <code>channel</code> 上监听到这个消息，从而实现延时任务。</p>\n<h3 id=\"Redis过期事件监听实现延时任务有什么缺陷\"><a href=\"#Redis过期事件监听实现延时任务有什么缺陷\" class=\"headerlink\" title=\"Redis过期事件监听实现延时任务有什么缺陷\"></a>Redis过期事件监听实现延时任务有什么缺陷</h3><ol>\n<li>时效性差：过期事件消息是在 Redis 服务器删除 <code>key</code> 时发布的，而不是一个 <code>key</code> 过期之后就会就会直接发布。Redis 采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>。 因此会存在设置了 <code>key</code> 的过期时间，但到了指定时间 <code>key</code> 还未被删除，进而没有发布过期事件的情况。</li>\n<li>丢消息：Redis 的 <code>pub/sub</code> 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。</li>\n<li>多服务实例下消息重复消费：pub&#x2F;sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。</li>\n</ol>\n<h3 id=\"Redisson内置的延时队列实现延时任务的原理及优势\"><a href=\"#Redisson内置的延时队列实现延时任务的原理及优势\" class=\"headerlink\" title=\"Redisson内置的延时队列实现延时任务的原理及优势\"></a>Redisson内置的延时队列实现延时任务的原理及优势</h3><p>可以借助 <code>Redisson</code> 内置的延时队列 <code>RDelayedQueue</code> 来实现延时任务功能。<code>RDelayedQueue</code> 基于 Redis 的 <code>SortedSet</code> 来实现，<code>SortedSet</code> 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 <code>SortedSet</code> 中，使用<code>zrangebyscore</code> 命令扫描 <code>SortedSet</code> 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 <code>SortedSet</code> 的轮询，提高了执行效率。</p>\n<p><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>\n<ul>\n<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>\n<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>\n</ul>\n<h3 id=\"Redis数据类型✅\"><a href=\"#Redis数据类型✅\" class=\"headerlink\" title=\"Redis数据类型✅\"></a>Redis数据类型✅</h3><ul>\n<li>5种基本数据类型：<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">底层实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>String</code>(字符串)</td>\n<td align=\"left\"><code>SDS</code>(简单动态字符串)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>List</code>(列表)</td>\n<td align=\"left\"><code>LinkedList</code>(双向链表)、<code>ZipList</code>(压缩列表)、<code>QuickList</code>(快速列表)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Hash</code>(哈希)</td>\n<td align=\"left\"><code>Dict</code>(哈希表&#x2F;字典)、<code>ZipList</code>(压缩列表)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Set</code>(集合)</td>\n<td align=\"left\"><code>Dict</code>(哈希表&#x2F;字典)、<code>Intset</code>(整数集合)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Zset</code>(有序集合)</td>\n<td align=\"left\"><code>ZipList</code>(压缩列表)、<code>SkipList</code>(跳表)</td>\n</tr>\n</tbody></table>\n</li>\n<li>3种特殊数据类型：<ul>\n<li><code>Bitmap</code>：位图</li>\n<li><code>HyperLogLog</code>：基数统计</li>\n<li><code>Geo</code>：地理位置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p><code>String</code> 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(<code>Simple Dynamic String，SDS</code>)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SET key value</td>\n<td>设置指定 key 的值</td>\n</tr>\n<tr>\n<td>SETNX key value</td>\n<td>只有在 key 不存在时设置 key 的值</td>\n</tr>\n<tr>\n<td>GET key</td>\n<td>获取指定 key 的值</td>\n</tr>\n<tr>\n<td>MSET key1 value1 key2 value2 ……</td>\n<td>设置一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>MGET key1 key2 …</td>\n<td>获取一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>STRLEN key</td>\n<td>返回 key 所储存的字符串值的长度</td>\n</tr>\n<tr>\n<td>INCR key</td>\n<td>将 key 中储存的数字值增一</td>\n</tr>\n<tr>\n<td>DECR key</td>\n<td>将 key 中储存的数字值减一</td>\n</tr>\n<tr>\n<td>EXISTS key</td>\n<td>判断指定 key 是否存在</td>\n</tr>\n<tr>\n<td>DEL key(通用)</td>\n<td>删除指定的 key</td>\n</tr>\n<tr>\n<td>EXPIRE key seconds(通用)</td>\n<td>给指定 key 设置过期时间</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong><br><code>String</code> 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 <code>base64</code> 编码或者解码或者图片的路径)、序列化后的对象。</p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>Redis 的 <code>List</code> 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RPUSH key value1 value2 …</td>\n<td>在指定列表的尾部(右边)添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LPUSH key value1 value2 …</td>\n<td>在指定列表的头部(左边)添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LSET key index value</td>\n<td>将指定列表索引 index 位置的值设置为 value</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并获取指定列表的第一个元素(最左边)</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并获取指定列表的最后一个元素(最右边)</td>\n</tr>\n<tr>\n<td>LLEN key</td>\n<td>获取列表元素数量</td>\n</tr>\n<tr>\n<td>LRANGE key start end</td>\n<td>获取列表 start 和 end 之间 的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>信息流展示，如最新文章、最新动态。</li>\n<li>消息队列，只是与专业的消息队列相比，<code>List</code> 功能较弱。</li>\n</ul>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p> <code>Hash</code> 是一个 <code>String</code> 类型的 <code>field-value</code>(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。</p>\n<p><code>Hash</code> 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)，不过做了更多优化。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HSET key field value</td>\n<td>设置指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HSETNX key field value</td>\n<td>只有指定字段不存在时设置指定字段的值</td>\n</tr>\n<tr>\n<td>HMSET key field1 value1 field2 value2 …</td>\n<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HMGET key field1 field2 …</td>\n<td>获取指定哈希表中一个或者多个指定字段的值</td>\n</tr>\n<tr>\n<td>HGETALL key</td>\n<td>获取指定哈希表中所有的键值对</td>\n</tr>\n<tr>\n<td>HEXISTS key field</td>\n<td>查看指定哈希表中指定的字段是否存在</td>\n</tr>\n<tr>\n<td>HDEL key field1 field2 …</td>\n<td>删除一个或多个哈希表字段</td>\n</tr>\n<tr>\n<td>HLEN key</td>\n<td>获取指定哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>HINCRBY key field increment</td>\n<td>对指定哈希中的指定字段做运算操作(正数为加，负数为减)</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>存储对象，如用户信息、商品信息、文章信息、购物车信息.</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 <code>HashSet</code> 。当需要存储无重复列表数据时，<code>Set</code> 是一个很好的选择，且 <code>Set</code> 提供了判断某个元素是否在其内的重要接口，这个也是 <code>List</code> 所不能提供的。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SADD key member1 member2 …</td>\n<td>向指定集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SMEMBERS key</td>\n<td>获取指定集合中的所有元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>获取指定集合的元素数量</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断指定元素是否在指定集合中</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 …</td>\n<td>获取给定所有集合的交集</td>\n</tr>\n<tr>\n<td>SINTERSTORE destination key1 key2 …</td>\n<td>将给定所有集合的交集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 …</td>\n<td>获取给定所有集合的并集</td>\n</tr>\n<tr>\n<td>SUNIONSTORE destination key1 key2 …</td>\n<td>将给定所有集合的并集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 …</td>\n<td>获取给定所有集合的差集</td>\n</tr>\n<tr>\n<td>SDIFFSTORE destination key1 key2 …</td>\n<td>将给定所有集合的差集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SPOP key count</td>\n<td>随机移除并获取指定集合中一个或多个元素</td>\n</tr>\n<tr>\n<td>SRANDMEMBER key count</td>\n<td>随机获取指定集合中指定数量的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>存放无重复数据：如文章点赞、用户收藏、共同好友等。</li>\n<li>需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。</li>\n<li>随机获取数据源：如抽奖、随机推荐等。</li>\n</ul>\n<h3 id=\"Zset\"><a href=\"#Zset\" class=\"headerlink\" title=\"Zset\"></a>Zset</h3><p><code>Zset</code>相较于<code>Set</code>增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ZADD key score1 member1 score2 member2 …</td>\n<td>向指定有序集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>ZCARD KEY</td>\n<td>获取指定有序集合的元素数量</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取指定有序集合中指定元素的 score 值</td>\n</tr>\n<tr>\n<td>ZINTERSTORE destination numkeys key1 key2 …</td>\n<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>\n</tr>\n<tr>\n<td>ZUNIONSTORE destination numkeys key1 key2 …</td>\n<td>求并集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZDIFFSTORE destination numkeys key1 key2 …</td>\n<td>求差集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素(score 从低到高)</td>\n</tr>\n<tr>\n<td>ZREVRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素(score 从高到底)</td>\n</tr>\n<tr>\n<td>ZREVRANK key member</td>\n<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>\n<li>需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。</li>\n</ul>\n<h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><p><code>Bitmap</code>存储的是连续的二进制数据(1&#x2F;0)，只需要一个 <code>bit</code> 位来表示某个元素对应的值或者状态，非常节省内存。可以将<code>Bitmap</code> 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 <code>offset</code>(偏移量)。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SETBIT key offset value</td>\n<td>设置指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>GETBIT key offset</td>\n<td>获取指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>BITCOUNT key start end</td>\n<td>获取 start 和 end 之前值为 1 的元素个数</td>\n</tr>\n<tr>\n<td>BITOP operation destkey key1 key2 …</td>\n<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>用户签到：每天签到的用户用一个 <code>bit</code> 位来表示，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为签到状态(1&#x2F;0)。</li>\n<li>用户在线状态：用一个 <code>bit</code> 位来表示用户的在线状态，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为在线状态(1&#x2F;0)。</li>\n</ul>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p><code>HyperLogLog</code> 是一种基数统计算法，用于估计一个集合中不重复元素的个数。<code>HyperLogLog</code> 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PFADD key element1 element2 …</td>\n<td>添加一个或多个元素到 HyperLogLog 中</td>\n</tr>\n<tr>\n<td>PFCOUNT key1 key2</td>\n<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>\n</tr>\n<tr>\n<td>PFMERGE destkey sourcekey1 sourcekey2 …</td>\n<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。</li>\n</ul>\n<h3 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h3><p><code>Geospatial index</code>(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 <code>Sorted Set</code> 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GEOADD key longitude1 latitude1 member1 …</td>\n<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>\n</tr>\n<tr>\n<td>GEOPOS key member1 member2 …</td>\n<td>返回给定元素的经纬度信息</td>\n</tr>\n<tr>\n<td>GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI</td>\n<td>返回两个给定元素之间的距离</td>\n</tr>\n<tr>\n<td>GEORADIUS key longitude latitude radius distance</td>\n<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数</td>\n</tr>\n<tr>\n<td>GEORADIUSBYMEMBER key member radius distance</td>\n<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>附近的人：根据用户的经纬度信息，获取附近的人。</li>\n<li>附近的商家：根据用户的经纬度信息，获取附近的商家。</li>\n<li>附近的车辆：根据用户的经纬度信息，获取附近的车辆。</li>\n</ul>\n<h3 id=\"使用String存储对象还是Hash\"><a href=\"#使用String存储对象还是Hash\" class=\"headerlink\" title=\"使用String存储对象还是Hash\"></a>使用String存储对象还是Hash</h3><ul>\n<li><code>String</code> 存储的是序列化后的对象数据，存放的是整个对象。<code>Hash</code> 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 <code>Hash</code>。</li>\n<li><code>String</code> 存储相对来说更加节省内存，缓存相同数量的对象数据，<code>String</code> 消耗的内存约是 <code>Hash</code> 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用<code>String</code>。</li>\n</ul>\n<h3 id=\"购物车信息用String还是Hash存储\"><a href=\"#购物车信息用String还是Hash存储\" class=\"headerlink\" title=\"购物车信息用String还是Hash存储\"></a>购物车信息用String还是Hash存储</h3><p>购物车中的商品频繁修改和变动，建议使用 <code>Hash</code>储存。</p>\n<ul>\n<li>用户 id 为 <code>key</code></li>\n<li>商品 id 为 <code>field</code>，商品数量为 <code>value</code></li>\n</ul>\n<p>具体维护：</p>\n<ul>\n<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>\n<li>查询购物车信息就是遍历对应的 Hash；</li>\n<li>更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；</li>\n<li>删除商品就是删除 Hash 中对应的 field；</li>\n<li>清空购物车直接删除对应的 key 即可。</li>\n</ul>\n<h3 id=\"Zset为什么要用跳表\"><a href=\"#Zset为什么要用跳表\" class=\"headerlink\" title=\"Zset为什么要用跳表\"></a>Zset为什么要用跳表</h3><ul>\n<li>跳表 vs 平衡树<ul>\n<li>跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。</li>\n</ul>\n</li>\n<li>跳表 vs 红黑树<ul>\n<li>跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>\n</ul>\n</li>\n<li>跳表 vs B+ 树<ul>\n<li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用Set实现抽奖系统\"><a href=\"#用Set实现抽奖系统\" class=\"headerlink\" title=\"用Set实现抽奖系统\"></a>用Set实现抽奖系统</h3><ul>\n<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>\n<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>\n<li><code>SRANDMEMBER key count</code>： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>\n</ul>\n<h3 id=\"Bitmap统计活跃用户\"><a href=\"#Bitmap统计活跃用户\" class=\"headerlink\" title=\"Bitmap统计活跃用户\"></a>Bitmap统计活跃用户</h3><p>用日期(精确到天)作为 <code>key</code>，用户 ID 为 <code>offset</code>，如果当日活跃过就设置为 1，否则为 0。通过 <code>BITCOUNT</code> 命令统计某个时间段内的活跃用户数。</p>\n<h3 id=\"HyperLogLog统计网站-UV\"><a href=\"#HyperLogLog统计网站-UV\" class=\"headerlink\" title=\"HyperLogLog统计网站 UV\"></a>HyperLogLog统计网站 UV</h3><ul>\n<li><code>PFADD PAGE_1:UV USER1 USER2 ...... USERn</code>：将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</li>\n<li><code>PFCOUNT PAGE_1:UV</code>：统计指定页面的 UV。</li>\n</ul>\n<h3 id=\"Redis持久化机制✅\"><a href=\"#Redis持久化机制✅\" class=\"headerlink\" title=\"Redis持久化机制✅\"></a>Redis持久化机制✅</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。</p>\n<h3 id=\"为什么要持久化\"><a href=\"#为什么要持久化\" class=\"headerlink\" title=\"为什么要持久化\"></a>为什么要持久化</h3><ul>\n<li>重用数据(比如重启机器、机器故障之后恢复数据)</li>\n<li>数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。</li>\n</ul>\n<h3 id=\"三种持久化方式\"><a href=\"#三种持久化方式\" class=\"headerlink\" title=\"三种持久化方式\"></a>三种持久化方式</h3><ul>\n<li>快照(<code>snapshotting</code>, RDB)</li>\n<li>只追加文件(<code>append-only file</code>, AOF)</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<h3 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h3><p>Redis通过创建快照获取存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。</p>\n<h3 id=\"RDB创建时会阻塞主线程吗\"><a href=\"#RDB创建时会阻塞主线程吗\" class=\"headerlink\" title=\"RDB创建时会阻塞主线程吗\"></a>RDB创建时会阻塞主线程吗</h3><p>有两个命令生成 RDB 快照文件</p>\n<ul>\n<li><code>save</code>：同步保存操作，会阻塞 Redis 主线程； </li>\n<li><code>bgsave</code>：<code>fork</code> 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<h3 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(<code>fsync</code>策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。</p>\n<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。</p>\n<h3 id=\"AOF工作流程\"><a href=\"#AOF工作流程\" class=\"headerlink\" title=\"AOF工作流程\"></a>AOF工作流程</h3><ol>\n<li>命令追加(<code>append</code>)：所有的写命令会追加到 AOF 缓冲区中。</li>\n<li>文件写入(<code>write</code>)：将 AOF 缓冲区的数据写入到<strong>系统内核缓冲区</strong>中。这一步系统调用<code>write</code>函数，将数据写入到了<strong>系统内核缓冲区</strong>之后直接返回(延迟写)。</li>\n<li>文件同步(<code>fsync</code>)：<strong>系统内核缓冲区</strong>根据对应的持久化方式(<code>fsync</code>策略)向硬盘做同步操作。这一步系统调用 <code>fsync</code> 函数， <code>fsync</code> 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。</li>\n<li>文件重写(<code>rewrite</code>)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>\n<li>重启加载(<code>load</code>)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>\n</ol>\n<p><img src=\"/./image/Database-Interview/aof-work-process.png\" alt=\"AOF工作流程\"></p>\n<h3 id=\"AOF持久化的三种同步策略\"><a href=\"#AOF持久化的三种同步策略\" class=\"headerlink\" title=\"AOF持久化的三种同步策略\"></a>AOF持久化的三种同步策略</h3><p>即 <code>fsync</code> 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。</p>\n<ul>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程( <code>aof_fsync</code> 线程)立即会调用 <code>fsync</code> 函数同步 AOF 文件(刷盘)，<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能(<code>write + fsync</code>)。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程( <code>aof_fsync</code> 线程)每秒钟调用 <code>fsync</code> 函数同步一次 AOF 文件(<code>write+fsync</code>，<code>fsync</code>间隔为 1 秒)</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定)。</li>\n</ul>\n<blockquote>\n<p>刷盘：将内存中的数据写入到磁盘中。</p>\n</blockquote>\n<h3 id=\"AOF为什么是执行完命令后记录日志\"><a href=\"#AOF为什么是执行完命令后记录日志\" class=\"headerlink\" title=\"AOF为什么是执行完命令后记录日志\"></a>AOF为什么是执行完命令后记录日志</h3><p>不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。</p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>但也存在风险：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； </li>\n<li>可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。</li>\n</ul>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>\n<p>重写期间，AOF维护一个<strong>AOF重写缓冲区</strong>，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将<strong>AOF重写缓冲区</strong>内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。</p>\n<p>可以配置如下参数：<br><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;<br><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小(<code>aof_current_size</code>)和上一次重写时 AOF 大小(<code>aof_base_size</code>)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</p>\n<h3 id=\"AOF校验机制\"><a href=\"#AOF校验机制\" class=\"headerlink\" title=\"AOF校验机制\"></a>AOF校验机制</h3><p>Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 <code>CRC64</code> 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。</p>\n<p>Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。</p>\n<h3 id=\"Redis4-0对持久化的优化\"><a href=\"#Redis4-0对持久化的优化\" class=\"headerlink\" title=\"Redis4.0对持久化的优化\"></a>Redis4.0对持久化的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>\n<h3 id=\"如何选择RDB和AOF\"><a href=\"#如何选择RDB和AOF\" class=\"headerlink\" title=\"如何选择RDB和AOF\"></a>如何选择RDB和AOF</h3><p>RDB优势：</p>\n<ul>\n<li>RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。</li>\n<li>RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。</li>\n</ul>\n<p>AOF优势：</p>\n<ul>\n<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。</li>\n<li>RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。</li>\n<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。</li>\n</ul>\n<p>综上：</p>\n<ul>\n<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>\n<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>\n<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>\n</ul>\n<h3 id=\"Redis单线程模型✅\"><a href=\"#Redis单线程模型✅\" class=\"headerlink\" title=\"Redis单线程模型✅\"></a>Redis单线程模型✅</h3><p>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(<code>file event handler</code>)，是单线程方式运行的，所以说 Redis 是单线程模型。</p>\n<h3 id=\"如何监听大量客户端链接\"><a href=\"#如何监听大量客户端链接\" class=\"headerlink\" title=\"如何监听大量客户端链接\"></a>如何监听大量客户端链接</h3><p>通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接(或者说是监听多个 <code>socket</code>)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。</p>\n<p>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p>\n<p>文件事件处理器主要是包含 4 个部分：</p>\n<ul>\n<li>多个 socket(客户端连接)</li>\n<li>IO 多路复用程序(支持多个客户端连接的关键)</li>\n<li>文件事件分派器(将 <code>socket</code> 关联到相应的事件处理器)</li>\n<li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li>\n</ul>\n<p><img src=\"/./image/Database-Interview/redis-event-handler.png\" alt=\"文件事件处理器\"></p>\n<h3 id=\"Redis4-0多线程\"><a href=\"#Redis4-0多线程\" class=\"headerlink\" title=\"Redis4.0多线程\"></a>Redis4.0多线程</h3><p>在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p>\n<p>异步命令：</p>\n<ul>\n<li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li>\n<li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li>\n<li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li>\n</ul>\n<p>总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p>\n<h3 id=\"Redis6-0之前为什么不用多线程\"><a href=\"#Redis6-0之前为什么不用多线程\" class=\"headerlink\" title=\"Redis6.0之前为什么不用多线程\"></a>Redis6.0之前为什么不用多线程</h3><ul>\n<li>单线程编程容易并且更容易维护；</li>\n<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>\n<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>\n</ul>\n<h3 id=\"Redis6-0之后为何引入多线程\"><a href=\"#Redis6-0之后为何引入多线程\" class=\"headerlink\" title=\"Redis6.0之后为何引入多线程\"></a>Redis6.0之后为何引入多线程</h3><p>Redis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p>\n<h3 id=\"Redis后台线程\"><a href=\"#Redis后台线程\" class=\"headerlink\" title=\"Redis后台线程\"></a>Redis后台线程</h3><p>Redis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：</p>\n<ul>\n<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF&#x2F;RDB 等过程中产生的临时文件资源。</li>\n<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。</li>\n<li>通过 <code>bio_lazy_free</code>后台线程释放大对象(已删除)占用的内存空间.</li>\n</ul>\n<h3 id=\"Redis内存管理✅\"><a href=\"#Redis内存管理✅\" class=\"headerlink\" title=\"Redis内存管理✅\"></a>Redis内存管理✅</h3><h3 id=\"Redis给缓存数据设置过期时间有啥用\"><a href=\"#Redis给缓存数据设置过期时间有啥用\" class=\"headerlink\" title=\"Redis给缓存数据设置过期时间有啥用\"></a>Redis给缓存数据设置过期时间有啥用</h3><ul>\n<li>因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。</li>\n<li>某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。</li>\n</ul>\n<h3 id=\"Redis如何判断数据过期\"><a href=\"#Redis如何判断数据过期\" class=\"headerlink\" title=\"Redis如何判断数据过期\"></a>Redis如何判断数据过期</h3><p>Redis 通过一个叫做<strong>过期字典</strong>(可以看作是 <code>hash</code> 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 <code>key</code>(键)，过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了 <code>key</code> 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。</p>\n<p>在查询一个 <code>key</code> 的时候，Redis 首先检查该 <code>key</code> 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 <code>key</code> 是否过期，过期直接删除 <code>key</code> 然后返回 <code>null</code>。</p>\n<h3 id=\"Redis过期key删除策略\"><a href=\"#Redis过期key删除策略\" class=\"headerlink\" title=\"Redis过期key删除策略\"></a>Redis过期key删除策略</h3><ul>\n<li>惰性删除：只会在取出&#x2F;查询 <code>key</code> 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 <code>key</code> 没有删除。</li>\n<li>定期删除：周期性地随机从设置了过期时间的 <code>key</code> 中抽查一批，然后逐个检查这些 <code>key</code> 是否过期，过期就删除 <code>key</code>。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>\n<li>延迟队列：把设置过期时间的 <code>key</code> 放到一个延迟队列里，到期之后就删除 <code>key</code>。这样可保证每个过期 <code>key</code> 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>\n<li>定时删除：每个设置了过期时间的 <code>key</code> 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。</li>\n</ul>\n<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。</p>\n<h3 id=\"定期删除策略详细细节\"><a href=\"#定期删除策略详细细节\" class=\"headerlink\" title=\"定期删除策略详细细节\"></a>定期删除策略详细细节</h3><ul>\n<li>Redis 默认每 100ms 检查 20 个随机的过期 <code>key</code>，如果有过期的 <code>key</code> 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 <code>key</code> 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li>\n</ul>\n<p><strong>大量key集中过期如何处理</strong><br>如果大量 <code>key</code> 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：</p>\n<ul>\n<li>尽量避免 <code>key</code> 集中过期，在设置键的过期时间时尽量随机一点。</li>\n<li>对过期的 <code>key</code> 开启 <code>lazyfree</code> 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。</li>\n</ul>\n<h3 id=\"Redis内存淘汰策略✅\"><a href=\"#Redis内存淘汰策略✅\" class=\"headerlink\" title=\"Redis内存淘汰策略✅\"></a>Redis内存淘汰策略✅</h3><p>当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：</p>\n<ul>\n<li><code>volatile-lru</code>(least recently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最近最少使用的数据淘汰。</li>\n<li><code>volatile-ttl</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选将要过期的数据淘汰。</li>\n<li><code>volatile-random</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中任意选择数据淘汰。</li>\n<li><code>allkeys-lru</code>(least recently used)：从数据集(<code>server.db[i].dict</code>)中移除最近最少使用的数据淘汰。</li>\n<li><code>allkeys-random</code>：从数据集(<code>server.db[i].dict</code>)中任意选择数据淘汰。</li>\n<li><code>no-eviction</code>(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>\n</ul>\n<p>4.0 版本后增加以下两种：</p>\n<ul>\n<li><code>volatile-lfu</code>(least frequently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰。</li>\n<li><code>allkeys-lfu</code>(least frequently used)：从数据集(<code>server.db[i].dict</code>)中移除最不经常使用的数据淘汰。</li>\n</ul>\n<p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p>\n<h3 id=\"Redis事务\"><a href=\"#Redis事务\" class=\"headerlink\" title=\"Redis事务\"></a>Redis事务</h3><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p>\n<h3 id=\"如何解决Redis事务的缺陷\"><a href=\"#如何解决Redis事务的缺陷\" class=\"headerlink\" title=\"如何解决Redis事务的缺陷\"></a>如何解决Redis事务的缺陷</h3><p>可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</p>\n<h3 id=\"Redis性能优化✅\"><a href=\"#Redis性能优化✅\" class=\"headerlink\" title=\"Redis性能优化✅\"></a>Redis性能优化✅</h3><h3 id=\"批量操作减少网络传输\"><a href=\"#批量操作减少网络传输\" class=\"headerlink\" title=\"批量操作减少网络传输\"></a>批量操作减少网络传输</h3><p>Redis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。</p>\n<p>批量操作的三种方式</p>\n<ul>\n<li>原生批量操作：Redis 提供了一些原生的批量操作命令，如 <code>MSET</code>、<code>MGET</code>、<code>DEL</code> 等。</li>\n<li>Pipeline：通过 <code>pipeline</code> 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。</li>\n<li>Lua脚本：</li>\n</ul>\n<h3 id=\"大量key集中过期\"><a href=\"#大量key集中过期\" class=\"headerlink\" title=\"大量key集中过期\"></a>大量key集中过期</h3><p>Redis采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>清理过期<code>key</code>。如果大量 <code>key</code> 集中过期的问题，客户端请求必须等待定期清理过期 <code>key</code> 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：</p>\n<ul>\n<li>给 <code>key</code> 设置随机过期时间。</li>\n<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)，让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将删除<code>key</code>的操作该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<h3 id=\"bigkey-大key\"><a href=\"#bigkey-大key\" class=\"headerlink\" title=\"bigkey(大key)\"></a>bigkey(大key)</h3><p>如果一个 <code>key</code> 对应的 <code>value</code> 所占用的内存比较大，那这个 <code>key</code> 就可以看作是 <code>bigkey</code>。<code>bigkey</code>的标准：</p>\n<ul>\n<li><code>String</code> 类型的 <code>value</code> 超过 1MB</li>\n<li>复合类型(<code>List</code>、<code>Hash</code>、<code>Set</code>、<code>Sorted Set</code> 等)的 <code>value</code> 包含的元素超过 5000 个(不过，对于复合类型的 <code>value</code> 来说，不一定包含的元素越多，占用的内存就越多)。</li>\n</ul>\n<p><strong>产生原因</strong></p>\n<ul>\n<li>程序设计不当，比如直接使用 <code>String</code> 类型存储较大的文件对应的二进制数据。</li>\n<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>\n<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>\n</ul>\n<p><strong>危害</strong></p>\n<ul>\n<li>单线程的Redis 在操作<code>bigkey</code> 时候比较耗时，造成客户端超时阻塞。</li>\n<li>网络拥塞：获取<code>bigkey</code>需要较多的流量。</li>\n<li>工作线程阻塞：如果使用 <code>del</code> 删除大 <code>key</code> 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n<li><code>bigkey</code>会进一步影响主从同步。</li>\n</ul>\n<p><strong>bigkey发现</strong></p>\n<ul>\n<li><code>--bigkeys</code>：执行<code>redis-cli -p 6379 --bigkeys</code>扫描所有key，只能找到<code>top 1 bigkey</code>(占用内存最大的 <code>String</code> 数据类型，包含元素最多的复合数据类型)。</li>\n<li><code>SCAN+STRLEN/HLEN/LLEN</code>：Redis 自带的 <code>SCAN</code> 命令按指定模式扫描匹配的<code>key</code>，然后结合<code>STRLEN/HLEN/LLEN</code>返回<code>key</code>的长度或者成员数量。</li>\n<li>集合类型可以使用<code>MEMORY USAGE</code></li>\n<li>借助开源工具分析 RDB 文件。如<code>redis-rdb-tools</code>、<code>rdb_bigkeys</code></li>\n<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>\n</ul>\n<p><strong>处理bigkey</strong></p>\n<ul>\n<li>分割 <code>bigkey</code>：将<code>bigkey</code>分割为多个小 <code>key</code>。例如，将一个含有上万字段数量的 <code>Hash</code> 按照一定策略(比如二次哈希)拆分为多个 <code>Hash</code>。</li>\n<li>手动清理：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 <code>key</code>。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>\n<li>采用合适的数据结构：例如，文件二进制数据不使用 <code>String</code> 保存、使用 <code>HyperLogLog</code> 统计页面 <code>UV</code>、<code>Bitmap</code> 保存状态信息(0&#x2F;1)。</li>\n<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)：<code>lazy-free</code> 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<p>也可以配合使用上述方法</p>\n<h3 id=\"hotkey-热key\"><a href=\"#hotkey-热key\" class=\"headerlink\" title=\"hotkey(热key)\"></a>hotkey(热key)</h3><p>如果一个 <code>key</code> 的访问次数比较多且明显多于其他 <code>key</code>，就可以看作是 <code>hotkey</code>。</p>\n<p><strong>产生原因</strong><br>某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>\n<p><strong>危害</strong></p>\n<ul>\n<li><code>hotkey</code> 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</li>\n<li>如果突然访问 <code>hotkey</code> 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</li>\n</ul>\n<p><code>hotkey</code> 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>\n<p><strong>发现hotkey</strong></p>\n<ul>\n<li><code>--hotkeys</code>：执行<code>redis-cli -p 6379 --hotkeys</code>命令</li>\n<li><code>MONITOR</code>： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。<ul>\n<li>可在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 <code>hotkey</code>。</li>\n</ul>\n</li>\n<li>根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 <code>hotkey</code>，比如突发的热点新闻事件等。</li>\n<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>\n</ul>\n<p><strong>处理hotkey</strong></p>\n<ul>\n<li>读写分离：主节点处理写请求，从节点处理读请求。</li>\n<li>使用 <code>Redis Cluster</code>：将热点数据分散存储在多个 Redis 节点上。</li>\n<li>二级缓存：<code>hotkey</code> 采用二级缓存的方式进行处理，将 <code>hotkey</code> 存放一份到 JVM 本地内存中(可以用 Caffeine)。</li>\n<li>使用公有云的 Redis 服务中的解决方案。</li>\n</ul>\n<p>也可以配合使用上述方法。</p>\n<h3 id=\"慢查询命令\"><a href=\"#慢查询命令\" class=\"headerlink\" title=\"慢查询命令\"></a>慢查询命令</h3><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如<code>KEYS *</code>、<code>HGETALL</code>等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</p>\n<h3 id=\"Redis内存碎片✅\"><a href=\"#Redis内存碎片✅\" class=\"headerlink\" title=\"Redis内存碎片✅\"></a>Redis内存碎片✅</h3><p>Redis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。</p>\n<h3 id=\"内存碎片产生原因\"><a href=\"#内存碎片产生原因\" class=\"headerlink\" title=\"内存碎片产生原因\"></a>内存碎片产生原因</h3><ol>\n<li>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。<ul>\n<li>Redis 采用多种内存分配器分配内存，默认采用 <code>jemalloc</code>，其按照 2 的幂次方分配内存，可能会导致内存浪费。</li>\n</ul>\n</li>\n<li>频繁修改 Redis 中的数据也会产生内存碎片。</li>\n</ol>\n<h3 id=\"查看内存碎片率\"><a href=\"#查看内存碎片率\" class=\"headerlink\" title=\"查看内存碎片率\"></a>查看内存碎片率</h3><p>使用 <code>info memory</code> 命令查看 Redis 内存碎片率。</p>\n<p><code>mem_fragmentation_ratio</code> (内存碎片率)&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>\n<p>内粗碎片率越大，说明 Redis 中的内存碎片越多。<code>used_memory_rss</code> 减去 <code>used_memory</code> 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>\n<p>通常内存碎片率<code>mem_fragmentation_ratio</code> &gt; 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了</p>\n<h3 id=\"Redis内存碎片清理\"><a href=\"#Redis内存碎片清理\" class=\"headerlink\" title=\"Redis内存碎片清理\"></a>Redis内存碎片清理</h3><ol>\n<li>重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</li>\n<li>Redis4.0-RC3可以通过<code>config set activedefrag yes</code>开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config <span class=\"built_in\">set</span> activedefrag <span class=\"built_in\">yes</span> <span class=\"comment\"># 开启主动碎片整理功能</span></span><br><span class=\"line\"></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-ignore-bytes 500mb <span class=\"comment\"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-threshold-lower 50 <span class=\"comment\"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class=\"line\"></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-cycle-min 20 <span class=\"comment\"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-cycle-max 50 <span class=\"comment\"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis生产问题✅\"><a href=\"#Redis生产问题✅\" class=\"headerlink\" title=\"Redis生产问题✅\"></a>Redis生产问题✅</h3><h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透是大量请求的 <code>key</code> 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><strong>举例</strong><br>某个黑客故意制造一些非法的 <code>key</code> 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</li>\n<li>缓存无效 <code>key</code>。短暂地缓存无效<code>key</code>，并设置一个较短的过期时间，这样就可以防止缓存穿透。</li>\n<li>布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 <code>hash</code> 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。</li>\n<li>接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</li>\n</ol>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><strong>举例</strong><br>秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。</li>\n<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li>\n</ol>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>缓存雪崩是缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>\n<p><strong>举例</strong><br>数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong><br>针对大量缓存同时失效的情况：</p>\n<ol>\n<li>设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li>\n<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li>\n</ol>\n<p>针对 Redis 服务不可用的情况：</p>\n<ol>\n<li>Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li>\n<li>多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>\n</ol>\n<h3 id=\"缓存穿透-缓存击穿区别\"><a href=\"#缓存穿透-缓存击穿区别\" class=\"headerlink\" title=\"缓存穿透&#x2F;缓存击穿区别\"></a>缓存穿透&#x2F;缓存击穿区别</h3><ul>\n<li>缓存穿透中，请求的 <code>key</code> 既不存在于缓存中，也不存在于数据库中。</li>\n<li>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。</li>\n</ul>\n<h3 id=\"缓存预热如何实现\"><a href=\"#缓存预热如何实现\" class=\"headerlink\" title=\"缓存预热如何实现\"></a>缓存预热如何实现</h3><ol>\n<li>使用定时任务，比如 <code>xxl-job</code>，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>\n<li>使用消息队列，比如 <code>Kafka</code>，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>\n</ol>\n<h3 id=\"缓存击穿-缓存雪崩区别\"><a href=\"#缓存击穿-缓存雪崩区别\" class=\"headerlink\" title=\"缓存击穿&#x2F;缓存雪崩区别\"></a>缓存击穿&#x2F;缓存雪崩区别</h3><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。</p>\n<h3 id=\"Redis常见阻塞原因\"><a href=\"#Redis常见阻塞原因\" class=\"headerlink\" title=\"Redis常见阻塞原因\"></a>Redis常见阻塞原因</h3><ol>\n<li>O(n)命令：如<code>KEYS *</code>(返回所有符合规则的 <code>key</code>)、<code>HGETALL</code>(会返回一个 <code>Hash</code> 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</li>\n<li><code>Save</code>创建RDB快照：<code>save</code> 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。</li>\n<li>AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。</li>\n<li>AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会<code>append</code>到AOF缓冲区，然后<code>write</code> 到系统内核缓冲区，最后 <code>fsync</code> 刷到磁盘。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。</li>\n<li>AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。</li>\n<li>查找和删除<code>bigkey</code>：查找<code>bigkey</code>时，Redis 会遍历所有的 <code>key</code>，这个操作是阻塞的。删除<code>bigkey</code>时，会先释放<code>bigkey</code>内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的<code>bigkey</code>，空闲内存块插入链表的操作就会阻塞主线程。</li>\n<li>清空数据库：<code>flushall</code> 和 <code>flushdb</code> 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。</li>\n<li>CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</li>\n<li>网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</li>\n</ol>\n<h2 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h2><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供<strong>面向文档</strong>的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong>。</p>\n<p>在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点&#x2F;实例，以保证服务性能和可用性。</p>\n<h3 id=\"mongodb的存储结构是什么\"><a href=\"#mongodb的存储结构是什么\" class=\"headerlink\" title=\"mongodb的存储结构是什么\"></a>mongodb的存储结构是什么</h3><p>主要由三个单元组成：</p>\n<ul>\n<li>数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。</li>\n<li>集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(<code>Table</code>)。</li>\n<li>文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(<code>key-value</code>)组成，类似于关系型数据库中的行(<code>Row</code>)。</li>\n</ul>\n<p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>SQL</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表(Table)</td>\n<td>集合(Collection)</td>\n</tr>\n<tr>\n<td>行(Row)</td>\n<td>文档(Document)</td>\n</tr>\n<tr>\n<td>列(Col)</td>\n<td>字段(Field)</td>\n</tr>\n<tr>\n<td>主键(Primary Key)</td>\n<td>对象 ID(Objectid)</td>\n</tr>\n<tr>\n<td>索引(Index)</td>\n<td>索引(Index)</td>\n</tr>\n<tr>\n<td>嵌套表(Embedded Table)</td>\n<td>嵌入式文档(Embedded Document)</td>\n</tr>\n<tr>\n<td>数组(Array)</td>\n<td>数组(Array)</td>\n</tr>\n</tbody></table>\n<p><strong>集合</strong><br>集合存储于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。</p>\n<p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p>\n<p><strong>文档</strong><br>BSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。</p>\n<h3 id=\"mongodb特点\"><a href=\"#mongodb特点\" class=\"headerlink\" title=\"mongodb特点\"></a>mongodb特点</h3><ul>\n<li>数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。</li>\n<li>数据模型自由：不需要设计表结构，可以存储不同结构的文档。</li>\n<li>支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li>\n<li>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</li>\n<li>高效的二进制存储：文档以键值对的形式存储在集合中，键(<code>ObjectId</code>类型)唯一标识文件，值是以 BSON 形式存在。</li>\n<li>自带数据压缩功能：MongoDB 3.0 版本开始支持 <code>WiredTiger</code> 存储引擎，支持数据压缩，减少磁盘空间占用。</li>\n<li>支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。</li>\n<li>支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li>支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。</li>\n<li>支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 <code>GridFS</code> 存储。</li>\n</ul>\n<h3 id=\"mongodb适合什么场景\"><a href=\"#mongodb适合什么场景\" class=\"headerlink\" title=\"mongodb适合什么场景\"></a>mongodb适合什么场景</h3><p>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。</p>\n<h3 id=\"mongodb存储引擎\"><a href=\"#mongodb存储引擎\" class=\"headerlink\" title=\"mongodb存储引擎\"></a>mongodb存储引擎</h3><p>MongoDB 采用的是 <strong>插件式的存储引擎架构</strong>，现在主要使用两种存储引擎：</p>\n<ul>\n<li><code>MMAPv1</code> 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。</li>\n<li><code>WiredTiger</code> 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 <code>WiredTiger</code> 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。</li>\n<li><code>In-Memory</code> 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。</li>\n</ul>\n<h3 id=\"WiredTiger存储引擎\"><a href=\"#WiredTiger存储引擎\" class=\"headerlink\" title=\"WiredTiger存储引擎\"></a>WiredTiger存储引擎</h3><p><code>WiredTiger</code> 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。</p>\n<p>使用 B+ 树时，<code>WiredTiger</code> 以 <code>page</code> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 <code>page</code>，共有三种类型的 <code>page</code>：</p>\n<ul>\n<li><code>root page</code>(根节点)：B+ 树的根节点。</li>\n<li><code>internal page</code>(内部节点)：不实际存储数据的中间索引节点。</li>\n<li><code>leaf page</code>(叶子节点)：真正存储数据的叶子节点，包含一个页头(<code>page header</code>)、块头(<code>block header</code>)和真正的数据(<code>key/value</code>)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 <code>checksum</code>、块在磁盘上的寻址位置等信息。</li>\n</ul>\n<h3 id=\"mongodb聚合\"><a href=\"#mongodb聚合\" class=\"headerlink\" title=\"mongodb聚合\"></a>mongodb聚合</h3><p>将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：</p>\n<ul>\n<li>将来自多个文档的值组合在一起。 </li>\n<li>对集合中的数据进行的一系列运算。 </li>\n<li>分析数据随时间的变化。</li>\n</ul>\n<p>两种聚合方法：</p>\n<ul>\n<li>聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。</li>\n<li>单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li>\n</ul>\n<p>聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：</p>\n<ul>\n<li>接受一系列原始数据文档</li>\n<li>对这些文档进行一系列运算</li>\n<li>结果文档输出给下一个阶段</li>\n</ul>\n<h3 id=\"mongodb事务\"><a href=\"#mongodb事务\" class=\"headerlink\" title=\"mongodb事务\"></a>mongodb事务</h3><p>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</p>\n<h3 id=\"mongodb数据压缩\"><a href=\"#mongodb数据压缩\" class=\"headerlink\" title=\"mongodb数据压缩\"></a>mongodb数据压缩</h3><p>借助 <code>WiredTiger</code> 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。<code>WiredTiger</code> 存储引擎支持以下压缩算法：</p>\n<ul>\n<li><code>snappy</code>：快速压缩算法，压缩比(3～5倍)较低，但速度快。</li>\n<li><code>zlib</code>：压缩比(5～7倍)较高，但速度较慢。</li>\n<li><code>Zstandard</code>：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li>\n</ul>\n<p><code>WiredTiger</code> 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。</p>\n<h3 id=\"mongodb索引\"><a href=\"#mongodb索引\" class=\"headerlink\" title=\"mongodb索引\"></a>mongodb索引</h3><p>索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。</p>\n<p>索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。</p>\n<p><strong>索引类型</strong></p>\n<ul>\n<li>单字段索引：建立在单个字段上的索引。</li>\n<li>复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>\n<li>多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>\n<li>哈希索引：按数据的哈希值索引，用在哈希分片集群上。</li>\n<li>文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>\n<li>地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>\n<li>唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>\n<li>TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.</li>\n</ul>\n<h3 id=\"复合索引中字段顺序\"><a href=\"#复合索引中字段顺序\" class=\"headerlink\" title=\"复合索引中字段顺序\"></a>复合索引中字段顺序</h3><p>复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。</p>\n<p>复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。</p>\n<blockquote>\n<p>有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p>\n</blockquote>\n<h3 id=\"TTL索引\"><a href=\"#TTL索引\" class=\"headerlink\" title=\"TTL索引\"></a>TTL索引</h3><p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code>，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>\n<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>\n<p><strong>原理</strong></p>\n<ul>\n<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>\n<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 <code>oplog</code> 做同步。</li>\n</ul>\n<p><strong>TTL索引限制</strong></p>\n<ul>\n<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>\n<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"SQL-NoSQL基础\"><a href=\"#SQL-NoSQL基础\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL基础\"></a>SQL&#x2F;NoSQL基础</h2><h3 id=\"什么是SQL\"><a href=\"#什么是SQL\" class=\"headerlink\" title=\"什么是SQL\"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p>\n<h3 id=\"DB-DBMS-DBS-DBA\"><a href=\"#DB-DBMS-DBS-DBA\" class=\"headerlink\" title=\"DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA\"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul>\n<li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li>\n<li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"数据库术语\"><a href=\"#数据库术语\" class=\"headerlink\" title=\"数据库术语\"></a>数据库术语</h3><ul>\n<li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li>\n<li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li>\n<li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li>行(<code>row</code>)：表中的一个记录。</li>\n<li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性概念\"><a href=\"#元组-码-候选码-主码-外码-主属性-非主属性概念\" class=\"headerlink\" title=\"元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念\"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul>\n<li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p>\n<ul>\n<li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li>\n<li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<h3 id=\"数据库三范式\"><a href=\"#数据库三范式\" class=\"headerlink\" title=\"数据库三范式\"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。<ul>\n<li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li>\n</ul>\n</li>\n<li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li>\n<li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul>\n<li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul>\n<li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li>\n</ul>\n</li>\n<li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul>\n<li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li>\n</ul>\n</li>\n<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li>\n<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul>\n<li>例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主键-外键区别\"><a href=\"#主键-外键区别\" class=\"headerlink\" title=\"主键&#x2F;外键区别\"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>\n<h3 id=\"为什么不推荐使用外键和级联操作\"><a href=\"#为什么不推荐使用外键和级联操作\" class=\"headerlink\" title=\"为什么不推荐使用外键和级联操作\"></a>为什么不推荐使用外键和级联操作</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p>\n<ul>\n<li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；</li>\n<li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li>\n<li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li>\n</ul>\n<p><strong>外键好处</strong></p>\n<ul>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n</ul>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p>\n<p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<h3 id=\"DROP-TRUNCATE-DELETE区别\"><a href=\"#DROP-TRUNCATE-DELETE区别\" class=\"headerlink\" title=\"DROP&#x2F;TRUNCATE&#x2F;DELETE区别\"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol>\n<li>用法不同</li>\n</ol>\n<ul>\n<li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li>\n</ul>\n<p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p>\n<ol start=\"2\">\n<li>属于不同的数据库语言</li>\n</ol>\n<ul>\n<li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li>\n</ul>\n<ol start=\"3\">\n<li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li>\n</ol>\n<ul>\n<li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>DROP</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<h3 id=\"数据库设计分为哪几个步\"><a href=\"#数据库设计分为哪几个步\" class=\"headerlink\" title=\"数据库设计分为哪几个步\"></a>数据库设计分为哪几个步</h3><ol>\n<li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li>\n<li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li>数据库实施：包括编程、测试和试运行</li>\n<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>\n</ol>\n<h3 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p>\n<blockquote>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n</blockquote>\n<h3 id=\"SQL-NoSQL区别\"><a href=\"#SQL-NoSQL区别\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL区别\"></a>SQL&#x2F;NoSQL区别</h3><p>|         | SQL 数据库                                      | NoSQL 数据库                                                                                |<br>|：——–|———————————————-|——————————————————————————————|<br>| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |<br>| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |<br>| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |<br>| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |<br>| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |<br>| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |<br>| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |<br>| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |</p>\n<h3 id=\"NoSQL优劣\"><a href=\"#NoSQL优劣\" class=\"headerlink\" title=\"NoSQL优劣\"></a>NoSQL优劣</h3><p><strong>优点</strong></p>\n<ul>\n<li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li>\n<li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li>\n<li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li>\n<li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li>\n</ul>\n<h3 id=\"NoSQL分类\"><a href=\"#NoSQL分类\" class=\"headerlink\" title=\"NoSQL分类\"></a>NoSQL分类</h3><ul>\n<li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<h3 id=\"数据库分类\"><a href=\"#数据库分类\" class=\"headerlink\" title=\"数据库分类\"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p>\n<ul>\n<li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul>\n<li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li>\n</ul>\n</li>\n<li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul>\n<li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li>\n</ul>\n</li>\n<li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li>\n<li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li>\n</ul>\n<h3 id=\"SQL三种注释方式\"><a href=\"#SQL三种注释方式\" class=\"headerlink\" title=\"SQL三种注释方式\"></a>SQL三种注释方式</h3><ul>\n<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li>\n<li>多行注释：<code>/* 注释内容 */</code>。</li>\n<li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li>\n</ul>\n<h3 id=\"DML语句✅\"><a href=\"#DML语句✅\" class=\"headerlink\" title=\"DML语句✅\"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p>\n<h3 id=\"增删改查CRUD\"><a href=\"#增删改查CRUD\" class=\"headerlink\" title=\"增删改查CRUD\"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入完整的行</span></span><br><span class=\"line\"><span class=\"comment\">-- 插入一行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 插入多行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">12</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">18</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入行的一部分</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username, password, email)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入查询出来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> account;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> username<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span>, password<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 删除表中的指定数据</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;robot&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表中的数据</span></span><br><span class=\"line\"><span class=\"keyword\">TRUNCATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询数据</strong></p>\n<ul>\n<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>\n<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>\n<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>\n<li><code>ASC</code>：升序(默认)</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询单列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询多列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询所有列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询不同的值</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">vend_id <span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 限制查询结果</span></span><br><span class=\"line\"><span class=\"comment\">-- 返回前 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">0</span>, <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 返回第 3 ~ 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">2</span>, <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li>\n<li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> prod_price <span class=\"keyword\">DESC</span>, prod_name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>**<code>GROUP BY</code>**：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分组</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 分组后排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cust_name <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> NumberOfOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_email <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE-HAVING对比\"><a href=\"#WHERE-HAVING对比\" class=\"headerlink\" title=\"WHERE&#x2F;HAVING对比\"></a>WHERE&#x2F;HAVING对比</h3><ul>\n<li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li>\n<li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li>\n</ul>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>MYSQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   table1 [, table2 ]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  column_name operator</span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">    [<span class=\"keyword\">WHERE</span>])</span><br></pre></td></tr></table></figure></li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">      <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">      [<span class=\"keyword\">WHERE</span>]) <span class=\"keyword\">as</span> temp_table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  <span class=\"keyword\">condition</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, cust_contact</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> cust_id</span><br><span class=\"line\">                  <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\">                  <span class=\"keyword\">WHERE</span> order_num <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> order_num</span><br><span class=\"line\">                                      <span class=\"keyword\">FROM</span> orderitems</span><br><span class=\"line\">                                      <span class=\"keyword\">WHERE</span> prod_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SELECT语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">SET</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jack Jones&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- DELETE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>&lt;&gt;</code></td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>BETWEEN</code></td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td><code>LIKE</code></td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td><code>IN</code></td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"IN-BETWEEN\"><a href=\"#IN-BETWEEN\" class=\"headerlink\" title=\"IN&#x2F;BETWEEN\"></a>IN&#x2F;BETWEEN</h3><ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- IN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"keyword\">IN</span> (<span class=\"string\">&#x27;DLL01&#x27;</span>, <span class=\"string\">&#x27;BRS01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- BETWEEN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AND-OR-NOT\"><a href=\"#AND-OR-NOT\" class=\"headerlink\" title=\"AND&#x2F;OR&#x2F;NOT\"></a>AND&#x2F;OR&#x2F;NOT</h3><ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- AND示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">AND</span> prod_price <span class=\"operator\">&lt;=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- OR示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">OR</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;BRS01&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- NOT示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">NOT</span> <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- %示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%bean bag%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- _示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接JOIN\"><a href=\"#连接JOIN\" class=\"headerlink\" title=\"连接JOIN\"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> table1.column1, table2.column2...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> table2</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table1.common_column1 <span class=\"operator\">=</span> table2.common_column2; <span class=\"comment\">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JOIN....ON</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> c.cust_name, o.order_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers c</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Orders o</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.cust_id <span class=\"operator\">=</span> o.cust_id</span><br><span class=\"line\"><span class=\"comment\">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class=\"line\"><span class=\"comment\">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内连接-外连接\"><a href=\"#内连接-外连接\" class=\"headerlink\" title=\"内连接&#x2F;外连接\"></a>内连接&#x2F;外连接</h3><ul>\n<li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li>\n<li><code>外连接</code>：<ul>\n<li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li>\n<li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li>\n<li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">student表</span></span><br><span class=\"line\"><span class=\"comment\">student_id\tname</span></span><br><span class=\"line\"><span class=\"comment\">1\t        Alice</span></span><br><span class=\"line\"><span class=\"comment\">2\t        Bob</span></span><br><span class=\"line\"><span class=\"comment\">3\t        Carol</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">courses表</span></span><br><span class=\"line\"><span class=\"comment\">course_id\tstudent_id\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">101\t        1\t        Math</span></span><br><span class=\"line\"><span class=\"comment\">102\t        2\t        Science</span></span><br><span class=\"line\"><span class=\"comment\">103\t        4\t        History</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 内连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 左外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 右外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 全外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">FULL</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ON-WHERE区别\"><a href=\"#ON-WHERE区别\" class=\"headerlink\" title=\"ON&#x2F;WHERE区别\"></a>ON&#x2F;WHERE区别</h3><ul>\n<li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li>\n<li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li>\n</ul>\n<h3 id=\"组合UNION\"><a href=\"#组合UNION\" class=\"headerlink\" title=\"组合UNION\"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n<li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DDL语言✅\"><a href=\"#DDL语言✅\" class=\"headerlink\" title=\"DDL语言✅\"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p>\n<h3 id=\"数据库DATABSE\"><a href=\"#数据库DATABSE\" class=\"headerlink\" title=\"数据库DATABSE\"></a>数据库DATABSE</h3><ul>\n<li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li>\n<li>删除数据库：<code>DROP DATABASE 数据库名;</code></li>\n<li>选择数据库：<code>USE 数据库名;</code></li>\n<li>查看数据库：<code>SHOW DATABASES;</code></li>\n</ul>\n<h3 id=\"数据表TABLE\"><a href=\"#数据表TABLE\" class=\"headerlink\" title=\"数据表TABLE\"></a>数据表TABLE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 普通创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> (</span><br><span class=\"line\">id <span class=\"type\">int</span>(<span class=\"number\">10</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;Id&#x27;</span>,</span><br><span class=\"line\">username <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">password <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">email <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱&#x27;</span></span><br><span class=\"line\">) COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 根据已有表创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> vip_user <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"comment\">-- ALTER用于修改表</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> age <span class=\"type\">int</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\">MODIFY <span class=\"keyword\">COLUMN</span> age tinyint;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"视图VIEW\"><a href=\"#视图VIEW\" class=\"headerlink\" title=\"视图VIEW\"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p>\n<p>作用：</p>\n<ul>\n<li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li>\n<li>提高数据安全性：用来限制用户访问敏感数据。</li>\n<li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li>\n<li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> top_10_user_view <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, username</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">&lt;</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除视图</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引INDEX\"><a href=\"#索引INDEX\" class=\"headerlink\" title=\"索引INDEX\"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">table</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX user_index(id)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p>\n<p><strong>约束类型</strong></p>\n<ul>\n<li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li>\n<li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>：保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Users (</span><br><span class=\"line\">  Id <span class=\"type\">INT</span>(<span class=\"number\">10</span>) UNSIGNED <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增Id&#x27;</span>,</span><br><span class=\"line\">  Username <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">  Password <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">  Email <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱地址&#x27;</span>,</span><br><span class=\"line\">  Enabled TINYINT(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;是否有效&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (Id)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"TCL语句✅\"><a href=\"#TCL语句✅\" class=\"headerlink\" title=\"TCL语句✅\"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h3 id=\"事务TRANSACTION\"><a href=\"#事务TRANSACTION\" class=\"headerlink\" title=\"事务TRANSACTION\"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p>\n<p><strong>事务的四个特性(ACID)</strong></p>\n<ul>\n<li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li>\n<li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<blockquote>\n<p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开始事务</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 A</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">SAVEPOINT</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 B</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 回滚到保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> <span class=\"keyword\">TO</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务，只有操作 A 生效</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DCL语句✅\"><a href=\"#DCL语句✅\" class=\"headerlink\" title=\"DCL语句✅\"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p>\n<h3 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h3><ul>\n<li>授予用户帐户权限，用<code>GRANT</code>命令。<ul>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ul>\n</li>\n<li>撤销用户的权限，用<code>REVOKE</code>命令。<ul>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ul>\n</li>\n</ul>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- GRANT用法</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> privilege,[privilege],.. <span class=\"keyword\">ON</span> privilege_level</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span> [IDENTIFIED <span class=\"keyword\">BY</span> password]</span><br><span class=\"line\">[REQUIRE tsl_option]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> [GRANT_OPTION <span class=\"operator\">|</span> resource_option]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- REVOKE用法</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> privilege_type [(column_list)]</span><br><span class=\"line\">       [, priv_type [(column_list)]]...</span><br><span class=\"line\"><span class=\"keyword\">ON</span> [object_type] privilege_level</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> [, <span class=\"keyword\">user</span>]...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建账户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> myuser IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;mypassword&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 修改账户名</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;newuser&#x27;</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;myuser&#x27;</span>;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"><span class=\"comment\">-- 删除账户</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 查看权限</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> GRANTS <span class=\"keyword\">FOR</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 授予权限</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 更改密码</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> PASSWORD <span class=\"keyword\">FOR</span> myuser <span class=\"operator\">=</span> <span class=\"string\">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"游标CURSOR\"><a href=\"#游标CURSOR\" class=\"headerlink\" title=\"游标CURSOR\"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<h3 id=\"触发器TRIGGER\"><a href=\"#触发器TRIGGER\" class=\"headerlink\" title=\"触发器TRIGGER\"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n</ul>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>：将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>：从表中删除数据后激活。</li>\n</ul>\n<p><code>NEW</code> 和 <code>OLD</code>：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li>\n</ul>\n<h3 id=\"触发器语法\"><a href=\"#触发器语法\" class=\"headerlink\" title=\"触发器语法\"></a>触发器语法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name</span><br><span class=\"line\">trigger_time</span><br><span class=\"line\">trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">trigger_statements</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li><code>trigger_name</code>：触发器名</li>\n<li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\">DELIMITER $</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> `trigger_insert_user`</span><br><span class=\"line\">AFTER <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (NEW.id, <span class=\"string\">&#x27;add a user&#x27;</span>,  now());</span><br><span class=\"line\"><span class=\"keyword\">END</span> $</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看触发器</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TRIGGERS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p>\n<h3 id=\"MySQL基础✅\"><a href=\"#MySQL基础✅\" class=\"headerlink\" title=\"MySQL基础✅\"></a>MySQL基础✅</h3><h3 id=\"MySQL优点\"><a href=\"#MySQL优点\" class=\"headerlink\" title=\"MySQL优点\"></a>MySQL优点</h3><ul>\n<li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ul>\n<h3 id=\"什么是关系型数据库\"><a href=\"#什么是关系型数据库\" class=\"headerlink\" title=\"什么是关系型数据库\"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p>\n<h3 id=\"MySQL字段类型\"><a href=\"#MySQL字段类型\" class=\"headerlink\" title=\"MySQL字段类型\"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p>\n<ul>\n<li>数值类型：<ul>\n<li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li>\n<li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li>\n<li>定点数：<code>DECIMAL</code>。</li>\n</ul>\n</li>\n<li>字符串类型：<ul>\n<li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li>\n<li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li>\n</ul>\n</li>\n<li>日期和时间类型：<ul>\n<li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"整数类型的UNSIGNED属性\"><a href=\"#整数类型的UNSIGNED属性\" class=\"headerlink\" title=\"整数类型的UNSIGNED属性\"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>\n<blockquote>\n<p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p>\n</blockquote>\n<p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h3 id=\"CHAR-VARCHAR区别\"><a href=\"#CHAR-VARCHAR区别\" class=\"headerlink\" title=\"CHAR&#x2F;VARCHAR区别\"></a>CHAR&#x2F;VARCHAR区别</h3><ul>\n<li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li>\n<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li>\n<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>\n<li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li>\n</ul>\n<h3 id=\"VARCHAR-100-VARCHAR-10-区别\"><a href=\"#VARCHAR-100-VARCHAR-10-区别\" class=\"headerlink\" title=\"VARCHAR(100)&#x2F;VARCHAR(10)区别\"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul>\n<li>前者最大长度为 100，后者最大长度为 10。</li>\n<li>二者存储相同的字符串所占用的存储空间是一样的。</li>\n<li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li>\n</ul>\n<h3 id=\"DECIMAL和FLOAT-DOUBLE区别\"><a href=\"#DECIMAL和FLOAT-DOUBLE区别\" class=\"headerlink\" title=\"DECIMAL和FLOAT&#x2F;DOUBLE区别\"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p>\n<h3 id=\"为什么没不推荐使用TEXT-BLOB类型\"><a href=\"#为什么没不推荐使用TEXT-BLOB类型\" class=\"headerlink\" title=\"为什么没不推荐使用TEXT&#x2F;BLOB类型\"></a>为什么没不推荐使用TEXT&#x2F;BLOB类型</h3><ul>\n<li><code>TEXT</code>用于存储长文本数据，如博客数据。</li>\n<li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li>\n</ul>\n<p>这两种类型有如下缺陷：</p>\n<ul>\n<li>不能有默认值。</li>\n<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。</li>\n<li>检索效率较低。</li>\n<li>不能直接创建索引，需要指定前缀长度。</li>\n<li>可能会消耗大量的网络和 IO 带宽。</li>\n<li>可能导致表上的 DML 操作变慢。</li>\n</ul>\n<h3 id=\"DATETIME-TIMESTAMP区别\"><a href=\"#DATETIME-TIMESTAMP区别\" class=\"headerlink\" title=\"DATETIME&#x2F;TIMESTAMP区别\"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul>\n<li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li>\n<li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul>\n<li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li>\n</ul>\n</li>\n<li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li>\n</ul>\n<h3 id=\"NULL和’’区别\"><a href=\"#NULL和’’区别\" class=\"headerlink\" title=\"NULL和’’区别\"></a>NULL和’’区别</h3><ul>\n<li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul>\n<li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li>\n</ul>\n</li>\n<li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li>\n<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>\n<li><code>NULL</code> 会影响聚合函数的结果。<ul>\n<li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>\n</ul>\n</li>\n</ul>\n<p>不推荐使用<code>NULL</code>作为列默认值。</p>\n<h3 id=\"Boolean类型如何在MySQL中存储\"><a href=\"#Boolean类型如何在MySQL中存储\" class=\"headerlink\" title=\"Boolean类型如何在MySQL中存储\"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p>\n<h3 id=\"MySQL基础架构✅\"><a href=\"#MySQL基础架构✅\" class=\"headerlink\" title=\"MySQL基础架构✅\"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li>\n<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎，其中 <code>InnoDB</code> 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 <code>InnoDB</code>，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li>\n</ul>\n<p><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<ul>\n<li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li>查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。</li>\n<li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li>优化器：按照 MySQL 认为最优的方案去执行。</li>\n<li>执行器：执行语句，然后从存储引擎返回数据。</li>\n<li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<ol>\n<li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>\n</li>\n<li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n</li>\n<li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p>\n<ul>\n<li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 SELECT，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>\n<li>第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</li>\n</ul>\n</li>\n<li><p>优化器。<br>优化器以它认为的最优的执行方案去执行(有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解)，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n</li>\n<li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n</li>\n</ol>\n<h3 id=\"SQL语句在MySQL中的执行过程\"><a href=\"#SQL语句在MySQL中的执行过程\" class=\"headerlink\" title=\"SQL语句在MySQL中的执行过程\"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验(如果命中缓存)—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> tb_student  A <span class=\"keyword\">WHERE</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;18&#x27;</span> <span class=\"keyword\">AND</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接返回，如果没有，执行下一步。</li>\n<li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询<code>SELECT</code>，提取需要查询的表名为 <code>tb_student</code>，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n<li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul>\n<li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li>\n<li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。</li>\n</ul>\n</li>\n<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>\n</ol>\n<p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—<code>redo log</code>(<code>prepare</code> 状态)—&gt;<code>binlog</code>—&gt;<code>redo log</code>(<code>commit</code> 状态)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> tb_student A <span class=\"keyword\">SET</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;19&#x27;</span> <span class=\"keyword\">WHERE</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p>\n<ol>\n<li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li>\n<li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li>\n<li>更新完成。</li>\n</ol>\n<h3 id=\"MySQL存储引擎✅\"><a href=\"#MySQL存储引擎✅\" class=\"headerlink\" title=\"MySQL存储引擎✅\"></a>MySQL存储引擎✅</h3><h3 id=\"MySQL支持哪些存储引擎？\"><a href=\"#MySQL支持哪些存储引擎？\" class=\"headerlink\" title=\"MySQL支持哪些存储引擎？\"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p>\n<p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p>\n<h3 id=\"MySQL存储引擎架构\"><a href=\"#MySQL存储引擎架构\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。</p>\n<h3 id=\"MyISAM-InnoDB存储引擎区别\"><a href=\"#MyISAM-InnoDB存储引擎区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB存储引擎区别\"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul>\n<li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>\n<li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>(可重读)隔离级别是可以解决幻读问题发生的(基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>)。</li>\n<li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li>\n<li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li>\n<li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li>\n<li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li>\n<li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li>\n<li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池(<code>Buffer Pool</code>)缓存数据页和索引页，<code>MyISAM</code> 使用键缓存(<code>Key Cache</code>)仅缓存索引页而不缓存数据页。</li>\n</ul>\n<h3 id=\"MySQL索引✅\"><a href=\"#MySQL索引✅\" class=\"headerlink\" title=\"MySQL索引✅\"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyIsam</code>，都使用了 <strong>B+树</strong>作为索引结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h3 id=\"索引底层数据类型选型\"><a href=\"#索引底层数据类型选型\" class=\"headerlink\" title=\"索引底层数据类型选型\"></a>索引底层数据类型选型</h3><ol>\n<li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(<code>Adaptive Hash Index</code>)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p>\n</li>\n<li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p>\n</li>\n<li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p>\n</li>\n<li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p>\n</li>\n<li><p>B树&amp;B+树<br>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced (平衡)的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br><strong>B树&amp;B+树区别</strong></p>\n</li>\n</ol>\n<ul>\n<li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li>\n<li>B 树的叶子节点都是独立的;</li>\n<li>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>\n</ul>\n<p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>\n<h3 id=\"MyISAM-InnoDB索引区别\"><a href=\"#MyISAM-InnoDB索引区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB索引区别\"></a>MyISAM&#x2F;InnoDB索引区别</h3><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p>\n<ul>\n<li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。</li>\n<li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>按照数据结构维度划分：</p>\n<ul>\n<li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li>\n<li>哈希索引：类似键值对的形式，一次即可定位。</li>\n</ul>\n<p>按照底层存储方式角度划分：</p>\n<ul>\n<li>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>\n<li>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。<code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>\n</ul>\n<p>按照应用维度划分：</p>\n<ul>\n<li>主键索引：加速查询 + 列值唯一(不可以有 <code>NULL</code>)+ 表中只有一个。</li>\n<li>普通索引：仅加速查询。</li>\n<li>唯一索引：加速查询 + 列值唯一(可以有 <code>NULL</code>)。</li>\n<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的索引新特性：</p>\n<ul>\n<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。</li>\n<li>降序索引：之前的版本就支持通过 <code>DESC</code> 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 <code>GROUP BY</code> 语句进行隐式排序。</li>\n<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p>\n<p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p>\n<h3 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h3><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p>\n<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>\n<ul>\n<li>唯一索引(<code>Unique Key</code>)：唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li>普通索引(<code>Index</code>)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li>\n<li>前缀索引(<code>Prefix</code>)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>\n<li>全文索引(<code>Full Text</code>)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li>\n</ul>\n<h3 id=\"聚簇索引-非聚簇索引\"><a href=\"#聚簇索引-非聚簇索引\" class=\"headerlink\" title=\"聚簇索引&#x2F;非聚簇索引\"></a>聚簇索引&#x2F;非聚簇索引</h3><p>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>\n<li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li>\n<li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<p>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>\n<p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据</li>\n<li>可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ul>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p>\n<h3 id=\"覆盖索引-联合索引\"><a href=\"#覆盖索引-联合索引\" class=\"headerlink\" title=\"覆盖索引&#x2F;联合索引\"></a>覆盖索引&#x2F;联合索引</h3><ul>\n<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n</ul>\n<h3 id=\"联合索引最左前缀匹配原则\"><a href=\"#联合索引最左前缀匹配原则\" class=\"headerlink\" title=\"联合索引最左前缀匹配原则\"></a>联合索引最左前缀匹配原则</h3><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>\n<h3 id=\"索引下推ICP\"><a href=\"#索引下推ICP\" class=\"headerlink\" title=\"索引下推ICP\"></a>索引下推ICP</h3><p>索引下推(<code>Index Condition Pushdown,ICP</code>) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p>\n<p><strong>原理</strong><br><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p>\n<p>索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> zipcode <span class=\"operator\">=</span> <span class=\"string\">&#x27;431200&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span>(birthdate) <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li>\n<li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li>\n</ul>\n<p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p>\n<h3 id=\"MySQL查询缓存✅\"><a href=\"#MySQL查询缓存✅\" class=\"headerlink\" title=\"MySQL查询缓存✅\"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p>查询缓存不命中的情况：</p>\n<ul>\n<li>两个查询在任何字符上的不同都会导致缓存不命中。</li>\n<li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n</ul>\n<p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p>\n<h3 id=\"MySQL三大日志✅\"><a href=\"#MySQL三大日志✅\" class=\"headerlink\" title=\"MySQL三大日志✅\"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>(归档日志)和事务日志 <code>redo log</code>(重做日志)和 <code>undo log</code>(回滚日志)。</p>\n<p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h3><p><code>redo log</code>(重做日志)是 <code>InnoDB</code> 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p>\n<p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(<code>redo log buffer</code>)里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<h3 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h3><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p>\n<ul>\n<li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li>\n<li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>\n<li><code>Checkpoint</code>(检查点)：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>\n<li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li>\n<li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</li>\n</ul>\n<h3 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h3><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p>\n<ul>\n<li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li>\n<li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li>\n<li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>(文件系统缓存)。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>默认策略为第二种。</p>\n<h3 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p>\n<p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h3><p><code>binlog</code> 有三种记录格式：</p>\n<ul>\n<li><code>Statement</code>：记录的是 SQL 语句，如 <code>UPDATE t SET c=c+1 WHERE id=2</code>。<ul>\n<li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li>\n</ul>\n</li>\n<li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul>\n<li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li>\n</ul>\n</li>\n<li><code>Mixed</code>：记录的是上面两种的混合模式。<ul>\n<li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</p>\n<p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p>\n<ul>\n<li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul>\n<li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li>\n</ul>\n</li>\n<li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li>\n<li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul>\n<li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p><code>redo log</code>(重做日志)让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>(归档日志)保证了 MySQL 集群架构的数据一致性。</p>\n<p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p>\n<p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p>\n<p>为了解决数据不一致问题，<code>InnoDB</code> 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p>\n<ul>\n<li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li>\n<li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li>\n</ul>\n<p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p>\n<p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p><code>undo log</code> 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p>\n<p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p>\n<p><code>undo log</code> 采用 <code>segment</code>(段)进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理(<code>purge</code>)的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p>\n<h3 id=\"MySQL事务✅\"><a href=\"#MySQL事务✅\" class=\"headerlink\" title=\"MySQL事务✅\"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<h3 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h3><ul>\n<li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性(Consistency)：执行事务前后，数据保持一致。</li>\n<li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<blockquote>\n<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>\n</blockquote>\n<h3 id=\"并发事务存在的问题\"><a href=\"#并发事务存在的问题\" class=\"headerlink\" title=\"并发事务存在的问题\"></a>并发事务存在的问题</h3><h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p>\n<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>解决：</p>\n<ul>\n<li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li>\n</ul>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>解决：</p>\n<ul>\n<li>乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li>\n<li>悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li>\n</ul>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p>\n<p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li>\n</ul>\n<h3 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h3><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p>\n<p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>\n<li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li>\n</ul>\n<h3 id=\"不可重复读和幻读有什么区别\"><a href=\"#不可重复读和幻读有什么区别\" class=\"headerlink\" title=\"不可重复读和幻读有什么区别\"></a>不可重复读和幻读有什么区别</h3><ul>\n<li>不可重复读：多次读取同一数据，发现数据不一致。</li>\n<li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p>\n<ul>\n<li>解决不可重复读：执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>解决幻读：执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>\n</ul>\n<h3 id=\"并发事务的控制方式有哪些\"><a href=\"#并发事务的控制方式有哪些\" class=\"headerlink\" title=\"并发事务的控制方式有哪些\"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制(<code>MVCC，Multiversion concurrency control</code>)可以看作是乐观控制的模式。</p>\n<ul>\n<li>锁：<ul>\n<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>\n<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>\n</ul>\n</li>\n<li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p>\n<blockquote>\n<p>注意：不论是表级锁还是行级锁，都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)这两类。</p>\n</blockquote>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、<code>read view</code>、<code>undo log</code>。</p>\n<ul>\n<li><code>undo log</code>：<code>undo log</code> 用于记录某行数据的多个版本的数据。</li>\n<li><code>read view</code> 和 隐藏字段： 用来判断当前版本数据的可见性。</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n<th align=\"center\">实现方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">READ-UNCOMMITTED</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">READ-COMMITTED</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁</td>\n</tr>\n<tr>\n<td align=\"center\">REPEATABLE-READ</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td>\n</tr>\n<tr>\n<td align=\"center\">SERIALIZABLE</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">基于 锁</td>\n</tr>\n</tbody></table>\n<p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p>\n<p><code>InnoDB</code> 实现的 <code>REPEATABLE-READ</code> 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p>\n<ul>\n<li>快照读：由 <code>MVCC</code> 机制来保证不出现幻读。</li>\n<li>当前读：使用 <code>Next-Key Lock</code> 进行加锁来保证不出现幻读，<code>Next-Key Lock</code> 是行锁(<code>Record Lock</code>)和间隙锁(<code>Gap Lock</code>)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li>\n</ul>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code> ，不过 <code>InnoDB</code> 存储引擎默认使用 <code>REPEATABLE-READ</code>，这并不会有任何性能损失。<code>InnoDB</code> 存储引擎在分布式事务的情况下一般会用到 <code>SERIALIZABLE</code> 隔离级别。</p>\n<h3 id=\"MVCC✅\"><a href=\"#MVCC✅\" class=\"headerlink\" title=\"MVCC✅\"></a>MVCC✅</h3><p>多版本并发控制(<code>Multi-Version Concurrency Control, MVCC</code>) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，<code>MVCC</code> 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>\n<ol>\n<li><p>读操作(<code>SELECT</code>)<br>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：</p>\n<ul>\n<li>对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li>\n<li>如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li>\n<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li>\n</ul>\n</li>\n<li><p>写操作(<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>)<br>当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：</p>\n<ul>\n<li>对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>\n<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li>\n<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li>\n</ul>\n</li>\n<li><p>事务提交和回滚</p>\n<ul>\n<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>\n<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>\n</ul>\n</li>\n<li><p>版本回收<br>为了防止数据库中的版本无限增长，<code>MVCC</code> 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p>\n</li>\n</ol>\n<p><code>MVCC</code> 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>\n<h3 id=\"一致性非锁定读\"><a href=\"#一致性非锁定读\" class=\"headerlink\" title=\"一致性非锁定读\"></a>一致性非锁定读</h3><p>一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。</p>\n<p><code>InnoDB</code>中，<code>MVCC</code>就是对一致性非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(<code>snapshot read</code>)。</p>\n<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>SELECT</code> 语句(不包括 <code>SELECT ... lock in share mode</code> ，<code>SELECT ... FOR UPDATE</code>)则会使用一致性非锁定读(<code>MVCC</code>)。<code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p>\n<h3 id=\"锁定读-当前读\"><a href=\"#锁定读-当前读\" class=\"headerlink\" title=\"锁定读&#x2F;当前读\"></a>锁定读&#x2F;当前读</h3><p>在锁定读下，读取的是数据的最新版本。下面语句都是锁定读&#x2F;当前读，会对读取到的记录加锁。</p>\n<ul>\n<li><code>SELECT ... lock in share mode</code>： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。</li>\n<li><code>SELECT ... FOR UPDATE</code>： 对读取到记录加排他锁，其他事务不能任何锁。</li>\n<li><code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作：对读取到记录加排他锁，其他事务不能任何锁。</li>\n</ul>\n<p>当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以<code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据。</p>\n<h3 id=\"InnoDB的MVCC实现\"><a href=\"#InnoDB的MVCC实现\" class=\"headerlink\" title=\"InnoDB的MVCC实现\"></a>InnoDB的MVCC实现</h3><p><code>MVCC</code> 的实现依赖于：隐藏字段、<code>Read View</code>、<code>undo log</code>。在内部实现中，<code>InnoDB</code> 通过数据行隐藏字段的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p>\n<p><strong>隐藏字段</strong><br>InnoDB为每行数据添加了三个隐藏字段：</p>\n<ul>\n<li><code>DB_TRX_ID</code>：表示最后一次更新或插入操作的事务ID。<code>DELETE</code>操作也被视为更新。</li>\n<li><code>DB_ROLL_PTR</code>：指向该行<code>undo log</code> 日志的指针。</li>\n<li><code>DB_ROW_ID</code>：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 <code>DB_ROW_ID</code> 作为聚簇索引。</li>\n</ul>\n<p><strong>Read View</strong><br><code>Read View</code> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。</p>\n<ul>\n<li><code>m_low_limit_id</code>(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>\n<li><code>m_up_limit_id</code>(上限事务ID)：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>\n<li><code>m_ids</code>(活跃事务列表)：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务(正在内存中)</li>\n<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>\n</ul>\n<p><strong>undo log</strong><br>其有两个作用：</p>\n<ul>\n<li>事务回滚时用于将数据恢复到修改前的样子</li>\n<li><code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前版本的快照数据，以此实现非锁定读</li>\n</ul>\n<h3 id=\"RC和RR隔离级别下MVCC的差异\"><a href=\"#RC和RR隔离级别下MVCC的差异\" class=\"headerlink\" title=\"RC和RR隔离级别下MVCC的差异\"></a>RC和RR隔离级别下MVCC的差异</h3><ul>\n<li><code>Read Committed</code>：<code>MVCC</code> 会在每次<code>SELECT</code>读取数据时创建一个新的 <code>Read View</code>(<code>m_ids</code>列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 <code>Read View</code>，因此会导致一些不可重复读问题。</li>\n<li><code>Repeatable Read</code>：<code>MVCC</code> 会在事务开始后第一次 <code>SELECT</code>创建一个 <code>Read View</code>，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。</li>\n</ul>\n<h3 id=\"RR隔离级别下的MVCC如何解决幻读\"><a href=\"#RR隔离级别下的MVCC如何解决幻读\" class=\"headerlink\" title=\"RR隔离级别下的MVCC如何解决幻读\"></a>RR隔离级别下的MVCC如何解决幻读</h3><p><code>MVCC</code>+<code>Next-key-Lock</code> 防止幻读</p>\n<ul>\n<li>执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>\n<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>\n</ul>\n</li>\n<li>执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等当前读<ul>\n<li>当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL锁✅\"><a href=\"#MySQL锁✅\" class=\"headerlink\" title=\"MySQL锁✅\"></a>MySQL锁✅</h3><h3 id=\"表级锁-行级锁区别\"><a href=\"#表级锁-行级锁区别\" class=\"headerlink\" title=\"表级锁&#x2F;行级锁区别\"></a>表级锁&#x2F;行级锁区别</h3><ul>\n<li><p>表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，<code>MyISAM</code> 和 <code>InnoDB</code> 引擎都支持表级锁。</p>\n</li>\n<li><p>行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p>\n</li>\n<li><p><code>MyISAM</code> 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p>\n</li>\n<li><p><code>InnoDB</code> 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 <code>InnoDB</code>的并发性能更高</p>\n</li>\n</ul>\n<h3 id=\"InnoDB的行级锁\"><a href=\"#InnoDB的行级锁\" class=\"headerlink\" title=\"InnoDB的行级锁\"></a>InnoDB的行级锁</h3><ul>\n<li>记录锁(<code>Record Lock</code>)：也被称为记录锁，属于单个行记录上的锁。</li>\n<li>间隙锁(<code>Gap Lock</code>)：锁定一个范围，不包括记录本身。</li>\n<li>临键锁(<code>Next-Key Lock</code>)：<code>Record Lock</code>+<code>Gap Lock</code>，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>\n</ul>\n<h3 id=\"共享锁-排他锁\"><a href=\"#共享锁-排他锁\" class=\"headerlink\" title=\"共享锁&#x2F;排他锁\"></a>共享锁&#x2F;排他锁</h3><p>表级锁和行级锁都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)两类。</p>\n<ul>\n<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>\n<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>\n</ul>\n<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 </p>\n<p>由于有<code>MVCC</code>机制，对于一般的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加任何锁。</p>\n<h3 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h3><p>意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。</p>\n<p>意向锁是表级锁，有两种：</p>\n<ul>\n<li>意向共享锁(<code>Intention Shared Lock</code>，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。</li>\n<li>意向排他锁(<code>Intention Exclusive Lock</code>，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。</li>\n</ul>\n<p>意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，<code>InnoDB</code> 会先获取该数据行所在在数据表的对应意向锁。</p>\n<p>意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。</p>\n<h3 id=\"当前读-快照读区别\"><a href=\"#当前读-快照读区别\" class=\"headerlink\" title=\"当前读&#x2F;快照读区别\"></a>当前读&#x2F;快照读区别</h3><ul>\n<li>当前读(一致性锁定读)：执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code><ul>\n<li>当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>\n</ul>\n</li>\n<li>快照读(一致性非锁定读)：执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>\n<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL性能优化✅\"><a href=\"#MySQL性能优化✅\" class=\"headerlink\" title=\"MySQL性能优化✅\"></a>MySQL性能优化✅</h3><h3 id=\"可以用MySQL存储文件吗？\"><a href=\"#可以用MySQL存储文件吗？\" class=\"headerlink\" title=\"可以用MySQL存储文件吗？\"></a>可以用MySQL存储文件吗？</h3><p>可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。</p>\n<h3 id=\"MySQL如何存储IP地址\"><a href=\"#MySQL如何存储IP地址\" class=\"headerlink\" title=\"MySQL如何存储IP地址\"></a>MySQL如何存储IP地址</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：</p>\n<ul>\n<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code>：把整型的 ip 转为地址</li>\n</ul>\n<p>存储数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，取出数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>\n<h3 id=\"如何分析SQL性能\"><a href=\"#如何分析SQL性能\" class=\"headerlink\" title=\"如何分析SQL性能\"></a>如何分析SQL性能</h3><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>\n<h3 id=\"MySQL执行计划✅\"><a href=\"#MySQL执行计划✅\" class=\"headerlink\" title=\"MySQL执行计划✅\"></a>MySQL执行计划✅</h3><p>执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> dept_emp <span class=\"keyword\">WHERE</span> emp_no <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> emp_no <span class=\"keyword\">FROM</span> dept_emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> emp_no <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(emp_no)<span class=\"operator\">&gt;</span><span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> id <span class=\"operator\">|</span> select_type <span class=\"operator\">|</span> <span class=\"keyword\">table</span>    <span class=\"operator\">|</span> partitions <span class=\"operator\">|</span> type  <span class=\"operator\">|</span> possible_keys   <span class=\"operator\">|</span> key     <span class=\"operator\">|</span> key_len <span class=\"operator\">|</span> <span class=\"keyword\">ref</span>  <span class=\"operator\">|</span> <span class=\"keyword\">rows</span>   <span class=\"operator\">|</span> filtered <span class=\"operator\">|</span> Extra       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">1</span> <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span>     <span class=\"operator\">|</span> dept_emp <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>       <span class=\"operator\">|</span> <span class=\"keyword\">ALL</span>   <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>            <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"number\">331143</span> <span class=\"operator\">|</span>   <span class=\"number\">100.00</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> <span class=\"keyword\">where</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">2</span> <span class=\"operator\">|</span> SUBQUERY    <span class=\"operator\">|</span> dept_emp <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>       <span class=\"operator\">|</span> index <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span>,dept_no <span class=\"operator\">|</span> <span class=\"keyword\">PRIMARY</span> <span class=\"operator\">|</span> <span class=\"number\">16</span>      <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"number\">331143</span> <span class=\"operator\">|</span>   <span class=\"number\">100.00</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> index <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>\n<p>各列含义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>列名</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>SELECT 查询的序列标识符</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT 关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>用到的表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区，对于未分区的表，值为 NULL</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>所选索引的长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引等值查询时，与索引作比较的列或常量</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预计要读取的行数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>按表条件过滤后，留存的记录数的百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>附加信息</td>\n</tr>\n</tbody></table>\n<p><strong>type(重要)</strong><br>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code><br>常见的几种类型具体含义如下：</p>\n<ul>\n<li><code>system</code>：如果表使用的引擎对于表行数统计是精确的(如：<code>MyISAM</code>)，且表中只有一行记录的情况下，访问方法是 <code>system</code>，是 <code>const</code> 的一种特例。</li>\n<li><code>const</code>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>\n<li><code>eq_ref</code>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 <code>system</code> 与 <code>const</code> 之外最好的 <code>JOIN</code> 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>\n<li><code>ref</code>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>\n<li><code>index_merge</code>：当查询条件使用了多个索引时，表示开启了 <code>Index Merge</code> 优化，此时执行计划中的 <code>key</code> 列列出了使用到的索引。</li>\n<li><code>range</code>：对索引列进行范围查询，执行计划中的 <code>key</code> 列表示哪个索引被使用了。</li>\n<li><code>index</code>：查询遍历了整棵索引树，与 <code>ALL</code> 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>\n<li><code>ALL</code>：全表扫描。</li>\n</ul>\n<p><strong>key(重要)</strong><br><code>key</code> 列表示 MySQL 实际使用到的索引。如果为 <code>NULL</code>，则表示未用到索引。</p>\n<p><strong>Extra(重要)</strong></p>\n<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>\n<ul>\n<li><code>Using filesort</code>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>\n<li><code>Using temporary</code>：MySQL 需要创建临时表来存储查询的结果，常见于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</li>\n<li><code>Using index</code>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>\n<li><code>Using index condition</code>：表示查询优化器选择使用了索引条件下推这个特性。</li>\n<li><code>Using where</code>：表明查询使用了 <code>WHERE</code> 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>\n<li><code>Using join buffer (Block Nested Loop)</code>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 <code>join buffer</code> 中，再遍历被驱动表与驱动表进行查询。</li>\n</ul>\n<p>当 <code>Extra</code> 列包含 <code>Using filesort</code> 或 <code>Using temporary</code> 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>\n<h3 id=\"MySQL读写分离✅\"><a href=\"#MySQL读写分离✅\" class=\"headerlink\" title=\"MySQL读写分离✅\"></a>MySQL读写分离✅</h3><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。</p>\n<p>一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>\n<h3 id=\"如何实现读写分离\"><a href=\"#如何实现读写分离\" class=\"headerlink\" title=\"如何实现读写分离\"></a>如何实现读写分离</h3><ol>\n<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>\n<li>保证主数据库和从数据库之间的数据是实时同步的，即主从复制。</li>\n<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>\n</ol>\n<p>基于项目层面有两种方案：</p>\n<ol>\n<li>代理方式<br>可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。</li>\n<li>组件方式<br>可以通过引入第三方组件来实现读写分离，例如使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</li>\n</ol>\n<h3 id=\"主从复制原理\"><a href=\"#主从复制原理\" class=\"headerlink\" title=\"主从复制原理\"></a>主从复制原理</h3><p>MySQL 主从复制是依赖于 <code>binlog</code> 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 <code>canal</code>)的底层一般也是依赖 <code>binlog</code>。具体如下：</p>\n<ol>\n<li>主库将数据库中数据的变化写入到 <code>binlog</code></li>\n<li>从库连接主库</li>\n<li>从库创建一个 I&#x2F;O 线程向主库请求更新的 <code>binlog</code></li>\n<li>主库创建一个 <code>binlog dump</code> 线程来发送 <code>binlog</code>，从库中的 I&#x2F;O 线程负责接收</li>\n<li>从库的 I&#x2F;O 线程将接收的 <code>binlog</code> 写入到中继日志<code>relay log</code> 中。</li>\n<li>从库的 SQL 线程读取中继日志<code>relay log</code> 同步数据到本地(也就是再执行一遍 SQL )。</li>\n</ol>\n<blockquote>\n<p><code>binlog</code>主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)<br><code>relay log</code> 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。</p>\n</blockquote>\n<h3 id=\"如何避免主从延迟\"><a href=\"#如何避免主从延迟\" class=\"headerlink\" title=\"如何避免主从延迟\"></a>如何避免主从延迟</h3><p>主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。</p>\n<ul>\n<li>强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。</li>\n<li>延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。</li>\n</ul>\n<h3 id=\"什么情况下会出现主从延迟\"><a href=\"#什么情况下会出现主从延迟\" class=\"headerlink\" title=\"什么情况下会出现主从延迟\"></a>什么情况下会出现主从延迟</h3><p>主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：</p>\n<ul>\n<li>从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度跟不上主库写入 <code>binlog</code> 的速度，导致从库 <code>relay log</code> 的数据滞后于主库 <code>binlog</code> 的数据；</li>\n<li>从库 SQL 线程执行 <code>relay log</code> 的速度跟不上从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度，导致从库的数据滞后于从库 <code>relay log</code> 的数据。</li>\n</ul>\n<p>下面是一些可能导致主从延迟的原因及解决方案：</p>\n<ol>\n<li>从库机器性能比主库差：从库接收 <code>binlog</code> 写入 <code>relay log</code> 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 </li>\n<li>从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 <code>binlog</code> 接入到 <code>Hadoop</code>、<code>Elasticsearch</code> 等系统中。</li>\n<li>大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。</li>\n<li>从库太多：主库需要将 <code>binlog</code> 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。</li>\n<li>网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 <code>binlog</code> 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。</li>\n<li>单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。</li>\n<li>复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 <code>semi-sync</code> 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。</li>\n</ol>\n<h3 id=\"MySQL分库分表✅\"><a href=\"#MySQL分库分表✅\" class=\"headerlink\" title=\"MySQL分库分表✅\"></a>MySQL分库分表✅</h3><p>分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。<br><strong>分库</strong><br>分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>\n<ul>\n<li>垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。<ul>\n<li>如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</li>\n</ul>\n</li>\n<li>水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。<ul>\n<li>订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。</li>\n</ul>\n</li>\n</ul>\n<p><strong>分表</strong><br>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>\n<ul>\n<li>垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。</li>\n<li>水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</li>\n</ul>\n<h3 id=\"什么情况下需要分库分表\"><a href=\"#什么情况下需要分库分表\" class=\"headerlink\" title=\"什么情况下需要分库分表\"></a>什么情况下需要分库分表</h3><ul>\n<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>\n<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>\n<li>应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。</li>\n</ul>\n<h3 id=\"分片算法\"><a href=\"#分片算法\" class=\"headerlink\" title=\"分片算法\"></a>分片算法</h3><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>\n<p>常见的分片算法有：</p>\n<ul>\n<li>范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1<del>299999 的记录分到第一个表， 300000</del>599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。</li>\n<li>哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。</li>\n<li>地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。</li>\n<li>一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</li>\n</ul>\n<h3 id=\"分片键\"><a href=\"#分片键\" class=\"headerlink\" title=\"分片键\"></a>分片键</h3><p>分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。</p>\n<h3 id=\"分库分表会带来什么问题\"><a href=\"#分库分表会带来什么问题\" class=\"headerlink\" title=\"分库分表会带来什么问题\"></a>分库分表会带来什么问题</h3><ul>\n<li>事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。</li>\n<li>跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 <code>GROUP BY</code>，<code>ORDER BY</code> 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。</li>\n<li>数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。</li>\n<li>。。。</li>\n</ul>\n<h3 id=\"分库分表中数据如何迁移\"><a href=\"#分库分表中数据如何迁移\" class=\"headerlink\" title=\"分库分表中数据如何迁移\"></a>分库分表中数据如何迁移</h3><ul>\n<li>停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。</li>\n<li>双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。</li>\n</ul>\n<h3 id=\"MySQL数据冷热分离✅\"><a href=\"#MySQL数据冷热分离✅\" class=\"headerlink\" title=\"MySQL数据冷热分离✅\"></a>MySQL数据冷热分离✅</h3><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>\n<p><strong>优缺点</strong></p>\n<ul>\n<li>优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)</li>\n<li>缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。</li>\n</ul>\n<h3 id=\"冷数据和热数据\"><a href=\"#冷数据和热数据\" class=\"headerlink\" title=\"冷数据和热数据\"></a>冷数据和热数据</h3><ul>\n<li>热数据是指经常被访问和修改且需要快速访问的数据。</li>\n<li>冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</li>\n</ul>\n<p><strong>冷热数据如何区分</strong></p>\n<ol>\n<li>时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。<ul>\n<li>例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li>\n</ul>\n</li>\n<li>访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。<ul>\n<li>例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"冷数据如何迁移\"><a href=\"#冷数据如何迁移\" class=\"headerlink\" title=\"冷数据如何迁移\"></a>冷数据如何迁移</h3><ul>\n<li>任务调度：可以利用 <code>xxl-job</code> 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li>\n<li>监听数据库的变更日志 <code>binlog</code> ：将满足冷数据条件的数据从 <code>binlog</code> 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li>\n</ul>\n<h3 id=\"冷数据如何存储\"><a href=\"#冷数据如何存储\" class=\"headerlink\" title=\"冷数据如何存储\"></a>冷数据如何存储</h3><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：</p>\n<ul>\n<li>中小厂：直接使用 MySQL&#x2F;PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)</li>\n<li>大厂：Hbase(常用)、RocksDB、Doris、Cassandra</li>\n</ul>\n<h3 id=\"MySQL字符集\"><a href=\"#MySQL字符集\" class=\"headerlink\" title=\"MySQL字符集\"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p>\n<h3 id=\"MySQL字符集层次级别\"><a href=\"#MySQL字符集层次级别\" class=\"headerlink\" title=\"MySQL字符集层次级别\"></a>MySQL字符集层次级别</h3><ul>\n<li>MySQL 中的字符集分为四个层次：<ul>\n<li>server(MySQL 实例级别)</li>\n<li>database(库级别)</li>\n<li>table(表级别)</li>\n<li>column(字段级别)</li>\n</ul>\n</li>\n</ul>\n<p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>\n<h3 id=\"Redis为什么这么快\"><a href=\"#Redis为什么这么快\" class=\"headerlink\" title=\"Redis为什么这么快\"></a>Redis为什么这么快</h3><ul>\n<li>Redis 基于内存，内存的访问速度比磁盘快很多；</li>\n<li>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环</strong>和 <strong>IO 多路复用</strong></li>\n<li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li>\n<li>Redis 通信协议实现简单且解析高效。</li>\n</ul>\n<h3 id=\"Redis-Memcached\"><a href=\"#Redis-Memcached\" class=\"headerlink\" title=\"Redis&#x2F;Memcached\"></a>Redis&#x2F;Memcached</h3><p>共同点：</p>\n<ul>\n<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>\n<li>都有过期策略。</li>\n<li>两者的性能都非常高。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>Redis 支持更丰富的数据结构，如 <code>string</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code> 等，而 Memcached 只支持 <code>key-value</code> 的数据结构。</li>\n<li>Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。</li>\n<li>Redis 支持集群模式，而 Memcached 不支持集群模式。</li>\n<li>Redis 支持事务，而 Memcached 不支持事务。</li>\n<li>Redis 支持发布订阅，而 Memcached 不支持发布订阅。</li>\n<li>Redis 是单线程，而 Memcached 是多线程。</li>\n</ul>\n<h3 id=\"为什么用Redis\"><a href=\"#为什么用Redis\" class=\"headerlink\" title=\"为什么用Redis\"></a>为什么用Redis</h3><ol>\n<li>高性能：Redis 是基于内存的，读写速度非常快。</li>\n<li>高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。</li>\n<li>功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</li>\n</ol>\n<h3 id=\"三种常用缓存读写策略\"><a href=\"#三种常用缓存读写策略\" class=\"headerlink\" title=\"三种常用缓存读写策略\"></a>三种常用缓存读写策略</h3><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。<br>读：</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回</li>\n<li>cache 中读取不到的话，就从 db 中读取数据返回</li>\n<li>把 db 中读取到的数据写入 cache 中。</li>\n</ul>\n<p>写：</p>\n<ul>\n<li>先更新 db</li>\n<li>再删除 cache 中的数据</li>\n</ul>\n<blockquote>\n<p>在写的过程中可以先删除cache，再更新 db 吗？<br>不可以。这样可能会造成 数据库(db)和缓存(Cache)数据不一致的问题。<br>如场景：请求 1 先写数据 A，请求 2 随后读数据 A。<br>执行过程为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>\n<p>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？<br>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。<br>如场景：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。<br>执行过程为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A(此时缓存中无数据 A ，故不用执行删除缓存操作 ) -&gt; 请求 1 将数据 A 写入 cache</p>\n</blockquote>\n<p>这种策略有一些缺陷：</p>\n<ul>\n<li>首次请求数据一定不在 cache 的问题<ul>\n<li>解决办法：可以将热点数据可以提前放入 cache 中。</li>\n</ul>\n</li>\n<li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。<ul>\n<li>解决办法：可以使用Write Through 或者 Write Behind 策略。<br><strong>读写穿透</strong>(<code>Read/Write Through Pattern</code>)<br>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li>\n</ul>\n</li>\n</ul>\n<p>读：</p>\n<ul>\n<li>从 cache 中读取数据，读取到就直接返回。</li>\n<li>读取不到的话，先从 db 读取数据然后写入到cache 中，再返回。</li>\n</ul>\n<p>写：</p>\n<ul>\n<li>先查 cache，cache 中不存在，直接更新 db。</li>\n<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db(同步更新 cache 和 db)</li>\n</ul>\n<blockquote>\n<p>该模式也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>\n</blockquote>\n<p><strong>异步缓存写入</strong>(<code>Write Behind Pattern</code>)</p>\n<p><code>Write Behind Pattern</code> 和 <code>Read/Write Through Pattern</code> 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：<code>Read/Write Through</code> 是同步更新 cache 和 db，而 <code>Write Behind</code> 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>\n<blockquote>\n<p>应用场景：消息队列中消息的异步写入磁盘、MySQL 的 <code>Innodb Buffer Pool </code>机制都用到了这种策略。</p>\n</blockquote>\n<h3 id=\"Redis除了做缓存还有哪些应用场景\"><a href=\"#Redis除了做缓存还有哪些应用场景\" class=\"headerlink\" title=\"Redis除了做缓存还有哪些应用场景\"></a>Redis除了做缓存还有哪些应用场景</h3><ul>\n<li>分布式锁：基于 <code>Redisson</code> 来实现分布式锁。</li>\n<li>限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 <code>Redisson</code> 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>\n<li>消息队列：Redis 自带的 <code>List</code> 数据结构可以作为一个简单的队列使用。</li>\n<li>延时队列：<code>Redisson</code> 内置了延时队列(基于 <code>Sorted Set</code> 实现的)。</li>\n<li>分布式 <code>Session</code> ：利用 <code>String</code> 或者 <code>Hash</code> 数据类型保存 <code>Session</code> 数据，所有的服务器都可以访问。</li>\n<li>热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。</li>\n</ul>\n<h3 id=\"Redis可以做消息队列吗\"><a href=\"#Redis可以做消息队列吗\" class=\"headerlink\" title=\"Redis可以做消息队列吗\"></a>Redis可以做消息队列吗</h3><p>可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 <code>List</code> 来实现。Redis 2.0 之后，Redis 提供了 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。</p>\n<p>和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>\n<h3 id=\"Redis可以做搜索引擎吗\"><a href=\"#Redis可以做搜索引擎吗\" class=\"headerlink\" title=\"Redis可以做搜索引擎吗\"></a>Redis可以做搜索引擎吗</h3><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <code>RediSearch</code>，这是一个基于 Redis 的搜索引擎模块。</p>\n<p><code>RediSearch</code> 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 <code>Elasticsearch</code> 来说，<code>RediSearch</code> 有如下优势：</p>\n<ul>\n<li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作(<code>Elasticsearch</code> 基于磁盘)。</li>\n<li>较低内存占用实现快速索引：<code>RediSearch</code> 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li>\n</ul>\n<p><code>RediSearch</code> 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 <code>Elasticsearch</code>。</p>\n<ul>\n<li>数据量限制：<code>RedisSearch</code> 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。</li>\n<li>分布式能力较差：<code>RedisSearch</code> 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。<code>Elasticsearch</code> 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。</li>\n<li><code>RediSearch</code>聚合功能相较于 <code>Elasticsearch</code> 功能较弱。</li>\n<li>生态较差：<code>Elasticsearch</code> 可以轻松和常见的一些系统&#x2F;软件集成比如 <code>Hadoop</code>、<code>Spark</code>、<code>Kibana</code>，而 <code>RedisSearch</code> 则不具备该优势。</li>\n</ul>\n<h3 id=\"基于Redis实现延时任务✅\"><a href=\"#基于Redis实现延时任务✅\" class=\"headerlink\" title=\"基于Redis实现延时任务✅\"></a>基于Redis实现延时任务✅</h3><blockquote>\n<p>类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？</p>\n</blockquote>\n<p>两种方案：</p>\n<ol>\n<li>Redis 过期事件监听 </li>\n<li><code>Redisson</code> 内置的延时队列</li>\n</ol>\n<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。<br><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>\n<ul>\n<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>\n<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>\n</ul>\n<h3 id=\"Redis过期事件监听实现延时任务的原理\"><a href=\"#Redis过期事件监听实现延时任务的原理\" class=\"headerlink\" title=\"Redis过期事件监听实现延时任务的原理\"></a>Redis过期事件监听实现延时任务的原理</h3><p>Redis 2.0 引入了发布订阅 (<code>pub/sub</code>) 功能(其中有一个叫做 <code>channel</code>的概念)，涉及发布者(<code>publisher</code>)和订阅者(<code>subscriber</code>，也叫消费者)两个角色：</p>\n<ul>\n<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 <code>channel</code>。</li>\n<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 <code>channel</code>。并且，订阅者可以订阅一个或者多个 <code>channel</code>。</li>\n</ul>\n<p>在 <code>pub/sub</code> 模式下，生产者需要指定消息发送到哪个 <code>channel</code> 中，而消费者则订阅对应的 <code>channel</code> 以获取消息。</p>\n<p>Redis 中有很多默认的 <code>channel</code>，Redis 本身向它们发送一些消息，比如 <code>__keyevent@0__:expired</code>，这个 <code>channel</code> 用来监听 Redis 中的 key 过期事件。</p>\n<p>实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 <code>key</code> 过期时，Redis 会向 <code>__keyevent@0__:expired</code> 这个<code>channel</code>发送一条消息，这时候就可以在这个 <code>channel</code> 上监听到这个消息，从而实现延时任务。</p>\n<h3 id=\"Redis过期事件监听实现延时任务有什么缺陷\"><a href=\"#Redis过期事件监听实现延时任务有什么缺陷\" class=\"headerlink\" title=\"Redis过期事件监听实现延时任务有什么缺陷\"></a>Redis过期事件监听实现延时任务有什么缺陷</h3><ol>\n<li>时效性差：过期事件消息是在 Redis 服务器删除 <code>key</code> 时发布的，而不是一个 <code>key</code> 过期之后就会就会直接发布。Redis 采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>。 因此会存在设置了 <code>key</code> 的过期时间，但到了指定时间 <code>key</code> 还未被删除，进而没有发布过期事件的情况。</li>\n<li>丢消息：Redis 的 <code>pub/sub</code> 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。</li>\n<li>多服务实例下消息重复消费：pub&#x2F;sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。</li>\n</ol>\n<h3 id=\"Redisson内置的延时队列实现延时任务的原理及优势\"><a href=\"#Redisson内置的延时队列实现延时任务的原理及优势\" class=\"headerlink\" title=\"Redisson内置的延时队列实现延时任务的原理及优势\"></a>Redisson内置的延时队列实现延时任务的原理及优势</h3><p>可以借助 <code>Redisson</code> 内置的延时队列 <code>RDelayedQueue</code> 来实现延时任务功能。<code>RDelayedQueue</code> 基于 Redis 的 <code>SortedSet</code> 来实现，<code>SortedSet</code> 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 <code>SortedSet</code> 中，使用<code>zrangebyscore</code> 命令扫描 <code>SortedSet</code> 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 <code>SortedSet</code> 的轮询，提高了执行效率。</p>\n<p><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>\n<ul>\n<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>\n<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>\n</ul>\n<h3 id=\"Redis数据类型✅\"><a href=\"#Redis数据类型✅\" class=\"headerlink\" title=\"Redis数据类型✅\"></a>Redis数据类型✅</h3><ul>\n<li>5种基本数据类型：<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">底层实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>String</code>(字符串)</td>\n<td align=\"left\"><code>SDS</code>(简单动态字符串)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>List</code>(列表)</td>\n<td align=\"left\"><code>LinkedList</code>(双向链表)、<code>ZipList</code>(压缩列表)、<code>QuickList</code>(快速列表)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Hash</code>(哈希)</td>\n<td align=\"left\"><code>Dict</code>(哈希表&#x2F;字典)、<code>ZipList</code>(压缩列表)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Set</code>(集合)</td>\n<td align=\"left\"><code>Dict</code>(哈希表&#x2F;字典)、<code>Intset</code>(整数集合)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Zset</code>(有序集合)</td>\n<td align=\"left\"><code>ZipList</code>(压缩列表)、<code>SkipList</code>(跳表)</td>\n</tr>\n</tbody></table>\n</li>\n<li>3种特殊数据类型：<ul>\n<li><code>Bitmap</code>：位图</li>\n<li><code>HyperLogLog</code>：基数统计</li>\n<li><code>Geo</code>：地理位置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p><code>String</code> 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(<code>Simple Dynamic String，SDS</code>)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SET key value</td>\n<td>设置指定 key 的值</td>\n</tr>\n<tr>\n<td>SETNX key value</td>\n<td>只有在 key 不存在时设置 key 的值</td>\n</tr>\n<tr>\n<td>GET key</td>\n<td>获取指定 key 的值</td>\n</tr>\n<tr>\n<td>MSET key1 value1 key2 value2 ……</td>\n<td>设置一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>MGET key1 key2 …</td>\n<td>获取一个或多个指定 key 的值</td>\n</tr>\n<tr>\n<td>STRLEN key</td>\n<td>返回 key 所储存的字符串值的长度</td>\n</tr>\n<tr>\n<td>INCR key</td>\n<td>将 key 中储存的数字值增一</td>\n</tr>\n<tr>\n<td>DECR key</td>\n<td>将 key 中储存的数字值减一</td>\n</tr>\n<tr>\n<td>EXISTS key</td>\n<td>判断指定 key 是否存在</td>\n</tr>\n<tr>\n<td>DEL key(通用)</td>\n<td>删除指定的 key</td>\n</tr>\n<tr>\n<td>EXPIRE key seconds(通用)</td>\n<td>给指定 key 设置过期时间</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong><br><code>String</code> 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 <code>base64</code> 编码或者解码或者图片的路径)、序列化后的对象。</p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>Redis 的 <code>List</code> 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RPUSH key value1 value2 …</td>\n<td>在指定列表的尾部(右边)添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LPUSH key value1 value2 …</td>\n<td>在指定列表的头部(左边)添加一个或多个元素</td>\n</tr>\n<tr>\n<td>LSET key index value</td>\n<td>将指定列表索引 index 位置的值设置为 value</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并获取指定列表的第一个元素(最左边)</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并获取指定列表的最后一个元素(最右边)</td>\n</tr>\n<tr>\n<td>LLEN key</td>\n<td>获取列表元素数量</td>\n</tr>\n<tr>\n<td>LRANGE key start end</td>\n<td>获取列表 start 和 end 之间 的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>信息流展示，如最新文章、最新动态。</li>\n<li>消息队列，只是与专业的消息队列相比，<code>List</code> 功能较弱。</li>\n</ul>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p> <code>Hash</code> 是一个 <code>String</code> 类型的 <code>field-value</code>(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。</p>\n<p><code>Hash</code> 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)，不过做了更多优化。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HSET key field value</td>\n<td>设置指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HSETNX key field value</td>\n<td>只有指定字段不存在时设置指定字段的值</td>\n</tr>\n<tr>\n<td>HMSET key field1 value1 field2 value2 …</td>\n<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取指定哈希表中指定字段的值</td>\n</tr>\n<tr>\n<td>HMGET key field1 field2 …</td>\n<td>获取指定哈希表中一个或者多个指定字段的值</td>\n</tr>\n<tr>\n<td>HGETALL key</td>\n<td>获取指定哈希表中所有的键值对</td>\n</tr>\n<tr>\n<td>HEXISTS key field</td>\n<td>查看指定哈希表中指定的字段是否存在</td>\n</tr>\n<tr>\n<td>HDEL key field1 field2 …</td>\n<td>删除一个或多个哈希表字段</td>\n</tr>\n<tr>\n<td>HLEN key</td>\n<td>获取指定哈希表中字段的数量</td>\n</tr>\n<tr>\n<td>HINCRBY key field increment</td>\n<td>对指定哈希中的指定字段做运算操作(正数为加，负数为减)</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>存储对象，如用户信息、商品信息、文章信息、购物车信息.</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 <code>HashSet</code> 。当需要存储无重复列表数据时，<code>Set</code> 是一个很好的选择，且 <code>Set</code> 提供了判断某个元素是否在其内的重要接口，这个也是 <code>List</code> 所不能提供的。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SADD key member1 member2 …</td>\n<td>向指定集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SMEMBERS key</td>\n<td>获取指定集合中的所有元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>获取指定集合的元素数量</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断指定元素是否在指定集合中</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 …</td>\n<td>获取给定所有集合的交集</td>\n</tr>\n<tr>\n<td>SINTERSTORE destination key1 key2 …</td>\n<td>将给定所有集合的交集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 …</td>\n<td>获取给定所有集合的并集</td>\n</tr>\n<tr>\n<td>SUNIONSTORE destination key1 key2 …</td>\n<td>将给定所有集合的并集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 …</td>\n<td>获取给定所有集合的差集</td>\n</tr>\n<tr>\n<td>SDIFFSTORE destination key1 key2 …</td>\n<td>将给定所有集合的差集存储在 destination 中</td>\n</tr>\n<tr>\n<td>SPOP key count</td>\n<td>随机移除并获取指定集合中一个或多个元素</td>\n</tr>\n<tr>\n<td>SRANDMEMBER key count</td>\n<td>随机获取指定集合中指定数量的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>存放无重复数据：如文章点赞、用户收藏、共同好友等。</li>\n<li>需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。</li>\n<li>随机获取数据源：如抽奖、随机推荐等。</li>\n</ul>\n<h3 id=\"Zset\"><a href=\"#Zset\" class=\"headerlink\" title=\"Zset\"></a>Zset</h3><p><code>Zset</code>相较于<code>Set</code>增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ZADD key score1 member1 score2 member2 …</td>\n<td>向指定有序集合添加一个或多个元素</td>\n</tr>\n<tr>\n<td>ZCARD KEY</td>\n<td>获取指定有序集合的元素数量</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取指定有序集合中指定元素的 score 值</td>\n</tr>\n<tr>\n<td>ZINTERSTORE destination numkeys key1 key2 …</td>\n<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>\n</tr>\n<tr>\n<td>ZUNIONSTORE destination numkeys key1 key2 …</td>\n<td>求并集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZDIFFSTORE destination numkeys key1 key2 …</td>\n<td>求差集，其它和 ZINTERSTORE 类似</td>\n</tr>\n<tr>\n<td>ZRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素(score 从低到高)</td>\n</tr>\n<tr>\n<td>ZREVRANGE key start end</td>\n<td>获取指定有序集合 start 和 end 之间的元素(score 从高到底)</td>\n</tr>\n<tr>\n<td>ZREVRANK key member</td>\n<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>\n<li>需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。</li>\n</ul>\n<h3 id=\"Bitmap\"><a href=\"#Bitmap\" class=\"headerlink\" title=\"Bitmap\"></a>Bitmap</h3><p><code>Bitmap</code>存储的是连续的二进制数据(1&#x2F;0)，只需要一个 <code>bit</code> 位来表示某个元素对应的值或者状态，非常节省内存。可以将<code>Bitmap</code> 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 <code>offset</code>(偏移量)。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SETBIT key offset value</td>\n<td>设置指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>GETBIT key offset</td>\n<td>获取指定 offset 位置的值</td>\n</tr>\n<tr>\n<td>BITCOUNT key start end</td>\n<td>获取 start 和 end 之前值为 1 的元素个数</td>\n</tr>\n<tr>\n<td>BITOP operation destkey key1 key2 …</td>\n<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>用户签到：每天签到的用户用一个 <code>bit</code> 位来表示，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为签到状态(1&#x2F;0)。</li>\n<li>用户在线状态：用一个 <code>bit</code> 位来表示用户的在线状态，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为在线状态(1&#x2F;0)。</li>\n</ul>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p><code>HyperLogLog</code> 是一种基数统计算法，用于估计一个集合中不重复元素的个数。<code>HyperLogLog</code> 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PFADD key element1 element2 …</td>\n<td>添加一个或多个元素到 HyperLogLog 中</td>\n</tr>\n<tr>\n<td>PFCOUNT key1 key2</td>\n<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>\n</tr>\n<tr>\n<td>PFMERGE destkey sourcekey1 sourcekey2 …</td>\n<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。</li>\n</ul>\n<h3 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h3><p><code>Geospatial index</code>(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 <code>Sorted Set</code> 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>\n<p><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GEOADD key longitude1 latitude1 member1 …</td>\n<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>\n</tr>\n<tr>\n<td>GEOPOS key member1 member2 …</td>\n<td>返回给定元素的经纬度信息</td>\n</tr>\n<tr>\n<td>GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI</td>\n<td>返回两个给定元素之间的距离</td>\n</tr>\n<tr>\n<td>GEORADIUS key longitude latitude radius distance</td>\n<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数</td>\n</tr>\n<tr>\n<td>GEORADIUSBYMEMBER key member radius distance</td>\n<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>\n</tr>\n</tbody></table>\n<p><strong>应用场景</strong></p>\n<ul>\n<li>附近的人：根据用户的经纬度信息，获取附近的人。</li>\n<li>附近的商家：根据用户的经纬度信息，获取附近的商家。</li>\n<li>附近的车辆：根据用户的经纬度信息，获取附近的车辆。</li>\n</ul>\n<h3 id=\"使用String存储对象还是Hash\"><a href=\"#使用String存储对象还是Hash\" class=\"headerlink\" title=\"使用String存储对象还是Hash\"></a>使用String存储对象还是Hash</h3><ul>\n<li><code>String</code> 存储的是序列化后的对象数据，存放的是整个对象。<code>Hash</code> 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 <code>Hash</code>。</li>\n<li><code>String</code> 存储相对来说更加节省内存，缓存相同数量的对象数据，<code>String</code> 消耗的内存约是 <code>Hash</code> 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用<code>String</code>。</li>\n</ul>\n<h3 id=\"购物车信息用String还是Hash存储\"><a href=\"#购物车信息用String还是Hash存储\" class=\"headerlink\" title=\"购物车信息用String还是Hash存储\"></a>购物车信息用String还是Hash存储</h3><p>购物车中的商品频繁修改和变动，建议使用 <code>Hash</code>储存。</p>\n<ul>\n<li>用户 id 为 <code>key</code></li>\n<li>商品 id 为 <code>field</code>，商品数量为 <code>value</code></li>\n</ul>\n<p>具体维护：</p>\n<ul>\n<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>\n<li>查询购物车信息就是遍历对应的 Hash；</li>\n<li>更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；</li>\n<li>删除商品就是删除 Hash 中对应的 field；</li>\n<li>清空购物车直接删除对应的 key 即可。</li>\n</ul>\n<h3 id=\"Zset为什么要用跳表\"><a href=\"#Zset为什么要用跳表\" class=\"headerlink\" title=\"Zset为什么要用跳表\"></a>Zset为什么要用跳表</h3><ul>\n<li>跳表 vs 平衡树<ul>\n<li>跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。</li>\n</ul>\n</li>\n<li>跳表 vs 红黑树<ul>\n<li>跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>\n</ul>\n</li>\n<li>跳表 vs B+ 树<ul>\n<li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用Set实现抽奖系统\"><a href=\"#用Set实现抽奖系统\" class=\"headerlink\" title=\"用Set实现抽奖系统\"></a>用Set实现抽奖系统</h3><ul>\n<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>\n<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>\n<li><code>SRANDMEMBER key count</code>： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>\n</ul>\n<h3 id=\"Bitmap统计活跃用户\"><a href=\"#Bitmap统计活跃用户\" class=\"headerlink\" title=\"Bitmap统计活跃用户\"></a>Bitmap统计活跃用户</h3><p>用日期(精确到天)作为 <code>key</code>，用户 ID 为 <code>offset</code>，如果当日活跃过就设置为 1，否则为 0。通过 <code>BITCOUNT</code> 命令统计某个时间段内的活跃用户数。</p>\n<h3 id=\"HyperLogLog统计网站-UV\"><a href=\"#HyperLogLog统计网站-UV\" class=\"headerlink\" title=\"HyperLogLog统计网站 UV\"></a>HyperLogLog统计网站 UV</h3><ul>\n<li><code>PFADD PAGE_1:UV USER1 USER2 ...... USERn</code>：将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</li>\n<li><code>PFCOUNT PAGE_1:UV</code>：统计指定页面的 UV。</li>\n</ul>\n<h3 id=\"Redis持久化机制✅\"><a href=\"#Redis持久化机制✅\" class=\"headerlink\" title=\"Redis持久化机制✅\"></a>Redis持久化机制✅</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。</p>\n<h3 id=\"为什么要持久化\"><a href=\"#为什么要持久化\" class=\"headerlink\" title=\"为什么要持久化\"></a>为什么要持久化</h3><ul>\n<li>重用数据(比如重启机器、机器故障之后恢复数据)</li>\n<li>数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。</li>\n</ul>\n<h3 id=\"三种持久化方式\"><a href=\"#三种持久化方式\" class=\"headerlink\" title=\"三种持久化方式\"></a>三种持久化方式</h3><ul>\n<li>快照(<code>snapshotting</code>, RDB)</li>\n<li>只追加文件(<code>append-only file</code>, AOF)</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<h3 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h3><p>Redis通过创建快照获取存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。</p>\n<h3 id=\"RDB创建时会阻塞主线程吗\"><a href=\"#RDB创建时会阻塞主线程吗\" class=\"headerlink\" title=\"RDB创建时会阻塞主线程吗\"></a>RDB创建时会阻塞主线程吗</h3><p>有两个命令生成 RDB 快照文件</p>\n<ul>\n<li><code>save</code>：同步保存操作，会阻塞 Redis 主线程； </li>\n<li><code>bgsave</code>：<code>fork</code> 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>\n</ul>\n<h3 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(<code>fsync</code>策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。</p>\n<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。</p>\n<h3 id=\"AOF工作流程\"><a href=\"#AOF工作流程\" class=\"headerlink\" title=\"AOF工作流程\"></a>AOF工作流程</h3><ol>\n<li>命令追加(<code>append</code>)：所有的写命令会追加到 AOF 缓冲区中。</li>\n<li>文件写入(<code>write</code>)：将 AOF 缓冲区的数据写入到<strong>系统内核缓冲区</strong>中。这一步系统调用<code>write</code>函数，将数据写入到了<strong>系统内核缓冲区</strong>之后直接返回(延迟写)。</li>\n<li>文件同步(<code>fsync</code>)：<strong>系统内核缓冲区</strong>根据对应的持久化方式(<code>fsync</code>策略)向硬盘做同步操作。这一步系统调用 <code>fsync</code> 函数， <code>fsync</code> 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。</li>\n<li>文件重写(<code>rewrite</code>)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>\n<li>重启加载(<code>load</code>)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>\n</ol>\n<p><img src=\"/./image/Database-Interview/aof-work-process.png\" alt=\"AOF工作流程\"></p>\n<h3 id=\"AOF持久化的三种同步策略\"><a href=\"#AOF持久化的三种同步策略\" class=\"headerlink\" title=\"AOF持久化的三种同步策略\"></a>AOF持久化的三种同步策略</h3><p>即 <code>fsync</code> 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。</p>\n<ul>\n<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程( <code>aof_fsync</code> 线程)立即会调用 <code>fsync</code> 函数同步 AOF 文件(刷盘)，<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能(<code>write + fsync</code>)。</li>\n<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程( <code>aof_fsync</code> 线程)每秒钟调用 <code>fsync</code> 函数同步一次 AOF 文件(<code>write+fsync</code>，<code>fsync</code>间隔为 1 秒)</li>\n<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定)。</li>\n</ul>\n<blockquote>\n<p>刷盘：将内存中的数据写入到磁盘中。</p>\n</blockquote>\n<h3 id=\"AOF为什么是执行完命令后记录日志\"><a href=\"#AOF为什么是执行完命令后记录日志\" class=\"headerlink\" title=\"AOF为什么是执行完命令后记录日志\"></a>AOF为什么是执行完命令后记录日志</h3><p>不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。</p>\n<ul>\n<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>\n<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>\n</ul>\n<p>但也存在风险：</p>\n<ul>\n<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； </li>\n<li>可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。</li>\n</ul>\n<h3 id=\"AOF重写\"><a href=\"#AOF重写\" class=\"headerlink\" title=\"AOF重写\"></a>AOF重写</h3><p>当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>\n<p>重写期间，AOF维护一个<strong>AOF重写缓冲区</strong>，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将<strong>AOF重写缓冲区</strong>内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。</p>\n<p>可以配置如下参数：<br><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;<br><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小(<code>aof_current_size</code>)和上一次重写时 AOF 大小(<code>aof_base_size</code>)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</p>\n<h3 id=\"AOF校验机制\"><a href=\"#AOF校验机制\" class=\"headerlink\" title=\"AOF校验机制\"></a>AOF校验机制</h3><p>Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 <code>CRC64</code> 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。</p>\n<p>Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。</p>\n<h3 id=\"Redis4-0对持久化的优化\"><a href=\"#Redis4-0对持久化的优化\" class=\"headerlink\" title=\"Redis4.0对持久化的优化\"></a>Redis4.0对持久化的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。</p>\n<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>\n<h3 id=\"如何选择RDB和AOF\"><a href=\"#如何选择RDB和AOF\" class=\"headerlink\" title=\"如何选择RDB和AOF\"></a>如何选择RDB和AOF</h3><p>RDB优势：</p>\n<ul>\n<li>RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。</li>\n<li>RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。</li>\n</ul>\n<p>AOF优势：</p>\n<ul>\n<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。</li>\n<li>RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。</li>\n<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。</li>\n</ul>\n<p>综上：</p>\n<ul>\n<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>\n<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>\n<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>\n</ul>\n<h3 id=\"Redis单线程模型✅\"><a href=\"#Redis单线程模型✅\" class=\"headerlink\" title=\"Redis单线程模型✅\"></a>Redis单线程模型✅</h3><p>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(<code>file event handler</code>)，是单线程方式运行的，所以说 Redis 是单线程模型。</p>\n<h3 id=\"如何监听大量客户端链接\"><a href=\"#如何监听大量客户端链接\" class=\"headerlink\" title=\"如何监听大量客户端链接\"></a>如何监听大量客户端链接</h3><p>通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接(或者说是监听多个 <code>socket</code>)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。</p>\n<p>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p>\n<p>文件事件处理器主要是包含 4 个部分：</p>\n<ul>\n<li>多个 socket(客户端连接)</li>\n<li>IO 多路复用程序(支持多个客户端连接的关键)</li>\n<li>文件事件分派器(将 <code>socket</code> 关联到相应的事件处理器)</li>\n<li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li>\n</ul>\n<p><img src=\"/./image/Database-Interview/redis-event-handler.png\" alt=\"文件事件处理器\"></p>\n<h3 id=\"Redis4-0多线程\"><a href=\"#Redis4-0多线程\" class=\"headerlink\" title=\"Redis4.0多线程\"></a>Redis4.0多线程</h3><p>在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p>\n<p>异步命令：</p>\n<ul>\n<li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li>\n<li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li>\n<li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li>\n</ul>\n<p>总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p>\n<h3 id=\"Redis6-0之前为什么不用多线程\"><a href=\"#Redis6-0之前为什么不用多线程\" class=\"headerlink\" title=\"Redis6.0之前为什么不用多线程\"></a>Redis6.0之前为什么不用多线程</h3><ul>\n<li>单线程编程容易并且更容易维护；</li>\n<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>\n<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>\n</ul>\n<h3 id=\"Redis6-0之后为何引入多线程\"><a href=\"#Redis6-0之后为何引入多线程\" class=\"headerlink\" title=\"Redis6.0之后为何引入多线程\"></a>Redis6.0之后为何引入多线程</h3><p>Redis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p>\n<h3 id=\"Redis后台线程\"><a href=\"#Redis后台线程\" class=\"headerlink\" title=\"Redis后台线程\"></a>Redis后台线程</h3><p>Redis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：</p>\n<ul>\n<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF&#x2F;RDB 等过程中产生的临时文件资源。</li>\n<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。</li>\n<li>通过 <code>bio_lazy_free</code>后台线程释放大对象(已删除)占用的内存空间.</li>\n</ul>\n<h3 id=\"Redis内存管理✅\"><a href=\"#Redis内存管理✅\" class=\"headerlink\" title=\"Redis内存管理✅\"></a>Redis内存管理✅</h3><h3 id=\"Redis给缓存数据设置过期时间有啥用\"><a href=\"#Redis给缓存数据设置过期时间有啥用\" class=\"headerlink\" title=\"Redis给缓存数据设置过期时间有啥用\"></a>Redis给缓存数据设置过期时间有啥用</h3><ul>\n<li>因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。</li>\n<li>某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。</li>\n</ul>\n<h3 id=\"Redis如何判断数据过期\"><a href=\"#Redis如何判断数据过期\" class=\"headerlink\" title=\"Redis如何判断数据过期\"></a>Redis如何判断数据过期</h3><p>Redis 通过一个叫做<strong>过期字典</strong>(可以看作是 <code>hash</code> 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 <code>key</code>(键)，过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了 <code>key</code> 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。</p>\n<p>在查询一个 <code>key</code> 的时候，Redis 首先检查该 <code>key</code> 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 <code>key</code> 是否过期，过期直接删除 <code>key</code> 然后返回 <code>null</code>。</p>\n<h3 id=\"Redis过期key删除策略\"><a href=\"#Redis过期key删除策略\" class=\"headerlink\" title=\"Redis过期key删除策略\"></a>Redis过期key删除策略</h3><ul>\n<li>惰性删除：只会在取出&#x2F;查询 <code>key</code> 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 <code>key</code> 没有删除。</li>\n<li>定期删除：周期性地随机从设置了过期时间的 <code>key</code> 中抽查一批，然后逐个检查这些 <code>key</code> 是否过期，过期就删除 <code>key</code>。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>\n<li>延迟队列：把设置过期时间的 <code>key</code> 放到一个延迟队列里，到期之后就删除 <code>key</code>。这样可保证每个过期 <code>key</code> 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>\n<li>定时删除：每个设置了过期时间的 <code>key</code> 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。</li>\n</ul>\n<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。</p>\n<h3 id=\"定期删除策略详细细节\"><a href=\"#定期删除策略详细细节\" class=\"headerlink\" title=\"定期删除策略详细细节\"></a>定期删除策略详细细节</h3><ul>\n<li>Redis 默认每 100ms 检查 20 个随机的过期 <code>key</code>，如果有过期的 <code>key</code> 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 <code>key</code> 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li>\n</ul>\n<p><strong>大量key集中过期如何处理</strong><br>如果大量 <code>key</code> 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：</p>\n<ul>\n<li>尽量避免 <code>key</code> 集中过期，在设置键的过期时间时尽量随机一点。</li>\n<li>对过期的 <code>key</code> 开启 <code>lazyfree</code> 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。</li>\n</ul>\n<h3 id=\"Redis内存淘汰策略✅\"><a href=\"#Redis内存淘汰策略✅\" class=\"headerlink\" title=\"Redis内存淘汰策略✅\"></a>Redis内存淘汰策略✅</h3><p>当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：</p>\n<ul>\n<li><code>volatile-lru</code>(least recently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最近最少使用的数据淘汰。</li>\n<li><code>volatile-ttl</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选将要过期的数据淘汰。</li>\n<li><code>volatile-random</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中任意选择数据淘汰。</li>\n<li><code>allkeys-lru</code>(least recently used)：从数据集(<code>server.db[i].dict</code>)中移除最近最少使用的数据淘汰。</li>\n<li><code>allkeys-random</code>：从数据集(<code>server.db[i].dict</code>)中任意选择数据淘汰。</li>\n<li><code>no-eviction</code>(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>\n</ul>\n<p>4.0 版本后增加以下两种：</p>\n<ul>\n<li><code>volatile-lfu</code>(least frequently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰。</li>\n<li><code>allkeys-lfu</code>(least frequently used)：从数据集(<code>server.db[i].dict</code>)中移除最不经常使用的数据淘汰。</li>\n</ul>\n<p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p>\n<h3 id=\"Redis事务\"><a href=\"#Redis事务\" class=\"headerlink\" title=\"Redis事务\"></a>Redis事务</h3><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p>\n<h3 id=\"如何解决Redis事务的缺陷\"><a href=\"#如何解决Redis事务的缺陷\" class=\"headerlink\" title=\"如何解决Redis事务的缺陷\"></a>如何解决Redis事务的缺陷</h3><p>可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</p>\n<h3 id=\"Redis性能优化✅\"><a href=\"#Redis性能优化✅\" class=\"headerlink\" title=\"Redis性能优化✅\"></a>Redis性能优化✅</h3><h3 id=\"批量操作减少网络传输\"><a href=\"#批量操作减少网络传输\" class=\"headerlink\" title=\"批量操作减少网络传输\"></a>批量操作减少网络传输</h3><p>Redis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。</p>\n<p>批量操作的三种方式</p>\n<ul>\n<li>原生批量操作：Redis 提供了一些原生的批量操作命令，如 <code>MSET</code>、<code>MGET</code>、<code>DEL</code> 等。</li>\n<li>Pipeline：通过 <code>pipeline</code> 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。</li>\n<li>Lua脚本：</li>\n</ul>\n<h3 id=\"大量key集中过期\"><a href=\"#大量key集中过期\" class=\"headerlink\" title=\"大量key集中过期\"></a>大量key集中过期</h3><p>Redis采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>清理过期<code>key</code>。如果大量 <code>key</code> 集中过期的问题，客户端请求必须等待定期清理过期 <code>key</code> 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：</p>\n<ul>\n<li>给 <code>key</code> 设置随机过期时间。</li>\n<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)，让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将删除<code>key</code>的操作该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<h3 id=\"bigkey-大key\"><a href=\"#bigkey-大key\" class=\"headerlink\" title=\"bigkey(大key)\"></a>bigkey(大key)</h3><p>如果一个 <code>key</code> 对应的 <code>value</code> 所占用的内存比较大，那这个 <code>key</code> 就可以看作是 <code>bigkey</code>。<code>bigkey</code>的标准：</p>\n<ul>\n<li><code>String</code> 类型的 <code>value</code> 超过 1MB</li>\n<li>复合类型(<code>List</code>、<code>Hash</code>、<code>Set</code>、<code>Sorted Set</code> 等)的 <code>value</code> 包含的元素超过 5000 个(不过，对于复合类型的 <code>value</code> 来说，不一定包含的元素越多，占用的内存就越多)。</li>\n</ul>\n<p><strong>产生原因</strong></p>\n<ul>\n<li>程序设计不当，比如直接使用 <code>String</code> 类型存储较大的文件对应的二进制数据。</li>\n<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>\n<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>\n</ul>\n<p><strong>危害</strong></p>\n<ul>\n<li>单线程的Redis 在操作<code>bigkey</code> 时候比较耗时，造成客户端超时阻塞。</li>\n<li>网络拥塞：获取<code>bigkey</code>需要较多的流量。</li>\n<li>工作线程阻塞：如果使用 <code>del</code> 删除大 <code>key</code> 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n<li><code>bigkey</code>会进一步影响主从同步。</li>\n</ul>\n<p><strong>bigkey发现</strong></p>\n<ul>\n<li><code>--bigkeys</code>：执行<code>redis-cli -p 6379 --bigkeys</code>扫描所有key，只能找到<code>top 1 bigkey</code>(占用内存最大的 <code>String</code> 数据类型，包含元素最多的复合数据类型)。</li>\n<li><code>SCAN+STRLEN/HLEN/LLEN</code>：Redis 自带的 <code>SCAN</code> 命令按指定模式扫描匹配的<code>key</code>，然后结合<code>STRLEN/HLEN/LLEN</code>返回<code>key</code>的长度或者成员数量。</li>\n<li>集合类型可以使用<code>MEMORY USAGE</code></li>\n<li>借助开源工具分析 RDB 文件。如<code>redis-rdb-tools</code>、<code>rdb_bigkeys</code></li>\n<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>\n</ul>\n<p><strong>处理bigkey</strong></p>\n<ul>\n<li>分割 <code>bigkey</code>：将<code>bigkey</code>分割为多个小 <code>key</code>。例如，将一个含有上万字段数量的 <code>Hash</code> 按照一定策略(比如二次哈希)拆分为多个 <code>Hash</code>。</li>\n<li>手动清理：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 <code>key</code>。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>\n<li>采用合适的数据结构：例如，文件二进制数据不使用 <code>String</code> 保存、使用 <code>HyperLogLog</code> 统计页面 <code>UV</code>、<code>Bitmap</code> 保存状态信息(0&#x2F;1)。</li>\n<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)：<code>lazy-free</code> 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>\n</ul>\n<p>也可以配合使用上述方法</p>\n<h3 id=\"hotkey-热key\"><a href=\"#hotkey-热key\" class=\"headerlink\" title=\"hotkey(热key)\"></a>hotkey(热key)</h3><p>如果一个 <code>key</code> 的访问次数比较多且明显多于其他 <code>key</code>，就可以看作是 <code>hotkey</code>。</p>\n<p><strong>产生原因</strong><br>某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>\n<p><strong>危害</strong></p>\n<ul>\n<li><code>hotkey</code> 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</li>\n<li>如果突然访问 <code>hotkey</code> 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</li>\n</ul>\n<p><code>hotkey</code> 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>\n<p><strong>发现hotkey</strong></p>\n<ul>\n<li><code>--hotkeys</code>：执行<code>redis-cli -p 6379 --hotkeys</code>命令</li>\n<li><code>MONITOR</code>： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。<ul>\n<li>可在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 <code>hotkey</code>。</li>\n</ul>\n</li>\n<li>根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 <code>hotkey</code>，比如突发的热点新闻事件等。</li>\n<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>\n</ul>\n<p><strong>处理hotkey</strong></p>\n<ul>\n<li>读写分离：主节点处理写请求，从节点处理读请求。</li>\n<li>使用 <code>Redis Cluster</code>：将热点数据分散存储在多个 Redis 节点上。</li>\n<li>二级缓存：<code>hotkey</code> 采用二级缓存的方式进行处理，将 <code>hotkey</code> 存放一份到 JVM 本地内存中(可以用 Caffeine)。</li>\n<li>使用公有云的 Redis 服务中的解决方案。</li>\n</ul>\n<p>也可以配合使用上述方法。</p>\n<h3 id=\"慢查询命令\"><a href=\"#慢查询命令\" class=\"headerlink\" title=\"慢查询命令\"></a>慢查询命令</h3><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如<code>KEYS *</code>、<code>HGETALL</code>等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</p>\n<h3 id=\"Redis内存碎片✅\"><a href=\"#Redis内存碎片✅\" class=\"headerlink\" title=\"Redis内存碎片✅\"></a>Redis内存碎片✅</h3><p>Redis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。</p>\n<h3 id=\"内存碎片产生原因\"><a href=\"#内存碎片产生原因\" class=\"headerlink\" title=\"内存碎片产生原因\"></a>内存碎片产生原因</h3><ol>\n<li>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。<ul>\n<li>Redis 采用多种内存分配器分配内存，默认采用 <code>jemalloc</code>，其按照 2 的幂次方分配内存，可能会导致内存浪费。</li>\n</ul>\n</li>\n<li>频繁修改 Redis 中的数据也会产生内存碎片。</li>\n</ol>\n<h3 id=\"查看内存碎片率\"><a href=\"#查看内存碎片率\" class=\"headerlink\" title=\"查看内存碎片率\"></a>查看内存碎片率</h3><p>使用 <code>info memory</code> 命令查看 Redis 内存碎片率。</p>\n<p><code>mem_fragmentation_ratio</code> (内存碎片率)&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>\n<p>内粗碎片率越大，说明 Redis 中的内存碎片越多。<code>used_memory_rss</code> 减去 <code>used_memory</code> 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>\n<p>通常内存碎片率<code>mem_fragmentation_ratio</code> &gt; 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了</p>\n<h3 id=\"Redis内存碎片清理\"><a href=\"#Redis内存碎片清理\" class=\"headerlink\" title=\"Redis内存碎片清理\"></a>Redis内存碎片清理</h3><ol>\n<li>重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</li>\n<li>Redis4.0-RC3可以通过<code>config set activedefrag yes</code>开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config <span class=\"built_in\">set</span> activedefrag <span class=\"built_in\">yes</span> <span class=\"comment\"># 开启主动碎片整理功能</span></span><br><span class=\"line\"></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-ignore-bytes 500mb <span class=\"comment\"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-threshold-lower 50 <span class=\"comment\"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class=\"line\"></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-cycle-min 20 <span class=\"comment\"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class=\"line\">config <span class=\"built_in\">set</span> active-defrag-cycle-max 50 <span class=\"comment\"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis生产问题✅\"><a href=\"#Redis生产问题✅\" class=\"headerlink\" title=\"Redis生产问题✅\"></a>Redis生产问题✅</h3><h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透是大量请求的 <code>key</code> 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><strong>举例</strong><br>某个黑客故意制造一些非法的 <code>key</code> 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</li>\n<li>缓存无效 <code>key</code>。短暂地缓存无效<code>key</code>，并设置一个较短的过期时间，这样就可以防止缓存穿透。</li>\n<li>布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 <code>hash</code> 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。</li>\n<li>接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</li>\n</ol>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<p><strong>举例</strong><br>秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。</li>\n<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li>\n</ol>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>缓存雪崩是缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n<p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>\n<p><strong>举例</strong><br>数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>\n<p><strong>解决方案</strong><br>针对大量缓存同时失效的情况：</p>\n<ol>\n<li>设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li>\n<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>\n<li>持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li>\n</ol>\n<p>针对 Redis 服务不可用的情况：</p>\n<ol>\n<li>Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li>\n<li>多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>\n</ol>\n<h3 id=\"缓存穿透-缓存击穿区别\"><a href=\"#缓存穿透-缓存击穿区别\" class=\"headerlink\" title=\"缓存穿透&#x2F;缓存击穿区别\"></a>缓存穿透&#x2F;缓存击穿区别</h3><ul>\n<li>缓存穿透中，请求的 <code>key</code> 既不存在于缓存中，也不存在于数据库中。</li>\n<li>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。</li>\n</ul>\n<h3 id=\"缓存预热如何实现\"><a href=\"#缓存预热如何实现\" class=\"headerlink\" title=\"缓存预热如何实现\"></a>缓存预热如何实现</h3><ol>\n<li>使用定时任务，比如 <code>xxl-job</code>，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>\n<li>使用消息队列，比如 <code>Kafka</code>，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>\n</ol>\n<h3 id=\"缓存击穿-缓存雪崩区别\"><a href=\"#缓存击穿-缓存雪崩区别\" class=\"headerlink\" title=\"缓存击穿&#x2F;缓存雪崩区别\"></a>缓存击穿&#x2F;缓存雪崩区别</h3><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。</p>\n<h3 id=\"Redis常见阻塞原因\"><a href=\"#Redis常见阻塞原因\" class=\"headerlink\" title=\"Redis常见阻塞原因\"></a>Redis常见阻塞原因</h3><ol>\n<li>O(n)命令：如<code>KEYS *</code>(返回所有符合规则的 <code>key</code>)、<code>HGETALL</code>(会返回一个 <code>Hash</code> 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</li>\n<li><code>Save</code>创建RDB快照：<code>save</code> 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。</li>\n<li>AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。</li>\n<li>AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会<code>append</code>到AOF缓冲区，然后<code>write</code> 到系统内核缓冲区，最后 <code>fsync</code> 刷到磁盘。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。</li>\n<li>AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。</li>\n<li>查找和删除<code>bigkey</code>：查找<code>bigkey</code>时，Redis 会遍历所有的 <code>key</code>，这个操作是阻塞的。删除<code>bigkey</code>时，会先释放<code>bigkey</code>内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的<code>bigkey</code>，空闲内存块插入链表的操作就会阻塞主线程。</li>\n<li>清空数据库：<code>flushall</code> 和 <code>flushdb</code> 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。</li>\n<li>CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</li>\n<li>网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</li>\n</ol>\n<h2 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h2><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供<strong>面向文档</strong>的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong>。</p>\n<p>在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点&#x2F;实例，以保证服务性能和可用性。</p>\n<h3 id=\"mongodb的存储结构是什么\"><a href=\"#mongodb的存储结构是什么\" class=\"headerlink\" title=\"mongodb的存储结构是什么\"></a>mongodb的存储结构是什么</h3><p>主要由三个单元组成：</p>\n<ul>\n<li>数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。</li>\n<li>集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(<code>Table</code>)。</li>\n<li>文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(<code>key-value</code>)组成，类似于关系型数据库中的行(<code>Row</code>)。</li>\n</ul>\n<p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>SQL</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表(Table)</td>\n<td>集合(Collection)</td>\n</tr>\n<tr>\n<td>行(Row)</td>\n<td>文档(Document)</td>\n</tr>\n<tr>\n<td>列(Col)</td>\n<td>字段(Field)</td>\n</tr>\n<tr>\n<td>主键(Primary Key)</td>\n<td>对象 ID(Objectid)</td>\n</tr>\n<tr>\n<td>索引(Index)</td>\n<td>索引(Index)</td>\n</tr>\n<tr>\n<td>嵌套表(Embedded Table)</td>\n<td>嵌入式文档(Embedded Document)</td>\n</tr>\n<tr>\n<td>数组(Array)</td>\n<td>数组(Array)</td>\n</tr>\n</tbody></table>\n<p><strong>集合</strong><br>集合存储于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。</p>\n<p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p>\n<p><strong>文档</strong><br>BSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。</p>\n<h3 id=\"mongodb特点\"><a href=\"#mongodb特点\" class=\"headerlink\" title=\"mongodb特点\"></a>mongodb特点</h3><ul>\n<li>数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。</li>\n<li>数据模型自由：不需要设计表结构，可以存储不同结构的文档。</li>\n<li>支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li>\n<li>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</li>\n<li>高效的二进制存储：文档以键值对的形式存储在集合中，键(<code>ObjectId</code>类型)唯一标识文件，值是以 BSON 形式存在。</li>\n<li>自带数据压缩功能：MongoDB 3.0 版本开始支持 <code>WiredTiger</code> 存储引擎，支持数据压缩，减少磁盘空间占用。</li>\n<li>支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。</li>\n<li>支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>\n<li>支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。</li>\n<li>支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 <code>GridFS</code> 存储。</li>\n</ul>\n<h3 id=\"mongodb适合什么场景\"><a href=\"#mongodb适合什么场景\" class=\"headerlink\" title=\"mongodb适合什么场景\"></a>mongodb适合什么场景</h3><p>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。</p>\n<h3 id=\"mongodb存储引擎\"><a href=\"#mongodb存储引擎\" class=\"headerlink\" title=\"mongodb存储引擎\"></a>mongodb存储引擎</h3><p>MongoDB 采用的是 <strong>插件式的存储引擎架构</strong>，现在主要使用两种存储引擎：</p>\n<ul>\n<li><code>MMAPv1</code> 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。</li>\n<li><code>WiredTiger</code> 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 <code>WiredTiger</code> 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。</li>\n<li><code>In-Memory</code> 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。</li>\n</ul>\n<h3 id=\"WiredTiger存储引擎\"><a href=\"#WiredTiger存储引擎\" class=\"headerlink\" title=\"WiredTiger存储引擎\"></a>WiredTiger存储引擎</h3><p><code>WiredTiger</code> 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。</p>\n<p>使用 B+ 树时，<code>WiredTiger</code> 以 <code>page</code> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 <code>page</code>，共有三种类型的 <code>page</code>：</p>\n<ul>\n<li><code>root page</code>(根节点)：B+ 树的根节点。</li>\n<li><code>internal page</code>(内部节点)：不实际存储数据的中间索引节点。</li>\n<li><code>leaf page</code>(叶子节点)：真正存储数据的叶子节点，包含一个页头(<code>page header</code>)、块头(<code>block header</code>)和真正的数据(<code>key/value</code>)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 <code>checksum</code>、块在磁盘上的寻址位置等信息。</li>\n</ul>\n<h3 id=\"mongodb聚合\"><a href=\"#mongodb聚合\" class=\"headerlink\" title=\"mongodb聚合\"></a>mongodb聚合</h3><p>将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：</p>\n<ul>\n<li>将来自多个文档的值组合在一起。 </li>\n<li>对集合中的数据进行的一系列运算。 </li>\n<li>分析数据随时间的变化。</li>\n</ul>\n<p>两种聚合方法：</p>\n<ul>\n<li>聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。</li>\n<li>单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li>\n</ul>\n<p>聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：</p>\n<ul>\n<li>接受一系列原始数据文档</li>\n<li>对这些文档进行一系列运算</li>\n<li>结果文档输出给下一个阶段</li>\n</ul>\n<h3 id=\"mongodb事务\"><a href=\"#mongodb事务\" class=\"headerlink\" title=\"mongodb事务\"></a>mongodb事务</h3><p>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</p>\n<h3 id=\"mongodb数据压缩\"><a href=\"#mongodb数据压缩\" class=\"headerlink\" title=\"mongodb数据压缩\"></a>mongodb数据压缩</h3><p>借助 <code>WiredTiger</code> 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。<code>WiredTiger</code> 存储引擎支持以下压缩算法：</p>\n<ul>\n<li><code>snappy</code>：快速压缩算法，压缩比(3～5倍)较低，但速度快。</li>\n<li><code>zlib</code>：压缩比(5～7倍)较高，但速度较慢。</li>\n<li><code>Zstandard</code>：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li>\n</ul>\n<p><code>WiredTiger</code> 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。</p>\n<h3 id=\"mongodb索引\"><a href=\"#mongodb索引\" class=\"headerlink\" title=\"mongodb索引\"></a>mongodb索引</h3><p>索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。</p>\n<p>索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。</p>\n<p><strong>索引类型</strong></p>\n<ul>\n<li>单字段索引：建立在单个字段上的索引。</li>\n<li>复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>\n<li>多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>\n<li>哈希索引：按数据的哈希值索引，用在哈希分片集群上。</li>\n<li>文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>\n<li>地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>\n<li>唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>\n<li>TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.</li>\n</ul>\n<h3 id=\"复合索引中字段顺序\"><a href=\"#复合索引中字段顺序\" class=\"headerlink\" title=\"复合索引中字段顺序\"></a>复合索引中字段顺序</h3><p>复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。</p>\n<p>复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。</p>\n<blockquote>\n<p>有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p>\n</blockquote>\n<h3 id=\"TTL索引\"><a href=\"#TTL索引\" class=\"headerlink\" title=\"TTL索引\"></a>TTL索引</h3><p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code>，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>\n<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>\n<p><strong>原理</strong></p>\n<ul>\n<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>\n<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 <code>oplog</code> 做同步。</li>\n</ul>\n<p><strong>TTL索引限制</strong></p>\n<ul>\n<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>\n<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>\n</ul>\n"},{"title":"面经汇总","keywords":["面经"],"description":"面经汇总","abbrlink":17773,"date":"2024-06-25T11:52:15.000Z","updated":"2024-06-26T08:15:15.000Z","top_img":"https://s2.loli.net/2024/06/25/2VJc4rMTXeSqD7K.png","comments":1,"cover":"https://s2.loli.net/2024/06/25/Jfpxsi8HXMwbC29.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n### 腾讯 WXG - 移动客户端开发 实习\n基础微信&视频号团队\n2024/3/19 40多分钟 一面\n- 自我介绍\n- 研究生成绩、本科生成绩\n- 研究生主要专业课\n- Java - 强引用 弱引用\n- Java - 垃圾回收机制\n- TCP连接如何保成可靠性\n- HTTP状态码\n- 拷打实习、项目\n- 你的开源线上实习主要都做的啥？\n- 你在开源实习过程中遇到的最难的是什么？\n- 你的单点登录系统大前端项目中 主要都做了什么东西？\n- 手撕代码\n    - 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n- 意向城市是上海，组内基本都在广州，这个你有什么问题吗？\n- 为什么会想要投移动客户端开发？\n- 除了在实习项目中，你还在有通过其他途径了解到移动客户端开发吗？\n- 反问：\n    - 面试官您觉得我的表现如何？\n    - 组内日常工作？\n\n### 淘天集团 - 天猫技术部前端 实习\n2024/3/26 14:00  70多分钟。。感觉好难。。。\n- 面试官介绍部门、自我介绍\n- 自己自我介绍\n- RN和React的区别\n- 单点登录SSO原理\n- PKCE\n- Flutter RN区别，如何实现跨平台的\n- 项目中使用了unity，具体做了什么？\n- 具体讲2FA是什么\n- sdk实现的原理过程是什么\n- 原型和原型链\n- 事件循环机制\n- react 钩子hooks\n- JS 函数是类吗？函数与类的区别在哪？\n- 反问：\n    - 前端知识很零散很杂，对此您有何看法？\n\n### 淘天集团 - 闲鱼技术部前端 实习\n2024/3/26 19:00 40多分钟\n- 为什么想要走前端的这条路？对前端看法是怎么样的？\n- Casbin线上实习做了什么\n- 以RN sdk为例子，讲一下sdk的工作流程，具体做了啥？\n- 大前端系统做了什么\n- 国家电网项目做了什么？\n- JS this指针\n- JS Promise函数\n- JS ES6新特性有哪些\n- JS 变量作用域\n\n### 淘天集团 - 闲鱼技术部移动端开发 实习\n2024/4/1 16:00 20多分钟。。。 太菜了。。。多练啊。。。练习时长两天半还敢出来混啊卧槽了。\n- 自我介绍\n- 为什么想要走移动端开发这种道路。\n- Casbin是做什么的？\n- RN的原理\n- 单点登录SSO原理\n- 我看你简历上很多移动端开发的经历，可以讲讲吗？\n- 有学过什么计算机专业相关的专业课吗？\n- 常用的数据结构有什么？\n- 哈希表的结构\n- 排序算法的复杂度\n- 给一个数组，和一个数字，返回这个数字所在的index，有什么方法，复杂度是什么？\n- 给一个排好序的数组，且里面有很多重复的元素，这个时候如何返回一个指定数字的index？\n- 反问：\n    - 移动端开发如何去学习？\n    - 移动客户端开发有什么学习的一些网站吗？\n\n### 腾讯 - 移动客户端开发 实习\n2024/4/2 19:00 60多分钟\n- 自我介绍\n- 印象最深刻的实习或者项目\n- TCP、UDP区别\n- TCP三次握手、四次挥手\n- Java堆和栈区别\n- 进程线程区别\n- OSI七层模型\n- 死锁\n- 常见Linux线程间的通信方式\n- HTTP状态码\n- Java为什么会堆栈溢出\n- C++多态\n- C++是面向过程的语言吗？\n- i++和++i的区别\n- 302状态码是什么？\n- Java同步关键字\n- 操作系统的虚拟内存\n- 成员变量和全局变量都存在哪里？\n- Java最基础的类是什么类，有哪些方法？\n- Java异常机制\n- 从增加删除元素的角度说数组和链表的区别\n- 分别向链表数组中插入元素的复杂度\n- 用户态和内核态\n- 手撕两道题：\n    - 单例模式，如何保证一个类只创建一次\n    - 不含重复字符的最长子串的长度\n- 反问：\n    - 移动客户端开发的学习路线是什么\n\n### 携程 - 移动客户端开发iOS/Android\n2024/4/11 18:00 40分钟\n- 你在大前端项目里主要做了什么？\n- react的原理\n- Dom树\n- js的闭包\n- js的原型&原型链\n- C++的三大特性\n- 手撕两道题\n    - 有序链表合并\n    - 二叉树前序遍历，然后转为数组\n- 反问：\n    - 前端学习路线\n    - 工作城市\n\n其实后面面试官说，你做的项目跟我们现在做的很契合，然后第二天下午打了个电话没接到，应该是二面。后面假期过后就给我进人才池了，有点亏。。。\n\n### 腾讯金融科技 - 测试开发工程师\n2024/4/19 17:00 40 分钟\n- 自我介绍\n- 你最近认为做的最有难度最好的一次项目经历。\n- 开源项目\n- 你在开源实习和项目中使用的技术栈是什么，你学到了什么？\n- 国家电网项目\n- 手撕代码\n    - 最长重复子串\n- 数据库\n- Linux 系统\n- 反问：\n    - 测开的学习路线\n    - 工作地点和时间，加班多吗？\n\n### 美团到店 - 后端开发工程师 - 实习生\n2024/4/24 14:00 一个小时\n- 面试流程、部门介绍\n- 自我介绍\n- 项目介绍\n- 2FA\n- TOTP\n- OTP\n- PKCE\n- Java 如何实现高并发\n- 高并发会出现什么问题，Java如何解决的？\n- 上下文切换开销\n- Java虚拟机内存\n- HashMap底层、java7和java8有什么改进\n- ConcurrentHashMap如何实现多进程，java7和java8有什么改进\n- Java有哪些锁。\n- 乐观锁悲观锁\n- 进程、线程区别\n- mysql\n- redis\n- TCP、UDP区别\n- 三次握手四次挥手\n- 手撕代码： 二选一\n    - 反转部分链表\n    - 旋转数组后查找元素\n- 反问：\n    - 部门寻找实习生的标准是什么样的？\n    - 实习生日常工作时间\n\n### 美团核心 - 软件开发工程师-前端&移动端方向 实习\n2024/5/15 19:00\n- 自我介绍\n- 介绍开源项目主要的工作\n- 在父元素中调整子元素位置你用哪种方式用的多\n- position和display\n- css 让如何让元素居中\n- 直接开始手撕：\n    - 实现二分查找，然后将while循环改成递归。\n- 反问：\n    - 组内用了什么技术\n    - 美团app用了什么框架？\n\n### 荣耀 - 通用软件开发工程师 - 实习\n2024/5/21 16:30\n- 自我介绍\n- 开源项目介绍演示\n- 你还会点前端？会点前端挺好的\n- 讲讲国家电网项目\n- Java中你用过哪些集合 介绍一下\n- HashMap为什么不支持高并发\n- 有一个要执行的东西，丢到异步线程执行，执行完获取结果。如何实现？\n- 在开发中有遇到过高并发嘛？\n- redis中有哪几种数据类型\n- 手撕：\n    - LRU缓存，面试官口述，我没太听懂，之前也没做过这题，然后没撕出来。。。 到最后才跟我讲这是leetcode146，还说回去后好好看看。。\n\n### 阿里国际 - 测试开发工程师 - 实习\n2024/5/22 11:00 40min\n- 部门介绍\n- 自我介绍\n- 开源项目是做什么？\n- 国家电网项目是做什么的？数据量多少？如何智能？\n- TCP和UDP原理及区别\n- 如何将UDP变为TCP那样可靠\n- 用户态和和内核态\n- 数据库的事务\n- 反问：\n    - 测开学习路线\n    - 面试的是测开，但是问的时候都没怎么问？\n\n### 饿了么 - 测开实习 - 一面\n2024/6/12 15:00 50 多分钟\n- 自我介绍\n- 我看你本科不是计算机的，为啥想走计算机这条道路\n- 介绍一下你所工作的开源社区\n- 印象最深的一个项目，难点与亮点\n- 国家电网项目，数据结构如何设计的\n- mysql 两张表联合查询\n- mysql 事务\n- 浏览器输入一个 url 发生了什么？\n- http/https区别\n- SSL 加密了解过吗？\n- Java 数据类型\n- 手撕：\n    - Java 单例模式\n    - 删除链表的一个节点\n- 对于上述删除链表节点的题，围绕这个点做功能测试如何设计测试用例？\n- 饿了么外面搜索框功能测试，你该测试什么内容？\n- 对于现在大模型盛行的时代，你是如何看待大模型的？有用到过没？谈谈你的理解。\n- 反问：\n    - 最快什么时候入职\n\n### 阿里国际 - 测试开发工程师 - 实习\n2024/6/17，15:00 电话面，20 多分钟\n- 为什么会选择测开这个岗位\n- 你对测开具体哪个部分感兴趣？\n- 自我介绍\n- 你在开源项目中印象最深的一个项目\n- 国家电网项目介绍\n- 学生生涯过程中遇到的一些挫折和应对策略\n- 电商满减优惠券测试用例设计\n- 反问：\n    - 如果面试通过的话最快入职时间\n    - 一面二面间隔多久\n\n### 网易互娱 - 游戏研发工程师 - 实习\n2024/6/25 55 min\n- 自我介绍\n- 开源实习/开源项目介绍\n- 国家电网项目介绍\n- HashMap底层\n- HashMap线程安全吗？线程安全用什么？\n- ArrayList底层，线程安全吗？线程安全用什么？\n- 死锁的产生，如何避免？\n- 线程池的作用\n- 内存池了解过吗？内存池如何解决内存碎片化问题？\n- LRU了解过吗？用什么数据结构实现 LRU？\n- 如何保证线程安全？\n- Java 垃圾回收机制\n- Java设计模式用过吗？\n- C++、Python语言使用过吗？\n- C++常用数据结构\n- C++ lambda 表达式用过吗？\n- Python内存模型\n- 浏览器输入URL到展示的过程\n- TCP/UDP 区别\n- TCP 属于哪一层的协议？\n- 应用层协议有哪些？\n- 我怎么感觉你研究生什么都没做？有什么科研成果吗？\n- 具体讲讲小论文的创新点\n- TCP 如何保证连接可靠性\n- TCP 的丢包问题如何解决？只有重传机制吗？\n- 多个客户端访问一个服务端，如何实现？\n- 看过Redis源码吗？\n- Redis主要是做什么的？\n- 如果要你自己实现一个缓存，你会怎么做？\n- 处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？\n- A*算法了解过吗？\n- 为什么要应聘游戏研发这个岗位\n- 玩过哪些游戏？如何设计出一个游戏？\n- 反问：\n    - 会给实习生分配什么样的工作？竟然说这不是你该考虑的事情。。。。还建议我如果走游戏研发的话要多学学C++。。。完犊子喽。\n    - 前面 40 分钟都是一个面试官问，到后面我才知道原来有俩面试官。。。第二个面试官有点凶神恶煞的。。\n\n### 饿了么- 测试开发实习生 - 二面\n2024/6/25 14:00 一个小时\n- 手撕代码：\n    - 写一个实现rm -rf path 命令功能的函数\n- 针对上面写的函数，写测试用例\n- 上面函数在Linux 系统下使用会有什么问题？\n- Linux用过吗\n- 给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。\n- 支部宝转账测试用例\n- 针对于转账的高并发情况，在系统层面如何优化？\n- 数据库事务了解吗？\n- 你刚说转账是一系列操作，具体指？\n- 数据库索引了解吗？有什么优缺点\n- Java反射\n- Java中除了空指针异常，还有有哪些异常？\n- 自我介绍\n- 挑一个项目或者实习介绍一下你的工作内容及成就\n- 你的项目中有用Java写的没？\n- 迄今为止遇到过得最大困难是什么？怎么解决的？\n- 我看你本科专业不是计算机的，还是保研的，保研不是都保本专业吗，为什么想转专业？\n- 本科专业排名\n- 跨度很大，有系统的学习过相关课程和编程语言吗？\n- 转专业后学习过程中，有遇到过困难吗？\n- 研究生研究方向？\n- 项目和科研不太相关，这是怎么回事？\n- 智力题：\n    - 8个外形一样的球，其中有一个偏重，求如何只使用两次测量就找到重的球。\n- 谈谈未来职业规划以及为什么要做测开？为什么不选算法岗和开发岗。\n- 反问：\n    - 测试开发系统学习路线\n    - 最快什么时候入职\n\n### 阿里大文娱 - 优酷测开 - 实习生一面\n2024/6/26 14:00 20多分钟电话面\n- 自我介绍\n- 我看你是软件工程专业，而且项目经历也是开发较多，为什么要投测试开发的岗位\n- 你对测试相关知识有了解吗，介绍一下\n- 你刚说的黑盒测试和白盒测试，可不可以只有黑盒测试或者白盒测试？\n- 你刚介绍的那个模块，你如何保证它的质量\n- 写过测试用例吗？\n- 测试用例的一些设计方法\n- 优酷视频这个软件，从系统层面说一说如何进行测试\n- 你理解的 Java线程安全指的是什么？\n- 如何实现线程安全\n- 同步和异步指的是什么？\n- 如何实现异步调用？\n- 除了 Future 类还有其他实现异步调用的方法吗？\n- 内存溢出和内存泄漏区别\n- 了解 SQL注入吗？\n- 什么是事务\n- 慢查询的原因\n- 常见网络模型？\n- 你还会点前端是吧，什么是跨域？\n- 跨域是为了防止什么？\n- 反问：\n  - 目前部门还缺人吗\n  - 如果面试通过了的话，最快什么时候入职？\n  - 一共有几轮面试\n  - 官网流程快不快？\n\n其实面试体验挺不佳的，本来跟面试官约的两点面嘛，然后加了钉钉，之后到 14:10还没收到钉钉电话，我去问加钉钉那个人，结果他不是面试官，只是联系人，他去帮我问，原来是有好几个候选人，有一个候选人也姓陈，面试官给搞混了，给他打过去电话开始面试，然后把我给晾在这了。\n\n然后第一个面了一个多小时，到了 15:20才给我打电话，我就面了 20多分钟，结束了，结束后还跟我讲，你的测试开发相关知识比较薄弱啊，如果后面要面的话还需要再加强。我反问我是不是挂了，他说不是。。。。\n\n刚面完就看到官网流程更新，从简历评估到面试安排中了，反手一条邮件发过来，是测评。。应该是过了一面吧。。。\n\n\n内存池了解过吗？内存池如何解决内存碎片化问题？\n如何保证线程安全？\nJava 设计模式\nC++常用数据结构\nC++ lambda 表达式用过吗？\nPython内存模型\nTCP 的丢包问题如何解决？只有重传机制吗？\n多个客户端访问一个服务端，如何实现？\n如果要你自己实现一个缓存，你会怎么做？\n处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？\nA*算法了解过吗？\n为什么要应聘游戏研发这个岗位\n玩过哪些游戏？如何设计出一个游戏？\n\n给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。\n针对于转账的高并发情况，在系统层面如何优化？\n测试相关专业知识\n如何使用测试保证一个模块的质量\n测试用例的设计方法\n优酷视频这个软件，从系统层面说一说如何进行测试\n同步异步指的是什么\n除了 Future 类还有其他实现异步调用的方法吗？\n内存溢出和内存泄漏区别\nSQL 注入\n慢查询原因\n常见网络模型\n什么是跨域\n跨域是为了防止什么\n\n\n\n","source":"_posts/面经汇总.md","raw":"---\ntitle: 面经汇总\ntags:\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 面经汇总\nabbrlink: 17773\ndate: 2024-06-25 19:52:15\nupdated: 2024-06-26 16:15:15\ntop_img: https://s2.loli.net/2024/06/25/2VJc4rMTXeSqD7K.png\ncomments:\ncover: https://s2.loli.net/2024/06/25/Jfpxsi8HXMwbC29.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n### 腾讯 WXG - 移动客户端开发 实习\n基础微信&视频号团队\n2024/3/19 40多分钟 一面\n- 自我介绍\n- 研究生成绩、本科生成绩\n- 研究生主要专业课\n- Java - 强引用 弱引用\n- Java - 垃圾回收机制\n- TCP连接如何保成可靠性\n- HTTP状态码\n- 拷打实习、项目\n- 你的开源线上实习主要都做的啥？\n- 你在开源实习过程中遇到的最难的是什么？\n- 你的单点登录系统大前端项目中 主要都做了什么东西？\n- 手撕代码\n    - 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n- 意向城市是上海，组内基本都在广州，这个你有什么问题吗？\n- 为什么会想要投移动客户端开发？\n- 除了在实习项目中，你还在有通过其他途径了解到移动客户端开发吗？\n- 反问：\n    - 面试官您觉得我的表现如何？\n    - 组内日常工作？\n\n### 淘天集团 - 天猫技术部前端 实习\n2024/3/26 14:00  70多分钟。。感觉好难。。。\n- 面试官介绍部门、自我介绍\n- 自己自我介绍\n- RN和React的区别\n- 单点登录SSO原理\n- PKCE\n- Flutter RN区别，如何实现跨平台的\n- 项目中使用了unity，具体做了什么？\n- 具体讲2FA是什么\n- sdk实现的原理过程是什么\n- 原型和原型链\n- 事件循环机制\n- react 钩子hooks\n- JS 函数是类吗？函数与类的区别在哪？\n- 反问：\n    - 前端知识很零散很杂，对此您有何看法？\n\n### 淘天集团 - 闲鱼技术部前端 实习\n2024/3/26 19:00 40多分钟\n- 为什么想要走前端的这条路？对前端看法是怎么样的？\n- Casbin线上实习做了什么\n- 以RN sdk为例子，讲一下sdk的工作流程，具体做了啥？\n- 大前端系统做了什么\n- 国家电网项目做了什么？\n- JS this指针\n- JS Promise函数\n- JS ES6新特性有哪些\n- JS 变量作用域\n\n### 淘天集团 - 闲鱼技术部移动端开发 实习\n2024/4/1 16:00 20多分钟。。。 太菜了。。。多练啊。。。练习时长两天半还敢出来混啊卧槽了。\n- 自我介绍\n- 为什么想要走移动端开发这种道路。\n- Casbin是做什么的？\n- RN的原理\n- 单点登录SSO原理\n- 我看你简历上很多移动端开发的经历，可以讲讲吗？\n- 有学过什么计算机专业相关的专业课吗？\n- 常用的数据结构有什么？\n- 哈希表的结构\n- 排序算法的复杂度\n- 给一个数组，和一个数字，返回这个数字所在的index，有什么方法，复杂度是什么？\n- 给一个排好序的数组，且里面有很多重复的元素，这个时候如何返回一个指定数字的index？\n- 反问：\n    - 移动端开发如何去学习？\n    - 移动客户端开发有什么学习的一些网站吗？\n\n### 腾讯 - 移动客户端开发 实习\n2024/4/2 19:00 60多分钟\n- 自我介绍\n- 印象最深刻的实习或者项目\n- TCP、UDP区别\n- TCP三次握手、四次挥手\n- Java堆和栈区别\n- 进程线程区别\n- OSI七层模型\n- 死锁\n- 常见Linux线程间的通信方式\n- HTTP状态码\n- Java为什么会堆栈溢出\n- C++多态\n- C++是面向过程的语言吗？\n- i++和++i的区别\n- 302状态码是什么？\n- Java同步关键字\n- 操作系统的虚拟内存\n- 成员变量和全局变量都存在哪里？\n- Java最基础的类是什么类，有哪些方法？\n- Java异常机制\n- 从增加删除元素的角度说数组和链表的区别\n- 分别向链表数组中插入元素的复杂度\n- 用户态和内核态\n- 手撕两道题：\n    - 单例模式，如何保证一个类只创建一次\n    - 不含重复字符的最长子串的长度\n- 反问：\n    - 移动客户端开发的学习路线是什么\n\n### 携程 - 移动客户端开发iOS/Android\n2024/4/11 18:00 40分钟\n- 你在大前端项目里主要做了什么？\n- react的原理\n- Dom树\n- js的闭包\n- js的原型&原型链\n- C++的三大特性\n- 手撕两道题\n    - 有序链表合并\n    - 二叉树前序遍历，然后转为数组\n- 反问：\n    - 前端学习路线\n    - 工作城市\n\n其实后面面试官说，你做的项目跟我们现在做的很契合，然后第二天下午打了个电话没接到，应该是二面。后面假期过后就给我进人才池了，有点亏。。。\n\n### 腾讯金融科技 - 测试开发工程师\n2024/4/19 17:00 40 分钟\n- 自我介绍\n- 你最近认为做的最有难度最好的一次项目经历。\n- 开源项目\n- 你在开源实习和项目中使用的技术栈是什么，你学到了什么？\n- 国家电网项目\n- 手撕代码\n    - 最长重复子串\n- 数据库\n- Linux 系统\n- 反问：\n    - 测开的学习路线\n    - 工作地点和时间，加班多吗？\n\n### 美团到店 - 后端开发工程师 - 实习生\n2024/4/24 14:00 一个小时\n- 面试流程、部门介绍\n- 自我介绍\n- 项目介绍\n- 2FA\n- TOTP\n- OTP\n- PKCE\n- Java 如何实现高并发\n- 高并发会出现什么问题，Java如何解决的？\n- 上下文切换开销\n- Java虚拟机内存\n- HashMap底层、java7和java8有什么改进\n- ConcurrentHashMap如何实现多进程，java7和java8有什么改进\n- Java有哪些锁。\n- 乐观锁悲观锁\n- 进程、线程区别\n- mysql\n- redis\n- TCP、UDP区别\n- 三次握手四次挥手\n- 手撕代码： 二选一\n    - 反转部分链表\n    - 旋转数组后查找元素\n- 反问：\n    - 部门寻找实习生的标准是什么样的？\n    - 实习生日常工作时间\n\n### 美团核心 - 软件开发工程师-前端&移动端方向 实习\n2024/5/15 19:00\n- 自我介绍\n- 介绍开源项目主要的工作\n- 在父元素中调整子元素位置你用哪种方式用的多\n- position和display\n- css 让如何让元素居中\n- 直接开始手撕：\n    - 实现二分查找，然后将while循环改成递归。\n- 反问：\n    - 组内用了什么技术\n    - 美团app用了什么框架？\n\n### 荣耀 - 通用软件开发工程师 - 实习\n2024/5/21 16:30\n- 自我介绍\n- 开源项目介绍演示\n- 你还会点前端？会点前端挺好的\n- 讲讲国家电网项目\n- Java中你用过哪些集合 介绍一下\n- HashMap为什么不支持高并发\n- 有一个要执行的东西，丢到异步线程执行，执行完获取结果。如何实现？\n- 在开发中有遇到过高并发嘛？\n- redis中有哪几种数据类型\n- 手撕：\n    - LRU缓存，面试官口述，我没太听懂，之前也没做过这题，然后没撕出来。。。 到最后才跟我讲这是leetcode146，还说回去后好好看看。。\n\n### 阿里国际 - 测试开发工程师 - 实习\n2024/5/22 11:00 40min\n- 部门介绍\n- 自我介绍\n- 开源项目是做什么？\n- 国家电网项目是做什么的？数据量多少？如何智能？\n- TCP和UDP原理及区别\n- 如何将UDP变为TCP那样可靠\n- 用户态和和内核态\n- 数据库的事务\n- 反问：\n    - 测开学习路线\n    - 面试的是测开，但是问的时候都没怎么问？\n\n### 饿了么 - 测开实习 - 一面\n2024/6/12 15:00 50 多分钟\n- 自我介绍\n- 我看你本科不是计算机的，为啥想走计算机这条道路\n- 介绍一下你所工作的开源社区\n- 印象最深的一个项目，难点与亮点\n- 国家电网项目，数据结构如何设计的\n- mysql 两张表联合查询\n- mysql 事务\n- 浏览器输入一个 url 发生了什么？\n- http/https区别\n- SSL 加密了解过吗？\n- Java 数据类型\n- 手撕：\n    - Java 单例模式\n    - 删除链表的一个节点\n- 对于上述删除链表节点的题，围绕这个点做功能测试如何设计测试用例？\n- 饿了么外面搜索框功能测试，你该测试什么内容？\n- 对于现在大模型盛行的时代，你是如何看待大模型的？有用到过没？谈谈你的理解。\n- 反问：\n    - 最快什么时候入职\n\n### 阿里国际 - 测试开发工程师 - 实习\n2024/6/17，15:00 电话面，20 多分钟\n- 为什么会选择测开这个岗位\n- 你对测开具体哪个部分感兴趣？\n- 自我介绍\n- 你在开源项目中印象最深的一个项目\n- 国家电网项目介绍\n- 学生生涯过程中遇到的一些挫折和应对策略\n- 电商满减优惠券测试用例设计\n- 反问：\n    - 如果面试通过的话最快入职时间\n    - 一面二面间隔多久\n\n### 网易互娱 - 游戏研发工程师 - 实习\n2024/6/25 55 min\n- 自我介绍\n- 开源实习/开源项目介绍\n- 国家电网项目介绍\n- HashMap底层\n- HashMap线程安全吗？线程安全用什么？\n- ArrayList底层，线程安全吗？线程安全用什么？\n- 死锁的产生，如何避免？\n- 线程池的作用\n- 内存池了解过吗？内存池如何解决内存碎片化问题？\n- LRU了解过吗？用什么数据结构实现 LRU？\n- 如何保证线程安全？\n- Java 垃圾回收机制\n- Java设计模式用过吗？\n- C++、Python语言使用过吗？\n- C++常用数据结构\n- C++ lambda 表达式用过吗？\n- Python内存模型\n- 浏览器输入URL到展示的过程\n- TCP/UDP 区别\n- TCP 属于哪一层的协议？\n- 应用层协议有哪些？\n- 我怎么感觉你研究生什么都没做？有什么科研成果吗？\n- 具体讲讲小论文的创新点\n- TCP 如何保证连接可靠性\n- TCP 的丢包问题如何解决？只有重传机制吗？\n- 多个客户端访问一个服务端，如何实现？\n- 看过Redis源码吗？\n- Redis主要是做什么的？\n- 如果要你自己实现一个缓存，你会怎么做？\n- 处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？\n- A*算法了解过吗？\n- 为什么要应聘游戏研发这个岗位\n- 玩过哪些游戏？如何设计出一个游戏？\n- 反问：\n    - 会给实习生分配什么样的工作？竟然说这不是你该考虑的事情。。。。还建议我如果走游戏研发的话要多学学C++。。。完犊子喽。\n    - 前面 40 分钟都是一个面试官问，到后面我才知道原来有俩面试官。。。第二个面试官有点凶神恶煞的。。\n\n### 饿了么- 测试开发实习生 - 二面\n2024/6/25 14:00 一个小时\n- 手撕代码：\n    - 写一个实现rm -rf path 命令功能的函数\n- 针对上面写的函数，写测试用例\n- 上面函数在Linux 系统下使用会有什么问题？\n- Linux用过吗\n- 给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。\n- 支部宝转账测试用例\n- 针对于转账的高并发情况，在系统层面如何优化？\n- 数据库事务了解吗？\n- 你刚说转账是一系列操作，具体指？\n- 数据库索引了解吗？有什么优缺点\n- Java反射\n- Java中除了空指针异常，还有有哪些异常？\n- 自我介绍\n- 挑一个项目或者实习介绍一下你的工作内容及成就\n- 你的项目中有用Java写的没？\n- 迄今为止遇到过得最大困难是什么？怎么解决的？\n- 我看你本科专业不是计算机的，还是保研的，保研不是都保本专业吗，为什么想转专业？\n- 本科专业排名\n- 跨度很大，有系统的学习过相关课程和编程语言吗？\n- 转专业后学习过程中，有遇到过困难吗？\n- 研究生研究方向？\n- 项目和科研不太相关，这是怎么回事？\n- 智力题：\n    - 8个外形一样的球，其中有一个偏重，求如何只使用两次测量就找到重的球。\n- 谈谈未来职业规划以及为什么要做测开？为什么不选算法岗和开发岗。\n- 反问：\n    - 测试开发系统学习路线\n    - 最快什么时候入职\n\n### 阿里大文娱 - 优酷测开 - 实习生一面\n2024/6/26 14:00 20多分钟电话面\n- 自我介绍\n- 我看你是软件工程专业，而且项目经历也是开发较多，为什么要投测试开发的岗位\n- 你对测试相关知识有了解吗，介绍一下\n- 你刚说的黑盒测试和白盒测试，可不可以只有黑盒测试或者白盒测试？\n- 你刚介绍的那个模块，你如何保证它的质量\n- 写过测试用例吗？\n- 测试用例的一些设计方法\n- 优酷视频这个软件，从系统层面说一说如何进行测试\n- 你理解的 Java线程安全指的是什么？\n- 如何实现线程安全\n- 同步和异步指的是什么？\n- 如何实现异步调用？\n- 除了 Future 类还有其他实现异步调用的方法吗？\n- 内存溢出和内存泄漏区别\n- 了解 SQL注入吗？\n- 什么是事务\n- 慢查询的原因\n- 常见网络模型？\n- 你还会点前端是吧，什么是跨域？\n- 跨域是为了防止什么？\n- 反问：\n  - 目前部门还缺人吗\n  - 如果面试通过了的话，最快什么时候入职？\n  - 一共有几轮面试\n  - 官网流程快不快？\n\n其实面试体验挺不佳的，本来跟面试官约的两点面嘛，然后加了钉钉，之后到 14:10还没收到钉钉电话，我去问加钉钉那个人，结果他不是面试官，只是联系人，他去帮我问，原来是有好几个候选人，有一个候选人也姓陈，面试官给搞混了，给他打过去电话开始面试，然后把我给晾在这了。\n\n然后第一个面了一个多小时，到了 15:20才给我打电话，我就面了 20多分钟，结束了，结束后还跟我讲，你的测试开发相关知识比较薄弱啊，如果后面要面的话还需要再加强。我反问我是不是挂了，他说不是。。。。\n\n刚面完就看到官网流程更新，从简历评估到面试安排中了，反手一条邮件发过来，是测评。。应该是过了一面吧。。。\n\n\n内存池了解过吗？内存池如何解决内存碎片化问题？\n如何保证线程安全？\nJava 设计模式\nC++常用数据结构\nC++ lambda 表达式用过吗？\nPython内存模型\nTCP 的丢包问题如何解决？只有重传机制吗？\n多个客户端访问一个服务端，如何实现？\n如果要你自己实现一个缓存，你会怎么做？\n处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？\nA*算法了解过吗？\n为什么要应聘游戏研发这个岗位\n玩过哪些游戏？如何设计出一个游戏？\n\n给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。\n针对于转账的高并发情况，在系统层面如何优化？\n测试相关专业知识\n如何使用测试保证一个模块的质量\n测试用例的设计方法\n优酷视频这个软件，从系统层面说一说如何进行测试\n同步异步指的是什么\n除了 Future 类还有其他实现异步调用的方法吗？\n内存溢出和内存泄漏区别\nSQL 注入\n慢查询原因\n常见网络模型\n什么是跨域\n跨域是为了防止什么\n\n\n\n","slug":"面经汇总","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1y002rr7gnfx88efbk","content":"<h3 id=\"腾讯-WXG-移动客户端开发-实习\"><a href=\"#腾讯-WXG-移动客户端开发-实习\" class=\"headerlink\" title=\"腾讯 WXG - 移动客户端开发 实习\"></a>腾讯 WXG - 移动客户端开发 实习</h3><p>基础微信&amp;视频号团队<br>2024&#x2F;3&#x2F;19 40多分钟 一面</p>\n<ul>\n<li>自我介绍</li>\n<li>研究生成绩、本科生成绩</li>\n<li>研究生主要专业课</li>\n<li>Java - 强引用 弱引用</li>\n<li>Java - 垃圾回收机制</li>\n<li>TCP连接如何保成可靠性</li>\n<li>HTTP状态码</li>\n<li>拷打实习、项目</li>\n<li>你的开源线上实习主要都做的啥？</li>\n<li>你在开源实习过程中遇到的最难的是什么？</li>\n<li>你的单点登录系统大前端项目中 主要都做了什么东西？</li>\n<li>手撕代码<ul>\n<li>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</li>\n</ul>\n</li>\n<li>意向城市是上海，组内基本都在广州，这个你有什么问题吗？</li>\n<li>为什么会想要投移动客户端开发？</li>\n<li>除了在实习项目中，你还在有通过其他途径了解到移动客户端开发吗？</li>\n<li>反问：<ul>\n<li>面试官您觉得我的表现如何？</li>\n<li>组内日常工作？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"淘天集团-天猫技术部前端-实习\"><a href=\"#淘天集团-天猫技术部前端-实习\" class=\"headerlink\" title=\"淘天集团 - 天猫技术部前端 实习\"></a>淘天集团 - 天猫技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 14:00  70多分钟。。感觉好难。。。</p>\n<ul>\n<li>面试官介绍部门、自我介绍</li>\n<li>自己自我介绍</li>\n<li>RN和React的区别</li>\n<li>单点登录SSO原理</li>\n<li>PKCE</li>\n<li>Flutter RN区别，如何实现跨平台的</li>\n<li>项目中使用了unity，具体做了什么？</li>\n<li>具体讲2FA是什么</li>\n<li>sdk实现的原理过程是什么</li>\n<li>原型和原型链</li>\n<li>事件循环机制</li>\n<li>react 钩子hooks</li>\n<li>JS 函数是类吗？函数与类的区别在哪？</li>\n<li>反问：<ul>\n<li>前端知识很零散很杂，对此您有何看法？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"淘天集团-闲鱼技术部前端-实习\"><a href=\"#淘天集团-闲鱼技术部前端-实习\" class=\"headerlink\" title=\"淘天集团 - 闲鱼技术部前端 实习\"></a>淘天集团 - 闲鱼技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 19:00 40多分钟</p>\n<ul>\n<li>为什么想要走前端的这条路？对前端看法是怎么样的？</li>\n<li>Casbin线上实习做了什么</li>\n<li>以RN sdk为例子，讲一下sdk的工作流程，具体做了啥？</li>\n<li>大前端系统做了什么</li>\n<li>国家电网项目做了什么？</li>\n<li>JS this指针</li>\n<li>JS Promise函数</li>\n<li>JS ES6新特性有哪些</li>\n<li>JS 变量作用域</li>\n</ul>\n<h3 id=\"淘天集团-闲鱼技术部移动端开发-实习\"><a href=\"#淘天集团-闲鱼技术部移动端开发-实习\" class=\"headerlink\" title=\"淘天集团 - 闲鱼技术部移动端开发 实习\"></a>淘天集团 - 闲鱼技术部移动端开发 实习</h3><p>2024&#x2F;4&#x2F;1 16:00 20多分钟。。。 太菜了。。。多练啊。。。练习时长两天半还敢出来混啊卧槽了。</p>\n<ul>\n<li>自我介绍</li>\n<li>为什么想要走移动端开发这种道路。</li>\n<li>Casbin是做什么的？</li>\n<li>RN的原理</li>\n<li>单点登录SSO原理</li>\n<li>我看你简历上很多移动端开发的经历，可以讲讲吗？</li>\n<li>有学过什么计算机专业相关的专业课吗？</li>\n<li>常用的数据结构有什么？</li>\n<li>哈希表的结构</li>\n<li>排序算法的复杂度</li>\n<li>给一个数组，和一个数字，返回这个数字所在的index，有什么方法，复杂度是什么？</li>\n<li>给一个排好序的数组，且里面有很多重复的元素，这个时候如何返回一个指定数字的index？</li>\n<li>反问：<ul>\n<li>移动端开发如何去学习？</li>\n<li>移动客户端开发有什么学习的一些网站吗？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"腾讯-移动客户端开发-实习\"><a href=\"#腾讯-移动客户端开发-实习\" class=\"headerlink\" title=\"腾讯 - 移动客户端开发 实习\"></a>腾讯 - 移动客户端开发 实习</h3><p>2024&#x2F;4&#x2F;2 19:00 60多分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>印象最深刻的实习或者项目</li>\n<li>TCP、UDP区别</li>\n<li>TCP三次握手、四次挥手</li>\n<li>Java堆和栈区别</li>\n<li>进程线程区别</li>\n<li>OSI七层模型</li>\n<li>死锁</li>\n<li>常见Linux线程间的通信方式</li>\n<li>HTTP状态码</li>\n<li>Java为什么会堆栈溢出</li>\n<li>C++多态</li>\n<li>C++是面向过程的语言吗？</li>\n<li>i++和++i的区别</li>\n<li>302状态码是什么？</li>\n<li>Java同步关键字</li>\n<li>操作系统的虚拟内存</li>\n<li>成员变量和全局变量都存在哪里？</li>\n<li>Java最基础的类是什么类，有哪些方法？</li>\n<li>Java异常机制</li>\n<li>从增加删除元素的角度说数组和链表的区别</li>\n<li>分别向链表数组中插入元素的复杂度</li>\n<li>用户态和内核态</li>\n<li>手撕两道题：<ul>\n<li>单例模式，如何保证一个类只创建一次</li>\n<li>不含重复字符的最长子串的长度</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>移动客户端开发的学习路线是什么</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"携程-移动客户端开发iOS-Android\"><a href=\"#携程-移动客户端开发iOS-Android\" class=\"headerlink\" title=\"携程 - 移动客户端开发iOS&#x2F;Android\"></a>携程 - 移动客户端开发iOS&#x2F;Android</h3><p>2024&#x2F;4&#x2F;11 18:00 40分钟</p>\n<ul>\n<li>你在大前端项目里主要做了什么？</li>\n<li>react的原理</li>\n<li>Dom树</li>\n<li>js的闭包</li>\n<li>js的原型&amp;原型链</li>\n<li>C++的三大特性</li>\n<li>手撕两道题<ul>\n<li>有序链表合并</li>\n<li>二叉树前序遍历，然后转为数组</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>前端学习路线</li>\n<li>工作城市</li>\n</ul>\n</li>\n</ul>\n<p>其实后面面试官说，你做的项目跟我们现在做的很契合，然后第二天下午打了个电话没接到，应该是二面。后面假期过后就给我进人才池了，有点亏。。。</p>\n<h3 id=\"腾讯金融科技-测试开发工程师\"><a href=\"#腾讯金融科技-测试开发工程师\" class=\"headerlink\" title=\"腾讯金融科技 - 测试开发工程师\"></a>腾讯金融科技 - 测试开发工程师</h3><p>2024&#x2F;4&#x2F;19 17:00 40 分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>你最近认为做的最有难度最好的一次项目经历。</li>\n<li>开源项目</li>\n<li>你在开源实习和项目中使用的技术栈是什么，你学到了什么？</li>\n<li>国家电网项目</li>\n<li>手撕代码<ul>\n<li>最长重复子串</li>\n</ul>\n</li>\n<li>数据库</li>\n<li>Linux 系统</li>\n<li>反问：<ul>\n<li>测开的学习路线</li>\n<li>工作地点和时间，加班多吗？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"美团到店-后端开发工程师-实习生\"><a href=\"#美团到店-后端开发工程师-实习生\" class=\"headerlink\" title=\"美团到店 - 后端开发工程师 - 实习生\"></a>美团到店 - 后端开发工程师 - 实习生</h3><p>2024&#x2F;4&#x2F;24 14:00 一个小时</p>\n<ul>\n<li>面试流程、部门介绍</li>\n<li>自我介绍</li>\n<li>项目介绍</li>\n<li>2FA</li>\n<li>TOTP</li>\n<li>OTP</li>\n<li>PKCE</li>\n<li>Java 如何实现高并发</li>\n<li>高并发会出现什么问题，Java如何解决的？</li>\n<li>上下文切换开销</li>\n<li>Java虚拟机内存</li>\n<li>HashMap底层、java7和java8有什么改进</li>\n<li>ConcurrentHashMap如何实现多进程，java7和java8有什么改进</li>\n<li>Java有哪些锁。</li>\n<li>乐观锁悲观锁</li>\n<li>进程、线程区别</li>\n<li>mysql</li>\n<li>redis</li>\n<li>TCP、UDP区别</li>\n<li>三次握手四次挥手</li>\n<li>手撕代码： 二选一<ul>\n<li>反转部分链表</li>\n<li>旋转数组后查找元素</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>部门寻找实习生的标准是什么样的？</li>\n<li>实习生日常工作时间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"美团核心-软件开发工程师-前端-移动端方向-实习\"><a href=\"#美团核心-软件开发工程师-前端-移动端方向-实习\" class=\"headerlink\" title=\"美团核心 - 软件开发工程师-前端&amp;移动端方向 实习\"></a>美团核心 - 软件开发工程师-前端&amp;移动端方向 实习</h3><p>2024&#x2F;5&#x2F;15 19:00</p>\n<ul>\n<li>自我介绍</li>\n<li>介绍开源项目主要的工作</li>\n<li>在父元素中调整子元素位置你用哪种方式用的多</li>\n<li>position和display</li>\n<li>css 让如何让元素居中</li>\n<li>直接开始手撕：<ul>\n<li>实现二分查找，然后将while循环改成递归。</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>组内用了什么技术</li>\n<li>美团app用了什么框架？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"荣耀-通用软件开发工程师-实习\"><a href=\"#荣耀-通用软件开发工程师-实习\" class=\"headerlink\" title=\"荣耀 - 通用软件开发工程师 - 实习\"></a>荣耀 - 通用软件开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;21 16:30</p>\n<ul>\n<li>自我介绍</li>\n<li>开源项目介绍演示</li>\n<li>你还会点前端？会点前端挺好的</li>\n<li>讲讲国家电网项目</li>\n<li>Java中你用过哪些集合 介绍一下</li>\n<li>HashMap为什么不支持高并发</li>\n<li>有一个要执行的东西，丢到异步线程执行，执行完获取结果。如何实现？</li>\n<li>在开发中有遇到过高并发嘛？</li>\n<li>redis中有哪几种数据类型</li>\n<li>手撕：<ul>\n<li>LRU缓存，面试官口述，我没太听懂，之前也没做过这题，然后没撕出来。。。 到最后才跟我讲这是leetcode146，还说回去后好好看看。。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里国际-测试开发工程师-实习\"><a href=\"#阿里国际-测试开发工程师-实习\" class=\"headerlink\" title=\"阿里国际 - 测试开发工程师 - 实习\"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;22 11:00 40min</p>\n<ul>\n<li>部门介绍</li>\n<li>自我介绍</li>\n<li>开源项目是做什么？</li>\n<li>国家电网项目是做什么的？数据量多少？如何智能？</li>\n<li>TCP和UDP原理及区别</li>\n<li>如何将UDP变为TCP那样可靠</li>\n<li>用户态和和内核态</li>\n<li>数据库的事务</li>\n<li>反问：<ul>\n<li>测开学习路线</li>\n<li>面试的是测开，但是问的时候都没怎么问？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"饿了么-测开实习-一面\"><a href=\"#饿了么-测开实习-一面\" class=\"headerlink\" title=\"饿了么 - 测开实习 - 一面\"></a>饿了么 - 测开实习 - 一面</h3><p>2024&#x2F;6&#x2F;12 15:00 50 多分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>我看你本科不是计算机的，为啥想走计算机这条道路</li>\n<li>介绍一下你所工作的开源社区</li>\n<li>印象最深的一个项目，难点与亮点</li>\n<li>国家电网项目，数据结构如何设计的</li>\n<li>mysql 两张表联合查询</li>\n<li>mysql 事务</li>\n<li>浏览器输入一个 url 发生了什么？</li>\n<li>http&#x2F;https区别</li>\n<li>SSL 加密了解过吗？</li>\n<li>Java 数据类型</li>\n<li>手撕：<ul>\n<li>Java 单例模式</li>\n<li>删除链表的一个节点</li>\n</ul>\n</li>\n<li>对于上述删除链表节点的题，围绕这个点做功能测试如何设计测试用例？</li>\n<li>饿了么外面搜索框功能测试，你该测试什么内容？</li>\n<li>对于现在大模型盛行的时代，你是如何看待大模型的？有用到过没？谈谈你的理解。</li>\n<li>反问：<ul>\n<li>最快什么时候入职</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里国际-测试开发工程师-实习-1\"><a href=\"#阿里国际-测试开发工程师-实习-1\" class=\"headerlink\" title=\"阿里国际 - 测试开发工程师 - 实习\"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;17，15:00 电话面，20 多分钟</p>\n<ul>\n<li>为什么会选择测开这个岗位</li>\n<li>你对测开具体哪个部分感兴趣？</li>\n<li>自我介绍</li>\n<li>你在开源项目中印象最深的一个项目</li>\n<li>国家电网项目介绍</li>\n<li>学生生涯过程中遇到的一些挫折和应对策略</li>\n<li>电商满减优惠券测试用例设计</li>\n<li>反问：<ul>\n<li>如果面试通过的话最快入职时间</li>\n<li>一面二面间隔多久</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网易互娱-游戏研发工程师-实习\"><a href=\"#网易互娱-游戏研发工程师-实习\" class=\"headerlink\" title=\"网易互娱 - 游戏研发工程师 - 实习\"></a>网易互娱 - 游戏研发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;25 55 min</p>\n<ul>\n<li>自我介绍</li>\n<li>开源实习&#x2F;开源项目介绍</li>\n<li>国家电网项目介绍</li>\n<li>HashMap底层</li>\n<li>HashMap线程安全吗？线程安全用什么？</li>\n<li>ArrayList底层，线程安全吗？线程安全用什么？</li>\n<li>死锁的产生，如何避免？</li>\n<li>线程池的作用</li>\n<li>内存池了解过吗？内存池如何解决内存碎片化问题？</li>\n<li>LRU了解过吗？用什么数据结构实现 LRU？</li>\n<li>如何保证线程安全？</li>\n<li>Java 垃圾回收机制</li>\n<li>Java设计模式用过吗？</li>\n<li>C++、Python语言使用过吗？</li>\n<li>C++常用数据结构</li>\n<li>C++ lambda 表达式用过吗？</li>\n<li>Python内存模型</li>\n<li>浏览器输入URL到展示的过程</li>\n<li>TCP&#x2F;UDP 区别</li>\n<li>TCP 属于哪一层的协议？</li>\n<li>应用层协议有哪些？</li>\n<li>我怎么感觉你研究生什么都没做？有什么科研成果吗？</li>\n<li>具体讲讲小论文的创新点</li>\n<li>TCP 如何保证连接可靠性</li>\n<li>TCP 的丢包问题如何解决？只有重传机制吗？</li>\n<li>多个客户端访问一个服务端，如何实现？</li>\n<li>看过Redis源码吗？</li>\n<li>Redis主要是做什么的？</li>\n<li>如果要你自己实现一个缓存，你会怎么做？</li>\n<li>处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？</li>\n<li>A*算法了解过吗？</li>\n<li>为什么要应聘游戏研发这个岗位</li>\n<li>玩过哪些游戏？如何设计出一个游戏？</li>\n<li>反问：<ul>\n<li>会给实习生分配什么样的工作？竟然说这不是你该考虑的事情。。。。还建议我如果走游戏研发的话要多学学C++。。。完犊子喽。</li>\n<li>前面 40 分钟都是一个面试官问，到后面我才知道原来有俩面试官。。。第二个面试官有点凶神恶煞的。。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"饿了么-测试开发实习生-二面\"><a href=\"#饿了么-测试开发实习生-二面\" class=\"headerlink\" title=\"饿了么- 测试开发实习生 - 二面\"></a>饿了么- 测试开发实习生 - 二面</h3><p>2024&#x2F;6&#x2F;25 14:00 一个小时</p>\n<ul>\n<li>手撕代码：<ul>\n<li>写一个实现rm -rf path 命令功能的函数</li>\n</ul>\n</li>\n<li>针对上面写的函数，写测试用例</li>\n<li>上面函数在Linux 系统下使用会有什么问题？</li>\n<li>Linux用过吗</li>\n<li>给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。</li>\n<li>支部宝转账测试用例</li>\n<li>针对于转账的高并发情况，在系统层面如何优化？</li>\n<li>数据库事务了解吗？</li>\n<li>你刚说转账是一系列操作，具体指？</li>\n<li>数据库索引了解吗？有什么优缺点</li>\n<li>Java反射</li>\n<li>Java中除了空指针异常，还有有哪些异常？</li>\n<li>自我介绍</li>\n<li>挑一个项目或者实习介绍一下你的工作内容及成就</li>\n<li>你的项目中有用Java写的没？</li>\n<li>迄今为止遇到过得最大困难是什么？怎么解决的？</li>\n<li>我看你本科专业不是计算机的，还是保研的，保研不是都保本专业吗，为什么想转专业？</li>\n<li>本科专业排名</li>\n<li>跨度很大，有系统的学习过相关课程和编程语言吗？</li>\n<li>转专业后学习过程中，有遇到过困难吗？</li>\n<li>研究生研究方向？</li>\n<li>项目和科研不太相关，这是怎么回事？</li>\n<li>智力题：<ul>\n<li>8个外形一样的球，其中有一个偏重，求如何只使用两次测量就找到重的球。</li>\n</ul>\n</li>\n<li>谈谈未来职业规划以及为什么要做测开？为什么不选算法岗和开发岗。</li>\n<li>反问：<ul>\n<li>测试开发系统学习路线</li>\n<li>最快什么时候入职</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里大文娱-优酷测开-实习生一面\"><a href=\"#阿里大文娱-优酷测开-实习生一面\" class=\"headerlink\" title=\"阿里大文娱 - 优酷测开 - 实习生一面\"></a>阿里大文娱 - 优酷测开 - 实习生一面</h3><p>2024&#x2F;6&#x2F;26 14:00 20多分钟电话面</p>\n<ul>\n<li>自我介绍</li>\n<li>我看你是软件工程专业，而且项目经历也是开发较多，为什么要投测试开发的岗位</li>\n<li>你对测试相关知识有了解吗，介绍一下</li>\n<li>你刚说的黑盒测试和白盒测试，可不可以只有黑盒测试或者白盒测试？</li>\n<li>你刚介绍的那个模块，你如何保证它的质量</li>\n<li>写过测试用例吗？</li>\n<li>测试用例的一些设计方法</li>\n<li>优酷视频这个软件，从系统层面说一说如何进行测试</li>\n<li>你理解的 Java线程安全指的是什么？</li>\n<li>如何实现线程安全</li>\n<li>同步和异步指的是什么？</li>\n<li>如何实现异步调用？</li>\n<li>除了 Future 类还有其他实现异步调用的方法吗？</li>\n<li>内存溢出和内存泄漏区别</li>\n<li>了解 SQL注入吗？</li>\n<li>什么是事务</li>\n<li>慢查询的原因</li>\n<li>常见网络模型？</li>\n<li>你还会点前端是吧，什么是跨域？</li>\n<li>跨域是为了防止什么？</li>\n<li>反问：<ul>\n<li>目前部门还缺人吗</li>\n<li>如果面试通过了的话，最快什么时候入职？</li>\n<li>一共有几轮面试</li>\n<li>官网流程快不快？</li>\n</ul>\n</li>\n</ul>\n<p>其实面试体验挺不佳的，本来跟面试官约的两点面嘛，然后加了钉钉，之后到 14:10还没收到钉钉电话，我去问加钉钉那个人，结果他不是面试官，只是联系人，他去帮我问，原来是有好几个候选人，有一个候选人也姓陈，面试官给搞混了，给他打过去电话开始面试，然后把我给晾在这了。</p>\n<p>然后第一个面了一个多小时，到了 15:20才给我打电话，我就面了 20多分钟，结束了，结束后还跟我讲，你的测试开发相关知识比较薄弱啊，如果后面要面的话还需要再加强。我反问我是不是挂了，他说不是。。。。</p>\n<p>刚面完就看到官网流程更新，从简历评估到面试安排中了，反手一条邮件发过来，是测评。。应该是过了一面吧。。。</p>\n<p>内存池了解过吗？内存池如何解决内存碎片化问题？<br>如何保证线程安全？<br>Java 设计模式<br>C++常用数据结构<br>C++ lambda 表达式用过吗？<br>Python内存模型<br>TCP 的丢包问题如何解决？只有重传机制吗？<br>多个客户端访问一个服务端，如何实现？<br>如果要你自己实现一个缓存，你会怎么做？<br>处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？<br>A*算法了解过吗？<br>为什么要应聘游戏研发这个岗位<br>玩过哪些游戏？如何设计出一个游戏？</p>\n<p>给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。<br>针对于转账的高并发情况，在系统层面如何优化？<br>测试相关专业知识<br>如何使用测试保证一个模块的质量<br>测试用例的设计方法<br>优酷视频这个软件，从系统层面说一说如何进行测试<br>同步异步指的是什么<br>除了 Future 类还有其他实现异步调用的方法吗？<br>内存溢出和内存泄漏区别<br>SQL 注入<br>慢查询原因<br>常见网络模型<br>什么是跨域<br>跨域是为了防止什么</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h3 id=\"腾讯-WXG-移动客户端开发-实习\"><a href=\"#腾讯-WXG-移动客户端开发-实习\" class=\"headerlink\" title=\"腾讯 WXG - 移动客户端开发 实习\"></a>腾讯 WXG - 移动客户端开发 实习</h3><p>基础微信&amp;视频号团队<br>2024&#x2F;3&#x2F;19 40多分钟 一面</p>\n<ul>\n<li>自我介绍</li>\n<li>研究生成绩、本科生成绩</li>\n<li>研究生主要专业课</li>\n<li>Java - 强引用 弱引用</li>\n<li>Java - 垃圾回收机制</li>\n<li>TCP连接如何保成可靠性</li>\n<li>HTTP状态码</li>\n<li>拷打实习、项目</li>\n<li>你的开源线上实习主要都做的啥？</li>\n<li>你在开源实习过程中遇到的最难的是什么？</li>\n<li>你的单点登录系统大前端项目中 主要都做了什么东西？</li>\n<li>手撕代码<ul>\n<li>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</li>\n</ul>\n</li>\n<li>意向城市是上海，组内基本都在广州，这个你有什么问题吗？</li>\n<li>为什么会想要投移动客户端开发？</li>\n<li>除了在实习项目中，你还在有通过其他途径了解到移动客户端开发吗？</li>\n<li>反问：<ul>\n<li>面试官您觉得我的表现如何？</li>\n<li>组内日常工作？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"淘天集团-天猫技术部前端-实习\"><a href=\"#淘天集团-天猫技术部前端-实习\" class=\"headerlink\" title=\"淘天集团 - 天猫技术部前端 实习\"></a>淘天集团 - 天猫技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 14:00  70多分钟。。感觉好难。。。</p>\n<ul>\n<li>面试官介绍部门、自我介绍</li>\n<li>自己自我介绍</li>\n<li>RN和React的区别</li>\n<li>单点登录SSO原理</li>\n<li>PKCE</li>\n<li>Flutter RN区别，如何实现跨平台的</li>\n<li>项目中使用了unity，具体做了什么？</li>\n<li>具体讲2FA是什么</li>\n<li>sdk实现的原理过程是什么</li>\n<li>原型和原型链</li>\n<li>事件循环机制</li>\n<li>react 钩子hooks</li>\n<li>JS 函数是类吗？函数与类的区别在哪？</li>\n<li>反问：<ul>\n<li>前端知识很零散很杂，对此您有何看法？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"淘天集团-闲鱼技术部前端-实习\"><a href=\"#淘天集团-闲鱼技术部前端-实习\" class=\"headerlink\" title=\"淘天集团 - 闲鱼技术部前端 实习\"></a>淘天集团 - 闲鱼技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 19:00 40多分钟</p>\n<ul>\n<li>为什么想要走前端的这条路？对前端看法是怎么样的？</li>\n<li>Casbin线上实习做了什么</li>\n<li>以RN sdk为例子，讲一下sdk的工作流程，具体做了啥？</li>\n<li>大前端系统做了什么</li>\n<li>国家电网项目做了什么？</li>\n<li>JS this指针</li>\n<li>JS Promise函数</li>\n<li>JS ES6新特性有哪些</li>\n<li>JS 变量作用域</li>\n</ul>\n<h3 id=\"淘天集团-闲鱼技术部移动端开发-实习\"><a href=\"#淘天集团-闲鱼技术部移动端开发-实习\" class=\"headerlink\" title=\"淘天集团 - 闲鱼技术部移动端开发 实习\"></a>淘天集团 - 闲鱼技术部移动端开发 实习</h3><p>2024&#x2F;4&#x2F;1 16:00 20多分钟。。。 太菜了。。。多练啊。。。练习时长两天半还敢出来混啊卧槽了。</p>\n<ul>\n<li>自我介绍</li>\n<li>为什么想要走移动端开发这种道路。</li>\n<li>Casbin是做什么的？</li>\n<li>RN的原理</li>\n<li>单点登录SSO原理</li>\n<li>我看你简历上很多移动端开发的经历，可以讲讲吗？</li>\n<li>有学过什么计算机专业相关的专业课吗？</li>\n<li>常用的数据结构有什么？</li>\n<li>哈希表的结构</li>\n<li>排序算法的复杂度</li>\n<li>给一个数组，和一个数字，返回这个数字所在的index，有什么方法，复杂度是什么？</li>\n<li>给一个排好序的数组，且里面有很多重复的元素，这个时候如何返回一个指定数字的index？</li>\n<li>反问：<ul>\n<li>移动端开发如何去学习？</li>\n<li>移动客户端开发有什么学习的一些网站吗？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"腾讯-移动客户端开发-实习\"><a href=\"#腾讯-移动客户端开发-实习\" class=\"headerlink\" title=\"腾讯 - 移动客户端开发 实习\"></a>腾讯 - 移动客户端开发 实习</h3><p>2024&#x2F;4&#x2F;2 19:00 60多分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>印象最深刻的实习或者项目</li>\n<li>TCP、UDP区别</li>\n<li>TCP三次握手、四次挥手</li>\n<li>Java堆和栈区别</li>\n<li>进程线程区别</li>\n<li>OSI七层模型</li>\n<li>死锁</li>\n<li>常见Linux线程间的通信方式</li>\n<li>HTTP状态码</li>\n<li>Java为什么会堆栈溢出</li>\n<li>C++多态</li>\n<li>C++是面向过程的语言吗？</li>\n<li>i++和++i的区别</li>\n<li>302状态码是什么？</li>\n<li>Java同步关键字</li>\n<li>操作系统的虚拟内存</li>\n<li>成员变量和全局变量都存在哪里？</li>\n<li>Java最基础的类是什么类，有哪些方法？</li>\n<li>Java异常机制</li>\n<li>从增加删除元素的角度说数组和链表的区别</li>\n<li>分别向链表数组中插入元素的复杂度</li>\n<li>用户态和内核态</li>\n<li>手撕两道题：<ul>\n<li>单例模式，如何保证一个类只创建一次</li>\n<li>不含重复字符的最长子串的长度</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>移动客户端开发的学习路线是什么</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"携程-移动客户端开发iOS-Android\"><a href=\"#携程-移动客户端开发iOS-Android\" class=\"headerlink\" title=\"携程 - 移动客户端开发iOS&#x2F;Android\"></a>携程 - 移动客户端开发iOS&#x2F;Android</h3><p>2024&#x2F;4&#x2F;11 18:00 40分钟</p>\n<ul>\n<li>你在大前端项目里主要做了什么？</li>\n<li>react的原理</li>\n<li>Dom树</li>\n<li>js的闭包</li>\n<li>js的原型&amp;原型链</li>\n<li>C++的三大特性</li>\n<li>手撕两道题<ul>\n<li>有序链表合并</li>\n<li>二叉树前序遍历，然后转为数组</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>前端学习路线</li>\n<li>工作城市</li>\n</ul>\n</li>\n</ul>\n<p>其实后面面试官说，你做的项目跟我们现在做的很契合，然后第二天下午打了个电话没接到，应该是二面。后面假期过后就给我进人才池了，有点亏。。。</p>\n<h3 id=\"腾讯金融科技-测试开发工程师\"><a href=\"#腾讯金融科技-测试开发工程师\" class=\"headerlink\" title=\"腾讯金融科技 - 测试开发工程师\"></a>腾讯金融科技 - 测试开发工程师</h3><p>2024&#x2F;4&#x2F;19 17:00 40 分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>你最近认为做的最有难度最好的一次项目经历。</li>\n<li>开源项目</li>\n<li>你在开源实习和项目中使用的技术栈是什么，你学到了什么？</li>\n<li>国家电网项目</li>\n<li>手撕代码<ul>\n<li>最长重复子串</li>\n</ul>\n</li>\n<li>数据库</li>\n<li>Linux 系统</li>\n<li>反问：<ul>\n<li>测开的学习路线</li>\n<li>工作地点和时间，加班多吗？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"美团到店-后端开发工程师-实习生\"><a href=\"#美团到店-后端开发工程师-实习生\" class=\"headerlink\" title=\"美团到店 - 后端开发工程师 - 实习生\"></a>美团到店 - 后端开发工程师 - 实习生</h3><p>2024&#x2F;4&#x2F;24 14:00 一个小时</p>\n<ul>\n<li>面试流程、部门介绍</li>\n<li>自我介绍</li>\n<li>项目介绍</li>\n<li>2FA</li>\n<li>TOTP</li>\n<li>OTP</li>\n<li>PKCE</li>\n<li>Java 如何实现高并发</li>\n<li>高并发会出现什么问题，Java如何解决的？</li>\n<li>上下文切换开销</li>\n<li>Java虚拟机内存</li>\n<li>HashMap底层、java7和java8有什么改进</li>\n<li>ConcurrentHashMap如何实现多进程，java7和java8有什么改进</li>\n<li>Java有哪些锁。</li>\n<li>乐观锁悲观锁</li>\n<li>进程、线程区别</li>\n<li>mysql</li>\n<li>redis</li>\n<li>TCP、UDP区别</li>\n<li>三次握手四次挥手</li>\n<li>手撕代码： 二选一<ul>\n<li>反转部分链表</li>\n<li>旋转数组后查找元素</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>部门寻找实习生的标准是什么样的？</li>\n<li>实习生日常工作时间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"美团核心-软件开发工程师-前端-移动端方向-实习\"><a href=\"#美团核心-软件开发工程师-前端-移动端方向-实习\" class=\"headerlink\" title=\"美团核心 - 软件开发工程师-前端&amp;移动端方向 实习\"></a>美团核心 - 软件开发工程师-前端&amp;移动端方向 实习</h3><p>2024&#x2F;5&#x2F;15 19:00</p>\n<ul>\n<li>自我介绍</li>\n<li>介绍开源项目主要的工作</li>\n<li>在父元素中调整子元素位置你用哪种方式用的多</li>\n<li>position和display</li>\n<li>css 让如何让元素居中</li>\n<li>直接开始手撕：<ul>\n<li>实现二分查找，然后将while循环改成递归。</li>\n</ul>\n</li>\n<li>反问：<ul>\n<li>组内用了什么技术</li>\n<li>美团app用了什么框架？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"荣耀-通用软件开发工程师-实习\"><a href=\"#荣耀-通用软件开发工程师-实习\" class=\"headerlink\" title=\"荣耀 - 通用软件开发工程师 - 实习\"></a>荣耀 - 通用软件开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;21 16:30</p>\n<ul>\n<li>自我介绍</li>\n<li>开源项目介绍演示</li>\n<li>你还会点前端？会点前端挺好的</li>\n<li>讲讲国家电网项目</li>\n<li>Java中你用过哪些集合 介绍一下</li>\n<li>HashMap为什么不支持高并发</li>\n<li>有一个要执行的东西，丢到异步线程执行，执行完获取结果。如何实现？</li>\n<li>在开发中有遇到过高并发嘛？</li>\n<li>redis中有哪几种数据类型</li>\n<li>手撕：<ul>\n<li>LRU缓存，面试官口述，我没太听懂，之前也没做过这题，然后没撕出来。。。 到最后才跟我讲这是leetcode146，还说回去后好好看看。。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里国际-测试开发工程师-实习\"><a href=\"#阿里国际-测试开发工程师-实习\" class=\"headerlink\" title=\"阿里国际 - 测试开发工程师 - 实习\"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;22 11:00 40min</p>\n<ul>\n<li>部门介绍</li>\n<li>自我介绍</li>\n<li>开源项目是做什么？</li>\n<li>国家电网项目是做什么的？数据量多少？如何智能？</li>\n<li>TCP和UDP原理及区别</li>\n<li>如何将UDP变为TCP那样可靠</li>\n<li>用户态和和内核态</li>\n<li>数据库的事务</li>\n<li>反问：<ul>\n<li>测开学习路线</li>\n<li>面试的是测开，但是问的时候都没怎么问？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"饿了么-测开实习-一面\"><a href=\"#饿了么-测开实习-一面\" class=\"headerlink\" title=\"饿了么 - 测开实习 - 一面\"></a>饿了么 - 测开实习 - 一面</h3><p>2024&#x2F;6&#x2F;12 15:00 50 多分钟</p>\n<ul>\n<li>自我介绍</li>\n<li>我看你本科不是计算机的，为啥想走计算机这条道路</li>\n<li>介绍一下你所工作的开源社区</li>\n<li>印象最深的一个项目，难点与亮点</li>\n<li>国家电网项目，数据结构如何设计的</li>\n<li>mysql 两张表联合查询</li>\n<li>mysql 事务</li>\n<li>浏览器输入一个 url 发生了什么？</li>\n<li>http&#x2F;https区别</li>\n<li>SSL 加密了解过吗？</li>\n<li>Java 数据类型</li>\n<li>手撕：<ul>\n<li>Java 单例模式</li>\n<li>删除链表的一个节点</li>\n</ul>\n</li>\n<li>对于上述删除链表节点的题，围绕这个点做功能测试如何设计测试用例？</li>\n<li>饿了么外面搜索框功能测试，你该测试什么内容？</li>\n<li>对于现在大模型盛行的时代，你是如何看待大模型的？有用到过没？谈谈你的理解。</li>\n<li>反问：<ul>\n<li>最快什么时候入职</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里国际-测试开发工程师-实习-1\"><a href=\"#阿里国际-测试开发工程师-实习-1\" class=\"headerlink\" title=\"阿里国际 - 测试开发工程师 - 实习\"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;17，15:00 电话面，20 多分钟</p>\n<ul>\n<li>为什么会选择测开这个岗位</li>\n<li>你对测开具体哪个部分感兴趣？</li>\n<li>自我介绍</li>\n<li>你在开源项目中印象最深的一个项目</li>\n<li>国家电网项目介绍</li>\n<li>学生生涯过程中遇到的一些挫折和应对策略</li>\n<li>电商满减优惠券测试用例设计</li>\n<li>反问：<ul>\n<li>如果面试通过的话最快入职时间</li>\n<li>一面二面间隔多久</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"网易互娱-游戏研发工程师-实习\"><a href=\"#网易互娱-游戏研发工程师-实习\" class=\"headerlink\" title=\"网易互娱 - 游戏研发工程师 - 实习\"></a>网易互娱 - 游戏研发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;25 55 min</p>\n<ul>\n<li>自我介绍</li>\n<li>开源实习&#x2F;开源项目介绍</li>\n<li>国家电网项目介绍</li>\n<li>HashMap底层</li>\n<li>HashMap线程安全吗？线程安全用什么？</li>\n<li>ArrayList底层，线程安全吗？线程安全用什么？</li>\n<li>死锁的产生，如何避免？</li>\n<li>线程池的作用</li>\n<li>内存池了解过吗？内存池如何解决内存碎片化问题？</li>\n<li>LRU了解过吗？用什么数据结构实现 LRU？</li>\n<li>如何保证线程安全？</li>\n<li>Java 垃圾回收机制</li>\n<li>Java设计模式用过吗？</li>\n<li>C++、Python语言使用过吗？</li>\n<li>C++常用数据结构</li>\n<li>C++ lambda 表达式用过吗？</li>\n<li>Python内存模型</li>\n<li>浏览器输入URL到展示的过程</li>\n<li>TCP&#x2F;UDP 区别</li>\n<li>TCP 属于哪一层的协议？</li>\n<li>应用层协议有哪些？</li>\n<li>我怎么感觉你研究生什么都没做？有什么科研成果吗？</li>\n<li>具体讲讲小论文的创新点</li>\n<li>TCP 如何保证连接可靠性</li>\n<li>TCP 的丢包问题如何解决？只有重传机制吗？</li>\n<li>多个客户端访问一个服务端，如何实现？</li>\n<li>看过Redis源码吗？</li>\n<li>Redis主要是做什么的？</li>\n<li>如果要你自己实现一个缓存，你会怎么做？</li>\n<li>处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？</li>\n<li>A*算法了解过吗？</li>\n<li>为什么要应聘游戏研发这个岗位</li>\n<li>玩过哪些游戏？如何设计出一个游戏？</li>\n<li>反问：<ul>\n<li>会给实习生分配什么样的工作？竟然说这不是你该考虑的事情。。。。还建议我如果走游戏研发的话要多学学C++。。。完犊子喽。</li>\n<li>前面 40 分钟都是一个面试官问，到后面我才知道原来有俩面试官。。。第二个面试官有点凶神恶煞的。。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"饿了么-测试开发实习生-二面\"><a href=\"#饿了么-测试开发实习生-二面\" class=\"headerlink\" title=\"饿了么- 测试开发实习生 - 二面\"></a>饿了么- 测试开发实习生 - 二面</h3><p>2024&#x2F;6&#x2F;25 14:00 一个小时</p>\n<ul>\n<li>手撕代码：<ul>\n<li>写一个实现rm -rf path 命令功能的函数</li>\n</ul>\n</li>\n<li>针对上面写的函数，写测试用例</li>\n<li>上面函数在Linux 系统下使用会有什么问题？</li>\n<li>Linux用过吗</li>\n<li>给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。</li>\n<li>支部宝转账测试用例</li>\n<li>针对于转账的高并发情况，在系统层面如何优化？</li>\n<li>数据库事务了解吗？</li>\n<li>你刚说转账是一系列操作，具体指？</li>\n<li>数据库索引了解吗？有什么优缺点</li>\n<li>Java反射</li>\n<li>Java中除了空指针异常，还有有哪些异常？</li>\n<li>自我介绍</li>\n<li>挑一个项目或者实习介绍一下你的工作内容及成就</li>\n<li>你的项目中有用Java写的没？</li>\n<li>迄今为止遇到过得最大困难是什么？怎么解决的？</li>\n<li>我看你本科专业不是计算机的，还是保研的，保研不是都保本专业吗，为什么想转专业？</li>\n<li>本科专业排名</li>\n<li>跨度很大，有系统的学习过相关课程和编程语言吗？</li>\n<li>转专业后学习过程中，有遇到过困难吗？</li>\n<li>研究生研究方向？</li>\n<li>项目和科研不太相关，这是怎么回事？</li>\n<li>智力题：<ul>\n<li>8个外形一样的球，其中有一个偏重，求如何只使用两次测量就找到重的球。</li>\n</ul>\n</li>\n<li>谈谈未来职业规划以及为什么要做测开？为什么不选算法岗和开发岗。</li>\n<li>反问：<ul>\n<li>测试开发系统学习路线</li>\n<li>最快什么时候入职</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"阿里大文娱-优酷测开-实习生一面\"><a href=\"#阿里大文娱-优酷测开-实习生一面\" class=\"headerlink\" title=\"阿里大文娱 - 优酷测开 - 实习生一面\"></a>阿里大文娱 - 优酷测开 - 实习生一面</h3><p>2024&#x2F;6&#x2F;26 14:00 20多分钟电话面</p>\n<ul>\n<li>自我介绍</li>\n<li>我看你是软件工程专业，而且项目经历也是开发较多，为什么要投测试开发的岗位</li>\n<li>你对测试相关知识有了解吗，介绍一下</li>\n<li>你刚说的黑盒测试和白盒测试，可不可以只有黑盒测试或者白盒测试？</li>\n<li>你刚介绍的那个模块，你如何保证它的质量</li>\n<li>写过测试用例吗？</li>\n<li>测试用例的一些设计方法</li>\n<li>优酷视频这个软件，从系统层面说一说如何进行测试</li>\n<li>你理解的 Java线程安全指的是什么？</li>\n<li>如何实现线程安全</li>\n<li>同步和异步指的是什么？</li>\n<li>如何实现异步调用？</li>\n<li>除了 Future 类还有其他实现异步调用的方法吗？</li>\n<li>内存溢出和内存泄漏区别</li>\n<li>了解 SQL注入吗？</li>\n<li>什么是事务</li>\n<li>慢查询的原因</li>\n<li>常见网络模型？</li>\n<li>你还会点前端是吧，什么是跨域？</li>\n<li>跨域是为了防止什么？</li>\n<li>反问：<ul>\n<li>目前部门还缺人吗</li>\n<li>如果面试通过了的话，最快什么时候入职？</li>\n<li>一共有几轮面试</li>\n<li>官网流程快不快？</li>\n</ul>\n</li>\n</ul>\n<p>其实面试体验挺不佳的，本来跟面试官约的两点面嘛，然后加了钉钉，之后到 14:10还没收到钉钉电话，我去问加钉钉那个人，结果他不是面试官，只是联系人，他去帮我问，原来是有好几个候选人，有一个候选人也姓陈，面试官给搞混了，给他打过去电话开始面试，然后把我给晾在这了。</p>\n<p>然后第一个面了一个多小时，到了 15:20才给我打电话，我就面了 20多分钟，结束了，结束后还跟我讲，你的测试开发相关知识比较薄弱啊，如果后面要面的话还需要再加强。我反问我是不是挂了，他说不是。。。。</p>\n<p>刚面完就看到官网流程更新，从简历评估到面试安排中了，反手一条邮件发过来，是测评。。应该是过了一面吧。。。</p>\n<p>内存池了解过吗？内存池如何解决内存碎片化问题？<br>如何保证线程安全？<br>Java 设计模式<br>C++常用数据结构<br>C++ lambda 表达式用过吗？<br>Python内存模型<br>TCP 的丢包问题如何解决？只有重传机制吗？<br>多个客户端访问一个服务端，如何实现？<br>如果要你自己实现一个缓存，你会怎么做？<br>处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？<br>A*算法了解过吗？<br>为什么要应聘游戏研发这个岗位<br>玩过哪些游戏？如何设计出一个游戏？</p>\n<p>给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。<br>针对于转账的高并发情况，在系统层面如何优化？<br>测试相关专业知识<br>如何使用测试保证一个模块的质量<br>测试用例的设计方法<br>优酷视频这个软件，从系统层面说一说如何进行测试<br>同步异步指的是什么<br>除了 Future 类还有其他实现异步调用的方法吗？<br>内存溢出和内存泄漏区别<br>SQL 注入<br>慢查询原因<br>常见网络模型<br>什么是跨域<br>跨域是为了防止什么</p>\n"},{"title":"计算机基础","keywords":["面经"],"description":"计算机网络和操作系统面经","abbrlink":17770,"date":"2024-06-12T14:47:24.000Z","updated":"2024-06-25T08:46:24.000Z","top_img":"https://s2.loli.net/2024/06/27/k28sUQb3XqIK9wC.png","comments":1,"cover":"https://s2.loli.net/2024/06/27/7o6ubNCe3GgkqMF.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n\n### A*算法\n\n\n\n\n\n## 智力题\n\n### 8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\n为了在只使用两次测量的情况下找到8个球中偏重的那个球，可以采用以下方法：\n\n- 将8个球分成3组：\n  - 第一组：A、B、C\n  - 第二组：D、E、F\n  - 第三组：G、H\n\n- 第一次测量：\n  - 将第一组(A、B、C)放在天平的左边，第二组(D、E、F)放在天平的右边。\n\n  可能的结果有三种：\n  - 左边重(A、B、C中有一个是重球)\n  - 右边重(D、E、F中有一个是重球)\n  - 两边一样重(G、H中有一个是重球)\n\n- 第二次测量：\n  - 如果第一次测量左边重：从A、B、C中任选两个球进行测量，例如A和B。\n    - 如果A和B重量相等，则重球是C。\n    - 如果A和B不等，则重球是较重的那个。\n  - 如果第一次测量右边重：从D、E、F中任选两个球进行测量，例如D和E。\n    - 如果D和E重量相等，则重球是F。\n    - 如果D和E不等，则重球是较重的那个。\n  - 如果第一次测量两边一样重：对G和H进行测量。\n    - 如果G和H重量相等，则重球不存在(但由于题意重球必存在，所以这个情况不会出现)。\n    - 如果G和H不等，则重球是较重的那个。\n\n通过这种方法，可以在两次测量内准确找到8个球中偏重的那个球。\n\n\n\n## 网络\n### OSI七层模型\n- 应用层：为计算机提供服务\n- 表示层：数据处理(编码、解码、加密解密、压缩解压缩)\n- 会话层：管理(建立、维护、重连)应用程序之间的会话\n- 传输层：为两台主机进程之间的通信提供通用的数据传输服务\n- 网络层：转发、路由和寻址(决定数据在网络中的游走路径)\n- 数据链路层：帧编码和误差纠正控制\n- 物理层：透明地传送比特流传输\n\n### TCP/IP四层模型\n- 应用层(应用层、表示层、会话层)\n- 传输层\n- 网络层\n- 网络接口层(数据链路层、物理层)\n\n### 为什么网络要分层\n复杂系统需要分层，每层专注于一类事情。主要有三个原因：\n- 各层之间相互独立，不需要关注其他层如何实现的，只需知道如何调用下层的接口。\n- 提高了灵活性和可替换性。每层可使用最合适的技术实现，只需保证提供的功能及接口没改变就行。这也与平时系统开发高内聚、低耦合的原则契合。\n- 将复杂的网络问题分解为较小的、清晰的小问题来处理解决，使得计算机网络系统易于设计和维护。\n\n### 常见网络协议\n**应用层协议**\n- HTTP(Hypertext Transfer Protocol，超文本传输协议)：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。\n- SMTP(Simple Mail Transfer Protocol，简单邮件发送协议)：基于 TCP 协议，是一种用于发送电子邮件的协议。\n- POP3/IMAP(邮件接收协议)：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。\n- FTP(File Transfer Protocol，文件传输协议) : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。(不安全，更安全可以用SFTP)\n- Telnet(远程登陆协议)：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。\n- SSH(Secure Shell Protocol，安全的网络传输协议)：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。\n- RTP(Real-time Transport Protocol，实时传输协议)：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\n- DNS(Domain Name System，域名管理系统): 基于 UDP 协议，用于解决域名和 IP 地址的映射问题，端口为 53。\n\n**传输层协议**\n- TCP(Transmission Control Protocol，传输控制协议 )：提供 面向连接 的，可靠 的数据传输服务。\n- UDP(User Datagram Protocol，用户数据协议)：提供 无连接 的，尽最大努力 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n**网络层协议**\n- IP(Internet Protocol，网际协议)：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。(IPv4、IPv6)\n- ARP(Address Resolution Protocol，地址解析协议)：ARP 协议解决的是网络层地址和链路层地址之间的转换问题(IP 地址转 MAC 地址)。\n- ICMP(Internet Control Message Protocol，互联网控制报文协议)：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。\n- NAT(Network Address Translation，网络地址转换协议)：用于内部网到外部网的地址转换过程中。\n- OSPF(Open Shortest Path First，开放式最短路径优先)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\n- RIP(Routing Information Protocol，路由信息协议)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\n- BGP(Border Gateway Protocol，边界网关协议)：一种用来在路由选择域之间交换网络层可达性信息(Network Layer Reachability Information，NLRI)的路由选择协议，具有高度的灵活性和可扩展性。\n\n### 浏览器输入URL到页面展示的过程\n1. 在浏览器中输入指定网页的 URL。\n2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。\n3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。\n4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。\n5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。\n6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL(如图片、CSS、JS 等)，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。\n7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。\n\n### URL的组成\nURL(Uniform Resource Locators)，即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。\n\n![URL的组成](./image/Computer-Basic/URL-parts.png)\n- 协议：用于指定访问资源的协议，如 http、https、ftp(文件传输)、file(本地文件)、mailto(邮件)、telnet(远程登录)等。\n- 域名/IP：用于指定资源所在的主机名或 IP 地址。\n- 端口号：用于指定访问资源的端口号，HTTP默认端口号是 80，HTTPS默认端口号是 443。\n- 资源路径：从第一个/开始，表示从服务器上根目录开始进行索引到的文件路径。\n- 参数：浏览器在向服务器提交请求时，在 URL 中附带着参数会提取这些参数。参数采用键值对的形式`key=value`，每一个键值对使用`&`隔开。\n- 锚点：锚点就是在要访问的页面上的一个锚点，可以直接跳转到指定的位置。在 URL 中，锚点以`#`开头，并且不会作为请求的一部分发送给服务端。\n\n### DNS域名系统\nDNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议，解决的是域名和 IP 地址的映射问题。\n\n![DNS解析过程](./image/Computer-Basic/dns-overview.png)\n\n浏览器在本地维护一个`hosts`列表，用户访问网址时，先查看要访问的域名是否在`hosts`列表中，如果有就直接提取对应的 IP 地址记录，如果没有就使用 DNS 服务器获取域名和 IP 地址的映射。\n\n**DNS服务器**\nDNS 服务器自底向上几个层级：\n- 根域名服务器：负责管理顶级域名服务器的 IP 地址。世界上有 600多个根服务器，但只有 13 个 IP 地址。为了提高 DNS 的可靠性、安全性和性能，每个IP地址对应多个服务器。\n- 顶级域 DNS 服务器(TLD 服务器)：负责管理各个顶级域名服务器的 IP 地址。如 `.com`、`.cn`、`.org`、`.net` 等。\n- 权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，如baidu.com 的 DNS 服务器，负责管理该域名下的所有子域名。\n- 本地 DNS 服务器：每个 ISP(互联网服务提供商)都有一个自己的本地 DNS 服务器。\n\n**DNS工作流程**\n主机`cis.poly.edu`想知道`gaia.cs.umass.edu`的 IP 地址。\n![迭代式查询](./image/Computer-Basic/DNS-process.png)\n![递归式查询](./image/Computer-Basic/DNS-process2.png)\n\n### HTTP状态码\n| 状态码 | 类别                           | 原因短语          |\n|-----|------------------------------|---------------|\n| 1XX | Informational(信息性状态码)        | 接收的请求正在处理     |\n| 2XX | Success(成功状态码)               | 请求正常处理完毕      |\n| 3XX | Redirection(重定向状态码)          | 需要进行附加操作以完成请求 |\n| 4XX | Client Error(**_客户端错误状态码_**) | 服务器无法处理请求     |\n| 5XX | Server Error(**_服务器错误状态码_**) | 服务器处理请求出错     |\n\n- `200 OK`：请求被成功处理。如发送查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。\n- `201 Created`：请求被成功处理并且在服务端创建了一个新的资源。如通过 POST 请求创建一个新的用户。\n- `202 Accepted`：服务端已接收到了请求，但还未处理。\n- `204 No Content`：服务端已经成功处理了请求，但是没有返回任何内容。\n\n- `301 Moved Permanently`：资源被永久重定向了。如网站的网址更换了。\n- `302 Found`：资源被临时重定向了。如网站暂时关闭，重定向到一个临时的页面。\n\n- `400 Bad Request`：发送的 HTTP 请求存在问题。如请求参数不合法、请求方法错误。\n- `401 Unauthorized`：未认证却请求需要认证之后才能访问的资源。\n- `403 Forbidden`：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。\n- `404 Not Found`：请求的资源未在服务端找到。如请求某个用户的信息，服务端并没有找到指定的用户。\n- `409 Conflict`：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。\n\n- `500 Internal Server Error`：服务端出问题了(通常是服务端出 Bug 了)。如服务端处理请求的时候突然抛出异常，但异常并未在服务端被正确处理。\n- `502 Bad Gateway`：网关将请求转发到服务端，但服务端返回的却是一个错误的响应。\n\n### HTTP/HTTPS区别\n**基本概念**\n- HTTP协议：用来规范超文本的传输，主要用来是规范浏览器和服务器端的行为。扩展性强、速度快、跨平台支持性好。\n- HTTPS协议：HTTPS基于HTTP协议，并使用 SSL/TLS 协议用作加密和安全认证，其更安全可靠。保密性好、信任度高。\n\n> HTTP和HTTPS协议都需要三次握手建立连接、四次挥手断开连接。\n\n**HTTP和HTTPS的区别**\n- HTTP是明文传输，HTTPS使用SSL进行加密加密传输，更安全可靠。\n- HTTP默认端口是80，HTTPS默认端口是443。\n- HTTP连接简单，无状态，HTTPS握手阶段比较费时，所以HTTP比HTTPS快。\n\n**HTTP通信过程**\nHTTP 是应用层协议，它以 TCP(传输层)作为底层协议，通信过程主要如下：\n- 服务器在 80 端口等待客户的请求。\n- 浏览器发起到服务器的 TCP 连接(创建套接字 Socket)。\n- 服务器接收来自浏览器的 TCP 连接。\n- 浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息。\n- 关闭 TCP 连接。\n\n### SSL/TSL协议加密原理\nHTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。\n\nSSL/TLS 的加密的原理是非对称加密和对称加密的配合使用。对称加密用来加密数据，并生成唯一私有密钥 k，非对称加密用来加密k。通信双方(Client、Server)只需要一次非对称加密，交换对称加密的密钥k，在之后的信息通信中，使用绝对安全的密钥k，对信息进行对称加密，即可保证传输消息的保密性。\n- 非对称加密采用两个密钥：公钥、私钥。在通信时，私钥仅由Server保存，公钥由Client所知晓。公钥用于加密数据，私钥用于解密数据。\n- 对称加密中双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密。\n\n**公钥传输隐患**\n假设存在攻击者 A，其对应服务器为AServer，A发送给Client一个假包，假装是Server公钥，其实是诱饵服务器 AServer的公钥，Client收到后误以为是 Server的公钥，Client后续使用AServer公钥加密密钥k，然后在公开信道传输，那么攻击者 A可以捕获加密的包，然后用AServer的私钥解密，得到密钥k，这样攻击者 A 就可以解密Client和Server之间的通信。\n\n**数字证书**\n为了解决这个问题，需要使用数字证书，数字证书是由权威机构(CA，Certificate Authority)颁发的，用于证明公钥的合法性。具体流程如下：\n假设有服务器 Server，CA 机构，客户端 Client。\n1. Server信任 CA，CA也知道 Server公钥，CA首先为 Server颁发证书(包含 Server公钥)，采用散列技术为证书生成一个摘要，然后使用 CA私钥对摘要进行加密，生成数字签名。\n2. Server获得 CA颁发的证书和数字签名，并在 Client请求时，将证书和数字签名一并发送给 Client。\n3. Client信任 CA并知晓 CA公钥。Client在收到 Server的证书和数字签名时，使用 CA公钥解密数字签名，得到摘要，然后使用相同的散列技术为证书生成摘要。\n4. Client对比两个摘要是否一致，如果一致则证明证书(包含 Server公钥)是真实的，可以使用 Server公钥加密密钥k，然后在公开信道传输。\n\n### HTTP无状态如何保存用户状态\n可以使用 Session 机制来保存用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)。\n\n服务端可以使用内存和数据库保存Session，Session 跟踪是通过在客户端的 Cookie 中存放 Session ID 来实现的。如果 Cookie被禁用可以利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。\n\n### URI/URL区别\n- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\n- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位 这个资源。\n\nURI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\n\n### Session/Cookie区别\n- 存储位置不同：Cookie 存储在客户端，Session 存储在服务端。\n- 存储容量不同：单个Cookie保存的数据<=4KB，一个站点最多保存20个Cookie。Session 存储在服务端，一般没有存储容量限制，但考虑服务器性能，一般会设置 Session 的有效期和存储容量。\n- 安全性不同：Cookie 存储在客户端，容易被篡改，不安全。Session 存储在服务端，相对安全。\n- 生命周期不同：Cookie 有过期时间，可以设置长期有效的 Cookie。Session 一般保存在内存中，会话结束后会被销毁。\n- 作用范围不同：Cookie 的作用范围是整个域名，Session 的作用范围是当前会话。\n- 传输方式不同：Cookie 会随着 HTTP 请求一起发送到服务端，Session 保存在服务端，客户端只会收到 Session ID。\n\n### GET/POST区别\n- GET 用于获取或查询资源，POST 用于创建或修改资源。\n- GET 请求是幂等的，即多次重复执行不会改变资源的状态，POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。\n- GET 请求参数会附加在 URL 后面，POST 请求参数会放在请求体(`body`)中。\n- GET 请求的URL长度受到浏览器和服务器的限制，POST 请求的 `body`大小则没有明确的限制。\n- 由于 GET 请求是幂等的，可以被缓存，而POST 请求是不幂等的，不适合被缓存。\n- GET 请求的安全性较差，参数会暴露在 URL 中，POST 请求的安全性较好，参数在请求体中，不会暴露在 URL 中。\n\n### WebSocket\nWebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。\n\nWebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\nWebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。\n\n### WebSocket/HTTP区别\n- WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。\n- WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。\n- WebSocket 使用 `ws://` 或 `wss://`作为协议前缀，HTTP 使用 `http://` 或 `https://`作为协议前缀。\n- WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。\n- WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。\n\n### WebSocket工作流程\n1. 客户端向服务器发起一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key`等字段，表示要求升级协议为 WebSocket。\n2. 服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复`HTTP 101`状态码，响应头中包含`Upgrade: websocket`和`Sec-WebSocket-Accept:xxx`等字段，表示升级成功。\n3. 现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。\n4. 关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。\n\n### PING命令原理\nPING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\n```bash\nping -c 4 www.baidu.com\nPING www.baidu.com (36.155.132.3): 56 data bytes\n64 bytes from 36.155.132.3: icmp_seq=0 ttl=49 time=8.890 ms\n64 bytes from 36.155.132.3: icmp_seq=1 ttl=49 time=8.874 ms\n64 bytes from 36.155.132.3: icmp_seq=2 ttl=49 time=9.136 ms\n64 bytes from 36.155.132.3: icmp_seq=3 ttl=49 time=9.400 ms\n\n--- www.baidu.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 8.874/9.075/9.400/0.214 ms\n```\n输出由以下几部分组成：\n- ICMP Echo Request(请求报文)信息：序列号、TTL(Time to Live)值。\n- 目标主机的域名或 IP 地址：输出结果的第一行。\n- 往返时间(RTT，Round-Trip Time)：从发送 ICMP Echo Request(请求报文)到接收到 ICMP Echo Reply(响应报文)的总时间，用来衡量网络连接的延迟。\n- 统计结果(Statistics)：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值。\n\n如果PING目标主机无法正确响应，则说明网络连通性出现问题。\n\nPING命令的原理是基于 ICMP 协议，通过发送 ICMP Echo Request(请求报文)到目标主机，目标主机收到请求后，会返回 ICMP Echo Reply(响应报文)给发送方，从而实现网络连通性的测试。\n\n### TCP、UDP区别\n二者都是常见的传输层协议。\n- TCP(Transmission Control Protocol，传输控制协议 )：提供 **面向连接** 的，**可靠** 的数据传输服务。\n- UDP(User Datagram Protocol，用户数据协议)：提供 **无连接** 的，**尽最大努力** 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n区别总结：\n1. TCP面向连接(三次握手四次挥手)，UDP是无连接的，即发送数据之前不需要建立连接\n2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n3. TCP面向字节流，TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如实时视频会议)\n4. TCP只支持点对点通信，UDP支持一对一，一对多，多对一和多对多的交互通信\n5. TCP首部开销20字节，UDP的首部开销小，只有8个字节\n6. TCP通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n原文链接：https://blog.csdn.net/Li_Ning_/article/details/52117463\n\n### TCP/UDP应用场景\nhttps://blog.csdn.net/qq_44273429/article/details/131375961\n\n由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：\n- 文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。\n- 网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。\n- 电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。\n- 远程登录：TCP提供了稳定的连接，适合远程登录操作。\n- 数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。\n\n由于UDP具有低延迟和高效性的特点，它适用于以下场景：\n- 视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。\n- 实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。\n- DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。\n- 实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等\n\n### 如何将UDP变为将TCP那样可靠\n要使 UDP 像 TCP 那样可靠，需要在应用层实现类似 TCP 的功能。以下是一些常见的方法和步骤：\n1. 数据包确认机制(`ACK`)\n   每当接收方收到一个数据包时，它会发送一个确认(`ACK`)回给发送方。发送方在发送数据包后会等待 `ACK`，如果在一定时间内没有收到 `ACK`，则会重传该数据包。\n2. 序列号\n   在每个数据包中添加一个序列号，以便接收方可以按顺序重组数据包，并检测丢失或重复的数据包。\n3. 超时和重传\n   发送方在发送每个数据包后启动一个定时器。如果在规定时间内没有收到 `ACK`，则会重传该数据包。\n4. 滑动窗口\n   使用滑动窗口协议来控制数据包的流动。发送方可以在等待 `ACK` 的同时继续发送多个数据包，从而提高传输效率。\n5. 校验和\n   在数据包中包含校验和，以检测数据包在传输过程中是否被损坏。接收方会检查校验和，并丢弃任何损坏的数据包。\n6. 流量控制\n   发送方和接收方协商一个窗口大小，以确保发送方不会超过接收方的处理能力。\n\n### 三次握手四次挥手\n建立 TCP 连接需要“三次握手”，缺一不可：\n- 一次握手:客户端发送带有 `SYN`(SEQ=x) 标志的数据包 `->` 服务端，然后客户端进入 `SYN_SEND` 状态，等待服务端的确认；\n- 二次握手:服务端发送带有 `SYN+ACK`(SEQ=y,ACK=x+1) 标志的数据包 `–>` 客户端，然后服务端进入 `SYN_RECV` 状态；\n- 三次握手:客户端发送带有 `ACK`(ACK=y+1) 标志的数据包 `–>` 服务端，然后客户端和服务端都进入`ESTABLISHED`状态，完成 TCP 三次握手。\n\n注意，连接建立后，客户端和服务端都可以发送数据。\n\n断开 TCP 连接则需要“四次挥手”，缺一不可：\n- 第一次挥手：客户端发送一个 `FIN`(SEQ=x) 标志的数据包 `->` 服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 `FIN-WAIT-1` 状态。\n- 第二次挥手：服务端收到`FIN`标志的数据包，它发送一个 `ACK`(ACK=x+1)标志的数据包 `->` 客户端。然后服务端进入 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-2`状态。\n- 第三次挥手：服务端发送一个 `FIN` (SEQ=y)标志的数据包 `->` 客户端，请求关闭连接，然后服务端进入 `LAST-ACK` 状态。\n- 第四次挥手：客户端发送 `ACK`(ACK=y+1)标志的数据包 `->` 服务端，然后客户端进入`TIME-WAIT`状态，服务端在收到 `ACK` (ACK=y+1)标志的数据包后进入 `CLOSE` 状态。此时如果客户端等待 `2MSL` 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。\n\nTCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n![三次握手](./image/Computer-Basic/tcp-shakes-hands-three-times.png)\n\n![四次挥手](./image/Computer-Basic/tcp-waves-four-times.png)\n\n### 半连接队列/全连接队列\n在三次握手中，Linux 内核会维护两个队列管理连接请求：\n- 半连接队列(也称 SYN Queue)：当服务端收到客户端的 `SYN` 请求时，此时双方还没有完全建立连接，服务端会把半连接状态的连接放在半连接队列。\n- 全连接队列(也称 Accept Queue)：当服务端收到客户端的 `ACK` 请求时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。若未收到 `ACK` 请求，会进行重传，若超过最大重传次数，系统将从半连接队列中删除该连接信息。\n\n两队列的存在是为了处理并发请求，确保服务端能够有效地管理新的连接请求。\n\n### 为什么要三次握手\n三次握手为的是确认双方收发功能都正常，缺一不可。\n- 第一次握手：Client 无法确认任何信息；Server 确认了：对方发送正常，自己接收正常\n- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n\n### 第二次握手为何传回ACK和SYN\n**为什么传回ACK**\n第二次握手中，服务端传回 `ACK` 是为了确认接收到客户端的 `SYN` 报文。\n**为什么传回SYN**\n在第一次握手中，客户端发送 `SYN`包 是为了建立客户端到服务端的连接，然而 TCP 连接是双向的，服务端到客户端也需要建立连接，所以服务端在第二次握手中向客户端发送 `SYN`包，以建立服务端到客户端的连接。\n\n同时发送 `SYN` 包和 `ACK`包，服务器能够在一个报文中同时完成这两个操作，从而减少报文的数量，加快连接建立的效率。\n\n### 三次握手中可以携带数据吗\n允许在第三次发送 `ACK` 的时候携带数据，但是不建议这样做，因为在第三次握手时，服务端还没有确认客户端的 `ACK` 包，可能会导致数据丢失。\n\n### 为什么要四次挥手\n- 确保数据传输的完整性和可靠性：在任何一方关闭连接之前，确保所有数据都已正确接收和处理。\n- 保证双向关闭的确认：TCP 是全双工通信，每一方都需要确认对方的关闭请求，以避免数据丢失和连接的不正常终止。\n- 避免半开连接：确保在关闭过程中，没有未完成的数据传输或者遗留的数据包。\n- 保证连接的有序终止：TCP 是全双工的，每一方都需要单独关闭自己的发送和接收通道，因此需要四步来完成这一过程。\n\n四次握手虽然复杂，但却能够确保连接的稳定、可靠和有序终止。\n\n### 为何不能把服务端发送的ACK和FIN合并变成三次挥手\n因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 `ACK`，表示接收到了断开连接的请求。等到数据发完之后再发 `FIN`，断开服务端到客户端的数据传送。\n\n### 如果第二次挥手客户端未收到服务端发送的ACK会怎样\n客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n\n### 为什么第四次握手客户端需等待2*MSL\n第四次挥手时，客户端发送服务端的 `ACK` 有可能丢失，如果服务端没收到 `ACK` 的话，服务端就会重发 `FIN`，如果客户端在 `2*MSL` 的时间内收到了 `FIN`，就会重新发送 `ACK` 并再次等待 `2MSL`，防止 Server 没有收到 `ACK` 而不断重发 `FIN`。\n\n> `MSL`(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，`2MSL` 就是一个发送和一个回复所需的最大时间。如果直到 `2MSL`，Client 都没有再次收到 `FIN`，那么 Client 推断 `ACK` 已经被成功接收，则结束 `TCP` 连接。\n\n### TCP如何保证连接可靠性\n1. 基于数据块传输：数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。\n2. 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，给每个包一个序列号，这使得能够将接收到的数据根据序列号排序，去掉重复序列号的数据就可以实现数据包去重。\n3. 校验和：TCP 有端到端的校验和机制，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃此报文段和不确认收到此报文段。\n4. 重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。\n5. TCP 连接每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。\n6. 拥塞控制：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候会考虑网络的拥塞程度，由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。\n\n### TCP如何实现流量控制\nTCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n\n### 为什么需要流量控制\n因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果处理不过来，会先将数据放入接收缓冲区(Receiving Buffers) 里。如果接收缓冲区满了，就只能把再收到的数据包丢掉。而丢包会浪费网络资源。因此要让接收方与发送方处于一种动态平衡。\n\n### TCP如何实现拥塞控制\nTCP 发送发维持一个 拥塞窗口(`cwnd`) 的状态变量。采用了四种算法，即 `慢开始`、 `拥塞避免`、`快重传` 和 `快恢复`。\n- 慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。`cwnd` 初始值为 1，每经过一个传播轮次就加倍。\n- 拥塞避免：拥塞避免算法的思路是让拥塞窗口 `cwnd` 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 `cwnd` 加 1.\n- 快速重传和恢复(fast retransmit and recovery，FRR)能快速恢复丢失的数据包。\n\n### ARQ协议\n自动重传请求(Automatic Repeat-reQuest，ARQ)是数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息`ACK`，就会重新发送，直到收到确认或者重试超过一定的次数。\n\n### 停止等待ARQ协议\n停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复 `ACK`)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\n\n### 连续ARQ协议\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n- 优点：信道利用率高，容易实现。\n- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。\n\n### 超时重传机制如何实现\n发送方发送完数据后，会启动一个定时器，等待接收端确认收到这个报文段。接收端成功收到报文段的话会发送会 `ACK`包，如果发送端在合理的往返时延(RTT)内未收到确认信息，那数据包就被标记为已丢失并进行重传。\n\n超时重传时间 RTO(Retransmission Time Out)直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此 RTO 应根据网络的实际状况，动态地进行调整。\n\n超时重传时间不能直接使用往返时延RTT，因为其值会随着网络波动而变化。\n\n### IP地址\nIP地址是每个连入互联网的设备或域(如计算机、服务器、路由器等)都被分配的一个唯一标识符。\n\n### IP地址过滤\nIP 地址过滤(IP Address Filtering)就是限制或阻止特定 IP 地址或 IP 地址范围的访问。如：有一个图片服务突然被某一个 IP 地址攻击，那就可以禁止这个 IP 地址访问图片服务。\n\n### IPv4/IPv6区别\nIPv4(Internet Protocol version 4)是四组由点分隔的数字，例如：`123.89.46.72`。IPv4 使用 4Bytes 32 位(bits)地址作为其 Internet 地址，共有约 42 亿(2^32)个可用 IP 地址。不够用。\n\n为了解决 IP 地址耗尽的问题，采用具有更大地址空间的新版本 IP 协议 - IPv6(Internet Protocol version 6)。该格式使用由单或双冒号分隔的一组数字和字母，如：`2001:0db8:85a3:0000:0000:8a2e:0370:7334`。IPv6 使用 128 位互联网地址，有 2^128个可用 IP 地址。\n\n- IPv4采用DHCP(动态主机配置协议)来自动分配IP地址。IPv6支持自动配置(SLAAC)和DHCPv6，自动化程度更高。\n- IPv4路由表较大，互联网的快速增长导致路由表膨胀，路由效率受到一定影响。IPv6有更高效的路由聚合(aggregation)，路由表规模更小，有助于提高路由效率。\n\n## 操作系统\n\n### 用户态和内核态\n- 用户态是指应用程序运行时所处的模式。在用户态下，程序执行受到严格的限制，不能直接访问硬件或内存中的关键部分。任何试图进行这些操作的指令都会导致异常，并且操作系统会终止该程序。这种限制可以防止用户程序破坏系统的稳定性和安全性。\n  - 受限的指令集：只能执行非特权指令。\n  - 受限的资源访问：不能直接访问硬件设备和内核内存空间。\n  - 需要通过系统调用(System Call)与内核进行交互。\n- 内核态是指操作系统内核运行时所处的模式。在内核态下，系统具有完全的访问权限，可以执行任何指令，并且可以访问所有的硬件设备和内存。这种模式下，操作系统能够管理系统资源和控制硬件。\n  - 完全的指令集：可以执行所有的指令，包括特权指令。\n  - 完全的资源访问：可以直接访问硬件设备和内存。\n  - 执行关键任务：处理系统调用、中断处理、设备管理等。\n\n**切换**\n- 系统调用：当用户态的应用程序需要执行特权操作(如读写文件、分配内存、访问硬件设备)时，它会发出一个系统调用请求，触发从用户态到内核态的切换。内核处理完系统调用后，会返回用户态继续执行应用程序。\n- 中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。这种从用户态到内核态的切换是由硬件中断控制器完成的。\n- 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\n\n**示例**\n- 用户态：运行中的应用程序，如文本编辑器、浏览器等。它们通过系统调用请求操作系统提供的服务。\n- 内核态：操作系统内核在处理系统调用、硬件中断或其他低级别任务时的运行状态。\n\n**安全性和稳定性**\n用户态和内核态的分离是现代操作系统安全性和稳定性的关键。通过将用户程序与操作系统核心隔离，防止用户程序直接操作硬件或内存，减少了系统崩溃和安全漏洞的风险。\n\n**总结**\n用户态和内核态的划分使得计算机系统能够有效地管理资源，提供安全的运行环境，同时允许用户程序执行。用户态用于执行普通应用程序，而内核态用于执行操作系统核心任务，保证了系统的稳定性和安全性。\n\n### 只有内核态不行吗？\n- 在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。\n- 如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。\n\n### 系统调用\n系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。\n\n系统调用(System Call)是操作系统提供给应用程序的接口，用于访问操作系统内核的服务和功能。在用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n系统调用分下面几类：\n- 设备管理：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。\n- 文件管理：完成文件的读、写、创建及删除等功能。\n- 进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。\n- 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。\n\n### 虚拟内存\n虚拟内存(Virtual Memory)是一种计算机系统内存管理技术，它为每个进程提供一个假象，即它独占了整个计算机的内存。这种技术通过硬件和操作系统的共同协作，使得实际的物理内存和辅助存储设备(如硬盘)结合起来，给用户提供一个比实际物理内存大得多的内存空间。\n\n主要作用：\n- 隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n- 提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。\n- 简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。\n- 多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。\n- 提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。\n- 提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页(通常大小为 4 KB)保存到磁盘文件(会影响读写速度)，数据或代码页会根据需要在物理内存与磁盘之间移动。\n\n### 没有虚拟内存会存在什么问题？\n- 程序之间的内存隔离性差：没有虚拟内存，不同程序的内存空间可能会重叠，一个程序可以访问另一个程序的内存空间，导致数据泄露或者程序崩溃。\n- 物理内存利用率低：没有虚拟内存，每个程序都需要占用一定的物理内存，如果物理内存不足，就会导致程序无法运行。\n- 程序的内存管理复杂：没有虚拟内存，程序需要直接管理物理内存，需要考虑内存的分配、释放、回收等问题，增加了程序的复杂性。\n- 程序的安全性差：没有虚拟内存，程序可以直接访问物理内存，可能会导致程序的安全漏洞，如缓冲区溢出等。\n\n## Linux\n\n### 常见linux线程间的通信方式\n\n\n\n","source":"_posts/计算机基础.md","raw":"---\ntitle: 计算机基础\ntags:\n  - 计算机网络\n  - 操作系统\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 计算机网络和操作系统面经\nabbrlink: 17770\ndate: 2024-06-12 22:47:24\nupdated: 2024-06-25 16:46:24\ntop_img: https://s2.loli.net/2024/06/27/k28sUQb3XqIK9wC.png\ncomments:\ncover: https://s2.loli.net/2024/06/27/7o6ubNCe3GgkqMF.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n\n### A*算法\n\n\n\n\n\n## 智力题\n\n### 8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\n为了在只使用两次测量的情况下找到8个球中偏重的那个球，可以采用以下方法：\n\n- 将8个球分成3组：\n  - 第一组：A、B、C\n  - 第二组：D、E、F\n  - 第三组：G、H\n\n- 第一次测量：\n  - 将第一组(A、B、C)放在天平的左边，第二组(D、E、F)放在天平的右边。\n\n  可能的结果有三种：\n  - 左边重(A、B、C中有一个是重球)\n  - 右边重(D、E、F中有一个是重球)\n  - 两边一样重(G、H中有一个是重球)\n\n- 第二次测量：\n  - 如果第一次测量左边重：从A、B、C中任选两个球进行测量，例如A和B。\n    - 如果A和B重量相等，则重球是C。\n    - 如果A和B不等，则重球是较重的那个。\n  - 如果第一次测量右边重：从D、E、F中任选两个球进行测量，例如D和E。\n    - 如果D和E重量相等，则重球是F。\n    - 如果D和E不等，则重球是较重的那个。\n  - 如果第一次测量两边一样重：对G和H进行测量。\n    - 如果G和H重量相等，则重球不存在(但由于题意重球必存在，所以这个情况不会出现)。\n    - 如果G和H不等，则重球是较重的那个。\n\n通过这种方法，可以在两次测量内准确找到8个球中偏重的那个球。\n\n\n\n## 网络\n### OSI七层模型\n- 应用层：为计算机提供服务\n- 表示层：数据处理(编码、解码、加密解密、压缩解压缩)\n- 会话层：管理(建立、维护、重连)应用程序之间的会话\n- 传输层：为两台主机进程之间的通信提供通用的数据传输服务\n- 网络层：转发、路由和寻址(决定数据在网络中的游走路径)\n- 数据链路层：帧编码和误差纠正控制\n- 物理层：透明地传送比特流传输\n\n### TCP/IP四层模型\n- 应用层(应用层、表示层、会话层)\n- 传输层\n- 网络层\n- 网络接口层(数据链路层、物理层)\n\n### 为什么网络要分层\n复杂系统需要分层，每层专注于一类事情。主要有三个原因：\n- 各层之间相互独立，不需要关注其他层如何实现的，只需知道如何调用下层的接口。\n- 提高了灵活性和可替换性。每层可使用最合适的技术实现，只需保证提供的功能及接口没改变就行。这也与平时系统开发高内聚、低耦合的原则契合。\n- 将复杂的网络问题分解为较小的、清晰的小问题来处理解决，使得计算机网络系统易于设计和维护。\n\n### 常见网络协议\n**应用层协议**\n- HTTP(Hypertext Transfer Protocol，超文本传输协议)：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。\n- SMTP(Simple Mail Transfer Protocol，简单邮件发送协议)：基于 TCP 协议，是一种用于发送电子邮件的协议。\n- POP3/IMAP(邮件接收协议)：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。\n- FTP(File Transfer Protocol，文件传输协议) : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。(不安全，更安全可以用SFTP)\n- Telnet(远程登陆协议)：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。\n- SSH(Secure Shell Protocol，安全的网络传输协议)：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。\n- RTP(Real-time Transport Protocol，实时传输协议)：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\n- DNS(Domain Name System，域名管理系统): 基于 UDP 协议，用于解决域名和 IP 地址的映射问题，端口为 53。\n\n**传输层协议**\n- TCP(Transmission Control Protocol，传输控制协议 )：提供 面向连接 的，可靠 的数据传输服务。\n- UDP(User Datagram Protocol，用户数据协议)：提供 无连接 的，尽最大努力 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n**网络层协议**\n- IP(Internet Protocol，网际协议)：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。(IPv4、IPv6)\n- ARP(Address Resolution Protocol，地址解析协议)：ARP 协议解决的是网络层地址和链路层地址之间的转换问题(IP 地址转 MAC 地址)。\n- ICMP(Internet Control Message Protocol，互联网控制报文协议)：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。\n- NAT(Network Address Translation，网络地址转换协议)：用于内部网到外部网的地址转换过程中。\n- OSPF(Open Shortest Path First，开放式最短路径优先)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\n- RIP(Routing Information Protocol，路由信息协议)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\n- BGP(Border Gateway Protocol，边界网关协议)：一种用来在路由选择域之间交换网络层可达性信息(Network Layer Reachability Information，NLRI)的路由选择协议，具有高度的灵活性和可扩展性。\n\n### 浏览器输入URL到页面展示的过程\n1. 在浏览器中输入指定网页的 URL。\n2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。\n3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。\n4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。\n5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。\n6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL(如图片、CSS、JS 等)，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。\n7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。\n\n### URL的组成\nURL(Uniform Resource Locators)，即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。\n\n![URL的组成](./image/Computer-Basic/URL-parts.png)\n- 协议：用于指定访问资源的协议，如 http、https、ftp(文件传输)、file(本地文件)、mailto(邮件)、telnet(远程登录)等。\n- 域名/IP：用于指定资源所在的主机名或 IP 地址。\n- 端口号：用于指定访问资源的端口号，HTTP默认端口号是 80，HTTPS默认端口号是 443。\n- 资源路径：从第一个/开始，表示从服务器上根目录开始进行索引到的文件路径。\n- 参数：浏览器在向服务器提交请求时，在 URL 中附带着参数会提取这些参数。参数采用键值对的形式`key=value`，每一个键值对使用`&`隔开。\n- 锚点：锚点就是在要访问的页面上的一个锚点，可以直接跳转到指定的位置。在 URL 中，锚点以`#`开头，并且不会作为请求的一部分发送给服务端。\n\n### DNS域名系统\nDNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议，解决的是域名和 IP 地址的映射问题。\n\n![DNS解析过程](./image/Computer-Basic/dns-overview.png)\n\n浏览器在本地维护一个`hosts`列表，用户访问网址时，先查看要访问的域名是否在`hosts`列表中，如果有就直接提取对应的 IP 地址记录，如果没有就使用 DNS 服务器获取域名和 IP 地址的映射。\n\n**DNS服务器**\nDNS 服务器自底向上几个层级：\n- 根域名服务器：负责管理顶级域名服务器的 IP 地址。世界上有 600多个根服务器，但只有 13 个 IP 地址。为了提高 DNS 的可靠性、安全性和性能，每个IP地址对应多个服务器。\n- 顶级域 DNS 服务器(TLD 服务器)：负责管理各个顶级域名服务器的 IP 地址。如 `.com`、`.cn`、`.org`、`.net` 等。\n- 权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，如baidu.com 的 DNS 服务器，负责管理该域名下的所有子域名。\n- 本地 DNS 服务器：每个 ISP(互联网服务提供商)都有一个自己的本地 DNS 服务器。\n\n**DNS工作流程**\n主机`cis.poly.edu`想知道`gaia.cs.umass.edu`的 IP 地址。\n![迭代式查询](./image/Computer-Basic/DNS-process.png)\n![递归式查询](./image/Computer-Basic/DNS-process2.png)\n\n### HTTP状态码\n| 状态码 | 类别                           | 原因短语          |\n|-----|------------------------------|---------------|\n| 1XX | Informational(信息性状态码)        | 接收的请求正在处理     |\n| 2XX | Success(成功状态码)               | 请求正常处理完毕      |\n| 3XX | Redirection(重定向状态码)          | 需要进行附加操作以完成请求 |\n| 4XX | Client Error(**_客户端错误状态码_**) | 服务器无法处理请求     |\n| 5XX | Server Error(**_服务器错误状态码_**) | 服务器处理请求出错     |\n\n- `200 OK`：请求被成功处理。如发送查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。\n- `201 Created`：请求被成功处理并且在服务端创建了一个新的资源。如通过 POST 请求创建一个新的用户。\n- `202 Accepted`：服务端已接收到了请求，但还未处理。\n- `204 No Content`：服务端已经成功处理了请求，但是没有返回任何内容。\n\n- `301 Moved Permanently`：资源被永久重定向了。如网站的网址更换了。\n- `302 Found`：资源被临时重定向了。如网站暂时关闭，重定向到一个临时的页面。\n\n- `400 Bad Request`：发送的 HTTP 请求存在问题。如请求参数不合法、请求方法错误。\n- `401 Unauthorized`：未认证却请求需要认证之后才能访问的资源。\n- `403 Forbidden`：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。\n- `404 Not Found`：请求的资源未在服务端找到。如请求某个用户的信息，服务端并没有找到指定的用户。\n- `409 Conflict`：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。\n\n- `500 Internal Server Error`：服务端出问题了(通常是服务端出 Bug 了)。如服务端处理请求的时候突然抛出异常，但异常并未在服务端被正确处理。\n- `502 Bad Gateway`：网关将请求转发到服务端，但服务端返回的却是一个错误的响应。\n\n### HTTP/HTTPS区别\n**基本概念**\n- HTTP协议：用来规范超文本的传输，主要用来是规范浏览器和服务器端的行为。扩展性强、速度快、跨平台支持性好。\n- HTTPS协议：HTTPS基于HTTP协议，并使用 SSL/TLS 协议用作加密和安全认证，其更安全可靠。保密性好、信任度高。\n\n> HTTP和HTTPS协议都需要三次握手建立连接、四次挥手断开连接。\n\n**HTTP和HTTPS的区别**\n- HTTP是明文传输，HTTPS使用SSL进行加密加密传输，更安全可靠。\n- HTTP默认端口是80，HTTPS默认端口是443。\n- HTTP连接简单，无状态，HTTPS握手阶段比较费时，所以HTTP比HTTPS快。\n\n**HTTP通信过程**\nHTTP 是应用层协议，它以 TCP(传输层)作为底层协议，通信过程主要如下：\n- 服务器在 80 端口等待客户的请求。\n- 浏览器发起到服务器的 TCP 连接(创建套接字 Socket)。\n- 服务器接收来自浏览器的 TCP 连接。\n- 浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息。\n- 关闭 TCP 连接。\n\n### SSL/TSL协议加密原理\nHTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。\n\nSSL/TLS 的加密的原理是非对称加密和对称加密的配合使用。对称加密用来加密数据，并生成唯一私有密钥 k，非对称加密用来加密k。通信双方(Client、Server)只需要一次非对称加密，交换对称加密的密钥k，在之后的信息通信中，使用绝对安全的密钥k，对信息进行对称加密，即可保证传输消息的保密性。\n- 非对称加密采用两个密钥：公钥、私钥。在通信时，私钥仅由Server保存，公钥由Client所知晓。公钥用于加密数据，私钥用于解密数据。\n- 对称加密中双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密。\n\n**公钥传输隐患**\n假设存在攻击者 A，其对应服务器为AServer，A发送给Client一个假包，假装是Server公钥，其实是诱饵服务器 AServer的公钥，Client收到后误以为是 Server的公钥，Client后续使用AServer公钥加密密钥k，然后在公开信道传输，那么攻击者 A可以捕获加密的包，然后用AServer的私钥解密，得到密钥k，这样攻击者 A 就可以解密Client和Server之间的通信。\n\n**数字证书**\n为了解决这个问题，需要使用数字证书，数字证书是由权威机构(CA，Certificate Authority)颁发的，用于证明公钥的合法性。具体流程如下：\n假设有服务器 Server，CA 机构，客户端 Client。\n1. Server信任 CA，CA也知道 Server公钥，CA首先为 Server颁发证书(包含 Server公钥)，采用散列技术为证书生成一个摘要，然后使用 CA私钥对摘要进行加密，生成数字签名。\n2. Server获得 CA颁发的证书和数字签名，并在 Client请求时，将证书和数字签名一并发送给 Client。\n3. Client信任 CA并知晓 CA公钥。Client在收到 Server的证书和数字签名时，使用 CA公钥解密数字签名，得到摘要，然后使用相同的散列技术为证书生成摘要。\n4. Client对比两个摘要是否一致，如果一致则证明证书(包含 Server公钥)是真实的，可以使用 Server公钥加密密钥k，然后在公开信道传输。\n\n### HTTP无状态如何保存用户状态\n可以使用 Session 机制来保存用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)。\n\n服务端可以使用内存和数据库保存Session，Session 跟踪是通过在客户端的 Cookie 中存放 Session ID 来实现的。如果 Cookie被禁用可以利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。\n\n### URI/URL区别\n- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\n- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位 这个资源。\n\nURI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\n\n### Session/Cookie区别\n- 存储位置不同：Cookie 存储在客户端，Session 存储在服务端。\n- 存储容量不同：单个Cookie保存的数据<=4KB，一个站点最多保存20个Cookie。Session 存储在服务端，一般没有存储容量限制，但考虑服务器性能，一般会设置 Session 的有效期和存储容量。\n- 安全性不同：Cookie 存储在客户端，容易被篡改，不安全。Session 存储在服务端，相对安全。\n- 生命周期不同：Cookie 有过期时间，可以设置长期有效的 Cookie。Session 一般保存在内存中，会话结束后会被销毁。\n- 作用范围不同：Cookie 的作用范围是整个域名，Session 的作用范围是当前会话。\n- 传输方式不同：Cookie 会随着 HTTP 请求一起发送到服务端，Session 保存在服务端，客户端只会收到 Session ID。\n\n### GET/POST区别\n- GET 用于获取或查询资源，POST 用于创建或修改资源。\n- GET 请求是幂等的，即多次重复执行不会改变资源的状态，POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。\n- GET 请求参数会附加在 URL 后面，POST 请求参数会放在请求体(`body`)中。\n- GET 请求的URL长度受到浏览器和服务器的限制，POST 请求的 `body`大小则没有明确的限制。\n- 由于 GET 请求是幂等的，可以被缓存，而POST 请求是不幂等的，不适合被缓存。\n- GET 请求的安全性较差，参数会暴露在 URL 中，POST 请求的安全性较好，参数在请求体中，不会暴露在 URL 中。\n\n### WebSocket\nWebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。\n\nWebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\nWebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。\n\n### WebSocket/HTTP区别\n- WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。\n- WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。\n- WebSocket 使用 `ws://` 或 `wss://`作为协议前缀，HTTP 使用 `http://` 或 `https://`作为协议前缀。\n- WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。\n- WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。\n\n### WebSocket工作流程\n1. 客户端向服务器发起一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key`等字段，表示要求升级协议为 WebSocket。\n2. 服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复`HTTP 101`状态码，响应头中包含`Upgrade: websocket`和`Sec-WebSocket-Accept:xxx`等字段，表示升级成功。\n3. 现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。\n4. 关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。\n\n### PING命令原理\nPING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\n```bash\nping -c 4 www.baidu.com\nPING www.baidu.com (36.155.132.3): 56 data bytes\n64 bytes from 36.155.132.3: icmp_seq=0 ttl=49 time=8.890 ms\n64 bytes from 36.155.132.3: icmp_seq=1 ttl=49 time=8.874 ms\n64 bytes from 36.155.132.3: icmp_seq=2 ttl=49 time=9.136 ms\n64 bytes from 36.155.132.3: icmp_seq=3 ttl=49 time=9.400 ms\n\n--- www.baidu.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 8.874/9.075/9.400/0.214 ms\n```\n输出由以下几部分组成：\n- ICMP Echo Request(请求报文)信息：序列号、TTL(Time to Live)值。\n- 目标主机的域名或 IP 地址：输出结果的第一行。\n- 往返时间(RTT，Round-Trip Time)：从发送 ICMP Echo Request(请求报文)到接收到 ICMP Echo Reply(响应报文)的总时间，用来衡量网络连接的延迟。\n- 统计结果(Statistics)：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值。\n\n如果PING目标主机无法正确响应，则说明网络连通性出现问题。\n\nPING命令的原理是基于 ICMP 协议，通过发送 ICMP Echo Request(请求报文)到目标主机，目标主机收到请求后，会返回 ICMP Echo Reply(响应报文)给发送方，从而实现网络连通性的测试。\n\n### TCP、UDP区别\n二者都是常见的传输层协议。\n- TCP(Transmission Control Protocol，传输控制协议 )：提供 **面向连接** 的，**可靠** 的数据传输服务。\n- UDP(User Datagram Protocol，用户数据协议)：提供 **无连接** 的，**尽最大努力** 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n区别总结：\n1. TCP面向连接(三次握手四次挥手)，UDP是无连接的，即发送数据之前不需要建立连接\n2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n3. TCP面向字节流，TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如实时视频会议)\n4. TCP只支持点对点通信，UDP支持一对一，一对多，多对一和多对多的交互通信\n5. TCP首部开销20字节，UDP的首部开销小，只有8个字节\n6. TCP通信信道是全双工的可靠信道，UDP则是不可靠信道\n\n原文链接：https://blog.csdn.net/Li_Ning_/article/details/52117463\n\n### TCP/UDP应用场景\nhttps://blog.csdn.net/qq_44273429/article/details/131375961\n\n由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：\n- 文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。\n- 网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。\n- 电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。\n- 远程登录：TCP提供了稳定的连接，适合远程登录操作。\n- 数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。\n\n由于UDP具有低延迟和高效性的特点，它适用于以下场景：\n- 视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。\n- 实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。\n- DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。\n- 实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等\n\n### 如何将UDP变为将TCP那样可靠\n要使 UDP 像 TCP 那样可靠，需要在应用层实现类似 TCP 的功能。以下是一些常见的方法和步骤：\n1. 数据包确认机制(`ACK`)\n   每当接收方收到一个数据包时，它会发送一个确认(`ACK`)回给发送方。发送方在发送数据包后会等待 `ACK`，如果在一定时间内没有收到 `ACK`，则会重传该数据包。\n2. 序列号\n   在每个数据包中添加一个序列号，以便接收方可以按顺序重组数据包，并检测丢失或重复的数据包。\n3. 超时和重传\n   发送方在发送每个数据包后启动一个定时器。如果在规定时间内没有收到 `ACK`，则会重传该数据包。\n4. 滑动窗口\n   使用滑动窗口协议来控制数据包的流动。发送方可以在等待 `ACK` 的同时继续发送多个数据包，从而提高传输效率。\n5. 校验和\n   在数据包中包含校验和，以检测数据包在传输过程中是否被损坏。接收方会检查校验和，并丢弃任何损坏的数据包。\n6. 流量控制\n   发送方和接收方协商一个窗口大小，以确保发送方不会超过接收方的处理能力。\n\n### 三次握手四次挥手\n建立 TCP 连接需要“三次握手”，缺一不可：\n- 一次握手:客户端发送带有 `SYN`(SEQ=x) 标志的数据包 `->` 服务端，然后客户端进入 `SYN_SEND` 状态，等待服务端的确认；\n- 二次握手:服务端发送带有 `SYN+ACK`(SEQ=y,ACK=x+1) 标志的数据包 `–>` 客户端，然后服务端进入 `SYN_RECV` 状态；\n- 三次握手:客户端发送带有 `ACK`(ACK=y+1) 标志的数据包 `–>` 服务端，然后客户端和服务端都进入`ESTABLISHED`状态，完成 TCP 三次握手。\n\n注意，连接建立后，客户端和服务端都可以发送数据。\n\n断开 TCP 连接则需要“四次挥手”，缺一不可：\n- 第一次挥手：客户端发送一个 `FIN`(SEQ=x) 标志的数据包 `->` 服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 `FIN-WAIT-1` 状态。\n- 第二次挥手：服务端收到`FIN`标志的数据包，它发送一个 `ACK`(ACK=x+1)标志的数据包 `->` 客户端。然后服务端进入 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-2`状态。\n- 第三次挥手：服务端发送一个 `FIN` (SEQ=y)标志的数据包 `->` 客户端，请求关闭连接，然后服务端进入 `LAST-ACK` 状态。\n- 第四次挥手：客户端发送 `ACK`(ACK=y+1)标志的数据包 `->` 服务端，然后客户端进入`TIME-WAIT`状态，服务端在收到 `ACK` (ACK=y+1)标志的数据包后进入 `CLOSE` 状态。此时如果客户端等待 `2MSL` 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。\n\nTCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n![三次握手](./image/Computer-Basic/tcp-shakes-hands-three-times.png)\n\n![四次挥手](./image/Computer-Basic/tcp-waves-four-times.png)\n\n### 半连接队列/全连接队列\n在三次握手中，Linux 内核会维护两个队列管理连接请求：\n- 半连接队列(也称 SYN Queue)：当服务端收到客户端的 `SYN` 请求时，此时双方还没有完全建立连接，服务端会把半连接状态的连接放在半连接队列。\n- 全连接队列(也称 Accept Queue)：当服务端收到客户端的 `ACK` 请求时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。若未收到 `ACK` 请求，会进行重传，若超过最大重传次数，系统将从半连接队列中删除该连接信息。\n\n两队列的存在是为了处理并发请求，确保服务端能够有效地管理新的连接请求。\n\n### 为什么要三次握手\n三次握手为的是确认双方收发功能都正常，缺一不可。\n- 第一次握手：Client 无法确认任何信息；Server 确认了：对方发送正常，自己接收正常\n- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n\n### 第二次握手为何传回ACK和SYN\n**为什么传回ACK**\n第二次握手中，服务端传回 `ACK` 是为了确认接收到客户端的 `SYN` 报文。\n**为什么传回SYN**\n在第一次握手中，客户端发送 `SYN`包 是为了建立客户端到服务端的连接，然而 TCP 连接是双向的，服务端到客户端也需要建立连接，所以服务端在第二次握手中向客户端发送 `SYN`包，以建立服务端到客户端的连接。\n\n同时发送 `SYN` 包和 `ACK`包，服务器能够在一个报文中同时完成这两个操作，从而减少报文的数量，加快连接建立的效率。\n\n### 三次握手中可以携带数据吗\n允许在第三次发送 `ACK` 的时候携带数据，但是不建议这样做，因为在第三次握手时，服务端还没有确认客户端的 `ACK` 包，可能会导致数据丢失。\n\n### 为什么要四次挥手\n- 确保数据传输的完整性和可靠性：在任何一方关闭连接之前，确保所有数据都已正确接收和处理。\n- 保证双向关闭的确认：TCP 是全双工通信，每一方都需要确认对方的关闭请求，以避免数据丢失和连接的不正常终止。\n- 避免半开连接：确保在关闭过程中，没有未完成的数据传输或者遗留的数据包。\n- 保证连接的有序终止：TCP 是全双工的，每一方都需要单独关闭自己的发送和接收通道，因此需要四步来完成这一过程。\n\n四次握手虽然复杂，但却能够确保连接的稳定、可靠和有序终止。\n\n### 为何不能把服务端发送的ACK和FIN合并变成三次挥手\n因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 `ACK`，表示接收到了断开连接的请求。等到数据发完之后再发 `FIN`，断开服务端到客户端的数据传送。\n\n### 如果第二次挥手客户端未收到服务端发送的ACK会怎样\n客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n\n### 为什么第四次握手客户端需等待2*MSL\n第四次挥手时，客户端发送服务端的 `ACK` 有可能丢失，如果服务端没收到 `ACK` 的话，服务端就会重发 `FIN`，如果客户端在 `2*MSL` 的时间内收到了 `FIN`，就会重新发送 `ACK` 并再次等待 `2MSL`，防止 Server 没有收到 `ACK` 而不断重发 `FIN`。\n\n> `MSL`(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，`2MSL` 就是一个发送和一个回复所需的最大时间。如果直到 `2MSL`，Client 都没有再次收到 `FIN`，那么 Client 推断 `ACK` 已经被成功接收，则结束 `TCP` 连接。\n\n### TCP如何保证连接可靠性\n1. 基于数据块传输：数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。\n2. 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，给每个包一个序列号，这使得能够将接收到的数据根据序列号排序，去掉重复序列号的数据就可以实现数据包去重。\n3. 校验和：TCP 有端到端的校验和机制，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃此报文段和不确认收到此报文段。\n4. 重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。\n5. TCP 连接每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。\n6. 拥塞控制：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候会考虑网络的拥塞程度，由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。\n\n### TCP如何实现流量控制\nTCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n\n### 为什么需要流量控制\n因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果处理不过来，会先将数据放入接收缓冲区(Receiving Buffers) 里。如果接收缓冲区满了，就只能把再收到的数据包丢掉。而丢包会浪费网络资源。因此要让接收方与发送方处于一种动态平衡。\n\n### TCP如何实现拥塞控制\nTCP 发送发维持一个 拥塞窗口(`cwnd`) 的状态变量。采用了四种算法，即 `慢开始`、 `拥塞避免`、`快重传` 和 `快恢复`。\n- 慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。`cwnd` 初始值为 1，每经过一个传播轮次就加倍。\n- 拥塞避免：拥塞避免算法的思路是让拥塞窗口 `cwnd` 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 `cwnd` 加 1.\n- 快速重传和恢复(fast retransmit and recovery，FRR)能快速恢复丢失的数据包。\n\n### ARQ协议\n自动重传请求(Automatic Repeat-reQuest，ARQ)是数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息`ACK`，就会重新发送，直到收到确认或者重试超过一定的次数。\n\n### 停止等待ARQ协议\n停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复 `ACK`)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\n\n### 连续ARQ协议\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n- 优点：信道利用率高，容易实现。\n- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。\n\n### 超时重传机制如何实现\n发送方发送完数据后，会启动一个定时器，等待接收端确认收到这个报文段。接收端成功收到报文段的话会发送会 `ACK`包，如果发送端在合理的往返时延(RTT)内未收到确认信息，那数据包就被标记为已丢失并进行重传。\n\n超时重传时间 RTO(Retransmission Time Out)直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此 RTO 应根据网络的实际状况，动态地进行调整。\n\n超时重传时间不能直接使用往返时延RTT，因为其值会随着网络波动而变化。\n\n### IP地址\nIP地址是每个连入互联网的设备或域(如计算机、服务器、路由器等)都被分配的一个唯一标识符。\n\n### IP地址过滤\nIP 地址过滤(IP Address Filtering)就是限制或阻止特定 IP 地址或 IP 地址范围的访问。如：有一个图片服务突然被某一个 IP 地址攻击，那就可以禁止这个 IP 地址访问图片服务。\n\n### IPv4/IPv6区别\nIPv4(Internet Protocol version 4)是四组由点分隔的数字，例如：`123.89.46.72`。IPv4 使用 4Bytes 32 位(bits)地址作为其 Internet 地址，共有约 42 亿(2^32)个可用 IP 地址。不够用。\n\n为了解决 IP 地址耗尽的问题，采用具有更大地址空间的新版本 IP 协议 - IPv6(Internet Protocol version 6)。该格式使用由单或双冒号分隔的一组数字和字母，如：`2001:0db8:85a3:0000:0000:8a2e:0370:7334`。IPv6 使用 128 位互联网地址，有 2^128个可用 IP 地址。\n\n- IPv4采用DHCP(动态主机配置协议)来自动分配IP地址。IPv6支持自动配置(SLAAC)和DHCPv6，自动化程度更高。\n- IPv4路由表较大，互联网的快速增长导致路由表膨胀，路由效率受到一定影响。IPv6有更高效的路由聚合(aggregation)，路由表规模更小，有助于提高路由效率。\n\n## 操作系统\n\n### 用户态和内核态\n- 用户态是指应用程序运行时所处的模式。在用户态下，程序执行受到严格的限制，不能直接访问硬件或内存中的关键部分。任何试图进行这些操作的指令都会导致异常，并且操作系统会终止该程序。这种限制可以防止用户程序破坏系统的稳定性和安全性。\n  - 受限的指令集：只能执行非特权指令。\n  - 受限的资源访问：不能直接访问硬件设备和内核内存空间。\n  - 需要通过系统调用(System Call)与内核进行交互。\n- 内核态是指操作系统内核运行时所处的模式。在内核态下，系统具有完全的访问权限，可以执行任何指令，并且可以访问所有的硬件设备和内存。这种模式下，操作系统能够管理系统资源和控制硬件。\n  - 完全的指令集：可以执行所有的指令，包括特权指令。\n  - 完全的资源访问：可以直接访问硬件设备和内存。\n  - 执行关键任务：处理系统调用、中断处理、设备管理等。\n\n**切换**\n- 系统调用：当用户态的应用程序需要执行特权操作(如读写文件、分配内存、访问硬件设备)时，它会发出一个系统调用请求，触发从用户态到内核态的切换。内核处理完系统调用后，会返回用户态继续执行应用程序。\n- 中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。这种从用户态到内核态的切换是由硬件中断控制器完成的。\n- 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\n\n**示例**\n- 用户态：运行中的应用程序，如文本编辑器、浏览器等。它们通过系统调用请求操作系统提供的服务。\n- 内核态：操作系统内核在处理系统调用、硬件中断或其他低级别任务时的运行状态。\n\n**安全性和稳定性**\n用户态和内核态的分离是现代操作系统安全性和稳定性的关键。通过将用户程序与操作系统核心隔离，防止用户程序直接操作硬件或内存，减少了系统崩溃和安全漏洞的风险。\n\n**总结**\n用户态和内核态的划分使得计算机系统能够有效地管理资源，提供安全的运行环境，同时允许用户程序执行。用户态用于执行普通应用程序，而内核态用于执行操作系统核心任务，保证了系统的稳定性和安全性。\n\n### 只有内核态不行吗？\n- 在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。\n- 如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。\n\n### 系统调用\n系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。\n\n系统调用(System Call)是操作系统提供给应用程序的接口，用于访问操作系统内核的服务和功能。在用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n\n系统调用分下面几类：\n- 设备管理：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。\n- 文件管理：完成文件的读、写、创建及删除等功能。\n- 进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。\n- 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。\n\n### 虚拟内存\n虚拟内存(Virtual Memory)是一种计算机系统内存管理技术，它为每个进程提供一个假象，即它独占了整个计算机的内存。这种技术通过硬件和操作系统的共同协作，使得实际的物理内存和辅助存储设备(如硬盘)结合起来，给用户提供一个比实际物理内存大得多的内存空间。\n\n主要作用：\n- 隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n- 提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。\n- 简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。\n- 多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。\n- 提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。\n- 提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页(通常大小为 4 KB)保存到磁盘文件(会影响读写速度)，数据或代码页会根据需要在物理内存与磁盘之间移动。\n\n### 没有虚拟内存会存在什么问题？\n- 程序之间的内存隔离性差：没有虚拟内存，不同程序的内存空间可能会重叠，一个程序可以访问另一个程序的内存空间，导致数据泄露或者程序崩溃。\n- 物理内存利用率低：没有虚拟内存，每个程序都需要占用一定的物理内存，如果物理内存不足，就会导致程序无法运行。\n- 程序的内存管理复杂：没有虚拟内存，程序需要直接管理物理内存，需要考虑内存的分配、释放、回收等问题，增加了程序的复杂性。\n- 程序的安全性差：没有虚拟内存，程序可以直接访问物理内存，可能会导致程序的安全漏洞，如缓冲区溢出等。\n\n## Linux\n\n### 常见linux线程间的通信方式\n\n\n\n","slug":"计算机基础","published":1,"layout":"post","photos":[],"link":"","_id":"clxx1rq1y002ur7gn5ijb1mdw","content":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h3 id=\"A-算法\"><a href=\"#A-算法\" class=\"headerlink\" title=\"A*算法\"></a>A*算法</h3><h2 id=\"智力题\"><a href=\"#智力题\" class=\"headerlink\" title=\"智力题\"></a>智力题</h2><h3 id=\"8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\"><a href=\"#8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\" class=\"headerlink\" title=\"8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\"></a>8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球</h3><p>为了在只使用两次测量的情况下找到8个球中偏重的那个球，可以采用以下方法：</p>\n<ul>\n<li><p>将8个球分成3组：</p>\n<ul>\n<li>第一组：A、B、C</li>\n<li>第二组：D、E、F</li>\n<li>第三组：G、H</li>\n</ul>\n</li>\n<li><p>第一次测量：</p>\n<ul>\n<li>将第一组(A、B、C)放在天平的左边，第二组(D、E、F)放在天平的右边。</li>\n</ul>\n<p>可能的结果有三种：</p>\n<ul>\n<li>左边重(A、B、C中有一个是重球)</li>\n<li>右边重(D、E、F中有一个是重球)</li>\n<li>两边一样重(G、H中有一个是重球)</li>\n</ul>\n</li>\n<li><p>第二次测量：</p>\n<ul>\n<li>如果第一次测量左边重：从A、B、C中任选两个球进行测量，例如A和B。<ul>\n<li>如果A和B重量相等，则重球是C。</li>\n<li>如果A和B不等，则重球是较重的那个。</li>\n</ul>\n</li>\n<li>如果第一次测量右边重：从D、E、F中任选两个球进行测量，例如D和E。<ul>\n<li>如果D和E重量相等，则重球是F。</li>\n<li>如果D和E不等，则重球是较重的那个。</li>\n</ul>\n</li>\n<li>如果第一次测量两边一样重：对G和H进行测量。<ul>\n<li>如果G和H重量相等，则重球不存在(但由于题意重球必存在，所以这个情况不会出现)。</li>\n<li>如果G和H不等，则重球是较重的那个。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>通过这种方法，可以在两次测量内准确找到8个球中偏重的那个球。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><ul>\n<li>应用层：为计算机提供服务</li>\n<li>表示层：数据处理(编码、解码、加密解密、压缩解压缩)</li>\n<li>会话层：管理(建立、维护、重连)应用程序之间的会话</li>\n<li>传输层：为两台主机进程之间的通信提供通用的数据传输服务</li>\n<li>网络层：转发、路由和寻址(决定数据在网络中的游走路径)</li>\n<li>数据链路层：帧编码和误差纠正控制</li>\n<li>物理层：透明地传送比特流传输</li>\n</ul>\n<h3 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ul>\n<li>应用层(应用层、表示层、会话层)</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层(数据链路层、物理层)</li>\n</ul>\n<h3 id=\"为什么网络要分层\"><a href=\"#为什么网络要分层\" class=\"headerlink\" title=\"为什么网络要分层\"></a>为什么网络要分层</h3><p>复杂系统需要分层，每层专注于一类事情。主要有三个原因：</p>\n<ul>\n<li>各层之间相互独立，不需要关注其他层如何实现的，只需知道如何调用下层的接口。</li>\n<li>提高了灵活性和可替换性。每层可使用最合适的技术实现，只需保证提供的功能及接口没改变就行。这也与平时系统开发高内聚、低耦合的原则契合。</li>\n<li>将复杂的网络问题分解为较小的、清晰的小问题来处理解决，使得计算机网络系统易于设计和维护。</li>\n</ul>\n<h3 id=\"常见网络协议\"><a href=\"#常见网络协议\" class=\"headerlink\" title=\"常见网络协议\"></a>常见网络协议</h3><p><strong>应用层协议</strong></p>\n<ul>\n<li>HTTP(Hypertext Transfer Protocol，超文本传输协议)：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</li>\n<li>SMTP(Simple Mail Transfer Protocol，简单邮件发送协议)：基于 TCP 协议，是一种用于发送电子邮件的协议。</li>\n<li>POP3&#x2F;IMAP(邮件接收协议)：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。</li>\n<li>FTP(File Transfer Protocol，文件传输协议) : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。(不安全，更安全可以用SFTP)</li>\n<li>Telnet(远程登陆协议)：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。</li>\n<li>SSH(Secure Shell Protocol，安全的网络传输协议)：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</li>\n<li>RTP(Real-time Transport Protocol，实时传输协议)：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>\n<li>DNS(Domain Name System，域名管理系统): 基于 UDP 协议，用于解决域名和 IP 地址的映射问题，端口为 53。</li>\n</ul>\n<p><strong>传输层协议</strong></p>\n<ul>\n<li>TCP(Transmission Control Protocol，传输控制协议 )：提供 面向连接 的，可靠 的数据传输服务。</li>\n<li>UDP(User Datagram Protocol，用户数据协议)：提供 无连接 的，尽最大努力 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<p><strong>网络层协议</strong></p>\n<ul>\n<li>IP(Internet Protocol，网际协议)：TCP&#x2F;IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。(IPv4、IPv6)</li>\n<li>ARP(Address Resolution Protocol，地址解析协议)：ARP 协议解决的是网络层地址和链路层地址之间的转换问题(IP 地址转 MAC 地址)。</li>\n<li>ICMP(Internet Control Message Protocol，互联网控制报文协议)：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。</li>\n<li>NAT(Network Address Translation，网络地址转换协议)：用于内部网到外部网的地址转换过程中。</li>\n<li>OSPF(Open Shortest Path First，开放式最短路径优先)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>\n<li>RIP(Routing Information Protocol，路由信息协议)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>\n<li>BGP(Border Gateway Protocol，边界网关协议)：一种用来在路由选择域之间交换网络层可达性信息(Network Layer Reachability Information，NLRI)的路由选择协议，具有高度的灵活性和可扩展性。</li>\n</ul>\n<h3 id=\"浏览器输入URL到页面展示的过程\"><a href=\"#浏览器输入URL到页面展示的过程\" class=\"headerlink\" title=\"浏览器输入URL到页面展示的过程\"></a>浏览器输入URL到页面展示的过程</h3><ol>\n<li>在浏览器中输入指定网页的 URL。</li>\n<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>\n<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>\n<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>\n<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>\n<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL(如图片、CSS、JS 等)，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>\n<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>\n</ol>\n<h3 id=\"URL的组成\"><a href=\"#URL的组成\" class=\"headerlink\" title=\"URL的组成\"></a>URL的组成</h3><p>URL(Uniform Resource Locators)，即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。</p>\n<p><img src=\"/./image/Computer-Basic/URL-parts.png\" alt=\"URL的组成\"></p>\n<ul>\n<li>协议：用于指定访问资源的协议，如 http、https、ftp(文件传输)、file(本地文件)、mailto(邮件)、telnet(远程登录)等。</li>\n<li>域名&#x2F;IP：用于指定资源所在的主机名或 IP 地址。</li>\n<li>端口号：用于指定访问资源的端口号，HTTP默认端口号是 80，HTTPS默认端口号是 443。</li>\n<li>资源路径：从第一个&#x2F;开始，表示从服务器上根目录开始进行索引到的文件路径。</li>\n<li>参数：浏览器在向服务器提交请求时，在 URL 中附带着参数会提取这些参数。参数采用键值对的形式<code>key=value</code>，每一个键值对使用<code>&amp;</code>隔开。</li>\n<li>锚点：锚点就是在要访问的页面上的一个锚点，可以直接跳转到指定的位置。在 URL 中，锚点以<code>#</code>开头，并且不会作为请求的一部分发送给服务端。</li>\n</ul>\n<h3 id=\"DNS域名系统\"><a href=\"#DNS域名系统\" class=\"headerlink\" title=\"DNS域名系统\"></a>DNS域名系统</h3><p>DNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议，解决的是域名和 IP 地址的映射问题。</p>\n<p><img src=\"/./image/Computer-Basic/dns-overview.png\" alt=\"DNS解析过程\"></p>\n<p>浏览器在本地维护一个<code>hosts</code>列表，用户访问网址时，先查看要访问的域名是否在<code>hosts</code>列表中，如果有就直接提取对应的 IP 地址记录，如果没有就使用 DNS 服务器获取域名和 IP 地址的映射。</p>\n<p><strong>DNS服务器</strong><br>DNS 服务器自底向上几个层级：</p>\n<ul>\n<li>根域名服务器：负责管理顶级域名服务器的 IP 地址。世界上有 600多个根服务器，但只有 13 个 IP 地址。为了提高 DNS 的可靠性、安全性和性能，每个IP地址对应多个服务器。</li>\n<li>顶级域 DNS 服务器(TLD 服务器)：负责管理各个顶级域名服务器的 IP 地址。如 <code>.com</code>、<code>.cn</code>、<code>.org</code>、<code>.net</code> 等。</li>\n<li>权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，如baidu.com 的 DNS 服务器，负责管理该域名下的所有子域名。</li>\n<li>本地 DNS 服务器：每个 ISP(互联网服务提供商)都有一个自己的本地 DNS 服务器。</li>\n</ul>\n<p><strong>DNS工作流程</strong><br>主机<code>cis.poly.edu</code>想知道<code>gaia.cs.umass.edu</code>的 IP 地址。<br><img src=\"/./image/Computer-Basic/DNS-process.png\" alt=\"迭代式查询\"><br><img src=\"/./image/Computer-Basic/DNS-process2.png\" alt=\"递归式查询\"></p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational(信息性状态码)</td>\n<td>接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success(成功状态码)</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection(重定向状态码)</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error(<strong><em>客户端错误状态码</em></strong>)</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error(<strong><em>服务器错误状态码</em></strong>)</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>200 OK</code>：请求被成功处理。如发送查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。</p>\n</li>\n<li><p><code>201 Created</code>：请求被成功处理并且在服务端创建了一个新的资源。如通过 POST 请求创建一个新的用户。</p>\n</li>\n<li><p><code>202 Accepted</code>：服务端已接收到了请求，但还未处理。</p>\n</li>\n<li><p><code>204 No Content</code>：服务端已经成功处理了请求，但是没有返回任何内容。</p>\n</li>\n<li><p><code>301 Moved Permanently</code>：资源被永久重定向了。如网站的网址更换了。</p>\n</li>\n<li><p><code>302 Found</code>：资源被临时重定向了。如网站暂时关闭，重定向到一个临时的页面。</p>\n</li>\n<li><p><code>400 Bad Request</code>：发送的 HTTP 请求存在问题。如请求参数不合法、请求方法错误。</p>\n</li>\n<li><p><code>401 Unauthorized</code>：未认证却请求需要认证之后才能访问的资源。</p>\n</li>\n<li><p><code>403 Forbidden</code>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p>\n</li>\n<li><p><code>404 Not Found</code>：请求的资源未在服务端找到。如请求某个用户的信息，服务端并没有找到指定的用户。</p>\n</li>\n<li><p><code>409 Conflict</code>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p>\n</li>\n<li><p><code>500 Internal Server Error</code>：服务端出问题了(通常是服务端出 Bug 了)。如服务端处理请求的时候突然抛出异常，但异常并未在服务端被正确处理。</p>\n</li>\n<li><p><code>502 Bad Gateway</code>：网关将请求转发到服务端，但服务端返回的却是一个错误的响应。</p>\n</li>\n</ul>\n<h3 id=\"HTTP-HTTPS区别\"><a href=\"#HTTP-HTTPS区别\" class=\"headerlink\" title=\"HTTP&#x2F;HTTPS区别\"></a>HTTP&#x2F;HTTPS区别</h3><p><strong>基本概念</strong></p>\n<ul>\n<li>HTTP协议：用来规范超文本的传输，主要用来是规范浏览器和服务器端的行为。扩展性强、速度快、跨平台支持性好。</li>\n<li>HTTPS协议：HTTPS基于HTTP协议，并使用 SSL&#x2F;TLS 协议用作加密和安全认证，其更安全可靠。保密性好、信任度高。</li>\n</ul>\n<blockquote>\n<p>HTTP和HTTPS协议都需要三次握手建立连接、四次挥手断开连接。</p>\n</blockquote>\n<p><strong>HTTP和HTTPS的区别</strong></p>\n<ul>\n<li>HTTP是明文传输，HTTPS使用SSL进行加密加密传输，更安全可靠。</li>\n<li>HTTP默认端口是80，HTTPS默认端口是443。</li>\n<li>HTTP连接简单，无状态，HTTPS握手阶段比较费时，所以HTTP比HTTPS快。</li>\n</ul>\n<p><strong>HTTP通信过程</strong><br>HTTP 是应用层协议，它以 TCP(传输层)作为底层协议，通信过程主要如下：</p>\n<ul>\n<li>服务器在 80 端口等待客户的请求。</li>\n<li>浏览器发起到服务器的 TCP 连接(创建套接字 Socket)。</li>\n<li>服务器接收来自浏览器的 TCP 连接。</li>\n<li>浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息。</li>\n<li>关闭 TCP 连接。</li>\n</ul>\n<h3 id=\"SSL-TSL协议加密原理\"><a href=\"#SSL-TSL协议加密原理\" class=\"headerlink\" title=\"SSL&#x2F;TSL协议加密原理\"></a>SSL&#x2F;TSL协议加密原理</h3><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>\n<p>SSL&#x2F;TLS 的加密的原理是非对称加密和对称加密的配合使用。对称加密用来加密数据，并生成唯一私有密钥 k，非对称加密用来加密k。通信双方(Client、Server)只需要一次非对称加密，交换对称加密的密钥k，在之后的信息通信中，使用绝对安全的密钥k，对信息进行对称加密，即可保证传输消息的保密性。</p>\n<ul>\n<li>非对称加密采用两个密钥：公钥、私钥。在通信时，私钥仅由Server保存，公钥由Client所知晓。公钥用于加密数据，私钥用于解密数据。</li>\n<li>对称加密中双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密。</li>\n</ul>\n<p><strong>公钥传输隐患</strong><br>假设存在攻击者 A，其对应服务器为AServer，A发送给Client一个假包，假装是Server公钥，其实是诱饵服务器 AServer的公钥，Client收到后误以为是 Server的公钥，Client后续使用AServer公钥加密密钥k，然后在公开信道传输，那么攻击者 A可以捕获加密的包，然后用AServer的私钥解密，得到密钥k，这样攻击者 A 就可以解密Client和Server之间的通信。</p>\n<p><strong>数字证书</strong><br>为了解决这个问题，需要使用数字证书，数字证书是由权威机构(CA，Certificate Authority)颁发的，用于证明公钥的合法性。具体流程如下：<br>假设有服务器 Server，CA 机构，客户端 Client。</p>\n<ol>\n<li>Server信任 CA，CA也知道 Server公钥，CA首先为 Server颁发证书(包含 Server公钥)，采用散列技术为证书生成一个摘要，然后使用 CA私钥对摘要进行加密，生成数字签名。</li>\n<li>Server获得 CA颁发的证书和数字签名，并在 Client请求时，将证书和数字签名一并发送给 Client。</li>\n<li>Client信任 CA并知晓 CA公钥。Client在收到 Server的证书和数字签名时，使用 CA公钥解密数字签名，得到摘要，然后使用相同的散列技术为证书生成摘要。</li>\n<li>Client对比两个摘要是否一致，如果一致则证明证书(包含 Server公钥)是真实的，可以使用 Server公钥加密密钥k，然后在公开信道传输。</li>\n</ol>\n<h3 id=\"HTTP无状态如何保存用户状态\"><a href=\"#HTTP无状态如何保存用户状态\" class=\"headerlink\" title=\"HTTP无状态如何保存用户状态\"></a>HTTP无状态如何保存用户状态</h3><p>可以使用 Session 机制来保存用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)。</p>\n<p>服务端可以使用内存和数据库保存Session，Session 跟踪是通过在客户端的 Cookie 中存放 Session ID 来实现的。如果 Cookie被禁用可以利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>\n<h3 id=\"URI-URL区别\"><a href=\"#URI-URL区别\" class=\"headerlink\" title=\"URI&#x2F;URL区别\"></a>URI&#x2F;URL区别</h3><ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位 这个资源。</li>\n</ul>\n<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<h3 id=\"Session-Cookie区别\"><a href=\"#Session-Cookie区别\" class=\"headerlink\" title=\"Session&#x2F;Cookie区别\"></a>Session&#x2F;Cookie区别</h3><ul>\n<li>存储位置不同：Cookie 存储在客户端，Session 存储在服务端。</li>\n<li>存储容量不同：单个Cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie。Session 存储在服务端，一般没有存储容量限制，但考虑服务器性能，一般会设置 Session 的有效期和存储容量。</li>\n<li>安全性不同：Cookie 存储在客户端，容易被篡改，不安全。Session 存储在服务端，相对安全。</li>\n<li>生命周期不同：Cookie 有过期时间，可以设置长期有效的 Cookie。Session 一般保存在内存中，会话结束后会被销毁。</li>\n<li>作用范围不同：Cookie 的作用范围是整个域名，Session 的作用范围是当前会话。</li>\n<li>传输方式不同：Cookie 会随着 HTTP 请求一起发送到服务端，Session 保存在服务端，客户端只会收到 Session ID。</li>\n</ul>\n<h3 id=\"GET-POST区别\"><a href=\"#GET-POST区别\" class=\"headerlink\" title=\"GET&#x2F;POST区别\"></a>GET&#x2F;POST区别</h3><ul>\n<li>GET 用于获取或查询资源，POST 用于创建或修改资源。</li>\n<li>GET 请求是幂等的，即多次重复执行不会改变资源的状态，POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>\n<li>GET 请求参数会附加在 URL 后面，POST 请求参数会放在请求体(<code>body</code>)中。</li>\n<li>GET 请求的URL长度受到浏览器和服务器的限制，POST 请求的 <code>body</code>大小则没有明确的限制。</li>\n<li>由于 GET 请求是幂等的，可以被缓存，而POST 请求是不幂等的，不适合被缓存。</li>\n<li>GET 请求的安全性较差，参数会暴露在 URL 中，POST 请求的安全性较好，参数在请求体中，不会暴露在 URL 中。</li>\n</ul>\n<h3 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h3><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p>\n<p>WebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<p>WebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。</p>\n<h3 id=\"WebSocket-HTTP区别\"><a href=\"#WebSocket-HTTP区别\" class=\"headerlink\" title=\"WebSocket&#x2F;HTTP区别\"></a>WebSocket&#x2F;HTTP区别</h3><ul>\n<li>WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。</li>\n<li>WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。</li>\n<li>WebSocket 使用 <code>ws://</code> 或 <code>wss://</code>作为协议前缀，HTTP 使用 <code>http://</code> 或 <code>https://</code>作为协议前缀。</li>\n<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。</li>\n<li>WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。</li>\n</ul>\n<h3 id=\"WebSocket工作流程\"><a href=\"#WebSocket工作流程\" class=\"headerlink\" title=\"WebSocket工作流程\"></a>WebSocket工作流程</h3><ol>\n<li>客户端向服务器发起一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code>等字段，表示要求升级协议为 WebSocket。</li>\n<li>服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复<code>HTTP 101</code>状态码，响应头中包含<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Accept:xxx</code>等字段，表示升级成功。</li>\n<li>现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。</li>\n<li>关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。</li>\n</ol>\n<h3 id=\"PING命令原理\"><a href=\"#PING命令原理\" class=\"headerlink\" title=\"PING命令原理\"></a>PING命令原理</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 4 www.baidu.com</span><br><span class=\"line\">PING www.baidu.com (36.155.132.3): 56 data bytes</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=0 ttl=49 time=8.890 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=1 ttl=49 time=8.874 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=2 ttl=49 time=9.136 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=3 ttl=49 time=9.400 ms</span><br><span class=\"line\"></span><br><span class=\"line\">--- www.baidu.com ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 packets received, 0.0% packet loss</span><br><span class=\"line\">round-trip min/avg/max/stddev = 8.874/9.075/9.400/0.214 ms</span><br></pre></td></tr></table></figure>\n<p>输出由以下几部分组成：</p>\n<ul>\n<li>ICMP Echo Request(请求报文)信息：序列号、TTL(Time to Live)值。</li>\n<li>目标主机的域名或 IP 地址：输出结果的第一行。</li>\n<li>往返时间(RTT，Round-Trip Time)：从发送 ICMP Echo Request(请求报文)到接收到 ICMP Echo Reply(响应报文)的总时间，用来衡量网络连接的延迟。</li>\n<li>统计结果(Statistics)：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值。</li>\n</ul>\n<p>如果PING目标主机无法正确响应，则说明网络连通性出现问题。</p>\n<p>PING命令的原理是基于 ICMP 协议，通过发送 ICMP Echo Request(请求报文)到目标主机，目标主机收到请求后，会返回 ICMP Echo Reply(响应报文)给发送方，从而实现网络连通性的测试。</p>\n<h3 id=\"TCP、UDP区别\"><a href=\"#TCP、UDP区别\" class=\"headerlink\" title=\"TCP、UDP区别\"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p>\n<ul>\n<li>TCP(Transmission Control Protocol，传输控制协议 )：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li>\n<li>UDP(User Datagram Protocol，用户数据协议)：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<p>区别总结：</p>\n<ol>\n<li>TCP面向连接(三次握手四次挥手)，UDP是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>\n<li>TCP面向字节流，TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如实时视频会议)</li>\n<li>TCP只支持点对点通信，UDP支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP首部开销20字节，UDP的首部开销小，只有8个字节</li>\n<li>TCP通信信道是全双工的可靠信道，UDP则是不可靠信道</li>\n</ol>\n<p>原文链接：<a href=\"https://blog.csdn.net/Li_Ning_/article/details/52117463\">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p>\n<h3 id=\"TCP-UDP应用场景\"><a href=\"#TCP-UDP应用场景\" class=\"headerlink\" title=\"TCP&#x2F;UDP应用场景\"></a>TCP&#x2F;UDP应用场景</h3><p><a href=\"https://blog.csdn.net/qq_44273429/article/details/131375961\">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p>\n<p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p>\n<ul>\n<li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li>\n<li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li>\n<li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li>\n<li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li>\n<li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li>\n</ul>\n<p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p>\n<ul>\n<li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li>\n<li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li>\n<li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li>\n<li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li>\n</ul>\n<h3 id=\"如何将UDP变为将TCP那样可靠\"><a href=\"#如何将UDP变为将TCP那样可靠\" class=\"headerlink\" title=\"如何将UDP变为将TCP那样可靠\"></a>如何将UDP变为将TCP那样可靠</h3><p>要使 UDP 像 TCP 那样可靠，需要在应用层实现类似 TCP 的功能。以下是一些常见的方法和步骤：</p>\n<ol>\n<li>数据包确认机制(<code>ACK</code>)<br>每当接收方收到一个数据包时，它会发送一个确认(<code>ACK</code>)回给发送方。发送方在发送数据包后会等待 <code>ACK</code>，如果在一定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li>\n<li>序列号<br>在每个数据包中添加一个序列号，以便接收方可以按顺序重组数据包，并检测丢失或重复的数据包。</li>\n<li>超时和重传<br>发送方在发送每个数据包后启动一个定时器。如果在规定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li>\n<li>滑动窗口<br>使用滑动窗口协议来控制数据包的流动。发送方可以在等待 <code>ACK</code> 的同时继续发送多个数据包，从而提高传输效率。</li>\n<li>校验和<br>在数据包中包含校验和，以检测数据包在传输过程中是否被损坏。接收方会检查校验和，并丢弃任何损坏的数据包。</li>\n<li>流量控制<br>发送方和接收方协商一个窗口大小，以确保发送方不会超过接收方的处理能力。</li>\n</ol>\n<h3 id=\"三次握手四次挥手\"><a href=\"#三次握手四次挥手\" class=\"headerlink\" title=\"三次握手四次挥手\"></a>三次握手四次挥手</h3><p>建立 TCP 连接需要“三次握手”，缺一不可：</p>\n<ul>\n<li>一次握手:客户端发送带有 <code>SYN</code>(SEQ&#x3D;x) 标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入 <code>SYN_SEND</code> 状态，等待服务端的确认；</li>\n<li>二次握手:服务端发送带有 <code>SYN+ACK</code>(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 <code>–&gt;</code> 客户端，然后服务端进入 <code>SYN_RECV</code> 状态；</li>\n<li>三次握手:客户端发送带有 <code>ACK</code>(ACK&#x3D;y+1) 标志的数据包 <code>–&gt;</code> 服务端，然后客户端和服务端都进入<code>ESTABLISHED</code>状态，完成 TCP 三次握手。</li>\n</ul>\n<p>注意，连接建立后，客户端和服务端都可以发送数据。</p>\n<p>断开 TCP 连接则需要“四次挥手”，缺一不可：</p>\n<ul>\n<li>第一次挥手：客户端发送一个 <code>FIN</code>(SEQ&#x3D;x) 标志的数据包 <code>-&gt;</code> 服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 <code>FIN-WAIT-1</code> 状态。</li>\n<li>第二次挥手：服务端收到<code>FIN</code>标志的数据包，它发送一个 <code>ACK</code>(ACK&#x3D;x+1)标志的数据包 <code>-&gt;</code> 客户端。然后服务端进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code>状态。</li>\n<li>第三次挥手：服务端发送一个 <code>FIN</code> (SEQ&#x3D;y)标志的数据包 <code>-&gt;</code> 客户端，请求关闭连接，然后服务端进入 <code>LAST-ACK</code> 状态。</li>\n<li>第四次挥手：客户端发送 <code>ACK</code>(ACK&#x3D;y+1)标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入<code>TIME-WAIT</code>状态，服务端在收到 <code>ACK</code> (ACK&#x3D;y+1)标志的数据包后进入 <code>CLOSE</code> 状态。此时如果客户端等待 <code>2MSL</code> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>\n</ul>\n<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>\n<p><img src=\"/./image/Computer-Basic/tcp-shakes-hands-three-times.png\" alt=\"三次握手\"></p>\n<p><img src=\"/./image/Computer-Basic/tcp-waves-four-times.png\" alt=\"四次挥手\"></p>\n<h3 id=\"半连接队列-全连接队列\"><a href=\"#半连接队列-全连接队列\" class=\"headerlink\" title=\"半连接队列&#x2F;全连接队列\"></a>半连接队列&#x2F;全连接队列</h3><p>在三次握手中，Linux 内核会维护两个队列管理连接请求：</p>\n<ul>\n<li>半连接队列(也称 SYN Queue)：当服务端收到客户端的 <code>SYN</code> 请求时，此时双方还没有完全建立连接，服务端会把半连接状态的连接放在半连接队列。</li>\n<li>全连接队列(也称 Accept Queue)：当服务端收到客户端的 <code>ACK</code> 请求时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。若未收到 <code>ACK</code> 请求，会进行重传，若超过最大重传次数，系统将从半连接队列中删除该连接信息。</li>\n</ul>\n<p>两队列的存在是为了处理并发请求，确保服务端能够有效地管理新的连接请求。</p>\n<h3 id=\"为什么要三次握手\"><a href=\"#为什么要三次握手\" class=\"headerlink\" title=\"为什么要三次握手\"></a>为什么要三次握手</h3><p>三次握手为的是确认双方收发功能都正常，缺一不可。</p>\n<ul>\n<li>第一次握手：Client 无法确认任何信息；Server 确认了：对方发送正常，自己接收正常</li>\n<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>\n<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>\n</ul>\n<h3 id=\"第二次握手为何传回ACK和SYN\"><a href=\"#第二次握手为何传回ACK和SYN\" class=\"headerlink\" title=\"第二次握手为何传回ACK和SYN\"></a>第二次握手为何传回ACK和SYN</h3><p><strong>为什么传回ACK</strong><br>第二次握手中，服务端传回 <code>ACK</code> 是为了确认接收到客户端的 <code>SYN</code> 报文。<br><strong>为什么传回SYN</strong><br>在第一次握手中，客户端发送 <code>SYN</code>包 是为了建立客户端到服务端的连接，然而 TCP 连接是双向的，服务端到客户端也需要建立连接，所以服务端在第二次握手中向客户端发送 <code>SYN</code>包，以建立服务端到客户端的连接。</p>\n<p>同时发送 <code>SYN</code> 包和 <code>ACK</code>包，服务器能够在一个报文中同时完成这两个操作，从而减少报文的数量，加快连接建立的效率。</p>\n<h3 id=\"三次握手中可以携带数据吗\"><a href=\"#三次握手中可以携带数据吗\" class=\"headerlink\" title=\"三次握手中可以携带数据吗\"></a>三次握手中可以携带数据吗</h3><p>允许在第三次发送 <code>ACK</code> 的时候携带数据，但是不建议这样做，因为在第三次握手时，服务端还没有确认客户端的 <code>ACK</code> 包，可能会导致数据丢失。</p>\n<h3 id=\"为什么要四次挥手\"><a href=\"#为什么要四次挥手\" class=\"headerlink\" title=\"为什么要四次挥手\"></a>为什么要四次挥手</h3><ul>\n<li>确保数据传输的完整性和可靠性：在任何一方关闭连接之前，确保所有数据都已正确接收和处理。</li>\n<li>保证双向关闭的确认：TCP 是全双工通信，每一方都需要确认对方的关闭请求，以避免数据丢失和连接的不正常终止。</li>\n<li>避免半开连接：确保在关闭过程中，没有未完成的数据传输或者遗留的数据包。</li>\n<li>保证连接的有序终止：TCP 是全双工的，每一方都需要单独关闭自己的发送和接收通道，因此需要四步来完成这一过程。</li>\n</ul>\n<p>四次握手虽然复杂，但却能够确保连接的稳定、可靠和有序终止。</p>\n<h3 id=\"为何不能把服务端发送的ACK和FIN合并变成三次挥手\"><a href=\"#为何不能把服务端发送的ACK和FIN合并变成三次挥手\" class=\"headerlink\" title=\"为何不能把服务端发送的ACK和FIN合并变成三次挥手\"></a>为何不能把服务端发送的ACK和FIN合并变成三次挥手</h3><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 <code>ACK</code>，表示接收到了断开连接的请求。等到数据发完之后再发 <code>FIN</code>，断开服务端到客户端的数据传送。</p>\n<h3 id=\"如果第二次挥手客户端未收到服务端发送的ACK会怎样\"><a href=\"#如果第二次挥手客户端未收到服务端发送的ACK会怎样\" class=\"headerlink\" title=\"如果第二次挥手客户端未收到服务端发送的ACK会怎样\"></a>如果第二次挥手客户端未收到服务端发送的ACK会怎样</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>\n<h3 id=\"为什么第四次握手客户端需等待2-MSL\"><a href=\"#为什么第四次握手客户端需等待2-MSL\" class=\"headerlink\" title=\"为什么第四次握手客户端需等待2*MSL\"></a>为什么第四次握手客户端需等待2*MSL</h3><p>第四次挥手时，客户端发送服务端的 <code>ACK</code> 有可能丢失，如果服务端没收到 <code>ACK</code> 的话，服务端就会重发 <code>FIN</code>，如果客户端在 <code>2*MSL</code> 的时间内收到了 <code>FIN</code>，就会重新发送 <code>ACK</code> 并再次等待 <code>2MSL</code>，防止 Server 没有收到 <code>ACK</code> 而不断重发 <code>FIN</code>。</p>\n<blockquote>\n<p><code>MSL</code>(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，<code>2MSL</code> 就是一个发送和一个回复所需的最大时间。如果直到 <code>2MSL</code>，Client 都没有再次收到 <code>FIN</code>，那么 Client 推断 <code>ACK</code> 已经被成功接收，则结束 <code>TCP</code> 连接。</p>\n</blockquote>\n<h3 id=\"TCP如何保证连接可靠性\"><a href=\"#TCP如何保证连接可靠性\" class=\"headerlink\" title=\"TCP如何保证连接可靠性\"></a>TCP如何保证连接可靠性</h3><ol>\n<li>基于数据块传输：数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>\n<li>对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，给每个包一个序列号，这使得能够将接收到的数据根据序列号排序，去掉重复序列号的数据就可以实现数据包去重。</li>\n<li>校验和：TCP 有端到端的校验和机制，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃此报文段和不确认收到此报文段。</li>\n<li>重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。</li>\n<li>TCP 连接每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。</li>\n<li>拥塞控制：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候会考虑网络的拥塞程度，由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>\n</ol>\n<h3 id=\"TCP如何实现流量控制\"><a href=\"#TCP如何实现流量控制\" class=\"headerlink\" title=\"TCP如何实现流量控制\"></a>TCP如何实现流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"为什么需要流量控制\"><a href=\"#为什么需要流量控制\" class=\"headerlink\" title=\"为什么需要流量控制\"></a>为什么需要流量控制</h3><p>因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果处理不过来，会先将数据放入接收缓冲区(Receiving Buffers) 里。如果接收缓冲区满了，就只能把再收到的数据包丢掉。而丢包会浪费网络资源。因此要让接收方与发送方处于一种动态平衡。</p>\n<h3 id=\"TCP如何实现拥塞控制\"><a href=\"#TCP如何实现拥塞控制\" class=\"headerlink\" title=\"TCP如何实现拥塞控制\"></a>TCP如何实现拥塞控制</h3><p>TCP 发送发维持一个 拥塞窗口(<code>cwnd</code>) 的状态变量。采用了四种算法，即 <code>慢开始</code>、 <code>拥塞避免</code>、<code>快重传</code> 和 <code>快恢复</code>。</p>\n<ul>\n<li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。<code>cwnd</code> 初始值为 1，每经过一个传播轮次就加倍。</li>\n<li>拥塞避免：拥塞避免算法的思路是让拥塞窗口 <code>cwnd</code> 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 <code>cwnd</code> 加 1.</li>\n<li>快速重传和恢复(fast retransmit and recovery，FRR)能快速恢复丢失的数据包。</li>\n</ul>\n<h3 id=\"ARQ协议\"><a href=\"#ARQ协议\" class=\"headerlink\" title=\"ARQ协议\"></a>ARQ协议</h3><p>自动重传请求(Automatic Repeat-reQuest，ARQ)是数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息<code>ACK</code>，就会重新发送，直到收到确认或者重试超过一定的次数。</p>\n<h3 id=\"停止等待ARQ协议\"><a href=\"#停止等待ARQ协议\" class=\"headerlink\" title=\"停止等待ARQ协议\"></a>停止等待ARQ协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复 <code>ACK</code>)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<ul>\n<li>优点：信道利用率高，容易实现。</li>\n<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。</li>\n</ul>\n<h3 id=\"超时重传机制如何实现\"><a href=\"#超时重传机制如何实现\" class=\"headerlink\" title=\"超时重传机制如何实现\"></a>超时重传机制如何实现</h3><p>发送方发送完数据后，会启动一个定时器，等待接收端确认收到这个报文段。接收端成功收到报文段的话会发送会 <code>ACK</code>包，如果发送端在合理的往返时延(RTT)内未收到确认信息，那数据包就被标记为已丢失并进行重传。</p>\n<p>超时重传时间 RTO(Retransmission Time Out)直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此 RTO 应根据网络的实际状况，动态地进行调整。</p>\n<p>超时重传时间不能直接使用往返时延RTT，因为其值会随着网络波动而变化。</p>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><p>IP地址是每个连入互联网的设备或域(如计算机、服务器、路由器等)都被分配的一个唯一标识符。</p>\n<h3 id=\"IP地址过滤\"><a href=\"#IP地址过滤\" class=\"headerlink\" title=\"IP地址过滤\"></a>IP地址过滤</h3><p>IP 地址过滤(IP Address Filtering)就是限制或阻止特定 IP 地址或 IP 地址范围的访问。如：有一个图片服务突然被某一个 IP 地址攻击，那就可以禁止这个 IP 地址访问图片服务。</p>\n<h3 id=\"IPv4-IPv6区别\"><a href=\"#IPv4-IPv6区别\" class=\"headerlink\" title=\"IPv4&#x2F;IPv6区别\"></a>IPv4&#x2F;IPv6区别</h3><p>IPv4(Internet Protocol version 4)是四组由点分隔的数字，例如：<code>123.89.46.72</code>。IPv4 使用 4Bytes 32 位(bits)地址作为其 Internet 地址，共有约 42 亿(2^32)个可用 IP 地址。不够用。</p>\n<p>为了解决 IP 地址耗尽的问题，采用具有更大地址空间的新版本 IP 协议 - IPv6(Internet Protocol version 6)。该格式使用由单或双冒号分隔的一组数字和字母，如：<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>。IPv6 使用 128 位互联网地址，有 2^128个可用 IP 地址。</p>\n<ul>\n<li>IPv4采用DHCP(动态主机配置协议)来自动分配IP地址。IPv6支持自动配置(SLAAC)和DHCPv6，自动化程度更高。</li>\n<li>IPv4路由表较大，互联网的快速增长导致路由表膨胀，路由效率受到一定影响。IPv6有更高效的路由聚合(aggregation)，路由表规模更小，有助于提高路由效率。</li>\n</ul>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h3><ul>\n<li>用户态是指应用程序运行时所处的模式。在用户态下，程序执行受到严格的限制，不能直接访问硬件或内存中的关键部分。任何试图进行这些操作的指令都会导致异常，并且操作系统会终止该程序。这种限制可以防止用户程序破坏系统的稳定性和安全性。<ul>\n<li>受限的指令集：只能执行非特权指令。</li>\n<li>受限的资源访问：不能直接访问硬件设备和内核内存空间。</li>\n<li>需要通过系统调用(System Call)与内核进行交互。</li>\n</ul>\n</li>\n<li>内核态是指操作系统内核运行时所处的模式。在内核态下，系统具有完全的访问权限，可以执行任何指令，并且可以访问所有的硬件设备和内存。这种模式下，操作系统能够管理系统资源和控制硬件。<ul>\n<li>完全的指令集：可以执行所有的指令，包括特权指令。</li>\n<li>完全的资源访问：可以直接访问硬件设备和内存。</li>\n<li>执行关键任务：处理系统调用、中断处理、设备管理等。</li>\n</ul>\n</li>\n</ul>\n<p><strong>切换</strong></p>\n<ul>\n<li>系统调用：当用户态的应用程序需要执行特权操作(如读写文件、分配内存、访问硬件设备)时，它会发出一个系统调用请求，触发从用户态到内核态的切换。内核处理完系统调用后，会返回用户态继续执行应用程序。</li>\n<li>中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。这种从用户态到内核态的切换是由硬件中断控制器完成的。</li>\n<li>异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>\n</ul>\n<p><strong>示例</strong></p>\n<ul>\n<li>用户态：运行中的应用程序，如文本编辑器、浏览器等。它们通过系统调用请求操作系统提供的服务。</li>\n<li>内核态：操作系统内核在处理系统调用、硬件中断或其他低级别任务时的运行状态。</li>\n</ul>\n<p><strong>安全性和稳定性</strong><br>用户态和内核态的分离是现代操作系统安全性和稳定性的关键。通过将用户程序与操作系统核心隔离，防止用户程序直接操作硬件或内存，减少了系统崩溃和安全漏洞的风险。</p>\n<p><strong>总结</strong><br>用户态和内核态的划分使得计算机系统能够有效地管理资源，提供安全的运行环境，同时允许用户程序执行。用户态用于执行普通应用程序，而内核态用于执行操作系统核心任务，保证了系统的稳定性和安全性。</p>\n<h3 id=\"只有内核态不行吗？\"><a href=\"#只有内核态不行吗？\" class=\"headerlink\" title=\"只有内核态不行吗？\"></a>只有内核态不行吗？</h3><ul>\n<li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。</li>\n<li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li>\n</ul>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p>\n<p>系统调用(System Call)是操作系统提供给应用程序的接口，用于访问操作系统内核的服务和功能。在用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>\n<p>系统调用分下面几类：</p>\n<ul>\n<li>设备管理：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。</li>\n<li>文件管理：完成文件的读、写、创建及删除等功能。</li>\n<li>进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li>\n<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>\n</ul>\n<p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>虚拟内存(Virtual Memory)是一种计算机系统内存管理技术，它为每个进程提供一个假象，即它独占了整个计算机的内存。这种技术通过硬件和操作系统的共同协作，使得实际的物理内存和辅助存储设备(如硬盘)结合起来，给用户提供一个比实际物理内存大得多的内存空间。</p>\n<p>主要作用：</p>\n<ul>\n<li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n<li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li>\n<li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li>\n<li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li>\n<li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>\n<li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页(通常大小为 4 KB)保存到磁盘文件(会影响读写速度)，数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n</ul>\n<h3 id=\"没有虚拟内存会存在什么问题？\"><a href=\"#没有虚拟内存会存在什么问题？\" class=\"headerlink\" title=\"没有虚拟内存会存在什么问题？\"></a>没有虚拟内存会存在什么问题？</h3><ul>\n<li>程序之间的内存隔离性差：没有虚拟内存，不同程序的内存空间可能会重叠，一个程序可以访问另一个程序的内存空间，导致数据泄露或者程序崩溃。</li>\n<li>物理内存利用率低：没有虚拟内存，每个程序都需要占用一定的物理内存，如果物理内存不足，就会导致程序无法运行。</li>\n<li>程序的内存管理复杂：没有虚拟内存，程序需要直接管理物理内存，需要考虑内存的分配、释放、回收等问题，增加了程序的复杂性。</li>\n<li>程序的安全性差：没有虚拟内存，程序可以直接访问物理内存，可能会导致程序的安全漏洞，如缓冲区溢出等。</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><h3 id=\"常见linux线程间的通信方式\"><a href=\"#常见linux线程间的通信方式\" class=\"headerlink\" title=\"常见linux线程间的通信方式\"></a>常见linux线程间的通信方式</h3>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h3 id=\"A-算法\"><a href=\"#A-算法\" class=\"headerlink\" title=\"A*算法\"></a>A*算法</h3><h2 id=\"智力题\"><a href=\"#智力题\" class=\"headerlink\" title=\"智力题\"></a>智力题</h2><h3 id=\"8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\"><a href=\"#8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\" class=\"headerlink\" title=\"8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球\"></a>8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球</h3><p>为了在只使用两次测量的情况下找到8个球中偏重的那个球，可以采用以下方法：</p>\n<ul>\n<li><p>将8个球分成3组：</p>\n<ul>\n<li>第一组：A、B、C</li>\n<li>第二组：D、E、F</li>\n<li>第三组：G、H</li>\n</ul>\n</li>\n<li><p>第一次测量：</p>\n<ul>\n<li>将第一组(A、B、C)放在天平的左边，第二组(D、E、F)放在天平的右边。</li>\n</ul>\n<p>可能的结果有三种：</p>\n<ul>\n<li>左边重(A、B、C中有一个是重球)</li>\n<li>右边重(D、E、F中有一个是重球)</li>\n<li>两边一样重(G、H中有一个是重球)</li>\n</ul>\n</li>\n<li><p>第二次测量：</p>\n<ul>\n<li>如果第一次测量左边重：从A、B、C中任选两个球进行测量，例如A和B。<ul>\n<li>如果A和B重量相等，则重球是C。</li>\n<li>如果A和B不等，则重球是较重的那个。</li>\n</ul>\n</li>\n<li>如果第一次测量右边重：从D、E、F中任选两个球进行测量，例如D和E。<ul>\n<li>如果D和E重量相等，则重球是F。</li>\n<li>如果D和E不等，则重球是较重的那个。</li>\n</ul>\n</li>\n<li>如果第一次测量两边一样重：对G和H进行测量。<ul>\n<li>如果G和H重量相等，则重球不存在(但由于题意重球必存在，所以这个情况不会出现)。</li>\n<li>如果G和H不等，则重球是较重的那个。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>通过这种方法，可以在两次测量内准确找到8个球中偏重的那个球。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><ul>\n<li>应用层：为计算机提供服务</li>\n<li>表示层：数据处理(编码、解码、加密解密、压缩解压缩)</li>\n<li>会话层：管理(建立、维护、重连)应用程序之间的会话</li>\n<li>传输层：为两台主机进程之间的通信提供通用的数据传输服务</li>\n<li>网络层：转发、路由和寻址(决定数据在网络中的游走路径)</li>\n<li>数据链路层：帧编码和误差纠正控制</li>\n<li>物理层：透明地传送比特流传输</li>\n</ul>\n<h3 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ul>\n<li>应用层(应用层、表示层、会话层)</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层(数据链路层、物理层)</li>\n</ul>\n<h3 id=\"为什么网络要分层\"><a href=\"#为什么网络要分层\" class=\"headerlink\" title=\"为什么网络要分层\"></a>为什么网络要分层</h3><p>复杂系统需要分层，每层专注于一类事情。主要有三个原因：</p>\n<ul>\n<li>各层之间相互独立，不需要关注其他层如何实现的，只需知道如何调用下层的接口。</li>\n<li>提高了灵活性和可替换性。每层可使用最合适的技术实现，只需保证提供的功能及接口没改变就行。这也与平时系统开发高内聚、低耦合的原则契合。</li>\n<li>将复杂的网络问题分解为较小的、清晰的小问题来处理解决，使得计算机网络系统易于设计和维护。</li>\n</ul>\n<h3 id=\"常见网络协议\"><a href=\"#常见网络协议\" class=\"headerlink\" title=\"常见网络协议\"></a>常见网络协议</h3><p><strong>应用层协议</strong></p>\n<ul>\n<li>HTTP(Hypertext Transfer Protocol，超文本传输协议)：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</li>\n<li>SMTP(Simple Mail Transfer Protocol，简单邮件发送协议)：基于 TCP 协议，是一种用于发送电子邮件的协议。</li>\n<li>POP3&#x2F;IMAP(邮件接收协议)：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。</li>\n<li>FTP(File Transfer Protocol，文件传输协议) : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。(不安全，更安全可以用SFTP)</li>\n<li>Telnet(远程登陆协议)：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。</li>\n<li>SSH(Secure Shell Protocol，安全的网络传输协议)：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</li>\n<li>RTP(Real-time Transport Protocol，实时传输协议)：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>\n<li>DNS(Domain Name System，域名管理系统): 基于 UDP 协议，用于解决域名和 IP 地址的映射问题，端口为 53。</li>\n</ul>\n<p><strong>传输层协议</strong></p>\n<ul>\n<li>TCP(Transmission Control Protocol，传输控制协议 )：提供 面向连接 的，可靠 的数据传输服务。</li>\n<li>UDP(User Datagram Protocol，用户数据协议)：提供 无连接 的，尽最大努力 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<p><strong>网络层协议</strong></p>\n<ul>\n<li>IP(Internet Protocol，网际协议)：TCP&#x2F;IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。(IPv4、IPv6)</li>\n<li>ARP(Address Resolution Protocol，地址解析协议)：ARP 协议解决的是网络层地址和链路层地址之间的转换问题(IP 地址转 MAC 地址)。</li>\n<li>ICMP(Internet Control Message Protocol，互联网控制报文协议)：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。</li>\n<li>NAT(Network Address Translation，网络地址转换协议)：用于内部网到外部网的地址转换过程中。</li>\n<li>OSPF(Open Shortest Path First，开放式最短路径优先)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>\n<li>RIP(Routing Information Protocol，路由信息协议)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>\n<li>BGP(Border Gateway Protocol，边界网关协议)：一种用来在路由选择域之间交换网络层可达性信息(Network Layer Reachability Information，NLRI)的路由选择协议，具有高度的灵活性和可扩展性。</li>\n</ul>\n<h3 id=\"浏览器输入URL到页面展示的过程\"><a href=\"#浏览器输入URL到页面展示的过程\" class=\"headerlink\" title=\"浏览器输入URL到页面展示的过程\"></a>浏览器输入URL到页面展示的过程</h3><ol>\n<li>在浏览器中输入指定网页的 URL。</li>\n<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>\n<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>\n<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>\n<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>\n<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL(如图片、CSS、JS 等)，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>\n<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>\n</ol>\n<h3 id=\"URL的组成\"><a href=\"#URL的组成\" class=\"headerlink\" title=\"URL的组成\"></a>URL的组成</h3><p>URL(Uniform Resource Locators)，即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。</p>\n<p><img src=\"/./image/Computer-Basic/URL-parts.png\" alt=\"URL的组成\"></p>\n<ul>\n<li>协议：用于指定访问资源的协议，如 http、https、ftp(文件传输)、file(本地文件)、mailto(邮件)、telnet(远程登录)等。</li>\n<li>域名&#x2F;IP：用于指定资源所在的主机名或 IP 地址。</li>\n<li>端口号：用于指定访问资源的端口号，HTTP默认端口号是 80，HTTPS默认端口号是 443。</li>\n<li>资源路径：从第一个&#x2F;开始，表示从服务器上根目录开始进行索引到的文件路径。</li>\n<li>参数：浏览器在向服务器提交请求时，在 URL 中附带着参数会提取这些参数。参数采用键值对的形式<code>key=value</code>，每一个键值对使用<code>&amp;</code>隔开。</li>\n<li>锚点：锚点就是在要访问的页面上的一个锚点，可以直接跳转到指定的位置。在 URL 中，锚点以<code>#</code>开头，并且不会作为请求的一部分发送给服务端。</li>\n</ul>\n<h3 id=\"DNS域名系统\"><a href=\"#DNS域名系统\" class=\"headerlink\" title=\"DNS域名系统\"></a>DNS域名系统</h3><p>DNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议，解决的是域名和 IP 地址的映射问题。</p>\n<p><img src=\"/./image/Computer-Basic/dns-overview.png\" alt=\"DNS解析过程\"></p>\n<p>浏览器在本地维护一个<code>hosts</code>列表，用户访问网址时，先查看要访问的域名是否在<code>hosts</code>列表中，如果有就直接提取对应的 IP 地址记录，如果没有就使用 DNS 服务器获取域名和 IP 地址的映射。</p>\n<p><strong>DNS服务器</strong><br>DNS 服务器自底向上几个层级：</p>\n<ul>\n<li>根域名服务器：负责管理顶级域名服务器的 IP 地址。世界上有 600多个根服务器，但只有 13 个 IP 地址。为了提高 DNS 的可靠性、安全性和性能，每个IP地址对应多个服务器。</li>\n<li>顶级域 DNS 服务器(TLD 服务器)：负责管理各个顶级域名服务器的 IP 地址。如 <code>.com</code>、<code>.cn</code>、<code>.org</code>、<code>.net</code> 等。</li>\n<li>权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，如baidu.com 的 DNS 服务器，负责管理该域名下的所有子域名。</li>\n<li>本地 DNS 服务器：每个 ISP(互联网服务提供商)都有一个自己的本地 DNS 服务器。</li>\n</ul>\n<p><strong>DNS工作流程</strong><br>主机<code>cis.poly.edu</code>想知道<code>gaia.cs.umass.edu</code>的 IP 地址。<br><img src=\"/./image/Computer-Basic/DNS-process.png\" alt=\"迭代式查询\"><br><img src=\"/./image/Computer-Basic/DNS-process2.png\" alt=\"递归式查询\"></p>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational(信息性状态码)</td>\n<td>接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success(成功状态码)</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection(重定向状态码)</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error(<strong><em>客户端错误状态码</em></strong>)</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error(<strong><em>服务器错误状态码</em></strong>)</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>200 OK</code>：请求被成功处理。如发送查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。</p>\n</li>\n<li><p><code>201 Created</code>：请求被成功处理并且在服务端创建了一个新的资源。如通过 POST 请求创建一个新的用户。</p>\n</li>\n<li><p><code>202 Accepted</code>：服务端已接收到了请求，但还未处理。</p>\n</li>\n<li><p><code>204 No Content</code>：服务端已经成功处理了请求，但是没有返回任何内容。</p>\n</li>\n<li><p><code>301 Moved Permanently</code>：资源被永久重定向了。如网站的网址更换了。</p>\n</li>\n<li><p><code>302 Found</code>：资源被临时重定向了。如网站暂时关闭，重定向到一个临时的页面。</p>\n</li>\n<li><p><code>400 Bad Request</code>：发送的 HTTP 请求存在问题。如请求参数不合法、请求方法错误。</p>\n</li>\n<li><p><code>401 Unauthorized</code>：未认证却请求需要认证之后才能访问的资源。</p>\n</li>\n<li><p><code>403 Forbidden</code>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p>\n</li>\n<li><p><code>404 Not Found</code>：请求的资源未在服务端找到。如请求某个用户的信息，服务端并没有找到指定的用户。</p>\n</li>\n<li><p><code>409 Conflict</code>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p>\n</li>\n<li><p><code>500 Internal Server Error</code>：服务端出问题了(通常是服务端出 Bug 了)。如服务端处理请求的时候突然抛出异常，但异常并未在服务端被正确处理。</p>\n</li>\n<li><p><code>502 Bad Gateway</code>：网关将请求转发到服务端，但服务端返回的却是一个错误的响应。</p>\n</li>\n</ul>\n<h3 id=\"HTTP-HTTPS区别\"><a href=\"#HTTP-HTTPS区别\" class=\"headerlink\" title=\"HTTP&#x2F;HTTPS区别\"></a>HTTP&#x2F;HTTPS区别</h3><p><strong>基本概念</strong></p>\n<ul>\n<li>HTTP协议：用来规范超文本的传输，主要用来是规范浏览器和服务器端的行为。扩展性强、速度快、跨平台支持性好。</li>\n<li>HTTPS协议：HTTPS基于HTTP协议，并使用 SSL&#x2F;TLS 协议用作加密和安全认证，其更安全可靠。保密性好、信任度高。</li>\n</ul>\n<blockquote>\n<p>HTTP和HTTPS协议都需要三次握手建立连接、四次挥手断开连接。</p>\n</blockquote>\n<p><strong>HTTP和HTTPS的区别</strong></p>\n<ul>\n<li>HTTP是明文传输，HTTPS使用SSL进行加密加密传输，更安全可靠。</li>\n<li>HTTP默认端口是80，HTTPS默认端口是443。</li>\n<li>HTTP连接简单，无状态，HTTPS握手阶段比较费时，所以HTTP比HTTPS快。</li>\n</ul>\n<p><strong>HTTP通信过程</strong><br>HTTP 是应用层协议，它以 TCP(传输层)作为底层协议，通信过程主要如下：</p>\n<ul>\n<li>服务器在 80 端口等待客户的请求。</li>\n<li>浏览器发起到服务器的 TCP 连接(创建套接字 Socket)。</li>\n<li>服务器接收来自浏览器的 TCP 连接。</li>\n<li>浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息。</li>\n<li>关闭 TCP 连接。</li>\n</ul>\n<h3 id=\"SSL-TSL协议加密原理\"><a href=\"#SSL-TSL协议加密原理\" class=\"headerlink\" title=\"SSL&#x2F;TSL协议加密原理\"></a>SSL&#x2F;TSL协议加密原理</h3><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>\n<p>SSL&#x2F;TLS 的加密的原理是非对称加密和对称加密的配合使用。对称加密用来加密数据，并生成唯一私有密钥 k，非对称加密用来加密k。通信双方(Client、Server)只需要一次非对称加密，交换对称加密的密钥k，在之后的信息通信中，使用绝对安全的密钥k，对信息进行对称加密，即可保证传输消息的保密性。</p>\n<ul>\n<li>非对称加密采用两个密钥：公钥、私钥。在通信时，私钥仅由Server保存，公钥由Client所知晓。公钥用于加密数据，私钥用于解密数据。</li>\n<li>对称加密中双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密。</li>\n</ul>\n<p><strong>公钥传输隐患</strong><br>假设存在攻击者 A，其对应服务器为AServer，A发送给Client一个假包，假装是Server公钥，其实是诱饵服务器 AServer的公钥，Client收到后误以为是 Server的公钥，Client后续使用AServer公钥加密密钥k，然后在公开信道传输，那么攻击者 A可以捕获加密的包，然后用AServer的私钥解密，得到密钥k，这样攻击者 A 就可以解密Client和Server之间的通信。</p>\n<p><strong>数字证书</strong><br>为了解决这个问题，需要使用数字证书，数字证书是由权威机构(CA，Certificate Authority)颁发的，用于证明公钥的合法性。具体流程如下：<br>假设有服务器 Server，CA 机构，客户端 Client。</p>\n<ol>\n<li>Server信任 CA，CA也知道 Server公钥，CA首先为 Server颁发证书(包含 Server公钥)，采用散列技术为证书生成一个摘要，然后使用 CA私钥对摘要进行加密，生成数字签名。</li>\n<li>Server获得 CA颁发的证书和数字签名，并在 Client请求时，将证书和数字签名一并发送给 Client。</li>\n<li>Client信任 CA并知晓 CA公钥。Client在收到 Server的证书和数字签名时，使用 CA公钥解密数字签名，得到摘要，然后使用相同的散列技术为证书生成摘要。</li>\n<li>Client对比两个摘要是否一致，如果一致则证明证书(包含 Server公钥)是真实的，可以使用 Server公钥加密密钥k，然后在公开信道传输。</li>\n</ol>\n<h3 id=\"HTTP无状态如何保存用户状态\"><a href=\"#HTTP无状态如何保存用户状态\" class=\"headerlink\" title=\"HTTP无状态如何保存用户状态\"></a>HTTP无状态如何保存用户状态</h3><p>可以使用 Session 机制来保存用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)。</p>\n<p>服务端可以使用内存和数据库保存Session，Session 跟踪是通过在客户端的 Cookie 中存放 Session ID 来实现的。如果 Cookie被禁用可以利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>\n<h3 id=\"URI-URL区别\"><a href=\"#URI-URL区别\" class=\"headerlink\" title=\"URI&#x2F;URL区别\"></a>URI&#x2F;URL区别</h3><ul>\n<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>\n<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位 这个资源。</li>\n</ul>\n<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>\n<h3 id=\"Session-Cookie区别\"><a href=\"#Session-Cookie区别\" class=\"headerlink\" title=\"Session&#x2F;Cookie区别\"></a>Session&#x2F;Cookie区别</h3><ul>\n<li>存储位置不同：Cookie 存储在客户端，Session 存储在服务端。</li>\n<li>存储容量不同：单个Cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie。Session 存储在服务端，一般没有存储容量限制，但考虑服务器性能，一般会设置 Session 的有效期和存储容量。</li>\n<li>安全性不同：Cookie 存储在客户端，容易被篡改，不安全。Session 存储在服务端，相对安全。</li>\n<li>生命周期不同：Cookie 有过期时间，可以设置长期有效的 Cookie。Session 一般保存在内存中，会话结束后会被销毁。</li>\n<li>作用范围不同：Cookie 的作用范围是整个域名，Session 的作用范围是当前会话。</li>\n<li>传输方式不同：Cookie 会随着 HTTP 请求一起发送到服务端，Session 保存在服务端，客户端只会收到 Session ID。</li>\n</ul>\n<h3 id=\"GET-POST区别\"><a href=\"#GET-POST区别\" class=\"headerlink\" title=\"GET&#x2F;POST区别\"></a>GET&#x2F;POST区别</h3><ul>\n<li>GET 用于获取或查询资源，POST 用于创建或修改资源。</li>\n<li>GET 请求是幂等的，即多次重复执行不会改变资源的状态，POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>\n<li>GET 请求参数会附加在 URL 后面，POST 请求参数会放在请求体(<code>body</code>)中。</li>\n<li>GET 请求的URL长度受到浏览器和服务器的限制，POST 请求的 <code>body</code>大小则没有明确的限制。</li>\n<li>由于 GET 请求是幂等的，可以被缓存，而POST 请求是不幂等的，不适合被缓存。</li>\n<li>GET 请求的安全性较差，参数会暴露在 URL 中，POST 请求的安全性较好，参数在请求体中，不会暴露在 URL 中。</li>\n</ul>\n<h3 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h3><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p>\n<p>WebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n<p>WebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。</p>\n<h3 id=\"WebSocket-HTTP区别\"><a href=\"#WebSocket-HTTP区别\" class=\"headerlink\" title=\"WebSocket&#x2F;HTTP区别\"></a>WebSocket&#x2F;HTTP区别</h3><ul>\n<li>WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。</li>\n<li>WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。</li>\n<li>WebSocket 使用 <code>ws://</code> 或 <code>wss://</code>作为协议前缀，HTTP 使用 <code>http://</code> 或 <code>https://</code>作为协议前缀。</li>\n<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。</li>\n<li>WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。</li>\n</ul>\n<h3 id=\"WebSocket工作流程\"><a href=\"#WebSocket工作流程\" class=\"headerlink\" title=\"WebSocket工作流程\"></a>WebSocket工作流程</h3><ol>\n<li>客户端向服务器发起一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code>等字段，表示要求升级协议为 WebSocket。</li>\n<li>服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复<code>HTTP 101</code>状态码，响应头中包含<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Accept:xxx</code>等字段，表示升级成功。</li>\n<li>现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。</li>\n<li>关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。</li>\n</ol>\n<h3 id=\"PING命令原理\"><a href=\"#PING命令原理\" class=\"headerlink\" title=\"PING命令原理\"></a>PING命令原理</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 4 www.baidu.com</span><br><span class=\"line\">PING www.baidu.com (36.155.132.3): 56 data bytes</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=0 ttl=49 time=8.890 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=1 ttl=49 time=8.874 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=2 ttl=49 time=9.136 ms</span><br><span class=\"line\">64 bytes from 36.155.132.3: icmp_seq=3 ttl=49 time=9.400 ms</span><br><span class=\"line\"></span><br><span class=\"line\">--- www.baidu.com ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 packets received, 0.0% packet loss</span><br><span class=\"line\">round-trip min/avg/max/stddev = 8.874/9.075/9.400/0.214 ms</span><br></pre></td></tr></table></figure>\n<p>输出由以下几部分组成：</p>\n<ul>\n<li>ICMP Echo Request(请求报文)信息：序列号、TTL(Time to Live)值。</li>\n<li>目标主机的域名或 IP 地址：输出结果的第一行。</li>\n<li>往返时间(RTT，Round-Trip Time)：从发送 ICMP Echo Request(请求报文)到接收到 ICMP Echo Reply(响应报文)的总时间，用来衡量网络连接的延迟。</li>\n<li>统计结果(Statistics)：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值。</li>\n</ul>\n<p>如果PING目标主机无法正确响应，则说明网络连通性出现问题。</p>\n<p>PING命令的原理是基于 ICMP 协议，通过发送 ICMP Echo Request(请求报文)到目标主机，目标主机收到请求后，会返回 ICMP Echo Reply(响应报文)给发送方，从而实现网络连通性的测试。</p>\n<h3 id=\"TCP、UDP区别\"><a href=\"#TCP、UDP区别\" class=\"headerlink\" title=\"TCP、UDP区别\"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p>\n<ul>\n<li>TCP(Transmission Control Protocol，传输控制协议 )：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li>\n<li>UDP(User Datagram Protocol，用户数据协议)：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<p>区别总结：</p>\n<ol>\n<li>TCP面向连接(三次握手四次挥手)，UDP是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>\n<li>TCP面向字节流，TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如实时视频会议)</li>\n<li>TCP只支持点对点通信，UDP支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP首部开销20字节，UDP的首部开销小，只有8个字节</li>\n<li>TCP通信信道是全双工的可靠信道，UDP则是不可靠信道</li>\n</ol>\n<p>原文链接：<a href=\"https://blog.csdn.net/Li_Ning_/article/details/52117463\">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p>\n<h3 id=\"TCP-UDP应用场景\"><a href=\"#TCP-UDP应用场景\" class=\"headerlink\" title=\"TCP&#x2F;UDP应用场景\"></a>TCP&#x2F;UDP应用场景</h3><p><a href=\"https://blog.csdn.net/qq_44273429/article/details/131375961\">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p>\n<p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p>\n<ul>\n<li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li>\n<li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li>\n<li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li>\n<li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li>\n<li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li>\n</ul>\n<p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p>\n<ul>\n<li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li>\n<li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li>\n<li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li>\n<li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li>\n</ul>\n<h3 id=\"如何将UDP变为将TCP那样可靠\"><a href=\"#如何将UDP变为将TCP那样可靠\" class=\"headerlink\" title=\"如何将UDP变为将TCP那样可靠\"></a>如何将UDP变为将TCP那样可靠</h3><p>要使 UDP 像 TCP 那样可靠，需要在应用层实现类似 TCP 的功能。以下是一些常见的方法和步骤：</p>\n<ol>\n<li>数据包确认机制(<code>ACK</code>)<br>每当接收方收到一个数据包时，它会发送一个确认(<code>ACK</code>)回给发送方。发送方在发送数据包后会等待 <code>ACK</code>，如果在一定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li>\n<li>序列号<br>在每个数据包中添加一个序列号，以便接收方可以按顺序重组数据包，并检测丢失或重复的数据包。</li>\n<li>超时和重传<br>发送方在发送每个数据包后启动一个定时器。如果在规定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li>\n<li>滑动窗口<br>使用滑动窗口协议来控制数据包的流动。发送方可以在等待 <code>ACK</code> 的同时继续发送多个数据包，从而提高传输效率。</li>\n<li>校验和<br>在数据包中包含校验和，以检测数据包在传输过程中是否被损坏。接收方会检查校验和，并丢弃任何损坏的数据包。</li>\n<li>流量控制<br>发送方和接收方协商一个窗口大小，以确保发送方不会超过接收方的处理能力。</li>\n</ol>\n<h3 id=\"三次握手四次挥手\"><a href=\"#三次握手四次挥手\" class=\"headerlink\" title=\"三次握手四次挥手\"></a>三次握手四次挥手</h3><p>建立 TCP 连接需要“三次握手”，缺一不可：</p>\n<ul>\n<li>一次握手:客户端发送带有 <code>SYN</code>(SEQ&#x3D;x) 标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入 <code>SYN_SEND</code> 状态，等待服务端的确认；</li>\n<li>二次握手:服务端发送带有 <code>SYN+ACK</code>(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 <code>–&gt;</code> 客户端，然后服务端进入 <code>SYN_RECV</code> 状态；</li>\n<li>三次握手:客户端发送带有 <code>ACK</code>(ACK&#x3D;y+1) 标志的数据包 <code>–&gt;</code> 服务端，然后客户端和服务端都进入<code>ESTABLISHED</code>状态，完成 TCP 三次握手。</li>\n</ul>\n<p>注意，连接建立后，客户端和服务端都可以发送数据。</p>\n<p>断开 TCP 连接则需要“四次挥手”，缺一不可：</p>\n<ul>\n<li>第一次挥手：客户端发送一个 <code>FIN</code>(SEQ&#x3D;x) 标志的数据包 <code>-&gt;</code> 服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 <code>FIN-WAIT-1</code> 状态。</li>\n<li>第二次挥手：服务端收到<code>FIN</code>标志的数据包，它发送一个 <code>ACK</code>(ACK&#x3D;x+1)标志的数据包 <code>-&gt;</code> 客户端。然后服务端进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code>状态。</li>\n<li>第三次挥手：服务端发送一个 <code>FIN</code> (SEQ&#x3D;y)标志的数据包 <code>-&gt;</code> 客户端，请求关闭连接，然后服务端进入 <code>LAST-ACK</code> 状态。</li>\n<li>第四次挥手：客户端发送 <code>ACK</code>(ACK&#x3D;y+1)标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入<code>TIME-WAIT</code>状态，服务端在收到 <code>ACK</code> (ACK&#x3D;y+1)标志的数据包后进入 <code>CLOSE</code> 状态。此时如果客户端等待 <code>2MSL</code> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>\n</ul>\n<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>\n<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>\n<p><img src=\"/./image/Computer-Basic/tcp-shakes-hands-three-times.png\" alt=\"三次握手\"></p>\n<p><img src=\"/./image/Computer-Basic/tcp-waves-four-times.png\" alt=\"四次挥手\"></p>\n<h3 id=\"半连接队列-全连接队列\"><a href=\"#半连接队列-全连接队列\" class=\"headerlink\" title=\"半连接队列&#x2F;全连接队列\"></a>半连接队列&#x2F;全连接队列</h3><p>在三次握手中，Linux 内核会维护两个队列管理连接请求：</p>\n<ul>\n<li>半连接队列(也称 SYN Queue)：当服务端收到客户端的 <code>SYN</code> 请求时，此时双方还没有完全建立连接，服务端会把半连接状态的连接放在半连接队列。</li>\n<li>全连接队列(也称 Accept Queue)：当服务端收到客户端的 <code>ACK</code> 请求时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。若未收到 <code>ACK</code> 请求，会进行重传，若超过最大重传次数，系统将从半连接队列中删除该连接信息。</li>\n</ul>\n<p>两队列的存在是为了处理并发请求，确保服务端能够有效地管理新的连接请求。</p>\n<h3 id=\"为什么要三次握手\"><a href=\"#为什么要三次握手\" class=\"headerlink\" title=\"为什么要三次握手\"></a>为什么要三次握手</h3><p>三次握手为的是确认双方收发功能都正常，缺一不可。</p>\n<ul>\n<li>第一次握手：Client 无法确认任何信息；Server 确认了：对方发送正常，自己接收正常</li>\n<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>\n<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>\n</ul>\n<h3 id=\"第二次握手为何传回ACK和SYN\"><a href=\"#第二次握手为何传回ACK和SYN\" class=\"headerlink\" title=\"第二次握手为何传回ACK和SYN\"></a>第二次握手为何传回ACK和SYN</h3><p><strong>为什么传回ACK</strong><br>第二次握手中，服务端传回 <code>ACK</code> 是为了确认接收到客户端的 <code>SYN</code> 报文。<br><strong>为什么传回SYN</strong><br>在第一次握手中，客户端发送 <code>SYN</code>包 是为了建立客户端到服务端的连接，然而 TCP 连接是双向的，服务端到客户端也需要建立连接，所以服务端在第二次握手中向客户端发送 <code>SYN</code>包，以建立服务端到客户端的连接。</p>\n<p>同时发送 <code>SYN</code> 包和 <code>ACK</code>包，服务器能够在一个报文中同时完成这两个操作，从而减少报文的数量，加快连接建立的效率。</p>\n<h3 id=\"三次握手中可以携带数据吗\"><a href=\"#三次握手中可以携带数据吗\" class=\"headerlink\" title=\"三次握手中可以携带数据吗\"></a>三次握手中可以携带数据吗</h3><p>允许在第三次发送 <code>ACK</code> 的时候携带数据，但是不建议这样做，因为在第三次握手时，服务端还没有确认客户端的 <code>ACK</code> 包，可能会导致数据丢失。</p>\n<h3 id=\"为什么要四次挥手\"><a href=\"#为什么要四次挥手\" class=\"headerlink\" title=\"为什么要四次挥手\"></a>为什么要四次挥手</h3><ul>\n<li>确保数据传输的完整性和可靠性：在任何一方关闭连接之前，确保所有数据都已正确接收和处理。</li>\n<li>保证双向关闭的确认：TCP 是全双工通信，每一方都需要确认对方的关闭请求，以避免数据丢失和连接的不正常终止。</li>\n<li>避免半开连接：确保在关闭过程中，没有未完成的数据传输或者遗留的数据包。</li>\n<li>保证连接的有序终止：TCP 是全双工的，每一方都需要单独关闭自己的发送和接收通道，因此需要四步来完成这一过程。</li>\n</ul>\n<p>四次握手虽然复杂，但却能够确保连接的稳定、可靠和有序终止。</p>\n<h3 id=\"为何不能把服务端发送的ACK和FIN合并变成三次挥手\"><a href=\"#为何不能把服务端发送的ACK和FIN合并变成三次挥手\" class=\"headerlink\" title=\"为何不能把服务端发送的ACK和FIN合并变成三次挥手\"></a>为何不能把服务端发送的ACK和FIN合并变成三次挥手</h3><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 <code>ACK</code>，表示接收到了断开连接的请求。等到数据发完之后再发 <code>FIN</code>，断开服务端到客户端的数据传送。</p>\n<h3 id=\"如果第二次挥手客户端未收到服务端发送的ACK会怎样\"><a href=\"#如果第二次挥手客户端未收到服务端发送的ACK会怎样\" class=\"headerlink\" title=\"如果第二次挥手客户端未收到服务端发送的ACK会怎样\"></a>如果第二次挥手客户端未收到服务端发送的ACK会怎样</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>\n<h3 id=\"为什么第四次握手客户端需等待2-MSL\"><a href=\"#为什么第四次握手客户端需等待2-MSL\" class=\"headerlink\" title=\"为什么第四次握手客户端需等待2*MSL\"></a>为什么第四次握手客户端需等待2*MSL</h3><p>第四次挥手时，客户端发送服务端的 <code>ACK</code> 有可能丢失，如果服务端没收到 <code>ACK</code> 的话，服务端就会重发 <code>FIN</code>，如果客户端在 <code>2*MSL</code> 的时间内收到了 <code>FIN</code>，就会重新发送 <code>ACK</code> 并再次等待 <code>2MSL</code>，防止 Server 没有收到 <code>ACK</code> 而不断重发 <code>FIN</code>。</p>\n<blockquote>\n<p><code>MSL</code>(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，<code>2MSL</code> 就是一个发送和一个回复所需的最大时间。如果直到 <code>2MSL</code>，Client 都没有再次收到 <code>FIN</code>，那么 Client 推断 <code>ACK</code> 已经被成功接收，则结束 <code>TCP</code> 连接。</p>\n</blockquote>\n<h3 id=\"TCP如何保证连接可靠性\"><a href=\"#TCP如何保证连接可靠性\" class=\"headerlink\" title=\"TCP如何保证连接可靠性\"></a>TCP如何保证连接可靠性</h3><ol>\n<li>基于数据块传输：数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>\n<li>对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，给每个包一个序列号，这使得能够将接收到的数据根据序列号排序，去掉重复序列号的数据就可以实现数据包去重。</li>\n<li>校验和：TCP 有端到端的校验和机制，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃此报文段和不确认收到此报文段。</li>\n<li>重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。</li>\n<li>TCP 连接每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。</li>\n<li>拥塞控制：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候会考虑网络的拥塞程度，由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>\n</ol>\n<h3 id=\"TCP如何实现流量控制\"><a href=\"#TCP如何实现流量控制\" class=\"headerlink\" title=\"TCP如何实现流量控制\"></a>TCP如何实现流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h3 id=\"为什么需要流量控制\"><a href=\"#为什么需要流量控制\" class=\"headerlink\" title=\"为什么需要流量控制\"></a>为什么需要流量控制</h3><p>因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果处理不过来，会先将数据放入接收缓冲区(Receiving Buffers) 里。如果接收缓冲区满了，就只能把再收到的数据包丢掉。而丢包会浪费网络资源。因此要让接收方与发送方处于一种动态平衡。</p>\n<h3 id=\"TCP如何实现拥塞控制\"><a href=\"#TCP如何实现拥塞控制\" class=\"headerlink\" title=\"TCP如何实现拥塞控制\"></a>TCP如何实现拥塞控制</h3><p>TCP 发送发维持一个 拥塞窗口(<code>cwnd</code>) 的状态变量。采用了四种算法，即 <code>慢开始</code>、 <code>拥塞避免</code>、<code>快重传</code> 和 <code>快恢复</code>。</p>\n<ul>\n<li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。<code>cwnd</code> 初始值为 1，每经过一个传播轮次就加倍。</li>\n<li>拥塞避免：拥塞避免算法的思路是让拥塞窗口 <code>cwnd</code> 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 <code>cwnd</code> 加 1.</li>\n<li>快速重传和恢复(fast retransmit and recovery，FRR)能快速恢复丢失的数据包。</li>\n</ul>\n<h3 id=\"ARQ协议\"><a href=\"#ARQ协议\" class=\"headerlink\" title=\"ARQ协议\"></a>ARQ协议</h3><p>自动重传请求(Automatic Repeat-reQuest，ARQ)是数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息<code>ACK</code>，就会重新发送，直到收到确认或者重试超过一定的次数。</p>\n<h3 id=\"停止等待ARQ协议\"><a href=\"#停止等待ARQ协议\" class=\"headerlink\" title=\"停止等待ARQ协议\"></a>停止等待ARQ协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复 <code>ACK</code>)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>\n<ul>\n<li>优点：信道利用率高，容易实现。</li>\n<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。</li>\n</ul>\n<h3 id=\"超时重传机制如何实现\"><a href=\"#超时重传机制如何实现\" class=\"headerlink\" title=\"超时重传机制如何实现\"></a>超时重传机制如何实现</h3><p>发送方发送完数据后，会启动一个定时器，等待接收端确认收到这个报文段。接收端成功收到报文段的话会发送会 <code>ACK</code>包，如果发送端在合理的往返时延(RTT)内未收到确认信息，那数据包就被标记为已丢失并进行重传。</p>\n<p>超时重传时间 RTO(Retransmission Time Out)直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此 RTO 应根据网络的实际状况，动态地进行调整。</p>\n<p>超时重传时间不能直接使用往返时延RTT，因为其值会随着网络波动而变化。</p>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><p>IP地址是每个连入互联网的设备或域(如计算机、服务器、路由器等)都被分配的一个唯一标识符。</p>\n<h3 id=\"IP地址过滤\"><a href=\"#IP地址过滤\" class=\"headerlink\" title=\"IP地址过滤\"></a>IP地址过滤</h3><p>IP 地址过滤(IP Address Filtering)就是限制或阻止特定 IP 地址或 IP 地址范围的访问。如：有一个图片服务突然被某一个 IP 地址攻击，那就可以禁止这个 IP 地址访问图片服务。</p>\n<h3 id=\"IPv4-IPv6区别\"><a href=\"#IPv4-IPv6区别\" class=\"headerlink\" title=\"IPv4&#x2F;IPv6区别\"></a>IPv4&#x2F;IPv6区别</h3><p>IPv4(Internet Protocol version 4)是四组由点分隔的数字，例如：<code>123.89.46.72</code>。IPv4 使用 4Bytes 32 位(bits)地址作为其 Internet 地址，共有约 42 亿(2^32)个可用 IP 地址。不够用。</p>\n<p>为了解决 IP 地址耗尽的问题，采用具有更大地址空间的新版本 IP 协议 - IPv6(Internet Protocol version 6)。该格式使用由单或双冒号分隔的一组数字和字母，如：<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>。IPv6 使用 128 位互联网地址，有 2^128个可用 IP 地址。</p>\n<ul>\n<li>IPv4采用DHCP(动态主机配置协议)来自动分配IP地址。IPv6支持自动配置(SLAAC)和DHCPv6，自动化程度更高。</li>\n<li>IPv4路由表较大，互联网的快速增长导致路由表膨胀，路由效率受到一定影响。IPv6有更高效的路由聚合(aggregation)，路由表规模更小，有助于提高路由效率。</li>\n</ul>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"用户态和内核态\"><a href=\"#用户态和内核态\" class=\"headerlink\" title=\"用户态和内核态\"></a>用户态和内核态</h3><ul>\n<li>用户态是指应用程序运行时所处的模式。在用户态下，程序执行受到严格的限制，不能直接访问硬件或内存中的关键部分。任何试图进行这些操作的指令都会导致异常，并且操作系统会终止该程序。这种限制可以防止用户程序破坏系统的稳定性和安全性。<ul>\n<li>受限的指令集：只能执行非特权指令。</li>\n<li>受限的资源访问：不能直接访问硬件设备和内核内存空间。</li>\n<li>需要通过系统调用(System Call)与内核进行交互。</li>\n</ul>\n</li>\n<li>内核态是指操作系统内核运行时所处的模式。在内核态下，系统具有完全的访问权限，可以执行任何指令，并且可以访问所有的硬件设备和内存。这种模式下，操作系统能够管理系统资源和控制硬件。<ul>\n<li>完全的指令集：可以执行所有的指令，包括特权指令。</li>\n<li>完全的资源访问：可以直接访问硬件设备和内存。</li>\n<li>执行关键任务：处理系统调用、中断处理、设备管理等。</li>\n</ul>\n</li>\n</ul>\n<p><strong>切换</strong></p>\n<ul>\n<li>系统调用：当用户态的应用程序需要执行特权操作(如读写文件、分配内存、访问硬件设备)时，它会发出一个系统调用请求，触发从用户态到内核态的切换。内核处理完系统调用后，会返回用户态继续执行应用程序。</li>\n<li>中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。这种从用户态到内核态的切换是由硬件中断控制器完成的。</li>\n<li>异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>\n</ul>\n<p><strong>示例</strong></p>\n<ul>\n<li>用户态：运行中的应用程序，如文本编辑器、浏览器等。它们通过系统调用请求操作系统提供的服务。</li>\n<li>内核态：操作系统内核在处理系统调用、硬件中断或其他低级别任务时的运行状态。</li>\n</ul>\n<p><strong>安全性和稳定性</strong><br>用户态和内核态的分离是现代操作系统安全性和稳定性的关键。通过将用户程序与操作系统核心隔离，防止用户程序直接操作硬件或内存，减少了系统崩溃和安全漏洞的风险。</p>\n<p><strong>总结</strong><br>用户态和内核态的划分使得计算机系统能够有效地管理资源，提供安全的运行环境，同时允许用户程序执行。用户态用于执行普通应用程序，而内核态用于执行操作系统核心任务，保证了系统的稳定性和安全性。</p>\n<h3 id=\"只有内核态不行吗？\"><a href=\"#只有内核态不行吗？\" class=\"headerlink\" title=\"只有内核态不行吗？\"></a>只有内核态不行吗？</h3><ul>\n<li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。</li>\n<li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li>\n</ul>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p>\n<p>系统调用(System Call)是操作系统提供给应用程序的接口，用于访问操作系统内核的服务和功能。在用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>\n<p>系统调用分下面几类：</p>\n<ul>\n<li>设备管理：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。</li>\n<li>文件管理：完成文件的读、写、创建及删除等功能。</li>\n<li>进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li>\n<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>\n</ul>\n<p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>\n<h3 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h3><p>虚拟内存(Virtual Memory)是一种计算机系统内存管理技术，它为每个进程提供一个假象，即它独占了整个计算机的内存。这种技术通过硬件和操作系统的共同协作，使得实际的物理内存和辅助存储设备(如硬盘)结合起来，给用户提供一个比实际物理内存大得多的内存空间。</p>\n<p>主要作用：</p>\n<ul>\n<li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n<li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li>\n<li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li>\n<li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li>\n<li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>\n<li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页(通常大小为 4 KB)保存到磁盘文件(会影响读写速度)，数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n</ul>\n<h3 id=\"没有虚拟内存会存在什么问题？\"><a href=\"#没有虚拟内存会存在什么问题？\" class=\"headerlink\" title=\"没有虚拟内存会存在什么问题？\"></a>没有虚拟内存会存在什么问题？</h3><ul>\n<li>程序之间的内存隔离性差：没有虚拟内存，不同程序的内存空间可能会重叠，一个程序可以访问另一个程序的内存空间，导致数据泄露或者程序崩溃。</li>\n<li>物理内存利用率低：没有虚拟内存，每个程序都需要占用一定的物理内存，如果物理内存不足，就会导致程序无法运行。</li>\n<li>程序的内存管理复杂：没有虚拟内存，程序需要直接管理物理内存，需要考虑内存的分配、释放、回收等问题，增加了程序的复杂性。</li>\n<li>程序的安全性差：没有虚拟内存，程序可以直接访问物理内存，可能会导致程序的安全漏洞，如缓冲区溢出等。</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><h3 id=\"常见linux线程间的通信方式\"><a href=\"#常见linux线程间的通信方式\" class=\"headerlink\" title=\"常见linux线程间的通信方式\"></a>常见linux线程间的通信方式</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"clxx1rq1n0009r7gn9tfi2u9x","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1p000ir7gn4mhgggn5"},{"post_id":"clxx1rq1h0001r7gneas9hdmy","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1q000nr7gn1rtu0890"},{"post_id":"clxx1rq1m0007r7gn9opmgl73","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1r000wr7gna9dl24nq"},{"post_id":"clxx1rq1r000vr7gn0ai7elpr","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1r000zr7gnhg7qczo5"},{"post_id":"clxx1rq1n000br7gnfu8fe9o1","category_id":"clxx1rq1q000sr7gnb8w41atk","_id":"clxx1rq1s0011r7gnh9351uyr"},{"post_id":"clxx1rq1o000fr7gnfzla2loa","category_id":"clxx1rq1r000xr7gn49y0affa","_id":"clxx1rq1s0014r7gn8cyg6pzt"},{"post_id":"clxx1rq1k0003r7gn8hpx4mlw","category_id":"clxx1rq1o000cr7gner4566tt","_id":"clxx1rq1s0019r7gn36r3348f"},{"post_id":"clxx1rq1k0003r7gn8hpx4mlw","category_id":"clxx1rq1r0010r7gn74f98acs","_id":"clxx1rq1s001dr7gn06wlhm2w"},{"post_id":"clxx1rq1o000hr7gn9cm330j0","category_id":"clxx1rq1s0016r7gn1nzx8al7","_id":"clxx1rq1s001fr7gn7jjm0i4e"},{"post_id":"clxx1rq1q000mr7gngkzg6hk6","category_id":"clxx1rq1s001br7gn3t1mhjmr","_id":"clxx1rq1t001jr7gnca4v8fzm"},{"post_id":"clxx1rq1q000qr7gnade15vig","category_id":"clxx1rq1s001br7gn3t1mhjmr","_id":"clxx1rq1t001nr7gnfpfghmdc"},{"post_id":"clxx1rq1w002hr7gn1qki9rqf","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1y002mr7gn42l3h2f3"},{"post_id":"clxx1rq1x002ir7gn1anhfiqu","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1y002or7gndi1u6yo5"},{"post_id":"clxx1rq1x002kr7gn8at673q2","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1y002sr7gnc67q8ggn"},{"post_id":"clxx1rq1x002lr7gn1scvhhgt","category_id":"clxx1rq1o000cr7gner4566tt","_id":"clxx1rq1y002vr7gn8j9u98vh"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1z002yr7gnf9y7amig"},{"post_id":"clxx1rq1y002rr7gnfx88efbk","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1z0030r7gn2hmnex6e"},{"post_id":"clxx1rq1y002ur7gn5ijb1mdw","category_id":"clxx1rq1l0004r7gnam6z9jxa","_id":"clxx1rq1z0033r7gnbo99ceys"}],"PostTag":[{"post_id":"clxx1rq1h0001r7gneas9hdmy","tag_id":"clxx1rq1m0005r7gnb4of8u2d","_id":"clxx1rq1q000or7gneeil1ntj"},{"post_id":"clxx1rq1h0001r7gneas9hdmy","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1q000rr7gn4w60e3z7"},{"post_id":"clxx1rq1k0003r7gn8hpx4mlw","tag_id":"clxx1rq1p000kr7gn26gx332j","_id":"clxx1rq1s0013r7gn5jr50ndo"},{"post_id":"clxx1rq1k0003r7gn8hpx4mlw","tag_id":"clxx1rq1r000tr7gn0bjoe2n0","_id":"clxx1rq1s0015r7gn7up3ezt2"},{"post_id":"clxx1rq1k0003r7gn8hpx4mlw","tag_id":"clxx1rq1r000yr7gn2x4q5q8d","_id":"clxx1rq1s0018r7gn6eyp6xr0"},{"post_id":"clxx1rq1m0007r7gn9opmgl73","tag_id":"clxx1rq1m0005r7gnb4of8u2d","_id":"clxx1rq1s001cr7gn51w3ha0d"},{"post_id":"clxx1rq1m0007r7gn9opmgl73","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1s001er7gnbzau8vmh"},{"post_id":"clxx1rq1n0009r7gn9tfi2u9x","tag_id":"clxx1rq1s001ar7gn2rusgzkq","_id":"clxx1rq1t001kr7gnc6ntbjr1"},{"post_id":"clxx1rq1n0009r7gn9tfi2u9x","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1t001lr7gnhgotd9th"},{"post_id":"clxx1rq1n000br7gnfu8fe9o1","tag_id":"clxx1rq1r000yr7gn2x4q5q8d","_id":"clxx1rq1t001or7gnb8hs84r9"},{"post_id":"clxx1rq1o000fr7gnfzla2loa","tag_id":"clxx1rq1t001mr7gng51691if","_id":"clxx1rq1t001rr7gna0nz1tkw"},{"post_id":"clxx1rq1o000fr7gnfzla2loa","tag_id":"clxx1rq1t001pr7gn4bc4hbwr","_id":"clxx1rq1t001sr7gncqrm78sg"},{"post_id":"clxx1rq1o000hr7gn9cm330j0","tag_id":"clxx1rq1t001qr7gn6wnn9uve","_id":"clxx1rq1t001xr7gn92vddfp8"},{"post_id":"clxx1rq1o000hr7gn9cm330j0","tag_id":"clxx1rq1t001tr7gn7y5dee03","_id":"clxx1rq1t001yr7gn6ov7er6x"},{"post_id":"clxx1rq1o000hr7gn9cm330j0","tag_id":"clxx1rq1t001ur7gnfuab430i","_id":"clxx1rq1t0020r7gncexkeir4"},{"post_id":"clxx1rq1o000hr7gn9cm330j0","tag_id":"clxx1rq1t001vr7gneii33ofp","_id":"clxx1rq1u0021r7gn30k71kqg"},{"post_id":"clxx1rq1q000mr7gngkzg6hk6","tag_id":"clxx1rq1t001wr7gngqhoclzo","_id":"clxx1rq1u0024r7gn435u8tff"},{"post_id":"clxx1rq1q000mr7gngkzg6hk6","tag_id":"clxx1rq1t001zr7gnfx5t0s6b","_id":"clxx1rq1u0025r7gn013a1uwj"},{"post_id":"clxx1rq1q000mr7gngkzg6hk6","tag_id":"clxx1rq1t001pr7gn4bc4hbwr","_id":"clxx1rq1u0027r7gn4q959clh"},{"post_id":"clxx1rq1q000qr7gnade15vig","tag_id":"clxx1rq1t001wr7gngqhoclzo","_id":"clxx1rq1u002ar7gn85vzhvai"},{"post_id":"clxx1rq1q000qr7gnade15vig","tag_id":"clxx1rq1t001zr7gnfx5t0s6b","_id":"clxx1rq1u002br7gncup02uyt"},{"post_id":"clxx1rq1q000qr7gnade15vig","tag_id":"clxx1rq1t001pr7gn4bc4hbwr","_id":"clxx1rq1u002dr7gnhm7bg9j2"},{"post_id":"clxx1rq1r000vr7gn0ai7elpr","tag_id":"clxx1rq1t001tr7gn7y5dee03","_id":"clxx1rq1u002er7gnadbzed2x"},{"post_id":"clxx1rq1r000vr7gn0ai7elpr","tag_id":"clxx1rq1t001qr7gn6wnn9uve","_id":"clxx1rq1u002fr7gn24mlginl"},{"post_id":"clxx1rq1r000vr7gn0ai7elpr","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1u002gr7gnh4kg780s"},{"post_id":"clxx1rq1x002lr7gn1scvhhgt","tag_id":"clxx1rq1p000kr7gn26gx332j","_id":"clxx1rq1y002qr7gn20zh29v9"},{"post_id":"clxx1rq1x002lr7gn1scvhhgt","tag_id":"clxx1rq1r000yr7gn2x4q5q8d","_id":"clxx1rq1y002tr7gn9fq9b8mv"},{"post_id":"clxx1rq1w002hr7gn1qki9rqf","tag_id":"clxx1rq1x002jr7gn4b7u5rmu","_id":"clxx1rq1z002xr7gnc0xrho06"},{"post_id":"clxx1rq1w002hr7gn1qki9rqf","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z002zr7gn7mbd1s8a"},{"post_id":"clxx1rq1y002rr7gnfx88efbk","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z0032r7gncx5x71g6"},{"post_id":"clxx1rq1x002ir7gn1anhfiqu","tag_id":"clxx1rq1y002pr7gndir8dl2a","_id":"clxx1rq1z0034r7gn2chzd2yz"},{"post_id":"clxx1rq1x002ir7gn1anhfiqu","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z0035r7gndkjz7gcb"},{"post_id":"clxx1rq1x002kr7gn8at673q2","tag_id":"clxx1rq1y002wr7gnb7fr2yt4","_id":"clxx1rq1z0037r7gn9vmta2fm"},{"post_id":"clxx1rq1x002kr7gn8at673q2","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z0038r7gn9j7nerh1"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z0031r7gndjcg73i0","_id":"clxx1rq1z003er7gn2j8e5h9e"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z0036r7gn5zhi7ypx","_id":"clxx1rq1z003fr7gnfpnx4m0w"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z0039r7gndnbbfh8b","_id":"clxx1rq1z003hr7gngyt79v69"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z003ar7gnbjfydvrh","_id":"clxx1rq1z003ir7gndh914rq0"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z003br7gnfv3dgofn","_id":"clxx1rq1z003jr7gn6gb78y5y"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1z003cr7gn1sz8f011","_id":"clxx1rq1z003kr7gnhpx7ggod"},{"post_id":"clxx1rq1y002nr7gn1lkie2gy","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z003lr7gn21jr8jex"},{"post_id":"clxx1rq1y002ur7gn5ijb1mdw","tag_id":"clxx1rq1z003dr7gn4vtm5a3t","_id":"clxx1rq1z003mr7gn63imbtbx"},{"post_id":"clxx1rq1y002ur7gn5ijb1mdw","tag_id":"clxx1rq1z003gr7gn4rcm1z92","_id":"clxx1rq1z003nr7gncmda1pku"},{"post_id":"clxx1rq1y002ur7gn5ijb1mdw","tag_id":"clxx1rq1o000dr7gndl7vhvyv","_id":"clxx1rq1z003or7gnhygc4klm"}],"Tag":[{"name":"C++","_id":"clxx1rq1m0005r7gnb4of8u2d"},{"name":"面经","_id":"clxx1rq1o000dr7gndl7vhvyv"},{"name":"强化学习","_id":"clxx1rq1p000kr7gn26gx332j"},{"name":"多智能体强化学习","_id":"clxx1rq1r000tr7gn0bjoe2n0"},{"name":"算法","_id":"clxx1rq1r000yr7gn2x4q5q8d"},{"name":"Java","_id":"clxx1rq1s001ar7gn2rusgzkq"},{"name":"hexo","_id":"clxx1rq1t001mr7gng51691if"},{"name":"教程","_id":"clxx1rq1t001pr7gn4bc4hbwr"},{"name":"移动端","_id":"clxx1rq1t001qr7gn6wnn9uve"},{"name":"前端","_id":"clxx1rq1t001tr7gn7y5dee03"},{"name":"react","_id":"clxx1rq1t001ur7gnfuab430i"},{"name":"react-native","_id":"clxx1rq1t001vr7gneii33ofp"},{"name":"k8s","_id":"clxx1rq1t001wr7gngqhoclzo"},{"name":"Kubernetes","_id":"clxx1rq1t001zr7gnfx5t0s6b"},{"name":"手撕技巧","_id":"clxx1rq1x002jr7gn4b7u5rmu"},{"name":"测试开发","_id":"clxx1rq1y002pr7gndir8dl2a"},{"name":"框架","_id":"clxx1rq1y002wr7gnb7fr2yt4"},{"name":"数据库","_id":"clxx1rq1z0031r7gndjcg73i0"},{"name":"SQL","_id":"clxx1rq1z0036r7gn5zhi7ypx"},{"name":"NoSQL","_id":"clxx1rq1z0039r7gndnbbfh8b"},{"name":"MySQL","_id":"clxx1rq1z003ar7gnbjfydvrh"},{"name":"mongodb","_id":"clxx1rq1z003br7gnfv3dgofn"},{"name":"Redis","_id":"clxx1rq1z003cr7gn1sz8f011"},{"name":"计算机网络","_id":"clxx1rq1z003dr7gn4vtm5a3t"},{"name":"操作系统","_id":"clxx1rq1z003gr7gn4rcm1z92"}]}}