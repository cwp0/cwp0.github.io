{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/alipay.JPG","path":"img/alipay.JPG","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wechat.JPG","path":"img/wechat.JPG","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/Valine.min.js","path":"js/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/assets/头像.JPG","path":"img/assets/头像.JPG","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/background/樱花1.jpg","path":"img/background/樱花1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/background/樱花2.jpg","path":"img/background/樱花2.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/image/Database-Interview/13526879-3037b144ed09eb88.png","path":"image/Database-Interview/13526879-3037b144ed09eb88.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img.png","path":"image/MARL/img.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_1.png","path":"image/MARL/img_1.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_10.png","path":"image/MARL/img_10.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_11.png","path":"image/MARL/img_11.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_12.png","path":"image/MARL/img_12.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_13.png","path":"image/MARL/img_13.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_14.png","path":"image/MARL/img_14.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_15.png","path":"image/MARL/img_15.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_16.png","path":"image/MARL/img_16.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_17.png","path":"image/MARL/img_17.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_18.png","path":"image/MARL/img_18.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_19.png","path":"image/MARL/img_19.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_2.png","path":"image/MARL/img_2.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_20.png","path":"image/MARL/img_20.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_21.png","path":"image/MARL/img_21.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_22.png","path":"image/MARL/img_22.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_23.png","path":"image/MARL/img_23.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_24.png","path":"image/MARL/img_24.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_25.png","path":"image/MARL/img_25.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_26.png","path":"image/MARL/img_26.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_27.png","path":"image/MARL/img_27.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_28.png","path":"image/MARL/img_28.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_29.png","path":"image/MARL/img_29.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_3.png","path":"image/MARL/img_3.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_30.png","path":"image/MARL/img_30.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_31.png","path":"image/MARL/img_31.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_32.png","path":"image/MARL/img_32.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_33.png","path":"image/MARL/img_33.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_34.png","path":"image/MARL/img_34.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_35.png","path":"image/MARL/img_35.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_36.png","path":"image/MARL/img_36.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_37.png","path":"image/MARL/img_37.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_38.png","path":"image/MARL/img_38.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_39.png","path":"image/MARL/img_39.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_4.png","path":"image/MARL/img_4.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_40.png","path":"image/MARL/img_40.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_41.png","path":"image/MARL/img_41.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_42.png","path":"image/MARL/img_42.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_43.png","path":"image/MARL/img_43.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_44.png","path":"image/MARL/img_44.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_45.png","path":"image/MARL/img_45.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_46.png","path":"image/MARL/img_46.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_47.png","path":"image/MARL/img_47.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_48.png","path":"image/MARL/img_48.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_49.png","path":"image/MARL/img_49.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_5.png","path":"image/MARL/img_5.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_50.png","path":"image/MARL/img_50.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_51.png","path":"image/MARL/img_51.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_52.png","path":"image/MARL/img_52.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_53.png","path":"image/MARL/img_53.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_54.png","path":"image/MARL/img_54.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_55.png","path":"image/MARL/img_55.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_56.png","path":"image/MARL/img_56.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_6.png","path":"image/MARL/img_6.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_7.png","path":"image/MARL/img_7.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_8.png","path":"image/MARL/img_8.png","modified":0,"renderable":0},{"_id":"source/image/MARL/img_9.png","path":"image/MARL/img_9.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/1.png","path":"image/k8s部署云笔记系统/1.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/2.png","path":"image/k8s部署云笔记系统/2.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/3.png","path":"image/k8s部署云笔记系统/3.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/4.png","path":"image/k8s部署云笔记系统/4.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/5.png","path":"image/k8s部署云笔记系统/5.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/6.png","path":"image/k8s部署云笔记系统/6.png","modified":0,"renderable":0},{"_id":"source/image/k8s部署云笔记系统/可莉.png","path":"image/k8s部署云笔记系统/可莉.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/6.png","path":"image/云笔记系统扩容/6.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/add-labels.png","path":"image/云笔记系统扩容/add-labels.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/backup-desktop.png","path":"image/云笔记系统扩容/backup-desktop.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/backup.png","path":"image/云笔记系统扩容/backup.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/delete-pod.png","path":"image/云笔记系统扩容/delete-pod.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/expand.png","path":"image/云笔记系统扩容/expand.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/login.png","path":"image/云笔记系统扩容/login.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-after-deleted.png","path":"image/云笔记系统扩容/pod-after-deleted.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-after-deploy.png","path":"image/云笔记系统扩容/pod-after-deploy.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-deploy.png","path":"image/云笔记系统扩容/pod-deploy.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod-node.png","path":"image/云笔记系统扩容/pod-node.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/pod.png","path":"image/云笔记系统扩容/pod.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/setting.png","path":"image/云笔记系统扩容/setting.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/shutdown.png","path":"image/云笔记系统扩容/shutdown.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/vmware.png","path":"image/云笔记系统扩容/vmware.png","modified":0,"renderable":0},{"_id":"source/image/云笔记系统扩容/xftp.png","path":"image/云笔记系统扩容/xftp.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/A3C.png","path":"image/强化学习/A3C.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/A3C1.png","path":"image/强化学习/A3C1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/AC算法.png","path":"image/强化学习/AC算法.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DDPG1.png","path":"image/强化学习/DDPG1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DDPG2.png","path":"image/强化学习/DDPG2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DQN.png","path":"image/强化学习/DQN.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DQN公式.png","path":"image/强化学习/DQN公式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DQN更新的是Q值.png","path":"image/强化学习/DQN更新的是Q值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DuelDQN.png","path":"image/强化学习/DuelDQN.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/DuelDQN网络架构.png","path":"image/强化学习/DuelDQN网络架构.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/G值的意义.png","path":"image/强化学习/G值的意义.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Magic'(X).png","path":"image/强化学习/Magic'(X).png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Magic(X).png","path":"image/强化学习/Magic(X).png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q'估算Q 1.png","path":"image/强化学习/Q'估算Q 1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q'估计Q 2.png","path":"image/强化学习/Q'估计Q 2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q=S+A表格.png","path":"image/强化学习/Q=S+A表格.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Qlearning公式.png","path":"image/强化学习/Qlearning公式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Qlearning图解.png","path":"image/强化学习/Qlearning图解.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Qtable三维可视化.png","path":"image/强化学习/Qtable三维可视化.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q值的定义.png","path":"image/强化学习/Q值的定义.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q值转V值.png","path":"image/强化学习/Q值转V值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/Q值转V值1.png","path":"image/强化学习/Q值转V值1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/SARSA.png","path":"image/强化学习/SARSA.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/SARSA公式.png","path":"image/强化学习/SARSA公式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD(0).png","path":"image/强化学习/TD(0).png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD(0)与SARSA对比.png","path":"image/强化学习/TD(0)与SARSA对比.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD(0)图解.png","path":"image/强化学习/TD(0)图解.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD(0)更新公式.png","path":"image/强化学习/TD(0)更新公式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD(N).png","path":"image/强化学习/TD(N).png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD-error.png","path":"image/强化学习/TD-error.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/TD3.png","path":"image/强化学习/TD3.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/V值的定义.png","path":"image/强化学习/V值的定义.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/V值转Q值.png","path":"image/强化学习/V值转Q值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/V值转Q值1.png","path":"image/强化学习/V值转Q值1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/V值转V值.png","path":"image/强化学习/V值转V值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/fix-Q-targets.png","path":"image/强化学习/fix-Q-targets.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/两种理解方式.png","path":"image/强化学习/两种理解方式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/为什么不估算Q.png","path":"image/强化学习/为什么不估算Q.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/二维曲线.png","path":"image/强化学习/二维曲线.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/例子1.png","path":"image/强化学习/例子1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/公式1.png","path":"image/强化学习/公式1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/公式2.png","path":"image/强化学习/公式2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/回顾DQN.png","path":"image/强化学习/回顾DQN.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/坑的解释.png","path":"image/强化学习/坑的解释.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/复习MC.png","path":"image/强化学习/复习MC.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/学习路线.png","path":"image/强化学习/学习路线.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/扭曲的曲线.png","path":"image/强化学习/扭曲的曲线.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/数据加工厂.png","path":"image/强化学习/数据加工厂.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/普通DQN.png","path":"image/强化学习/普通DQN.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/更新公式.png","path":"image/强化学习/更新公式.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/正态分布.png","path":"image/强化学习/正态分布.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/理解DDPG1.png","path":"image/强化学习/理解DDPG1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/理解DDPG2.png","path":"image/强化学习/理解DDPG2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/用TD估计Q值.png","path":"image/强化学习/用TD估计Q值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/用下一个动作的Q代替V.png","path":"image/强化学习/用下一个动作的Q代替V.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/由G值算V值.png","path":"image/强化学习/由G值算V值.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/直观感受PG1.png","path":"image/强化学习/直观感受PG1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/直观感受PG2.png","path":"image/强化学习/直观感受PG2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/直观感受PG3.png","path":"image/强化学习/直观感受PG3.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/离散动作-策略分布.png","path":"image/强化学习/离散动作-策略分布.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略1.png","path":"image/强化学习/策略1.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略2.png","path":"image/强化学习/策略2.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略3.png","path":"image/强化学习/策略3.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略4.png","path":"image/强化学习/策略4.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略P和策略B.png","path":"image/强化学习/策略P和策略B.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/策略P和策略B更新示意图.png","path":"image/强化学习/策略P和策略B更新示意图.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/连续型概率分布示意图.png","path":"image/强化学习/连续型概率分布示意图.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/重要性权重表格.png","path":"image/强化学习/重要性权重表格.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/马尔科夫树.png","path":"image/强化学习/马尔科夫树.png","modified":0,"renderable":0},{"_id":"source/image/强化学习/马尔科夫链.png","path":"image/强化学习/马尔科夫链.png","modified":0,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img.png","path":"image/RNN-LSTM-GRU-GCN/img.png","modified":0,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_1.png","path":"image/RNN-LSTM-GRU-GCN/img_1.png","modified":0,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_2.png","path":"image/RNN-LSTM-GRU-GCN/img_2.png","modified":0,"renderable":0},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_3.png","path":"image/RNN-LSTM-GRU-GCN/img_3.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"93894d35822db147684c8ca1511132fc38db0725","modified":1708432925823},{"_id":"source/.DS_Store","hash":"4bea7c63a8123ff9b87f74cb1ef1c4388efd940c","modified":1695195358048},{"_id":"source/_data/link.yml","hash":"f98992c0731559bcdc7fdc1af1f93b8dbae10649","modified":1694621161236},{"_id":"source/categories/index.md","hash":"8327a464fbe3f93cac6b89401e6315c63eba895f","modified":1693482273118},{"_id":"source/_posts/hello-world.md","hash":"c4dabc86aa226113f500f9c79b3daab53cc7f19e","modified":1716813908177},{"_id":"source/_posts/RNN-LSTM-GRU-GCN.md","hash":"6e52f9a44726dbf1a5d6dc8e9612e65007eccdc1","modified":1716813849681},{"_id":"source/_posts/k8s部署云笔记系统.md","hash":"31daab24a778ebf1f415e6f4bffb2ce4156a35e0","modified":1695395735500},{"_id":"source/_posts/MARL.md","hash":"9ef3f36d4353aa52597efb3640605b25b22ddb9c","modified":1707223879808},{"_id":"source/_posts/云笔记系统扩容.md","hash":"087584c24cf1a57462f77d6463053fefb4d1ce82","modified":1707225167307},{"_id":"source/_posts/前端-移动端面经.md","hash":"1766057fb3b49ce9c2f657460c9b354feca11ba5","modified":1718261648563},{"_id":"source/_posts/react技巧.md","hash":"5b404eaf82d603fe8e3975bc08976dbd56334f24","modified":1716813849685},{"_id":"source/_posts/强化学习.md","hash":"ccebfe756916da1294ca3e02e33e20e15b22a755","modified":1707225304696},{"_id":"source/_posts/手撕相关.md","hash":"f3326998413653478a361ff4bbce89821e112830","modified":1718267267346},{"_id":"source/_posts/框架等面经.md","hash":"17efc8de6c4b3f1e1020d0d4ccecd27af3a14998","modified":1718266681793},{"_id":"source/movies/index.md","hash":"9fdcdf109e4daff4f0a66d140a764c5ce2a55dd7","modified":1693482586713},{"_id":"source/_posts/计算机基础.md","hash":"4ab23e8a1dead5386513e223d92499792750b278","modified":1718266681791},{"_id":"source/music/index.md","hash":"35648eb9af8d7b9fe29bb63e7b321c9cda6fefa0","modified":1693482586718},{"_id":"source/link/index.md","hash":"7a17f4dc4cf4eae0b205dceccf4d76c81d226f58","modified":1693482301378},{"_id":"source/_posts/测开面经.md","hash":"05dd9256d7adfcc9ebf5d35d040aaa9ac33a5a80","modified":1718196888188},{"_id":"source/tags/index.md","hash":"e9b98a407b92523541efe47ea7d4ad42e157124e","modified":1694620980990},{"_id":"source/pictures/index.md","hash":"60581014aace73d200a0719c720bc5f5aba08708","modified":1707225802948},{"_id":"source/image/Database-Interview/13526879-3037b144ed09eb88.png","hash":"6a6ba5d6f15a0fdd546018e5cacbd3509e887c17","modified":1718540301438},{"_id":"source/image/MARL/img_23.png","hash":"6ca8cadc7d839d30cd37a6274948a1c4d906241d","modified":1699429510588},{"_id":"source/image/MARL/img_26.png","hash":"ffe5deb6ad0a6bc709308d4eb7b91e989540d106","modified":1699430679176},{"_id":"source/image/MARL/img_29.png","hash":"a6830f8337fb9a859d4a2c1b07a6a349dad993b8","modified":1699431955161},{"_id":"source/image/MARL/img_31.png","hash":"3a056d2f64c018aad380d09337d10960278e7afe","modified":1699432536093},{"_id":"source/image/MARL/img_37.png","hash":"7fd6214a4f31c0c2174ea359fed9ffbd47135036","modified":1699435251687},{"_id":"source/image/MARL/img_36.png","hash":"6f6d264d3ccd0ec188cbaaa59d717e150361de42","modified":1699435203008},{"_id":"source/image/MARL/img_38.png","hash":"ee0c90f890da5e81d41b0a26bd6c1ac2baf8a44f","modified":1699445855380},{"_id":"source/image/MARL/img_42.png","hash":"76b07804b780b73e29f99bb4c603c9adb7ab4c42","modified":1699447044627},{"_id":"source/image/MARL/img_39.png","hash":"63c5ae9cec80b06bad00c35c5e515fb235ea032b","modified":1699445961327},{"_id":"source/image/MARL/img_4.png","hash":"3a15c0caf011c5d537c2ee6c81ba034271135ae5","modified":1699269298460},{"_id":"source/image/MARL/img_40.png","hash":"3f96da5e3b653c15749281c96391a6d5f7e4ef67","modified":1699445975883},{"_id":"source/image/MARL/img_43.png","hash":"f1abcb06f1c25a812a7c6ed23d247fe9fa0bfb3e","modified":1699447100650},{"_id":"source/image/MARL/img_44.png","hash":"e2577e0813fbf9cc4042287e4b7e3fdd8e041960","modified":1699447161097},{"_id":"source/image/MARL/img_51.png","hash":"438c730fee36179be3196cfb65ac79509f378a0c","modified":1699520914234},{"_id":"source/image/MARL/img_52.png","hash":"d1e26fa21fcf1c9d14374d298de37459511c05f8","modified":1699520939564},{"_id":"source/image/MARL/img_54.png","hash":"44936f25b9fc28b501e9dec0042473a4ea443bb7","modified":1699521055616},{"_id":"source/image/MARL/img_56.png","hash":"e9462c7dbb24de3d1387d770a1bff9ebb0d6862a","modified":1699521123464},{"_id":"source/image/k8s部署云笔记系统/1.png","hash":"cbbc86c9fa5786c5d9f3a2572f2404cd2e28343c","modified":1695134749835},{"_id":"source/image/k8s部署云笔记系统/4.png","hash":"ad4e697fc59a97823ecea4b0b1518e1b47ac554f","modified":1695135164081},{"_id":"source/image/云笔记系统扩容/delete-pod.png","hash":"555dd5ad746957138bf6322fad5a9c016b1c6c8b","modified":1695193512011},{"_id":"source/image/云笔记系统扩容/add-labels.png","hash":"bda66f4607328559c6c30ffdb8c72a609440b6d2","modified":1695193699809},{"_id":"source/image/云笔记系统扩容/expand.png","hash":"b7b091f13ebee50e6be59d2d1c49cb69c459a87d","modified":1695194083229},{"_id":"source/image/云笔记系统扩容/login.png","hash":"a004fc668d822d77284e1cceeee3c06e09501eec","modified":1695193348520},{"_id":"source/image/云笔记系统扩容/backup.png","hash":"5f24217b2cedf48df437fd12b07a40714b3aef42","modified":1695193380118},{"_id":"source/image/云笔记系统扩容/pod-after-deploy.png","hash":"ddb7e4b717be6f48c7f7090c34b5d9fec746589d","modified":1695193845583},{"_id":"source/image/云笔记系统扩容/pod-after-deleted.png","hash":"39cda3ef81cc34d9080163e85134bcad21d70521","modified":1695193632554},{"_id":"source/image/云笔记系统扩容/pod-node.png","hash":"47f61d747d459f2e0a4728c77e01c6f14f287436","modified":1695193233122},{"_id":"source/image/云笔记系统扩容/pod.png","hash":"77a844b176d7492e31868b9ba95bb9e468997de8","modified":1695193123630},{"_id":"source/pictures/gallery_groups/genshin.md","hash":"c4ef1a50d83f665cb7aeda388515a3cd1c02174e","modified":1707225666368},{"_id":"source/image/云笔记系统扩容/setting.png","hash":"4ca95d8e457eba8f21ffe74743f00d479623f20f","modified":1695194013834},{"_id":"source/image/云笔记系统扩容/shutdown.png","hash":"e320600cd94d80e5b89012afdc90a4a8e2668d5d","modified":1695193961828},{"_id":"source/pictures/gallery_groups/lol-kda.md","hash":"71adee600848e1aa15d90b8702421760f29e6127","modified":1707225758126},{"_id":"source/image/云笔记系统扩容/vmware.png","hash":"08bd99db55ee3786a77142de854b7d046410e100","modified":1695193301246},{"_id":"source/pictures/gallery_groups/wabobo.md","hash":"73164a4be798f334646a928e9850e16f3c755e64","modified":1703580802200},{"_id":"source/image/强化学习/DDPG1.png","hash":"ec86ecd8427b549620d9421d9667205585b401f3","modified":1698651842765},{"_id":"source/image/强化学习/DQN公式.png","hash":"c5853cc32e2e37efa40de4b2a428f4dd7e7fd0ee","modified":1698131302833},{"_id":"source/image/强化学习/DQN.png","hash":"b6054f8acddb250924d87682e59743bfae1d4355","modified":1698130997432},{"_id":"source/image/强化学习/DQN更新的是Q值.png","hash":"1513561ff6159ff47546cdd7e625840395a7a9ee","modified":1698396480795},{"_id":"source/image/强化学习/Magic(X).png","hash":"c4b28174d7b8d1ba5cfe66c80ca2f287193cfd35","modified":1698127119630},{"_id":"source/image/强化学习/Qlearning公式.png","hash":"3210173c653c2537862c9dc63ec95346e4295e13","modified":1698075767236},{"_id":"source/image/强化学习/TD(0)更新公式.png","hash":"70db3a258e3932edcdaa7ee9ccf8bc5e398fff89","modified":1698073783866},{"_id":"source/image/强化学习/TD(0)与SARSA对比.png","hash":"ff6c716f5f1a06c11eae440995a09e310ce9b4bd","modified":1698075486710},{"_id":"source/image/强化学习/SARSA.png","hash":"ea6aaf0c6b5dc7953045fb7700800ee3fdc700db","modified":1698075261938},{"_id":"source/image/强化学习/SARSA公式.png","hash":"40ca3c4957b16bc405d1da6ba263502c7e67e33a","modified":1698075438789},{"_id":"source/image/强化学习/V值转Q值1.png","hash":"a40ef07f53519b337bf0ff6b7ae97be0267b4c90","modified":1698067290092},{"_id":"source/image/强化学习/二维曲线.png","hash":"79d6d24224cb080eebcbacf9ea3fc9150f0e1efa","modified":1698130005699},{"_id":"source/image/强化学习/公式2.png","hash":"6581547a28f03a38bb1ff7f6795b54ce4b8ceb34","modified":1698067330761},{"_id":"source/image/强化学习/为什么不估算Q.png","hash":"bdd8c9609d188eccae505e62cd91653f97f44bff","modified":1698142267178},{"_id":"source/image/强化学习/复习MC.png","hash":"58bb9a31d6fe9d72e328eb968c3f3efdb89d49b2","modified":1698139201629},{"_id":"source/image/强化学习/公式1.png","hash":"40830fb8aa8c518414a8990c89574e7bc776afde","modified":1698066893279},{"_id":"source/image/强化学习/更新公式.png","hash":"b35143195b71b232c3dab90a86407538ba47319e","modified":1698072937063},{"_id":"source/image/强化学习/普通DQN.png","hash":"477f4e29663b44367dbd4beb42add37a4d9a9390","modified":1698137439974},{"_id":"source/image/强化学习/正态分布.png","hash":"3b4c5269bc41c9847e25e991a4fa9cddf4cba1d5","modified":1698393944004},{"_id":"source/image/强化学习/用下一个动作的Q代替V.png","hash":"8223f6e6e3013863bf48ca6af031129bb47ece6c","modified":1698074546181},{"_id":"source/image/强化学习/离散动作-策略分布.png","hash":"7ea3a2855155e0ba0d4340490c30e665520ef086","modified":1698393601833},{"_id":"source/image/强化学习/策略2.png","hash":"6338e81e51fa44716e4bb5aa7153001f7002f37b","modified":1698066082805},{"_id":"source/image/强化学习/策略1.png","hash":"03e05721672d45f7d1cfcecc8dc1c49330b49080","modified":1698066048393},{"_id":"source/image/强化学习/重要性权重表格.png","hash":"c636ebf159c7d5a8abdcb5324b0fb2e9dd7cbdb6","modified":1698649484352},{"_id":"source/image/强化学习/马尔科夫链.png","hash":"d54e77948355fb074bff4974edd3d4ee30756835","modified":1698075038617},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_1.png","hash":"9c4d7fb94cf4d88efa0f1d57c50837b1e5aa113f","modified":1703162286448},{"_id":"source/_posts/数据库.md","hash":"b4f5e8d22e16fea338859906cb7d5dfda3e4efd1","modified":1718720497420},{"_id":"source/image/MARL/img_1.png","hash":"6d1ebca900fd3c98a7382ea4cc52c9f9fb4bf6d6","modified":1699263064926},{"_id":"source/image/MARL/img.png","hash":"1a15c68b483bbe455c739a3e63d00f9bf517dd8f","modified":1699447688422},{"_id":"source/image/MARL/img_11.png","hash":"99d56908d7c6e6e00ee9cdebe963f253dd55f2c3","modified":1699275805693},{"_id":"source/image/MARL/img_10.png","hash":"19a0f333d77505aa50e3ce3a4cf8dbdef15a9a08","modified":1699275769385},{"_id":"source/image/MARL/img_14.png","hash":"a4270b1a9cc1d89e4ef81eb6288306bccd423293","modified":1699276381627},{"_id":"source/image/MARL/img_12.png","hash":"04e35d22666436dd7c937da31d6107769694cfe1","modified":1699276141729},{"_id":"source/image/MARL/img_21.png","hash":"159c9d40e4c3b86ce74dad3627eea0925c05d3d8","modified":1699348867917},{"_id":"source/image/MARL/img_22.png","hash":"7ae93ca4e125194633a84b6623e892d306563147","modified":1699429410488},{"_id":"source/image/MARL/img_25.png","hash":"780801543fbad5a539da734659da4267e98f6226","modified":1699430563834},{"_id":"source/image/MARL/img_27.png","hash":"7f45efb57054b5c741adf1338e074b7cb72f4682","modified":1699431715584},{"_id":"source/image/MARL/img_28.png","hash":"3331cbf3b0f5e02aad69ae549a2ca2992e4bc09b","modified":1699431810901},{"_id":"source/image/MARL/img_32.png","hash":"d19088279eea2d8be2c91789bed07bb8b9157cf3","modified":1699433871624},{"_id":"source/image/MARL/img_3.png","hash":"3cd6383d45a693af460d791b6397edadefb54dd7","modified":1699264231549},{"_id":"source/image/MARL/img_33.png","hash":"1d5a7d97483e1b7f9b15babafa9edaecd16a1ae5","modified":1699434003076},{"_id":"source/image/MARL/img_34.png","hash":"c40b199cbfa1e48eeb2f48703d97612b10cf8ddd","modified":1699434698850},{"_id":"source/image/MARL/img_35.png","hash":"9c3f707a1e976d26367cef5b697a1e1713e9d30a","modified":1699434762807},{"_id":"source/image/MARL/img_41.png","hash":"dc99ef84a23747bf1df39ffa75f65142833c50f2","modified":1699446131663},{"_id":"source/image/MARL/img_45.png","hash":"653093958a2cd8ec02eb57999be05dae36d22c78","modified":1699510828329},{"_id":"source/image/MARL/img_47.png","hash":"97bd6ad4c936907889397163b6b82f058bfeb8a5","modified":1699520646167},{"_id":"source/image/MARL/img_49.png","hash":"6f42c5de881e8e0e2f9205397492403608d305ea","modified":1699520732221},{"_id":"source/image/MARL/img_48.png","hash":"4a35a0f5f5d3db09ed2ffaed576384bd8b3a5b7f","modified":1699520709218},{"_id":"source/image/MARL/img_46.png","hash":"075ab0887e92c81a785a7fd5cc529e02d5b827a2","modified":1699510865035},{"_id":"source/image/MARL/img_50.png","hash":"d2a92cb31f82e75f76a836677ba630056c8a76de","modified":1699520797975},{"_id":"source/image/MARL/img_53.png","hash":"e77f4991c711db44fc958f9ff5848b3d23fa2155","modified":1699520990504},{"_id":"source/image/MARL/img_6.png","hash":"34f870290763316b68e4b0654992943d463b55ad","modified":1699272206553},{"_id":"source/image/MARL/img_55.png","hash":"2ae039d4635d2584df1aa70813fe0823ba64cd9a","modified":1699521090374},{"_id":"source/image/MARL/img_7.png","hash":"069091e238963421f52d381826bea91e89ca7fda","modified":1699272259493},{"_id":"source/image/MARL/img_9.png","hash":"5c9bd19962a9def0dc103325550201d406ebf1f9","modified":1699275717293},{"_id":"source/image/k8s部署云笔记系统/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1695135238989},{"_id":"source/image/云笔记系统扩容/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1695135238989},{"_id":"source/image/云笔记系统扩容/xftp.png","hash":"e3cb8d796d3576397b91f6168a106dcc215b85d6","modified":1695193439539},{"_id":"source/image/强化学习/A3C1.png","hash":"3005353326c11c8aebe3a637638f7be5f43a7825","modified":1698655179811},{"_id":"source/image/强化学习/DDPG2.png","hash":"e4df30b144f63e269dde8e2bd9fd613bc2a55551","modified":1698652051389},{"_id":"source/image/强化学习/AC算法.png","hash":"a1a024144b42ea965070692c87648dbc17640a5a","modified":1698143519699},{"_id":"source/image/强化学习/DuelDQN.png","hash":"e6a024745d81a004dbc9372754e0afcbea8500cd","modified":1698137595387},{"_id":"source/image/强化学习/DuelDQN网络架构.png","hash":"5faebac7e88f43d768347d2a44f5ea635aef5f93","modified":1698137812624},{"_id":"source/image/强化学习/Magic'(X).png","hash":"915a394ba63779fa45fb4ab337d35e9aa3656a1d","modified":1698127506423},{"_id":"source/image/强化学习/Qtable三维可视化.png","hash":"19e2457ff644019941c4e4889e271ae19851c8b7","modified":1698129622900},{"_id":"source/image/强化学习/Qlearning图解.png","hash":"99e1f7c3c09e8b8ff40013e5274197e84bbeccac","modified":1698075645794},{"_id":"source/image/强化学习/TD(0)图解.png","hash":"442c7c3185254c616b7dd581d3122c5b287d0609","modified":1698073834475},{"_id":"source/image/强化学习/TD3.png","hash":"f742b6d7ea08bddec59b241f4623e3a292fc8a99","modified":1698652474564},{"_id":"source/image/强化学习/TD-error.png","hash":"6cd354a8357bd9b351204db8ffbc86f14fa46388","modified":1698142535138},{"_id":"source/image/强化学习/V值转V值.png","hash":"04d61bd802407d82933d4fc3d48f655f82195df6","modified":1698067562607},{"_id":"source/image/强化学习/fix-Q-targets.png","hash":"28054b2d0b4c65f2e515366675d183072dc0670c","modified":1698132299748},{"_id":"source/image/强化学习/例子1.png","hash":"9f00eb53650a1323eed0c41405bc446f1edc0bc0","modified":1698065976437},{"_id":"source/image/强化学习/回顾DQN.png","hash":"3d6ef5df0f373b7e934dce35691e99cc2274e453","modified":1698651187817},{"_id":"source/image/强化学习/扭曲的曲线.png","hash":"1e785c5e507fcb8999cddd62724b194be6dbbae0","modified":1698129712910},{"_id":"source/image/强化学习/数据加工厂.png","hash":"0f6de0db66dba3926063c5e15801273c016eefe6","modified":1698127723223},{"_id":"source/image/强化学习/用TD估计Q值.png","hash":"4ae7ab1a840d2f66a6796920a561642608012404","modified":1698074262645},{"_id":"source/image/强化学习/直观感受PG2.png","hash":"dc3b790d0138431bd36ca86d9cecb4c3724948d0","modified":1698139454702},{"_id":"source/image/强化学习/直观感受PG1.png","hash":"abe569e686536c668a3f038c9a57052c6bcbc9d4","modified":1698139289526},{"_id":"source/image/强化学习/直观感受PG3.png","hash":"76a2980409108c0cb4330cee7d3bf27d0c7ea8b5","modified":1698139536195},{"_id":"source/image/强化学习/由G值算V值.png","hash":"4cd7c7aa68eba7d540f8d6ad3700f913b98b14d0","modified":1698068207405},{"_id":"source/image/强化学习/策略3.png","hash":"07c8459c5961babf996f8b4c16ab17b11c7f4c43","modified":1698068386281},{"_id":"source/image/强化学习/策略4.png","hash":"e7bfcbf76f24fe190ab7ed50a0f2085b22496cd6","modified":1698068425514},{"_id":"source/image/强化学习/连续型概率分布示意图.png","hash":"b3772e1cf96f08a1e289bc51c9c44750ce3c07ce","modified":1698393732421},{"_id":"source/image/RNN-LSTM-GRU-GCN/img.png","hash":"b5e3b81743830a235f98a3ed98888664ac1b8c01","modified":1703162192732},{"_id":"source/image/强化学习/策略P和策略B.png","hash":"2ea5ef3287f9d2a216c9d2abf8ddf49bf0ab8989","modified":1698395660821},{"_id":"source/_posts/Java后端面经.md","hash":"20cbefe3b108d9f87130bc14711ca371ce7044d2","modified":1718277764088},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_3.png","hash":"3ccf1aae722c09b1b8ab22b5270e33b37eafcb55","modified":1703162506776},{"_id":"source/image/强化学习/策略P和策略B更新示意图.png","hash":"61b7166aad0636090777247c4d4cff7d05177234","modified":1698396201316},{"_id":"source/image/MARL/img_13.png","hash":"439f1936f67cafa07c0e856eb64d49720f67637b","modified":1699276162593},{"_id":"source/image/MARL/img_15.png","hash":"e8f55f26c5bed2b0e1f9926d71fb84480180790b","modified":1699276421196},{"_id":"source/image/MARL/img_16.png","hash":"66909131a240f3e754bc656e4303d21815e7d100","modified":1699276517300},{"_id":"source/image/MARL/img_2.png","hash":"ab12cb07c1c4e44b70dc35a0a925544ac2a6e115","modified":1699263964324},{"_id":"source/image/MARL/img_17.png","hash":"f4a452e9775d395bfa369d54c14fca91c00b7a17","modified":1699276590851},{"_id":"source/image/MARL/img_20.png","hash":"0a3e3919dc0fa73b206df79f1c3c600d92defc2a","modified":1699276662379},{"_id":"source/image/MARL/img_8.png","hash":"803f9cd2e5768da860f76667e589d5b77a201340","modified":1699274324531},{"_id":"source/image/k8s部署云笔记系统/2.png","hash":"eae90eb1b195c84430fe54a09819862bdd352a2f","modified":1695135048964},{"_id":"source/image/k8s部署云笔记系统/5.png","hash":"1432b61eb04256e0627913d0e3323eff178626b1","modified":1695135226787},{"_id":"source/image/MARL/img_5.png","hash":"fa4cb933ca9f685f35f49d8262b4192a1955968b","modified":1699269359830},{"_id":"source/image/云笔记系统扩容/backup-desktop.png","hash":"e6ec39385bcd11c4db8a3599509e3fc40f0bce83","modified":1695193567047},{"_id":"source/image/强化学习/A3C.png","hash":"137d1bfc646d4aec2c83a97b339b58bc59ff81fa","modified":1698655021495},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1693301015683},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1693301015694},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1693301015683},{"_id":"themes/butterfly/.DS_Store","hash":"3c9af3e41223fcbc007179853fab8522390ad97a","modified":1697703842380},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1693301015683},{"_id":"themes/butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":1693301015683},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1693301015684},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1693301015684},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1693301015684},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1693301015684},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1693301015684},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1693301015684},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1693301015694},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1693301015694},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1693301015694},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1693301015694},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1693301015694},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1693301015683},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1693301015683},{"_id":"themes/butterfly/source/.DS_Store","hash":"2ff68457468623d62e1bfed5ae9879e1611800b6","modified":1697703837344},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1693301015683},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1693301015682},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1693301015687},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1693301015683},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"b8e05ea08ef5548c37d8022e76403c77d62d5d1a","modified":1695209464605},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1693301015694},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1693301015695},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1693301015695},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1693301015695},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1693301015695},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1693301015687},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1693301015695},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1693301015687},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1693301015695},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1693301015695},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1693301015696},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1693301015696},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1693301015695},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1693301015696},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1693301015701},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693301015701},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1693301015701},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693301015701},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693301015702},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1693301015702},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1693301015684},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1693301015685},{"_id":"themes/butterfly/source/img/wechat.JPG","hash":"6f338f11da8b9f568bde4a9255b4eefe29343c22","modified":1693472433708},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1693301015703},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1693301015685},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1693301015686},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1693301015702},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1693301015686},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1693301015694},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1693301015694},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1693301015697},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1693301015697},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1693301015699},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1693301015699},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1693301015698},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1693301015699},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1693301015699},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1693301015699},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1693301015700},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1693301015699},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1693301015700},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1693301015700},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1693301015700},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1693301015686},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1693301015700},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1693301015687},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1693301015700},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1693301015701},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1693301015701},{"_id":"themes/butterfly/source/img/background/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1697817149228},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1693301015702},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1693301015702},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1693301015700},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1693301015687},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1693301015688},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1693301015689},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"00960bf483318e76ee4e1d90456f0e934959a8c5","modified":1695269671591},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1693301015690},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1693301015691},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1693301015693},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1693301015692},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1693301015692},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1693301015697},{"_id":"source/image/强化学习/G值的意义.png","hash":"68992cb8a2194c779748e9a34ffccfb4156d25df","modified":1698067941803},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1693301015697},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1693301015697},{"_id":"source/image/强化学习/Q'估计Q 2.png","hash":"d4b88893a5d0c2d81e9ca846e4129c53ef989d1b","modified":1698654081600},{"_id":"source/image/强化学习/Q值的定义.png","hash":"969a8e6a7d764e5f3366de0b46fd22d34f6c90a2","modified":1698066186438},{"_id":"source/image/强化学习/Q'估算Q 1.png","hash":"fe5352cc8507ff0748c0e3bb0d90acd8055753e8","modified":1698654037660},{"_id":"source/image/强化学习/Q=S+A表格.png","hash":"8277d01e72f923f488d82cda32befd415d203f40","modified":1698137333051},{"_id":"source/image/强化学习/Q值转V值1.png","hash":"e168cf4b797ea342ea2cf45a15030424f594c7bf","modified":1698066824962},{"_id":"source/image/强化学习/TD(0).png","hash":"46c1b1d85bc500d3317fc98af24cc00407e4c3a2","modified":1698072622958},{"_id":"source/image/强化学习/V值的定义.png","hash":"9a95cb005f86b501901dbe8ecd63f4857ce45857","modified":1698065682845},{"_id":"source/image/强化学习/TD(N).png","hash":"cf4525e94a10fd8c40d5324f9a616edf0bb5e04d","modified":1698650138224},{"_id":"source/image/强化学习/两种理解方式.png","hash":"8ce85b9a7824394c5ff8eb685af6be073093b9d2","modified":1698070616781},{"_id":"source/image/强化学习/学习路线.png","hash":"34e7356e916c72ca4c778d116badc860ea1b8146","modified":1698063001345},{"_id":"source/image/强化学习/坑的解释.png","hash":"dc5251c2966f88383d3eaa7c92ac1961ab29b739","modified":1698074712932},{"_id":"source/image/RNN-LSTM-GRU-GCN/img_2.png","hash":"0e93fa825353061329cc917c8f98cd30f4591370","modified":1703162400100},{"_id":"source/image/MARL/img_19.png","hash":"6f2d0f1b01b1e55d1132aba9841ce70c908871ab","modified":1699276652495},{"_id":"source/image/MARL/img_18.png","hash":"98e324069ae326b697ea9fcdec3bfe9c8246ad19","modified":1699276636497},{"_id":"source/image/k8s部署云笔记系统/3.png","hash":"85cfb5ad615d808491052523c665dd38c152b148","modified":1695135130751},{"_id":"themes/butterfly/source/img/alipay.JPG","hash":"242f28ac6b31ce2fae669f9b357f88b19a1a755a","modified":1693472403927},{"_id":"source/image/强化学习/Q值转V值.png","hash":"2aff0b6882884466d6a727e42a9df19c6117b768","modified":1698066509888},{"_id":"source/image/强化学习/V值转Q值.png","hash":"2abc3e4c268f8a277ff1b1596d1fcd2d6f328d0a","modified":1698067186694},{"_id":"source/image/强化学习/理解DDPG2.png","hash":"d96a5ac6aa63978a4bca742c5c13319cc5acdd8f","modified":1698651557112},{"_id":"source/image/强化学习/理解DDPG1.png","hash":"31f1afbdee99c095a0939941bc0cf2f815c3a2e1","modified":1698651459850},{"_id":"source/image/强化学习/马尔科夫树.png","hash":"60c324eaffab2259fbdcb415a356f29088b182bd","modified":1698064272462},{"_id":"source/image/MARL/img_30.png","hash":"cd0054217d899963732fd6f7f7244fdf8ec27ee5","modified":1699432426918},{"_id":"themes/butterfly/source/js/Valine.min.js","hash":"c19fcca376470c5049873475548131c31e8a950b","modified":1695225699254},{"_id":"themes/butterfly/source/img/background/樱花2.jpg","hash":"858a926496f17529430ef9c1b56aa3a25abb97af","modified":1695213776091},{"_id":"themes/butterfly/source/img/assets/头像.JPG","hash":"2982b004f5f53918d2a6083056455bf3a479d60d","modified":1667716281000},{"_id":"themes/butterfly/source/img/background/樱花1.jpg","hash":"ffa38044c2b06e88c45468340c916e862b599b51","modified":1695213803321},{"_id":"source/image/云笔记系统扩容/pod-deploy.png","hash":"5d7087ce3dfa3e1c38cee56e75eef71845787de5","modified":1695193780237},{"_id":"source/image/MARL/img_24.png","hash":"db26640a9ac6de9c1e6f5a4c436f10a8598ecead","modified":1699430434980},{"_id":"source/image/k8s部署云笔记系统/可莉.png","hash":"19e482e216be26cf376cce9c2f26f95507cc8963","modified":1690225383971},{"_id":"public/search.xml","hash":"a9c4de3252bb7145722af5d69195fa9be752da66","modified":1718721285391},{"_id":"public/categories/index.html","hash":"54a7c75b6b052756776dc12240213ebbf750263f","modified":1718721285391},{"_id":"public/about/index.html","hash":"e700f24731d9398b28f8948e4b1bbdafdd255ace","modified":1718721285391},{"_id":"public/movies/index.html","hash":"a23f812db24b15e57efa8c7c6782d9acb011bf37","modified":1718721285391},{"_id":"public/link/index.html","hash":"718c27f9702960f7853ef28ad13208b3643a7d5a","modified":1718721285391},{"_id":"public/music/index.html","hash":"88a6d72e9cddd47c7c7e4a317add140a7f044354","modified":1718721285391},{"_id":"public/tags/index.html","hash":"5e006dba3cd4cb5dade894e8d0ec1f72eb36bc85","modified":1718721285391},{"_id":"public/pictures/index.html","hash":"8815c6f97202376c368010a4a3d237fde6baaf04","modified":1718721285391},{"_id":"public/pictures/gallery_groups/genshin.html","hash":"9e3ff03a0c2dd0551b899981b042ed3a9924c38f","modified":1718721285391},{"_id":"public/pictures/gallery_groups/lol-kda.html","hash":"6e00114ee7101831cacd25d1fb0b1e9094d2f857","modified":1718721285391},{"_id":"public/pictures/gallery_groups/wabobo.html","hash":"591661a844b1b30eac421d32b86eba96021a4a61","modified":1718721285391},{"_id":"public/posts/17772.html","hash":"975de3881c3770df6f7e8d1716095ed8867c451f","modified":1718721285391},{"_id":"public/posts/17771.html","hash":"2ec4e0c7b6ced2e2e52e2b08624ba17574641203","modified":1718721285391},{"_id":"public/posts/17769.html","hash":"568a0d87586ff3120b9167401f91ce1c5c90081d","modified":1718721285391},{"_id":"public/posts/17770.html","hash":"a2997b7a808e98d07833f8333fd6f93649b8d1e6","modified":1718721285391},{"_id":"public/posts/17768.html","hash":"7145f83eb6b67c623fa7eee8a6404547c830c532","modified":1718721285391},{"_id":"public/posts/17767.html","hash":"6e8dcfb7c6f513381442e711c011dc8e5cee1538","modified":1718721285391},{"_id":"public/posts/17766.html","hash":"16ae38b39b427849bd35b9caa1c1dcab1e07ae6c","modified":1718721285391},{"_id":"public/posts/17765.html","hash":"e9130c3428324cfa4928af490c92e710a14aad34","modified":1718721285391},{"_id":"public/posts/17763.html","hash":"4e6746c2174929092d73a1644c9cdedc597d3829","modified":1718721285391},{"_id":"public/posts/17762.html","hash":"1efbe72fc721f26c61ed6ca4762d41c8892b3fd2","modified":1718721285391},{"_id":"public/posts/56292.html","hash":"fe1af14790ee496e03982138db90306132281e71","modified":1718721285391},{"_id":"public/posts/36313.html","hash":"478fabf67a172cbc9640fa7311f3f49e633df168","modified":1718721285391},{"_id":"public/posts/16330.html","hash":"ceba09669d77d27b31af0d86def82b3f58da41cc","modified":1718721285391},{"_id":"public/posts/16107.html","hash":"ab2478c81be7098123d6af7dd9f8e36fa1d38ca7","modified":1718721285391},{"_id":"public/archives/index.html","hash":"d49adbe3409ada263f2fa14814854147ae22d332","modified":1718721285391},{"_id":"public/archives/page/2/index.html","hash":"25b4ad9300097c9821fc6b7407afa879b187f685","modified":1718721285391},{"_id":"public/archives/2018/index.html","hash":"bef3d0b174c0c64bb2994159bb05078208e922c9","modified":1718721285391},{"_id":"public/archives/2018/01/index.html","hash":"e0c7c82508a90f2a427113c31e6a6cb485c0d12e","modified":1718721285391},{"_id":"public/archives/2023/index.html","hash":"b980c4c1d9fcc6da8246750678e2124bbce228fb","modified":1718721285391},{"_id":"public/archives/2023/09/index.html","hash":"033b2cd546da26a8ced8069d11abdfeddfed73d7","modified":1718721285391},{"_id":"public/archives/2023/10/index.html","hash":"dc9ee8a3dd768e2ed0e0b5c65fa123075d7e4ea4","modified":1718721285391},{"_id":"public/archives/2023/12/index.html","hash":"2568a13703d054ddd9707d4f9de1acb2bd63c52a","modified":1718721285391},{"_id":"public/archives/2024/index.html","hash":"eab8d461c8bed69ae5230c4f5effb2b64ca8f7d5","modified":1718721285391},{"_id":"public/archives/2024/05/index.html","hash":"068536424885d0dfa329f7b83b7630113f50e026","modified":1718721285391},{"_id":"public/archives/2024/06/index.html","hash":"61f89ae25e21e16a0eecda1b6b08b6f5caf2fc1f","modified":1718721285391},{"_id":"public/categories/算法/index.html","hash":"ae8e7a7bc76b10861bde2184aa764c0012f7ce4e","modified":1718721285391},{"_id":"public/categories/强化学习/index.html","hash":"4b2f20ca289a7b70b17b8812e794682fcd5f11f7","modified":1718721285391},{"_id":"public/categories/hexo/index.html","hash":"12dca4b34229a8daeb6d5f665c37af376fa0ef63","modified":1718721285391},{"_id":"public/categories/Kubernetes/index.html","hash":"6f73184c47599d650c9d5fda3ff08a6c622e046f","modified":1718721285391},{"_id":"public/categories/react/index.html","hash":"69b2499e1fd321323c1b4010bacf0d427daccf57","modified":1718721285391},{"_id":"public/categories/面经/index.html","hash":"14afa558c9a0b722718a43903950273f2e028ea2","modified":1718721285391},{"_id":"public/categories/强化学习/多智能体强化学习/index.html","hash":"15f648218566a2a4043fbc0cd6d38d69fb808eab","modified":1718721285391},{"_id":"public/index.html","hash":"f7386eec53751f1cc6d36aa51a61f0e81facf0af","modified":1718721285391},{"_id":"public/page/2/index.html","hash":"b9f8bb64e20b1ba2ec48a43911849e4009abc739","modified":1718721285391},{"_id":"public/tags/算法/index.html","hash":"3a36db79d66a02cd572e94abbdadc31aaab360a8","modified":1718721285391},{"_id":"public/tags/强化学习/index.html","hash":"34a00926dbd1c8b7098230dfc8ce44e8d062ccbc","modified":1718721285391},{"_id":"public/tags/多智能体强化学习/index.html","hash":"f669888ea4088110711a2352abf1a7cb9ba21f8d","modified":1718721285391},{"_id":"public/tags/hexo/index.html","hash":"79ea7f7722e3e4d553aca690af2c5252fbb1438b","modified":1718721285391},{"_id":"public/tags/教程/index.html","hash":"b82b83e2249cd0711274f9475e250566657fee29","modified":1718721285391},{"_id":"public/tags/k8s/index.html","hash":"ff576fb62423a51827b41a5bbb0131ee868d82bf","modified":1718721285391},{"_id":"public/tags/Kubernetes/index.html","hash":"d8d984b58cb1da5045ee39149be6bbd886ace0b5","modified":1718721285391},{"_id":"public/tags/移动端/index.html","hash":"93a4f1f92384b47cc3dd7f7b87e4433e8d5b317b","modified":1718721285391},{"_id":"public/tags/前端/index.html","hash":"612ba7664e44c17dee76ec48a08d24f3c70454ee","modified":1718721285391},{"_id":"public/tags/react/index.html","hash":"2088ef7b13c2380afc38a2cb40201e3cbb6a1464","modified":1718721285391},{"_id":"public/tags/react-native/index.html","hash":"5bed7c6b66bdeea93aca8cd2bed064f340320874","modified":1718721285391},{"_id":"public/tags/面经/index.html","hash":"5a6a7a8b14ae881f9a6e85c3fc0e84ec5baf489f","modified":1718721285391},{"_id":"public/tags/框架/index.html","hash":"ee815db252258fd09efd4de04dc2720f8f3b17df","modified":1718721285391},{"_id":"public/tags/手撕技巧/index.html","hash":"1ec032514a2545c72c1346253590e084cdf476f9","modified":1718721285391},{"_id":"public/tags/计算机网络/index.html","hash":"2401a953d8f20e41d213e2e7b95b8fdbc78f5a90","modified":1718721285391},{"_id":"public/tags/操作系统/index.html","hash":"83d9d17f69def3b4e8e8e750b63a1961dc9cc033","modified":1718721285391},{"_id":"public/tags/测试开发/index.html","hash":"df087662ca753abd46a9e46d7e79243c096dafd1","modified":1718721285391},{"_id":"public/tags/Java/index.html","hash":"686c1dfed6b9b18caa9d35953382efcc5c7c70b9","modified":1718721285391},{"_id":"public/tags/数据库/index.html","hash":"5f5bd7f8df5dc697752f621c32697e29de8e5da7","modified":1718721285391},{"_id":"public/tags/SQL/index.html","hash":"5ab893e7500177fb6c5364058dc5128e25b7b976","modified":1718721285391},{"_id":"public/tags/NoSQL/index.html","hash":"eaa7d5ea4d646a165c6451629d7ff5610f78d476","modified":1718721285391},{"_id":"public/tags/MySQL/index.html","hash":"befecb740c3300f1fadc1f0cae1d335e5fed9750","modified":1718721285391},{"_id":"public/tags/mongodb/index.html","hash":"bc118d0de06a6c8e51fb261a07567479b50e123c","modified":1718721285391},{"_id":"public/tags/Redis/index.html","hash":"61a75fd083955ab572d035f2dda22d4fcf81e51d","modified":1718721285391},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1718721285391},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1718721285391},{"_id":"public/img/wechat.JPG","hash":"6f338f11da8b9f568bde4a9255b4eefe29343c22","modified":1718721285391},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1718721285391},{"_id":"public/image/Database-Interview/13526879-3037b144ed09eb88.png","hash":"6a6ba5d6f15a0fdd546018e5cacbd3509e887c17","modified":1718721285391},{"_id":"public/image/MARL/img_23.png","hash":"6ca8cadc7d839d30cd37a6274948a1c4d906241d","modified":1718721285391},{"_id":"public/image/MARL/img_26.png","hash":"ffe5deb6ad0a6bc709308d4eb7b91e989540d106","modified":1718721285391},{"_id":"public/image/MARL/img_29.png","hash":"a6830f8337fb9a859d4a2c1b07a6a349dad993b8","modified":1718721285391},{"_id":"public/image/MARL/img_36.png","hash":"6f6d264d3ccd0ec188cbaaa59d717e150361de42","modified":1718721285391},{"_id":"public/image/MARL/img_38.png","hash":"ee0c90f890da5e81d41b0a26bd6c1ac2baf8a44f","modified":1718721285391},{"_id":"public/image/MARL/img_37.png","hash":"7fd6214a4f31c0c2174ea359fed9ffbd47135036","modified":1718721285391},{"_id":"public/image/MARL/img_4.png","hash":"3a15c0caf011c5d537c2ee6c81ba034271135ae5","modified":1718721285391},{"_id":"public/image/MARL/img_40.png","hash":"3f96da5e3b653c15749281c96391a6d5f7e4ef67","modified":1718721285391},{"_id":"public/image/MARL/img_31.png","hash":"3a056d2f64c018aad380d09337d10960278e7afe","modified":1718721285391},{"_id":"public/image/MARL/img_39.png","hash":"63c5ae9cec80b06bad00c35c5e515fb235ea032b","modified":1718721285391},{"_id":"public/image/MARL/img_42.png","hash":"76b07804b780b73e29f99bb4c603c9adb7ab4c42","modified":1718721285391},{"_id":"public/image/MARL/img_44.png","hash":"e2577e0813fbf9cc4042287e4b7e3fdd8e041960","modified":1718721285391},{"_id":"public/image/MARL/img_43.png","hash":"f1abcb06f1c25a812a7c6ed23d247fe9fa0bfb3e","modified":1718721285391},{"_id":"public/image/MARL/img_51.png","hash":"438c730fee36179be3196cfb65ac79509f378a0c","modified":1718721285391},{"_id":"public/image/MARL/img_52.png","hash":"d1e26fa21fcf1c9d14374d298de37459511c05f8","modified":1718721285391},{"_id":"public/image/MARL/img_54.png","hash":"44936f25b9fc28b501e9dec0042473a4ea443bb7","modified":1718721285391},{"_id":"public/image/MARL/img_56.png","hash":"e9462c7dbb24de3d1387d770a1bff9ebb0d6862a","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/1.png","hash":"cbbc86c9fa5786c5d9f3a2572f2404cd2e28343c","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/4.png","hash":"ad4e697fc59a97823ecea4b0b1518e1b47ac554f","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/add-labels.png","hash":"bda66f4607328559c6c30ffdb8c72a609440b6d2","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/backup.png","hash":"5f24217b2cedf48df437fd12b07a40714b3aef42","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/delete-pod.png","hash":"555dd5ad746957138bf6322fad5a9c016b1c6c8b","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/expand.png","hash":"b7b091f13ebee50e6be59d2d1c49cb69c459a87d","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/pod-after-deleted.png","hash":"39cda3ef81cc34d9080163e85134bcad21d70521","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/login.png","hash":"a004fc668d822d77284e1cceeee3c06e09501eec","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/pod-after-deploy.png","hash":"ddb7e4b717be6f48c7f7090c34b5d9fec746589d","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/pod.png","hash":"77a844b176d7492e31868b9ba95bb9e468997de8","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/pod-node.png","hash":"47f61d747d459f2e0a4728c77e01c6f14f287436","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/setting.png","hash":"4ca95d8e457eba8f21ffe74743f00d479623f20f","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/vmware.png","hash":"08bd99db55ee3786a77142de854b7d046410e100","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/shutdown.png","hash":"e320600cd94d80e5b89012afdc90a4a8e2668d5d","modified":1718721285391},{"_id":"public/image/强化学习/DDPG1.png","hash":"ec86ecd8427b549620d9421d9667205585b401f3","modified":1718721285391},{"_id":"public/image/强化学习/DQN公式.png","hash":"c5853cc32e2e37efa40de4b2a428f4dd7e7fd0ee","modified":1718721285391},{"_id":"public/image/强化学习/DQN.png","hash":"b6054f8acddb250924d87682e59743bfae1d4355","modified":1718721285391},{"_id":"public/image/强化学习/DQN更新的是Q值.png","hash":"1513561ff6159ff47546cdd7e625840395a7a9ee","modified":1718721285391},{"_id":"public/image/强化学习/Magic(X).png","hash":"c4b28174d7b8d1ba5cfe66c80ca2f287193cfd35","modified":1718721285391},{"_id":"public/image/强化学习/Qlearning公式.png","hash":"3210173c653c2537862c9dc63ec95346e4295e13","modified":1718721285391},{"_id":"public/image/强化学习/SARSA.png","hash":"ea6aaf0c6b5dc7953045fb7700800ee3fdc700db","modified":1718721285391},{"_id":"public/image/强化学习/SARSA公式.png","hash":"40ca3c4957b16bc405d1da6ba263502c7e67e33a","modified":1718721285391},{"_id":"public/image/强化学习/TD(0)与SARSA对比.png","hash":"ff6c716f5f1a06c11eae440995a09e310ce9b4bd","modified":1718721285391},{"_id":"public/image/强化学习/TD(0)更新公式.png","hash":"70db3a258e3932edcdaa7ee9ccf8bc5e398fff89","modified":1718721285391},{"_id":"public/image/强化学习/V值转Q值1.png","hash":"a40ef07f53519b337bf0ff6b7ae97be0267b4c90","modified":1718721285391},{"_id":"public/image/强化学习/为什么不估算Q.png","hash":"bdd8c9609d188eccae505e62cd91653f97f44bff","modified":1718721285391},{"_id":"public/image/强化学习/二维曲线.png","hash":"79d6d24224cb080eebcbacf9ea3fc9150f0e1efa","modified":1718721285391},{"_id":"public/image/强化学习/公式2.png","hash":"6581547a28f03a38bb1ff7f6795b54ce4b8ceb34","modified":1718721285391},{"_id":"public/image/强化学习/公式1.png","hash":"40830fb8aa8c518414a8990c89574e7bc776afde","modified":1718721285391},{"_id":"public/image/强化学习/复习MC.png","hash":"58bb9a31d6fe9d72e328eb968c3f3efdb89d49b2","modified":1718721285391},{"_id":"public/image/强化学习/普通DQN.png","hash":"477f4e29663b44367dbd4beb42add37a4d9a9390","modified":1718721285391},{"_id":"public/image/强化学习/更新公式.png","hash":"b35143195b71b232c3dab90a86407538ba47319e","modified":1718721285391},{"_id":"public/image/强化学习/正态分布.png","hash":"3b4c5269bc41c9847e25e991a4fa9cddf4cba1d5","modified":1718721285391},{"_id":"public/image/强化学习/用下一个动作的Q代替V.png","hash":"8223f6e6e3013863bf48ca6af031129bb47ece6c","modified":1718721285391},{"_id":"public/image/强化学习/策略2.png","hash":"6338e81e51fa44716e4bb5aa7153001f7002f37b","modified":1718721285391},{"_id":"public/image/强化学习/离散动作-策略分布.png","hash":"7ea3a2855155e0ba0d4340490c30e665520ef086","modified":1718721285391},{"_id":"public/image/强化学习/策略1.png","hash":"03e05721672d45f7d1cfcecc8dc1c49330b49080","modified":1718721285391},{"_id":"public/image/强化学习/重要性权重表格.png","hash":"c636ebf159c7d5a8abdcb5324b0fb2e9dd7cbdb6","modified":1718721285391},{"_id":"public/image/强化学习/马尔科夫链.png","hash":"d54e77948355fb074bff4974edd3d4ee30756835","modified":1718721285391},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_1.png","hash":"9c4d7fb94cf4d88efa0f1d57c50837b1e5aa113f","modified":1718721285391},{"_id":"public/img/alipay.JPG","hash":"242f28ac6b31ce2fae669f9b357f88b19a1a755a","modified":1718721285391},{"_id":"public/image/MARL/img_1.png","hash":"6d1ebca900fd3c98a7382ea4cc52c9f9fb4bf6d6","modified":1718721285391},{"_id":"public/image/MARL/img_10.png","hash":"19a0f333d77505aa50e3ce3a4cf8dbdef15a9a08","modified":1718721285391},{"_id":"public/image/MARL/img_12.png","hash":"04e35d22666436dd7c937da31d6107769694cfe1","modified":1718721285391},{"_id":"public/image/MARL/img_11.png","hash":"99d56908d7c6e6e00ee9cdebe963f253dd55f2c3","modified":1718721285391},{"_id":"public/image/MARL/img.png","hash":"1a15c68b483bbe455c739a3e63d00f9bf517dd8f","modified":1718721285391},{"_id":"public/image/MARL/img_14.png","hash":"a4270b1a9cc1d89e4ef81eb6288306bccd423293","modified":1718721285391},{"_id":"public/image/MARL/img_22.png","hash":"7ae93ca4e125194633a84b6623e892d306563147","modified":1718721285391},{"_id":"public/image/MARL/img_21.png","hash":"159c9d40e4c3b86ce74dad3627eea0925c05d3d8","modified":1718721285391},{"_id":"public/image/MARL/img_25.png","hash":"780801543fbad5a539da734659da4267e98f6226","modified":1718721285391},{"_id":"public/image/MARL/img_27.png","hash":"7f45efb57054b5c741adf1338e074b7cb72f4682","modified":1718721285391},{"_id":"public/image/MARL/img_3.png","hash":"3cd6383d45a693af460d791b6397edadefb54dd7","modified":1718721285391},{"_id":"public/image/MARL/img_28.png","hash":"3331cbf3b0f5e02aad69ae549a2ca2992e4bc09b","modified":1718721285391},{"_id":"public/image/MARL/img_32.png","hash":"d19088279eea2d8be2c91789bed07bb8b9157cf3","modified":1718721285391},{"_id":"public/image/MARL/img_33.png","hash":"1d5a7d97483e1b7f9b15babafa9edaecd16a1ae5","modified":1718721285391},{"_id":"public/image/MARL/img_35.png","hash":"9c3f707a1e976d26367cef5b697a1e1713e9d30a","modified":1718721285391},{"_id":"public/image/MARL/img_34.png","hash":"c40b199cbfa1e48eeb2f48703d97612b10cf8ddd","modified":1718721285391},{"_id":"public/image/MARL/img_41.png","hash":"dc99ef84a23747bf1df39ffa75f65142833c50f2","modified":1718721285391},{"_id":"public/image/MARL/img_46.png","hash":"075ab0887e92c81a785a7fd5cc529e02d5b827a2","modified":1718721285391},{"_id":"public/image/MARL/img_45.png","hash":"653093958a2cd8ec02eb57999be05dae36d22c78","modified":1718721285391},{"_id":"public/image/MARL/img_47.png","hash":"97bd6ad4c936907889397163b6b82f058bfeb8a5","modified":1718721285391},{"_id":"public/image/MARL/img_48.png","hash":"4a35a0f5f5d3db09ed2ffaed576384bd8b3a5b7f","modified":1718721285391},{"_id":"public/image/MARL/img_49.png","hash":"6f42c5de881e8e0e2f9205397492403608d305ea","modified":1718721285391},{"_id":"public/image/MARL/img_50.png","hash":"d2a92cb31f82e75f76a836677ba630056c8a76de","modified":1718721285391},{"_id":"public/image/MARL/img_53.png","hash":"e77f4991c711db44fc958f9ff5848b3d23fa2155","modified":1718721285391},{"_id":"public/image/MARL/img_55.png","hash":"2ae039d4635d2584df1aa70813fe0823ba64cd9a","modified":1718721285391},{"_id":"public/image/MARL/img_6.png","hash":"34f870290763316b68e4b0654992943d463b55ad","modified":1718721285391},{"_id":"public/image/MARL/img_7.png","hash":"069091e238963421f52d381826bea91e89ca7fda","modified":1718721285391},{"_id":"public/image/MARL/img_9.png","hash":"5c9bd19962a9def0dc103325550201d406ebf1f9","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/6.png","hash":"7608498f2f5dede16990a0643e242280e193f9c1","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/xftp.png","hash":"e3cb8d796d3576397b91f6168a106dcc215b85d6","modified":1718721285391},{"_id":"public/image/强化学习/A3C1.png","hash":"3005353326c11c8aebe3a637638f7be5f43a7825","modified":1718721285391},{"_id":"public/image/强化学习/AC算法.png","hash":"a1a024144b42ea965070692c87648dbc17640a5a","modified":1718721285391},{"_id":"public/image/强化学习/DDPG2.png","hash":"e4df30b144f63e269dde8e2bd9fd613bc2a55551","modified":1718721285391},{"_id":"public/image/强化学习/DuelDQN.png","hash":"e6a024745d81a004dbc9372754e0afcbea8500cd","modified":1718721285391},{"_id":"public/image/强化学习/Magic'(X).png","hash":"915a394ba63779fa45fb4ab337d35e9aa3656a1d","modified":1718721285391},{"_id":"public/image/强化学习/DuelDQN网络架构.png","hash":"5faebac7e88f43d768347d2a44f5ea635aef5f93","modified":1718721285391},{"_id":"public/image/强化学习/Qlearning图解.png","hash":"99e1f7c3c09e8b8ff40013e5274197e84bbeccac","modified":1718721285391},{"_id":"public/image/强化学习/Qtable三维可视化.png","hash":"19e2457ff644019941c4e4889e271ae19851c8b7","modified":1718721285391},{"_id":"public/image/强化学习/TD(0)图解.png","hash":"442c7c3185254c616b7dd581d3122c5b287d0609","modified":1718721285391},{"_id":"public/image/强化学习/TD-error.png","hash":"6cd354a8357bd9b351204db8ffbc86f14fa46388","modified":1718721285391},{"_id":"public/image/强化学习/TD3.png","hash":"f742b6d7ea08bddec59b241f4623e3a292fc8a99","modified":1718721285391},{"_id":"public/image/强化学习/V值转V值.png","hash":"04d61bd802407d82933d4fc3d48f655f82195df6","modified":1718721285391},{"_id":"public/image/强化学习/fix-Q-targets.png","hash":"28054b2d0b4c65f2e515366675d183072dc0670c","modified":1718721285391},{"_id":"public/image/强化学习/例子1.png","hash":"9f00eb53650a1323eed0c41405bc446f1edc0bc0","modified":1718721285391},{"_id":"public/image/强化学习/回顾DQN.png","hash":"3d6ef5df0f373b7e934dce35691e99cc2274e453","modified":1718721285391},{"_id":"public/image/强化学习/数据加工厂.png","hash":"0f6de0db66dba3926063c5e15801273c016eefe6","modified":1718721285391},{"_id":"public/image/强化学习/扭曲的曲线.png","hash":"1e785c5e507fcb8999cddd62724b194be6dbbae0","modified":1718721285391},{"_id":"public/image/强化学习/用TD估计Q值.png","hash":"4ae7ab1a840d2f66a6796920a561642608012404","modified":1718721285391},{"_id":"public/image/强化学习/由G值算V值.png","hash":"4cd7c7aa68eba7d540f8d6ad3700f913b98b14d0","modified":1718721285391},{"_id":"public/image/强化学习/直观感受PG2.png","hash":"dc3b790d0138431bd36ca86d9cecb4c3724948d0","modified":1718721285391},{"_id":"public/image/强化学习/直观感受PG1.png","hash":"abe569e686536c668a3f038c9a57052c6bcbc9d4","modified":1718721285391},{"_id":"public/image/强化学习/直观感受PG3.png","hash":"76a2980409108c0cb4330cee7d3bf27d0c7ea8b5","modified":1718721285391},{"_id":"public/image/强化学习/策略3.png","hash":"07c8459c5961babf996f8b4c16ab17b11c7f4c43","modified":1718721285391},{"_id":"public/image/强化学习/策略4.png","hash":"e7bfcbf76f24fe190ab7ed50a0f2085b22496cd6","modified":1718721285391},{"_id":"public/image/强化学习/策略P和策略B更新示意图.png","hash":"61b7166aad0636090777247c4d4cff7d05177234","modified":1718721285391},{"_id":"public/image/强化学习/策略P和策略B.png","hash":"2ea5ef3287f9d2a216c9d2abf8ddf49bf0ab8989","modified":1718721285391},{"_id":"public/image/RNN-LSTM-GRU-GCN/img.png","hash":"b5e3b81743830a235f98a3ed98888664ac1b8c01","modified":1718721285391},{"_id":"public/image/强化学习/连续型概率分布示意图.png","hash":"b3772e1cf96f08a1e289bc51c9c44750ce3c07ce","modified":1718721285391},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_3.png","hash":"3ccf1aae722c09b1b8ab22b5270e33b37eafcb55","modified":1718721285391},{"_id":"public/css/index.css","hash":"7ec09b47c52077cb7a30b4c07512373d5223cdb9","modified":1718721285391},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718721285391},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1718721285391},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1718721285391},{"_id":"public/js/Valine.min.js","hash":"c19fcca376470c5049873475548131c31e8a950b","modified":1718721285391},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1718721285391},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1718721285391},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1718721285391},{"_id":"public/image/MARL/img_15.png","hash":"e8f55f26c5bed2b0e1f9926d71fb84480180790b","modified":1718721285391},{"_id":"public/image/MARL/img_13.png","hash":"439f1936f67cafa07c0e856eb64d49720f67637b","modified":1718721285391},{"_id":"public/image/MARL/img_17.png","hash":"f4a452e9775d395bfa369d54c14fca91c00b7a17","modified":1718721285391},{"_id":"public/image/MARL/img_16.png","hash":"66909131a240f3e754bc656e4303d21815e7d100","modified":1718721285391},{"_id":"public/image/MARL/img_2.png","hash":"ab12cb07c1c4e44b70dc35a0a925544ac2a6e115","modified":1718721285391},{"_id":"public/image/MARL/img_20.png","hash":"0a3e3919dc0fa73b206df79f1c3c600d92defc2a","modified":1718721285391},{"_id":"public/image/MARL/img_5.png","hash":"fa4cb933ca9f685f35f49d8262b4192a1955968b","modified":1718721285391},{"_id":"public/image/MARL/img_8.png","hash":"803f9cd2e5768da860f76667e589d5b77a201340","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/2.png","hash":"eae90eb1b195c84430fe54a09819862bdd352a2f","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/5.png","hash":"1432b61eb04256e0627913d0e3323eff178626b1","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/backup-desktop.png","hash":"e6ec39385bcd11c4db8a3599509e3fc40f0bce83","modified":1718721285391},{"_id":"public/image/强化学习/A3C.png","hash":"137d1bfc646d4aec2c83a97b339b58bc59ff81fa","modified":1718721285391},{"_id":"public/image/强化学习/Q'估算Q 1.png","hash":"fe5352cc8507ff0748c0e3bb0d90acd8055753e8","modified":1718721285391},{"_id":"public/image/强化学习/Q'估计Q 2.png","hash":"d4b88893a5d0c2d81e9ca846e4129c53ef989d1b","modified":1718721285391},{"_id":"public/image/强化学习/G值的意义.png","hash":"68992cb8a2194c779748e9a34ffccfb4156d25df","modified":1718721285391},{"_id":"public/image/强化学习/Q值的定义.png","hash":"969a8e6a7d764e5f3366de0b46fd22d34f6c90a2","modified":1718721285391},{"_id":"public/image/强化学习/Q值转V值1.png","hash":"e168cf4b797ea342ea2cf45a15030424f594c7bf","modified":1718721285391},{"_id":"public/image/强化学习/Q=S+A表格.png","hash":"8277d01e72f923f488d82cda32befd415d203f40","modified":1718721285391},{"_id":"public/image/强化学习/TD(0).png","hash":"46c1b1d85bc500d3317fc98af24cc00407e4c3a2","modified":1718721285391},{"_id":"public/image/强化学习/TD(N).png","hash":"cf4525e94a10fd8c40d5324f9a616edf0bb5e04d","modified":1718721285391},{"_id":"public/image/强化学习/V值的定义.png","hash":"9a95cb005f86b501901dbe8ecd63f4857ce45857","modified":1718721285391},{"_id":"public/image/强化学习/两种理解方式.png","hash":"8ce85b9a7824394c5ff8eb685af6be073093b9d2","modified":1718721285391},{"_id":"public/image/强化学习/学习路线.png","hash":"34e7356e916c72ca4c778d116badc860ea1b8146","modified":1718721285391},{"_id":"public/image/强化学习/坑的解释.png","hash":"dc5251c2966f88383d3eaa7c92ac1961ab29b739","modified":1718721285391},{"_id":"public/image/RNN-LSTM-GRU-GCN/img_2.png","hash":"0e93fa825353061329cc917c8f98cd30f4591370","modified":1718721285391},{"_id":"public/img/background/樱花2.jpg","hash":"858a926496f17529430ef9c1b56aa3a25abb97af","modified":1718721285391},{"_id":"public/image/MARL/img_19.png","hash":"6f2d0f1b01b1e55d1132aba9841ce70c908871ab","modified":1718721285391},{"_id":"public/image/MARL/img_18.png","hash":"98e324069ae326b697ea9fcdec3bfe9c8246ad19","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/3.png","hash":"85cfb5ad615d808491052523c665dd38c152b148","modified":1718721285391},{"_id":"public/image/强化学习/Q值转V值.png","hash":"2aff0b6882884466d6a727e42a9df19c6117b768","modified":1718721285391},{"_id":"public/image/强化学习/V值转Q值.png","hash":"2abc3e4c268f8a277ff1b1596d1fcd2d6f328d0a","modified":1718721285391},{"_id":"public/image/强化学习/理解DDPG1.png","hash":"31f1afbdee99c095a0939941bc0cf2f815c3a2e1","modified":1718721285391},{"_id":"public/image/强化学习/理解DDPG2.png","hash":"d96a5ac6aa63978a4bca742c5c13319cc5acdd8f","modified":1718721285391},{"_id":"public/image/强化学习/马尔科夫树.png","hash":"60c324eaffab2259fbdcb415a356f29088b182bd","modified":1718721285391},{"_id":"public/img/assets/头像.JPG","hash":"2982b004f5f53918d2a6083056455bf3a479d60d","modified":1718721285391},{"_id":"public/image/MARL/img_30.png","hash":"cd0054217d899963732fd6f7f7244fdf8ec27ee5","modified":1718721285391},{"_id":"public/img/background/樱花1.jpg","hash":"ffa38044c2b06e88c45468340c916e862b599b51","modified":1718721285391},{"_id":"public/image/云笔记系统扩容/pod-deploy.png","hash":"5d7087ce3dfa3e1c38cee56e75eef71845787de5","modified":1718721285391},{"_id":"public/image/MARL/img_24.png","hash":"db26640a9ac6de9c1e6f5a4c436f10a8598ecead","modified":1718721285391},{"_id":"public/image/k8s部署云笔记系统/可莉.png","hash":"19e482e216be26cf376cce9c2f26f95507cc8963","modified":1718721285391}],"Category":[{"name":"算法","_id":"clxkia0v10004uugn9efl15nk"},{"name":"强化学习","_id":"clxkia0v5000cuugnaw607gzo"},{"name":"hexo","_id":"clxkia0v6000kuugn2oyfeyc8"},{"name":"Kubernetes","_id":"clxkia0v6000ouugn1tiu8jlf"},{"name":"react","_id":"clxkia0v7000tuugn0uzmas55"},{"name":"面经","_id":"clxkia0v8000yuugn406t6e8b"},{"name":"多智能体强化学习","parent":"clxkia0v5000cuugnaw607gzo","_id":"clxkia0v80012uugncx8qgov9"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"about","type":"about","description":"相册","top_img":null,"abbrlink":0,"date":"2023-08-31T11:46:34.000Z","updated":"2023-10-20T14:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 闲来无事，搭建一个静态博客网站玩一玩。。。\n","source":"about/index.md","raw":"---\ntitle: about\ntype: \"about\"\ndescription: 相册\ntop_img:\nabbrlink: 00000\ndate: 2023-08-31 19:46:34\nupdated: 2023-10-20 22:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 闲来无事，搭建一个静态博客网站玩一玩。。。\n","path":"about/index.html","layout":"page","_id":"clxkia0uu0000uugne4an4tvj","content":"<blockquote>\n<p>闲来无事，搭建一个静态博客网站玩一玩。。。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>闲来无事，搭建一个静态博客网站玩一玩。。。</p>\n</blockquote>\n"},{"title":"categories","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---\n","updated":"2023-08-31T11:44:33.118Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clxkia0v00002uugn5xn1ax56","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"movies","date":"2023-08-31T11:48:52.000Z","type":"movies","_content":"","source":"movies/index.md","raw":"---\ntitle: movies\ndate: 2023-08-31 19:48:52\ntype: \"movies\"\n---\n","updated":"2023-08-31T11:49:46.713Z","path":"movies/index.html","comments":1,"layout":"page","_id":"clxkia0v30006uugn63yjfcve","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2023-08-31T11:44:43.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-08-31 19:44:43\ntype: \"link\"\n---\n","updated":"2023-08-31T11:45:01.378Z","path":"link/index.html","comments":1,"layout":"page","_id":"clxkia0v30008uugn1uht4p0m","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"music","date":"2023-08-31T11:48:40.000Z","type":"music","_content":"","source":"music/index.md","raw":"---\ntitle: music\ndate: 2023-08-31 19:48:40\ntype: \"music\"\n---\n","updated":"2023-08-31T11:49:46.718Z","path":"music/index.html","comments":1,"layout":"page","_id":"clxkia0v4000auugnabuh9lv6","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"title":"pictures","description":"相册","top_img":null,"abbrlink":0,"date":"2023-09-19T15:55:05.000Z","updated":"2023-10-20T14:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n\n\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '原神' '一些原神图片' '/pictures/gallery_groups/genshin' https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg %}\n{% galleryGroup '英雄联盟KDA' '一些LOL的KDA壁纸' '/pictures/gallery_groups/lol-kda' https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg %}\n\n[//]: # ({% galleryGroup '袜啵啵' '挺喜欢的一家写真摄影集' '/pictures/gallery_groups/wabobo' https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg %})\n</div>\n","source":"pictures/index.md","raw":"---\ntitle: pictures\ndescription: 相册\ntop_img:\nabbrlink: 00000\ndate: 2023-09-19 23:55:05\nupdated: 2023-10-20 22:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n\n\n\n<div class=\"gallery-group-main\">\n{% galleryGroup '原神' '一些原神图片' '/pictures/gallery_groups/genshin' https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg %}\n{% galleryGroup '英雄联盟KDA' '一些LOL的KDA壁纸' '/pictures/gallery_groups/lol-kda' https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg %}\n\n[//]: # ({% galleryGroup '袜啵啵' '挺喜欢的一家写真摄影集' '/pictures/gallery_groups/wabobo' https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg %})\n</div>\n","path":"pictures/index.html","layout":"page","_id":"clxkia0v5000fuugn905y918h","content":"<div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">原神</div>\n  <p>一些原神图片</p>\n  <a href='/pictures/gallery_groups/genshin'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">英雄联盟KDA</div>\n  <p>一些LOL的KDA壁纸</p>\n  <a href='/pictures/gallery_groups/lol-kda'></a>\n  </figcaption>\n  </figure>\n  \n\n</div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">原神</div>\n  <p>一些原神图片</p>\n  <a href='/pictures/gallery_groups/genshin'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">英雄联盟KDA</div>\n  <p>一些LOL的KDA壁纸</p>\n  <a href='/pictures/gallery_groups/lol-kda'></a>\n  </figcaption>\n  </figure>\n  \n\n</div>\n"},{"title":"tags","date":"2018-01-04T16:00:00.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2023-09-13T16:03:00.990Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clxkia0v5000huugn1xf1deuy","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""},{"_content":"{% gallery %}\n![pic_11.jpg](https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg)\n![pic_66.jpg](https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png)\n![pic_59.jpg](https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg)\n{% endgallery %}\n","source":"pictures/gallery_groups/genshin.md","raw":"{% gallery %}\n![pic_11.jpg](https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg)\n![pic_66.jpg](https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png)\n![pic_59.jpg](https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg)\n{% endgallery %}\n","date":"2024-02-06T13:21:06.368Z","updated":"2024-02-06T13:21:06.368Z","path":"pictures/gallery_groups/genshin.html","title":"","comments":1,"layout":"page","_id":"clxkia0v6000muugn62qt6k2s","content":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg\",\"alt\":\"pic_11.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png\",\"alt\":\"pic_66.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg\",\"alt\":\"pic_59.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/l8qGkHUaoVMRWSg.jpg\",\"alt\":\"pic_11.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/hsxTQuk9FCKUWbl.png\",\"alt\":\"pic_66.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/6z8TXSAVsheiGjM.jpg\",\"alt\":\"pic_59.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n"},{"_content":"{% gallery %}\n![pic_79.jpg](https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg)\n![pic_37.jpg](https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg)\n![pic_82.jpg](https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg)\n![pic_78.jpg](https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg)\n\n{% endgallery %}\n","source":"pictures/gallery_groups/lol-kda.md","raw":"{% gallery %}\n![pic_79.jpg](https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg)\n![pic_37.jpg](https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg)\n![pic_82.jpg](https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg)\n![pic_78.jpg](https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg)\n\n{% endgallery %}\n","date":"2024-02-06T13:22:38.126Z","updated":"2024-02-06T13:22:38.126Z","path":"pictures/gallery_groups/lol-kda.html","title":"","comments":1,"layout":"page","_id":"clxkia0v6000nuugn3d8l7cpd","content":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg\",\"alt\":\"pic_79.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg\",\"alt\":\"pic_37.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg\",\"alt\":\"pic_82.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg\",\"alt\":\"pic_78.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://s2.loli.net/2024/02/06/oYPHsTbXzZt4j28.jpg\",\"alt\":\"pic_79.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/ikbs3McEfywNp7t.jpg\",\"alt\":\"pic_37.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/AwmqHPc7yo5VBWL.jpg\",\"alt\":\"pic_82.jpg\"},{\"url\":\"https://s2.loli.net/2024/02/06/yi2laTzqJVS6dgo.jpg\",\"alt\":\"pic_78.jpg\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>Load More</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n"},{"_content":"\n[//]: # (# 袜啵啵)\n\n[//]: # ()\n[//]: # (**袜啵啵**是我最喜欢的一家摄影工作室，他们的作品总是能让我感受到一种温暖。最喜欢稚予和小甜豆！！！)\n\n[//]: # ()\n[//]: # (有关的资源我有很多，物恋、誉铭、等，私信我即可，有偿。)\n\n[//]: # ({% gallery %})\n\n[//]: # ()\n[//]: # (![IMG_5152.JPG]&#40;https://s2.loli.net/2023/10/21/5AvpTcn41ukPLDU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5031.jpg]&#40;https://s2.loli.net/2023/10/21/ijo13Vm5dX7lLxc.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5134.JPG]&#40;https://s2.loli.net/2023/10/21/a1hAdBcIJFxNKli.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5151.JPG]&#40;https://s2.loli.net/2023/10/21/lrz6to5fZLdAwFb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5133.JPG]&#40;https://s2.loli.net/2023/10/21/RaQmzlqMrt9bPBG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5132.JPG]&#40;https://s2.loli.net/2023/10/21/AO1RdLJmhlB7WwG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5145.JPG]&#40;https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5126.JPG]&#40;https://s2.loli.net/2023/10/21/J5oYVMza1vjlRbI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5144.JPG]&#40;https://s2.loli.net/2023/10/21/tHjXpwbrl8a1L2M.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5124.JPG]&#40;https://s2.loli.net/2023/10/21/H9mpjRMdNBYFQSx.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5153.JPG]&#40;https://s2.loli.net/2023/10/21/4NEYUnQDgMGp6vk.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5219.JPG]&#40;https://s2.loli.net/2023/10/21/pFEuDlQ7Ay8Vrmi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5218.JPG]&#40;https://s2.loli.net/2023/10/21/mIFGhpzaw24dx7v.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5208.JPG]&#40;https://s2.loli.net/2023/10/21/t5HwUrThulbikBE.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5209.JPG]&#40;https://s2.loli.net/2023/10/21/6rqwmKp3NgW7Dci.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5216.JPG]&#40;https://s2.loli.net/2023/10/21/a7NA6gDBSxXwKpF.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5217.JPG]&#40;https://s2.loli.net/2023/10/21/UAkpsy6Se9r18mq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5229.JPG]&#40;https://s2.loli.net/2023/10/21/K68EUXYpDsvJZzQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5214.JPG]&#40;https://s2.loli.net/2023/10/21/hoVwMp7gCNXzkWP.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5212.JPG]&#40;https://s2.loli.net/2023/10/21/4o5JBygzavUqpDb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5263.JPG]&#40;https://s2.loli.net/2023/10/21/cO3wArBgIkGfVM6.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5265.JPG]&#40;https://s2.loli.net/2023/10/21/exNUZDHMRAPJ8rI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5249.JPG]&#40;https://s2.loli.net/2023/10/21/rtm1NWH6yKC4uYZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5272.JPG]&#40;https://s2.loli.net/2023/10/21/2ERusCdIavwy37L.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5241.JPG]&#40;https://s2.loli.net/2023/10/21/EAi9KQwsSfWRDHU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5243.JPG]&#40;https://s2.loli.net/2023/10/21/nB7iNUWRwQCgvL4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5246.JPG]&#40;https://s2.loli.net/2023/10/21/k4MzjmhYeGNiUrB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5245.JPG]&#40;https://s2.loli.net/2023/10/21/1f4KOGzBJ8Sudsn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5244.JPG]&#40;https://s2.loli.net/2023/10/21/ZJVAi74zM1YK9yC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5242.JPG]&#40;https://s2.loli.net/2023/10/21/a6WtA3s5lBkVFD4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5274.JPG]&#40;https://s2.loli.net/2023/10/21/wsTtBXN6b9Eeif7.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5281.JPG]&#40;https://s2.loli.net/2023/10/21/x8V2sCGL7eg4YPQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5273.JPG]&#40;https://s2.loli.net/2023/10/21/Ee6JFdcbNLBsApU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5286.JPG]&#40;https://s2.loli.net/2023/10/21/sEyijHa32UF7Dgw.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5276.JPG]&#40;https://s2.loli.net/2023/10/21/qmKbR2VSjZErBLX.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5310.JPG]&#40;https://s2.loli.net/2023/10/21/Xn4kBZoM1HDG6W9.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5302.JPG]&#40;https://s2.loli.net/2023/10/21/9eAq4JFMpLSthcu.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5284.JPG]&#40;https://s2.loli.net/2023/10/21/QdfkFYRKrpAU6S5.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5290.JPG]&#40;https://s2.loli.net/2023/10/21/ZLgJnp5NQIYdsVq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5303.JPG]&#40;https://s2.loli.net/2023/10/21/phSsqmxfl67wUyr.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5311.JPG]&#40;https://s2.loli.net/2023/10/21/RkrT9Mzt5Qw8LD3.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5394.JPG]&#40;https://s2.loli.net/2023/10/21/l3StIUqagrdRQDo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5312.JPG]&#40;https://s2.loli.net/2023/10/21/RzbXYaVAdhncpG1.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5350.JPG]&#40;https://s2.loli.net/2023/10/21/FhHV4Bx1JIAicq2.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5378.JPG]&#40;https://s2.loli.net/2023/10/21/9Bf6dhmgkrTpEcN.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5406.JPG]&#40;https://s2.loli.net/2023/10/21/FnWcLjEedV3fRIh.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5351.JPG]&#40;https://s2.loli.net/2023/10/21/H3O8eioK2zL4s1w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5354.JPG]&#40;https://s2.loli.net/2023/10/21/pF1MrHdXqBDRblz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5404.JPG]&#40;https://s2.loli.net/2023/10/21/RtXYhUGq9n7SAya.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5391.JPG]&#40;https://s2.loli.net/2023/10/21/YD2tcOCRXI5Ti8w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5421.JPG]&#40;https://s2.loli.net/2023/10/21/kSZEjvAP7iDhFzo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5435.JPG]&#40;https://s2.loli.net/2023/10/21/BwH7Viabkyr1QPJ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5426.JPG]&#40;https://s2.loli.net/2023/10/21/jcydXw7QmB6faOA.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5436.JPG]&#40;https://s2.loli.net/2023/10/21/oqDMTH8hPnEOIQK.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5469.JPG]&#40;https://s2.loli.net/2023/10/21/D4klmrJ37yFgvCZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5470.JPG]&#40;https://s2.loli.net/2023/10/21/qlJkzIupgt1AmW8.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5424.JPG]&#40;https://s2.loli.net/2023/10/21/ozHLuUc9mPb5Vej.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5430.JPG]&#40;https://s2.loli.net/2023/10/21/OJjqGiA7PMDdtCW.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5482.JPG]&#40;https://s2.loli.net/2023/10/21/gZJLNm8o3a5F9tl.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5756.jpeg]&#40;https://s2.loli.net/2023/10/21/7ABylJru36f4nZz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5783.JPG]&#40;https://s2.loli.net/2023/10/21/tYDnscUrSZ8V5xB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5782.JPG]&#40;https://s2.loli.net/2023/10/21/LDRGosFYtAakxQi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5792.JPG]&#40;https://s2.loli.net/2023/10/21/h9TMpZ3sGxfUvFO.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5794.JPG]&#40;https://s2.loli.net/2023/10/21/qxfHtEjXvlSDy8B.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5757.jpeg]&#40;https://s2.loli.net/2023/10/21/yrwEog9dLOAh1bG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5799.JPG]&#40;https://s2.loli.net/2023/10/21/bnAhag9HpPwWXqC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5800.JPG]&#40;https://s2.loli.net/2023/10/21/xcmua9iPd1WVsnq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_6046.jpg]&#40;https://s2.loli.net/2023/10/21/UVNFMdwjtmb38sC.jpg&#41;)\n\n[//]: # ()\n[//]: # ({% endgallery %})\n","source":"pictures/gallery_groups/wabobo.md","raw":"\n[//]: # (# 袜啵啵)\n\n[//]: # ()\n[//]: # (**袜啵啵**是我最喜欢的一家摄影工作室，他们的作品总是能让我感受到一种温暖。最喜欢稚予和小甜豆！！！)\n\n[//]: # ()\n[//]: # (有关的资源我有很多，物恋、誉铭、等，私信我即可，有偿。)\n\n[//]: # ({% gallery %})\n\n[//]: # ()\n[//]: # (![IMG_5152.JPG]&#40;https://s2.loli.net/2023/10/21/5AvpTcn41ukPLDU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5031.jpg]&#40;https://s2.loli.net/2023/10/21/ijo13Vm5dX7lLxc.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5134.JPG]&#40;https://s2.loli.net/2023/10/21/a1hAdBcIJFxNKli.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5151.JPG]&#40;https://s2.loli.net/2023/10/21/lrz6to5fZLdAwFb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5133.JPG]&#40;https://s2.loli.net/2023/10/21/RaQmzlqMrt9bPBG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5132.JPG]&#40;https://s2.loli.net/2023/10/21/AO1RdLJmhlB7WwG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5145.JPG]&#40;https://s2.loli.net/2023/10/21/OUWsxHFhyTVdufn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5126.JPG]&#40;https://s2.loli.net/2023/10/21/J5oYVMza1vjlRbI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5144.JPG]&#40;https://s2.loli.net/2023/10/21/tHjXpwbrl8a1L2M.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5124.JPG]&#40;https://s2.loli.net/2023/10/21/H9mpjRMdNBYFQSx.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5153.JPG]&#40;https://s2.loli.net/2023/10/21/4NEYUnQDgMGp6vk.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5219.JPG]&#40;https://s2.loli.net/2023/10/21/pFEuDlQ7Ay8Vrmi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5218.JPG]&#40;https://s2.loli.net/2023/10/21/mIFGhpzaw24dx7v.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5208.JPG]&#40;https://s2.loli.net/2023/10/21/t5HwUrThulbikBE.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5209.JPG]&#40;https://s2.loli.net/2023/10/21/6rqwmKp3NgW7Dci.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5216.JPG]&#40;https://s2.loli.net/2023/10/21/a7NA6gDBSxXwKpF.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5217.JPG]&#40;https://s2.loli.net/2023/10/21/UAkpsy6Se9r18mq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5229.JPG]&#40;https://s2.loli.net/2023/10/21/K68EUXYpDsvJZzQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5214.JPG]&#40;https://s2.loli.net/2023/10/21/hoVwMp7gCNXzkWP.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5212.JPG]&#40;https://s2.loli.net/2023/10/21/4o5JBygzavUqpDb.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5263.JPG]&#40;https://s2.loli.net/2023/10/21/cO3wArBgIkGfVM6.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5265.JPG]&#40;https://s2.loli.net/2023/10/21/exNUZDHMRAPJ8rI.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5249.JPG]&#40;https://s2.loli.net/2023/10/21/rtm1NWH6yKC4uYZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5272.JPG]&#40;https://s2.loli.net/2023/10/21/2ERusCdIavwy37L.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5241.JPG]&#40;https://s2.loli.net/2023/10/21/EAi9KQwsSfWRDHU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5243.JPG]&#40;https://s2.loli.net/2023/10/21/nB7iNUWRwQCgvL4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5246.JPG]&#40;https://s2.loli.net/2023/10/21/k4MzjmhYeGNiUrB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5245.JPG]&#40;https://s2.loli.net/2023/10/21/1f4KOGzBJ8Sudsn.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5244.JPG]&#40;https://s2.loli.net/2023/10/21/ZJVAi74zM1YK9yC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5242.JPG]&#40;https://s2.loli.net/2023/10/21/a6WtA3s5lBkVFD4.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5274.JPG]&#40;https://s2.loli.net/2023/10/21/wsTtBXN6b9Eeif7.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5281.JPG]&#40;https://s2.loli.net/2023/10/21/x8V2sCGL7eg4YPQ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5273.JPG]&#40;https://s2.loli.net/2023/10/21/Ee6JFdcbNLBsApU.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5286.JPG]&#40;https://s2.loli.net/2023/10/21/sEyijHa32UF7Dgw.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5276.JPG]&#40;https://s2.loli.net/2023/10/21/qmKbR2VSjZErBLX.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5310.JPG]&#40;https://s2.loli.net/2023/10/21/Xn4kBZoM1HDG6W9.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5302.JPG]&#40;https://s2.loli.net/2023/10/21/9eAq4JFMpLSthcu.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5284.JPG]&#40;https://s2.loli.net/2023/10/21/QdfkFYRKrpAU6S5.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5290.JPG]&#40;https://s2.loli.net/2023/10/21/ZLgJnp5NQIYdsVq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5303.JPG]&#40;https://s2.loli.net/2023/10/21/phSsqmxfl67wUyr.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5311.JPG]&#40;https://s2.loli.net/2023/10/21/RkrT9Mzt5Qw8LD3.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5394.JPG]&#40;https://s2.loli.net/2023/10/21/l3StIUqagrdRQDo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5312.JPG]&#40;https://s2.loli.net/2023/10/21/RzbXYaVAdhncpG1.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5350.JPG]&#40;https://s2.loli.net/2023/10/21/FhHV4Bx1JIAicq2.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5378.JPG]&#40;https://s2.loli.net/2023/10/21/9Bf6dhmgkrTpEcN.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5406.JPG]&#40;https://s2.loli.net/2023/10/21/FnWcLjEedV3fRIh.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5351.JPG]&#40;https://s2.loli.net/2023/10/21/H3O8eioK2zL4s1w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5354.JPG]&#40;https://s2.loli.net/2023/10/21/pF1MrHdXqBDRblz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5404.JPG]&#40;https://s2.loli.net/2023/10/21/RtXYhUGq9n7SAya.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5391.JPG]&#40;https://s2.loli.net/2023/10/21/YD2tcOCRXI5Ti8w.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5421.JPG]&#40;https://s2.loli.net/2023/10/21/kSZEjvAP7iDhFzo.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5435.JPG]&#40;https://s2.loli.net/2023/10/21/BwH7Viabkyr1QPJ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5426.JPG]&#40;https://s2.loli.net/2023/10/21/jcydXw7QmB6faOA.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5436.JPG]&#40;https://s2.loli.net/2023/10/21/oqDMTH8hPnEOIQK.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5469.JPG]&#40;https://s2.loli.net/2023/10/21/D4klmrJ37yFgvCZ.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5470.JPG]&#40;https://s2.loli.net/2023/10/21/qlJkzIupgt1AmW8.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5424.JPG]&#40;https://s2.loli.net/2023/10/21/ozHLuUc9mPb5Vej.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5430.JPG]&#40;https://s2.loli.net/2023/10/21/OJjqGiA7PMDdtCW.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5482.JPG]&#40;https://s2.loli.net/2023/10/21/gZJLNm8o3a5F9tl.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5756.jpeg]&#40;https://s2.loli.net/2023/10/21/7ABylJru36f4nZz.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5783.JPG]&#40;https://s2.loli.net/2023/10/21/tYDnscUrSZ8V5xB.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5782.JPG]&#40;https://s2.loli.net/2023/10/21/LDRGosFYtAakxQi.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5792.JPG]&#40;https://s2.loli.net/2023/10/21/h9TMpZ3sGxfUvFO.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5794.JPG]&#40;https://s2.loli.net/2023/10/21/qxfHtEjXvlSDy8B.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5757.jpeg]&#40;https://s2.loli.net/2023/10/21/yrwEog9dLOAh1bG.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5799.JPG]&#40;https://s2.loli.net/2023/10/21/bnAhag9HpPwWXqC.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_5800.JPG]&#40;https://s2.loli.net/2023/10/21/xcmua9iPd1WVsnq.jpg&#41;)\n\n[//]: # ()\n[//]: # (![IMG_6046.jpg]&#40;https://s2.loli.net/2023/10/21/UVNFMdwjtmb38sC.jpg&#41;)\n\n[//]: # ()\n[//]: # ({% endgallery %})\n","date":"2023-12-26T08:53:22.200Z","updated":"2023-12-26T08:53:22.200Z","path":"pictures/gallery_groups/wabobo.html","title":"","comments":1,"layout":"page","_id":"clxkia0v7000quugn8tyl6wez","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"RNN/LSTM/GRU/GCN","keywords":["算法"],"description":"多智能体强化学习的算法和思路总结","abbrlink":17765,"date":"2023-12-21T11:51:33.000Z","updated":"2023-12-21T11:51:33.000Z","top_img":"https://s2.loli.net/2024/02/06/U5SXRYACVolptGM.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/3uoiqZOIw6CPygm.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。\n\n> 参考：https://zhuanlan.zhihu.com/p/587276701\n> 参考：https://zhuanlan.zhihu.com/p/605750441\n\n## 循环神经网络RNN\n传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。\n\n由此诞生了RNN。\n\n循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。\n\n![img_1.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_1.png)\n\n```\nx 输入层 向量\nU 输入层到隐藏层的 权重矩阵\ns 隐藏层 向量\nV 隐藏层到输出层的 权重矩阵\no 输出层 向量\nW 上一次隐藏层的值作为这一次输入的权重 权重矩阵\n```\n循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。\n\n![img_2.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_2.png)\n\n\n具体的抽象图：\n![img.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg.png)\n\n## 长短期记忆网络LSTM\n\n长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。\n\n![img_3.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_3.png)\n(左：RNN，右：LSTM)\n\n\n\n","source":"_posts/RNN-LSTM-GRU-GCN.md","raw":"---\ntitle: RNN/LSTM/GRU/GCN\ntags:\n  - 算法\ncategories:\n  - 算法\nkeywords:\n  - 算法\ndescription: 多智能体强化学习的算法和思路总结\nabbrlink: 17765\ndate: 2023-12-21 19:51:33\nupdated: 2023-12-21 19:51:33\ntop_img: https://s2.loli.net/2024/02/06/U5SXRYACVolptGM.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/3uoiqZOIw6CPygm.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。\n\n> 参考：https://zhuanlan.zhihu.com/p/587276701\n> 参考：https://zhuanlan.zhihu.com/p/605750441\n\n## 循环神经网络RNN\n传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。\n\n由此诞生了RNN。\n\n循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。\n\n![img_1.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_1.png)\n\n```\nx 输入层 向量\nU 输入层到隐藏层的 权重矩阵\ns 隐藏层 向量\nV 隐藏层到输出层的 权重矩阵\no 输出层 向量\nW 上一次隐藏层的值作为这一次输入的权重 权重矩阵\n```\n循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。\n\n![img_2.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_2.png)\n\n\n具体的抽象图：\n![img.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg.png)\n\n## 长短期记忆网络LSTM\n\n长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。\n\n![img_3.png](..%2Fimage%2FRNN-LSTM-GRU-GCN%2Fimg_3.png)\n(左：RNN，右：LSTM)\n\n\n\n","slug":"RNN-LSTM-GRU-GCN","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0ux0001uugn08mx6pkv","content":"<blockquote>\n<p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/587276701\">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href=\"https://zhuanlan.zhihu.com/p/605750441\">https://zhuanlan.zhihu.com/p/605750441</a></p>\n</blockquote>\n<h2 id=\"循环神经网络RNN\"><a href=\"#循环神经网络RNN\" class=\"headerlink\" title=\"循环神经网络RNN\"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p>\n<p>由此诞生了RNN。</p>\n<p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_1.png\" alt=\"img_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x 输入层 向量</span><br><span class=\"line\">U 输入层到隐藏层的 权重矩阵</span><br><span class=\"line\">s 隐藏层 向量</span><br><span class=\"line\">V 隐藏层到输出层的 权重矩阵</span><br><span class=\"line\">o 输出层 向量</span><br><span class=\"line\">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure>\n<p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_2.png\" alt=\"img_2.png\"></p>\n<p>具体的抽象图：<br><img src=\"/../image/RNN-LSTM-GRU-GCN/img.png\" alt=\"img.png\"></p>\n<h2 id=\"长短期记忆网络LSTM\"><a href=\"#长短期记忆网络LSTM\" class=\"headerlink\" title=\"长短期记忆网络LSTM\"></a>长短期记忆网络LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_3.png\" alt=\"img_3.png\"><br>(左：RNN，右：LSTM)</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p>\n</blockquote>\n<blockquote>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/587276701\">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href=\"https://zhuanlan.zhihu.com/p/605750441\">https://zhuanlan.zhihu.com/p/605750441</a></p>\n</blockquote>\n<h2 id=\"循环神经网络RNN\"><a href=\"#循环神经网络RNN\" class=\"headerlink\" title=\"循环神经网络RNN\"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p>\n<p>由此诞生了RNN。</p>\n<p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_1.png\" alt=\"img_1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x 输入层 向量</span><br><span class=\"line\">U 输入层到隐藏层的 权重矩阵</span><br><span class=\"line\">s 隐藏层 向量</span><br><span class=\"line\">V 隐藏层到输出层的 权重矩阵</span><br><span class=\"line\">o 输出层 向量</span><br><span class=\"line\">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure>\n<p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_2.png\" alt=\"img_2.png\"></p>\n<p>具体的抽象图：<br><img src=\"/../image/RNN-LSTM-GRU-GCN/img.png\" alt=\"img.png\"></p>\n<h2 id=\"长短期记忆网络LSTM\"><a href=\"#长短期记忆网络LSTM\" class=\"headerlink\" title=\"长短期记忆网络LSTM\"></a>长短期记忆网络LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p>\n<p><img src=\"/../image/RNN-LSTM-GRU-GCN/img_3.png\" alt=\"img_3.png\"><br>(左：RNN，右：LSTM)</p>\n"},{"title":"MARL","keywords":["多智能体强化学习"],"description":"多智能体强化学习的算法和思路总结","abbrlink":17763,"date":"2023-10-30T09:04:41.000Z","updated":"2023-11-09T09:37:56.000Z","top_img":"https://s2.loli.net/2024/02/06/GAfLl3XPUJgH4ec.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/FCKdzqG2wJ8RmcS.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 由于我的科研方向是`多智能体强化学习`，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。\n\n> 在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。\n\n知乎专栏：https://www.zhihu.com/column/c_1061939147282915328\n\n## 基础知识与博弈\n\n### 引言\n在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。\n\n在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。\n\n1. 维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。\n2. 目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。\n3. 不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。\n4. 探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。\n\n多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。\n\n### 纳什均衡\n\n![img_1.png](..%2Fimage%2FMARL%2Fimg_1.png)\n\n### 完全混合策略\n若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。\n\n### 纯策略\n\n若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。\n\n### 零和博弈\n零和博弈中，两个智能体是完全竞争对抗关系，则 `R1 = - R2` 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。\n\n### 一般和博弈\n一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。\n\n> 矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：https://zhuanlan.zhihu.com/p/53474965\n\n## Minimax-Q\n论文：[Markov games as a framework for multi-agent reinforcement learning](https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf)\n\nMinimax-Q算法应用于`两个玩家的零和随机博弈中`。`Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。`\n\n在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，`每个智能体最大化在与对手博弈中最差情况下的期望奖励值`。\n\n![img_2.png](..%2Fimage%2FMARL%2Fimg_2.png)\n\n理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：\n\n1. 在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。\n2. 为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。\n3. 只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。\n\n## Nash Q-Learning\n论文：[Nash Q-learning for general-sum stochastic games](https://www.jmlr.org/papers/volume4/temp/hu03a.pdf)\n\nNash Q-Learning算法是将Minimax-Q算法`从零和博弈扩展到多人一般和博弈`的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到`Nash Q-Learning算法就是使用二次规划求解纳什均衡点`。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。\n\n其算法流程如下：\n\n![img_3.png](..%2Fimage%2FMARL%2Fimg_3.png)\n\n该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。\n\n## Friend-or-Foe Q-Learning\n论文：[Friend-or-foe Q-learning in general-sum games](https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf)\n\nFriend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。\n\n其纳什均衡策略求解方法如下所示：\n\n![img_4.png](..%2Fimage%2FMARL%2Fimg_4.png)\n\n算法流程如下：\n\n![img_5.png](..%2Fimage%2FMARL%2Fimg_5.png)\n\n有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。\n\nFFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。\n\nFFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。\n\n## WoLF Policy Hill-Climbing\n论文：[Multiagent learning using a variable learning rate](https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK%2Bil2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV%2Bk4Sy0RKqs%2FFblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL%2FzjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t%2F2bnTZ7qTDIfyIUlvNHlEKL%2F9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv%2BcEGunXeil0OTm%2FSRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz%2BTVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt%2Bupsy1T6e%2Bt1k0PCXzBrMR4xqRuv006eN8HG7%2FOHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN%2F%2Bt8okdIhgmNbKIikDVOUqNwejq1Mnka%2B0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8%2B1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J%2F3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb%2B2%2BMdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH%2BOpYXYXQA%2BusAbQ%2FJLnUibNKgBd8Ssk2Fj7%2BAj1H1%2B7hEDC%2BKVib31jzGP9aBwfa76WjOdwk%2B%2FVtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb%2FyzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr%2BMh%2F%2F5bt5%2FspmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT%2BQiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr%2Fop8JfLOur2Kx4cAbHsxPmwrtlKhbwv%2FByOhbxlQf%2BUKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t%2Fp1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR%2F20231107%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk)\n\n![img_6.png](..%2Fimage%2FMARL%2Fimg_6.png)\n\nWolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。\n\nPHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。\n\n其算法流程如下：\n\n![img_7.png](..%2Fimage%2FMARL%2Fimg_7.png)\n\n为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 `δ` 来实现WoLF效果，当策略效果较差时使用 `δl` ，策略效果较好时使用 `δw` ，并且满足 `δl > δw` 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。\n\n其算法流程如下所示：\n\n![img_8.png](..%2Fimage%2FMARL%2Fimg_8.png)\n\n> 关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：https://www.cnblogs.com/zuti666/p/16909220.html 和 https://zhuanlan.zhihu.com/p/53563792\n\n\n## MADDPG\n论文：[Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments](https://arxiv.org/abs/1706.02275)\n\nOpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。\n\n传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。\n\nMADDPG算法具有以下三点特征： \n1. 通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 \n2. 不需要知道环境的动力学模型以及特殊的通信需求。 \n3. 该算法不仅能用于合作环境，也能用于竞争环境。\n\nMADDPG算法具有以下三点技巧：\n1. 集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。\n2. 改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x', a1,..., an, r1,..., rn)组成，X = (o1,..., on)。表示每个智能体的观测。\n3. 利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。\n\n### 背景知识\n\n#### DQN\n深度Q网络（deep Q-network）\n![img_9.png](..%2Fimage%2FMARL%2Fimg_9.png)\n\n#### SPG\n随机策略梯度（stochastic policy gradient）\n\n![img_10.png](..%2Fimage%2FMARL%2Fimg_10.png)\n\n#### DPG\n确定性策略梯度（deterministic policy gradient）\n\n![img_11.png](..%2Fimage%2FMARL%2Fimg_11.png)\n\n### MADDPG\n\n#### 多智能体AC设计\n\nMADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。\n![img_12.png](..%2Fimage%2FMARL%2Fimg_12.png)\n![img_13.png](..%2Fimage%2FMARL%2Fimg_13.png)\n\n#### 估计其他智能体策略\n\n![img_14.png](..%2Fimage%2FMARL%2Fimg_14.png)\n\n#### 策略集合优化\n\n![img_15.png](..%2Fimage%2FMARL%2Fimg_15.png)\n\n### 相关PPT\n\n![img_16.png](..%2Fimage%2FMARL%2Fimg_16.png)\n![img_17.png](..%2Fimage%2FMARL%2Fimg_17.png)\n![img_18.png](..%2Fimage%2FMARL%2Fimg_18.png)\n![img_19.png](..%2Fimage%2FMARL%2Fimg_19.png)\n![img_20.png](..%2Fimage%2FMARL%2Fimg_20.png)\n\n\n## IQL\n论文：[Multiagent Cooperation and Competition with Deep Reinforcement Learning](https://arxiv.org/abs/1511.08779)\n\nIndependent Q-Learning\n\n本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。\n\nIQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。\n\nIQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。`这是此类算法的一个极端。`\n\n其他没啥要讲的。。。\n\n![img_21.png](..%2Fimage%2FMARL%2Fimg_21.png)\n\n## COMA\n论文：[Counterfactual Multi-Agent Policy Gradients](https://arxiv.org/abs/1705.08926)\n\nCOMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。`这是此类算法的另一个极端。`\n![img_23.png](..%2Fimage%2FMARL%2Fimg_23.png)\n\n多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。\n\n那么这些算法都在解决什么问题呢？\n\n只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。\n\n在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。\n\n![img_24.png](..%2Fimage%2FMARL%2Fimg_24.png)\n\n这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。\n\n![img_25.png](..%2Fimage%2FMARL%2Fimg_25.png)\n\nCOMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。\n\nCOMA算法具体框架如下图所示：\n![img_22.png](..%2Fimage%2FMARL%2Fimg_22.png)\n\n网络架构：\n![img_26.png](..%2Fimage%2FMARL%2Fimg_26.png)\n\n\n## VDN\n论文：[Value-Decomposition Networks For Cooperative Multi-Agent Learning](https://arxiv.org/abs/1706.05296)\n\nVDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。\n\nVDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：`Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。`如下图：\n左边是IQL，右边是VDN\n![img_27.png](..%2Fimage%2FMARL%2Fimg_27.png)\n\n作者假定如下等式成立：\n![img_29.png](..%2Fimage%2FMARL%2Fimg_29.png)\n\nh表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。\n\n推导上式：\n假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：\n![img_30.png](..%2Fimage%2FMARL%2Fimg_30.png)\n这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：\n![img_31.png](..%2Fimage%2FMARL%2Fimg_31.png)\n\n网络架构：\n![img_28.png](..%2Fimage%2FMARL%2Fimg_28.png)\n\n\nVDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。\n\n## QMIX\n论文：[QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1803.11485)\n\n深度多智能体强化学习的单调值函数分解\n\nQMIX是一个多智能体强化学习算法，具有如下特点： \n1. 学习得到分布式策略。 \n2. 本质是一个值函数逼近算法。 \n3. 由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 \n4. QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 \n5. 训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 \n6. 接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 \n7. 每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 \n8. 算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 \n9. 算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。\n\n### 背景知识\n\n#### MARL核心问题\n\n在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，`如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数`。另一个问题就是学得了联合动作值函数后，`如何通过联合值函数提取出一个优秀的分布式的策略`。这其实是单智能体强化学习拓展到MARL的核心问题。\n\n#### Dec-POMDP\nDec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。\n![img_32.png](..%2Fimage%2FMARL%2Fimg_32.png)\n\n#### IQL\n\nIQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。\n\n#### VDN\n\n如前介绍：\n![img_33.png](..%2Fimage%2FMARL%2Fimg_33.png)\n\n#### DRQN\n\nDRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。\n\n\n### QMIX\n\nQMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。\n\nQMIX约束条件：\n![img_34.png](..%2Fimage%2FMARL%2Fimg_34.png)\n也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。\n\n具体网络结构如下：\n![img_35.png](..%2Fimage%2FMARL%2Fimg_35.png)\n\n图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。\n\n图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。\n\n为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。\n\nQMIX的Loss：\n![img_36.png](..%2Fimage%2FMARL%2Fimg_36.png)\n\n更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，\n![img_37.png](..%2Fimage%2FMARL%2Fimg_37.png)\n\n由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。\n\n\n## QTRAN\n论文：[QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1905.05408)\n\n学习因式分解以实现协作多智能体强化学习 Q-Tran\n\nQMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。\n\nQTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。\n\n![img_38.png](..%2Fimage%2FMARL%2Fimg_38.png)\n\n这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。\n\n为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:\n![img_41.png](..%2Fimage%2FMARL%2Fimg_41.png)\n\n### TRAN-base\n分为三部分：\n1. 独立 Q 网络\n2. 联合 Q 网络\n3. 联合 V 网络\n\n整体的Loss如下：\n![img_39.png](..%2Fimage%2FMARL%2Fimg_39.png)\n![img_40.png](..%2Fimage%2FMARL%2Fimg_40.png)\n\n### TRAN-alt\nQTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。\n\n作者认为约束：\n![img_42.png](..%2Fimage%2FMARL%2Fimg_42.png)\n\n在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。\n\n为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。\n![img_43.png](..%2Fimage%2FMARL%2Fimg_43.png)\n这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：\n\n![img_44.png](..%2Fimage%2FMARL%2Fimg_44.png)\n\n具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。\n\n算法流程：\n![img.png](..%2Fimage%2FMARL%2Fimg.png)\n\n## MFMARL\n论文：[Mean Field Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1802.05438v4)\n\n平均场多智能体强化学习\n\n`MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。`由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。\n\nMFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。\n\n下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。\n\n### 背景知识\n\n#### 随机博弈\n\n![img_45.png](..%2Fimage%2FMARL%2Fimg_45.png)\n\n#### Nash-Q\n\n![img_46.png](..%2Fimage%2FMARL%2Fimg_46.png)\n\n### Mean Field MARL\n\n\n![img_50.png](..%2Fimage%2FMARL%2Fimg_50.png)\n#### 平均场近似\n\n![img_47.png](..%2Fimage%2FMARL%2Fimg_47.png)\n\n![img_48.png](..%2Fimage%2FMARL%2Fimg_48.png)\n\n![img_49.png](..%2Fimage%2FMARL%2Fimg_49.png)\n\n### 算法设计\n\n原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。\n\n#### MF-Q\n\n通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差\n![img_51.png](..%2Fimage%2FMARL%2Fimg_51.png)\n\n对上式求导可以得出参数梯度方向如下:\n![img_52.png](..%2Fimage%2FMARL%2Fimg_52.png)\n\n通过梯度下降法可以得到参数更新公式。\n\n算法流程：\n![img_53.png](..%2Fimage%2FMARL%2Fimg_53.png)\n\n#### MF-AC\n\n类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。\n\n类似SPG，actor策略梯度公式可以写为：\n![img_54.png](..%2Fimage%2FMARL%2Fimg_54.png)\n\ncritic类似于MF-Q的更新方式(9)\n\n![img_55.png](..%2Fimage%2FMARL%2Fimg_55.png)\n\n### 总结\n\n![img_56.png](..%2Fimage%2FMARL%2Fimg_56.png)\n\n> 至此，MARL的入门已结束，后面会结合科研方向看论文想点子。\n\n\n\n\n\n","source":"_posts/MARL.md","raw":"---\ntitle: MARL\ntags:\n    - 强化学习\n    - 多智能体强化学习\n    - 算法\ncategories:\n    - 强化学习\n    - 多智能体强化学习\nkeywords:\n    - 多智能体强化学习\ndescription: 多智能体强化学习的算法和思路总结\nabbrlink: 17763\ndate: 2023-10-30 17:04:41\nupdated: 2023-11-09 17:37:56\ntop_img: https://s2.loli.net/2024/02/06/GAfLl3XPUJgH4ec.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/FCKdzqG2wJ8RmcS.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 由于我的科研方向是`多智能体强化学习`，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。\n\n> 在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。\n\n知乎专栏：https://www.zhihu.com/column/c_1061939147282915328\n\n## 基础知识与博弈\n\n### 引言\n在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。\n\n在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。\n\n1. 维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。\n2. 目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。\n3. 不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。\n4. 探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。\n\n多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。\n\n### 纳什均衡\n\n![img_1.png](..%2Fimage%2FMARL%2Fimg_1.png)\n\n### 完全混合策略\n若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。\n\n### 纯策略\n\n若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。\n\n### 零和博弈\n零和博弈中，两个智能体是完全竞争对抗关系，则 `R1 = - R2` 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。\n\n### 一般和博弈\n一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。\n\n> 矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：https://zhuanlan.zhihu.com/p/53474965\n\n## Minimax-Q\n论文：[Markov games as a framework for multi-agent reinforcement learning](https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf)\n\nMinimax-Q算法应用于`两个玩家的零和随机博弈中`。`Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。`\n\n在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，`每个智能体最大化在与对手博弈中最差情况下的期望奖励值`。\n\n![img_2.png](..%2Fimage%2FMARL%2Fimg_2.png)\n\n理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：\n\n1. 在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。\n2. 为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。\n3. 只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。\n\n## Nash Q-Learning\n论文：[Nash Q-learning for general-sum stochastic games](https://www.jmlr.org/papers/volume4/temp/hu03a.pdf)\n\nNash Q-Learning算法是将Minimax-Q算法`从零和博弈扩展到多人一般和博弈`的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到`Nash Q-Learning算法就是使用二次规划求解纳什均衡点`。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。\n\n其算法流程如下：\n\n![img_3.png](..%2Fimage%2FMARL%2Fimg_3.png)\n\n该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。\n\n## Friend-or-Foe Q-Learning\n论文：[Friend-or-foe Q-learning in general-sum games](https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf)\n\nFriend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。\n\n其纳什均衡策略求解方法如下所示：\n\n![img_4.png](..%2Fimage%2FMARL%2Fimg_4.png)\n\n算法流程如下：\n\n![img_5.png](..%2Fimage%2FMARL%2Fimg_5.png)\n\n有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。\n\nFFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。\n\nFFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。\n\n## WoLF Policy Hill-Climbing\n论文：[Multiagent learning using a variable learning rate](https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK%2Bil2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV%2Bk4Sy0RKqs%2FFblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL%2FzjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t%2F2bnTZ7qTDIfyIUlvNHlEKL%2F9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv%2BcEGunXeil0OTm%2FSRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz%2BTVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt%2Bupsy1T6e%2Bt1k0PCXzBrMR4xqRuv006eN8HG7%2FOHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN%2F%2Bt8okdIhgmNbKIikDVOUqNwejq1Mnka%2B0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8%2B1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J%2F3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb%2B2%2BMdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH%2BOpYXYXQA%2BusAbQ%2FJLnUibNKgBd8Ssk2Fj7%2BAj1H1%2B7hEDC%2BKVib31jzGP9aBwfa76WjOdwk%2B%2FVtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb%2FyzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr%2BMh%2F%2F5bt5%2FspmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT%2BQiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr%2Fop8JfLOur2Kx4cAbHsxPmwrtlKhbwv%2FByOhbxlQf%2BUKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t%2Fp1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR%2F20231107%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk)\n\n![img_6.png](..%2Fimage%2FMARL%2Fimg_6.png)\n\nWolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。\n\nPHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。\n\n其算法流程如下：\n\n![img_7.png](..%2Fimage%2FMARL%2Fimg_7.png)\n\n为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 `δ` 来实现WoLF效果，当策略效果较差时使用 `δl` ，策略效果较好时使用 `δw` ，并且满足 `δl > δw` 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。\n\n其算法流程如下所示：\n\n![img_8.png](..%2Fimage%2FMARL%2Fimg_8.png)\n\n> 关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：https://www.cnblogs.com/zuti666/p/16909220.html 和 https://zhuanlan.zhihu.com/p/53563792\n\n\n## MADDPG\n论文：[Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments](https://arxiv.org/abs/1706.02275)\n\nOpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。\n\n传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。\n\nMADDPG算法具有以下三点特征： \n1. 通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 \n2. 不需要知道环境的动力学模型以及特殊的通信需求。 \n3. 该算法不仅能用于合作环境，也能用于竞争环境。\n\nMADDPG算法具有以下三点技巧：\n1. 集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。\n2. 改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x', a1,..., an, r1,..., rn)组成，X = (o1,..., on)。表示每个智能体的观测。\n3. 利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。\n\n### 背景知识\n\n#### DQN\n深度Q网络（deep Q-network）\n![img_9.png](..%2Fimage%2FMARL%2Fimg_9.png)\n\n#### SPG\n随机策略梯度（stochastic policy gradient）\n\n![img_10.png](..%2Fimage%2FMARL%2Fimg_10.png)\n\n#### DPG\n确定性策略梯度（deterministic policy gradient）\n\n![img_11.png](..%2Fimage%2FMARL%2Fimg_11.png)\n\n### MADDPG\n\n#### 多智能体AC设计\n\nMADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。\n![img_12.png](..%2Fimage%2FMARL%2Fimg_12.png)\n![img_13.png](..%2Fimage%2FMARL%2Fimg_13.png)\n\n#### 估计其他智能体策略\n\n![img_14.png](..%2Fimage%2FMARL%2Fimg_14.png)\n\n#### 策略集合优化\n\n![img_15.png](..%2Fimage%2FMARL%2Fimg_15.png)\n\n### 相关PPT\n\n![img_16.png](..%2Fimage%2FMARL%2Fimg_16.png)\n![img_17.png](..%2Fimage%2FMARL%2Fimg_17.png)\n![img_18.png](..%2Fimage%2FMARL%2Fimg_18.png)\n![img_19.png](..%2Fimage%2FMARL%2Fimg_19.png)\n![img_20.png](..%2Fimage%2FMARL%2Fimg_20.png)\n\n\n## IQL\n论文：[Multiagent Cooperation and Competition with Deep Reinforcement Learning](https://arxiv.org/abs/1511.08779)\n\nIndependent Q-Learning\n\n本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。\n\nIQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。\n\nIQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。`这是此类算法的一个极端。`\n\n其他没啥要讲的。。。\n\n![img_21.png](..%2Fimage%2FMARL%2Fimg_21.png)\n\n## COMA\n论文：[Counterfactual Multi-Agent Policy Gradients](https://arxiv.org/abs/1705.08926)\n\nCOMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。`这是此类算法的另一个极端。`\n![img_23.png](..%2Fimage%2FMARL%2Fimg_23.png)\n\n多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。\n\n那么这些算法都在解决什么问题呢？\n\n只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。\n\n在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。\n\n![img_24.png](..%2Fimage%2FMARL%2Fimg_24.png)\n\n这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。\n\n![img_25.png](..%2Fimage%2FMARL%2Fimg_25.png)\n\nCOMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。\n\nCOMA算法具体框架如下图所示：\n![img_22.png](..%2Fimage%2FMARL%2Fimg_22.png)\n\n网络架构：\n![img_26.png](..%2Fimage%2FMARL%2Fimg_26.png)\n\n\n## VDN\n论文：[Value-Decomposition Networks For Cooperative Multi-Agent Learning](https://arxiv.org/abs/1706.05296)\n\nVDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。\n\nVDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：`Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。`如下图：\n左边是IQL，右边是VDN\n![img_27.png](..%2Fimage%2FMARL%2Fimg_27.png)\n\n作者假定如下等式成立：\n![img_29.png](..%2Fimage%2FMARL%2Fimg_29.png)\n\nh表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。\n\n推导上式：\n假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：\n![img_30.png](..%2Fimage%2FMARL%2Fimg_30.png)\n这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：\n![img_31.png](..%2Fimage%2FMARL%2Fimg_31.png)\n\n网络架构：\n![img_28.png](..%2Fimage%2FMARL%2Fimg_28.png)\n\n\nVDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。\n\n## QMIX\n论文：[QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1803.11485)\n\n深度多智能体强化学习的单调值函数分解\n\nQMIX是一个多智能体强化学习算法，具有如下特点： \n1. 学习得到分布式策略。 \n2. 本质是一个值函数逼近算法。 \n3. 由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 \n4. QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 \n5. 训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 \n6. 接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 \n7. 每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 \n8. 算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 \n9. 算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。\n\n### 背景知识\n\n#### MARL核心问题\n\n在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，`如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数`。另一个问题就是学得了联合动作值函数后，`如何通过联合值函数提取出一个优秀的分布式的策略`。这其实是单智能体强化学习拓展到MARL的核心问题。\n\n#### Dec-POMDP\nDec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。\n![img_32.png](..%2Fimage%2FMARL%2Fimg_32.png)\n\n#### IQL\n\nIQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。\n\n#### VDN\n\n如前介绍：\n![img_33.png](..%2Fimage%2FMARL%2Fimg_33.png)\n\n#### DRQN\n\nDRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。\n\n\n### QMIX\n\nQMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。\n\nQMIX约束条件：\n![img_34.png](..%2Fimage%2FMARL%2Fimg_34.png)\n也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。\n\n具体网络结构如下：\n![img_35.png](..%2Fimage%2FMARL%2Fimg_35.png)\n\n图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。\n\n图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。\n\n为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。\n\nQMIX的Loss：\n![img_36.png](..%2Fimage%2FMARL%2Fimg_36.png)\n\n更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，\n![img_37.png](..%2Fimage%2FMARL%2Fimg_37.png)\n\n由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。\n\n\n## QTRAN\n论文：[QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1905.05408)\n\n学习因式分解以实现协作多智能体强化学习 Q-Tran\n\nQMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。\n\nQTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。\n\n![img_38.png](..%2Fimage%2FMARL%2Fimg_38.png)\n\n这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。\n\n为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:\n![img_41.png](..%2Fimage%2FMARL%2Fimg_41.png)\n\n### TRAN-base\n分为三部分：\n1. 独立 Q 网络\n2. 联合 Q 网络\n3. 联合 V 网络\n\n整体的Loss如下：\n![img_39.png](..%2Fimage%2FMARL%2Fimg_39.png)\n![img_40.png](..%2Fimage%2FMARL%2Fimg_40.png)\n\n### TRAN-alt\nQTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。\n\n作者认为约束：\n![img_42.png](..%2Fimage%2FMARL%2Fimg_42.png)\n\n在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。\n\n为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。\n![img_43.png](..%2Fimage%2FMARL%2Fimg_43.png)\n这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：\n\n![img_44.png](..%2Fimage%2FMARL%2Fimg_44.png)\n\n具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。\n\n算法流程：\n![img.png](..%2Fimage%2FMARL%2Fimg.png)\n\n## MFMARL\n论文：[Mean Field Multi-Agent Reinforcement Learning](https://arxiv.org/abs/1802.05438v4)\n\n平均场多智能体强化学习\n\n`MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。`由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。\n\nMFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。\n\n下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。\n\n### 背景知识\n\n#### 随机博弈\n\n![img_45.png](..%2Fimage%2FMARL%2Fimg_45.png)\n\n#### Nash-Q\n\n![img_46.png](..%2Fimage%2FMARL%2Fimg_46.png)\n\n### Mean Field MARL\n\n\n![img_50.png](..%2Fimage%2FMARL%2Fimg_50.png)\n#### 平均场近似\n\n![img_47.png](..%2Fimage%2FMARL%2Fimg_47.png)\n\n![img_48.png](..%2Fimage%2FMARL%2Fimg_48.png)\n\n![img_49.png](..%2Fimage%2FMARL%2Fimg_49.png)\n\n### 算法设计\n\n原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。\n\n#### MF-Q\n\n通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差\n![img_51.png](..%2Fimage%2FMARL%2Fimg_51.png)\n\n对上式求导可以得出参数梯度方向如下:\n![img_52.png](..%2Fimage%2FMARL%2Fimg_52.png)\n\n通过梯度下降法可以得到参数更新公式。\n\n算法流程：\n![img_53.png](..%2Fimage%2FMARL%2Fimg_53.png)\n\n#### MF-AC\n\n类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。\n\n类似SPG，actor策略梯度公式可以写为：\n![img_54.png](..%2Fimage%2FMARL%2Fimg_54.png)\n\ncritic类似于MF-Q的更新方式(9)\n\n![img_55.png](..%2Fimage%2FMARL%2Fimg_55.png)\n\n### 总结\n\n![img_56.png](..%2Fimage%2FMARL%2Fimg_56.png)\n\n> 至此，MARL的入门已结束，后面会结合科研方向看论文想点子。\n\n\n\n\n\n","slug":"MARL","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v00003uugn57hecdiw","content":"<blockquote>\n<p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p>\n</blockquote>\n<blockquote>\n<p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p>\n</blockquote>\n<p>知乎专栏：<a href=\"https://www.zhihu.com/column/c_1061939147282915328\">https://www.zhihu.com/column/c_1061939147282915328</a></p>\n<h2 id=\"基础知识与博弈\"><a href=\"#基础知识与博弈\" class=\"headerlink\" title=\"基础知识与博弈\"></a>基础知识与博弈</h2><h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p>\n<p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p>\n<ol>\n<li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li>\n<li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li>\n<li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li>\n<li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li>\n</ol>\n<p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p>\n<h3 id=\"纳什均衡\"><a href=\"#纳什均衡\" class=\"headerlink\" title=\"纳什均衡\"></a>纳什均衡</h3><p><img src=\"/../image/MARL/img_1.png\" alt=\"img_1.png\"></p>\n<h3 id=\"完全混合策略\"><a href=\"#完全混合策略\" class=\"headerlink\" title=\"完全混合策略\"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p>\n<h3 id=\"纯策略\"><a href=\"#纯策略\" class=\"headerlink\" title=\"纯策略\"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p>\n<h3 id=\"零和博弈\"><a href=\"#零和博弈\" class=\"headerlink\" title=\"零和博弈\"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p>\n<h3 id=\"一般和博弈\"><a href=\"#一般和博弈\" class=\"headerlink\" title=\"一般和博弈\"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p>\n<blockquote>\n<p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href=\"https://zhuanlan.zhihu.com/p/53474965\">https://zhuanlan.zhihu.com/p/53474965</a></p>\n</blockquote>\n<h2 id=\"Minimax-Q\"><a href=\"#Minimax-Q\" class=\"headerlink\" title=\"Minimax-Q\"></a>Minimax-Q</h2><p>论文：<a href=\"https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf\">Markov games as a framework for multi-agent reinforcement learning</a></p>\n<p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p>\n<p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p>\n<p><img src=\"/../image/MARL/img_2.png\" alt=\"img_2.png\"></p>\n<p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p>\n<ol>\n<li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li>\n<li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li>\n<li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li>\n</ol>\n<h2 id=\"Nash-Q-Learning\"><a href=\"#Nash-Q-Learning\" class=\"headerlink\" title=\"Nash Q-Learning\"></a>Nash Q-Learning</h2><p>论文：<a href=\"https://www.jmlr.org/papers/volume4/temp/hu03a.pdf\">Nash Q-learning for general-sum stochastic games</a></p>\n<p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_3.png\" alt=\"img_3.png\"></p>\n<p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p>\n<h2 id=\"Friend-or-Foe-Q-Learning\"><a href=\"#Friend-or-Foe-Q-Learning\" class=\"headerlink\" title=\"Friend-or-Foe Q-Learning\"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href=\"https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf\">Friend-or-foe Q-learning in general-sum games</a></p>\n<p>Friend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p>\n<p>其纳什均衡策略求解方法如下所示：</p>\n<p><img src=\"/../image/MARL/img_4.png\" alt=\"img_4.png\"></p>\n<p>算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_5.png\" alt=\"img_5.png\"></p>\n<p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p>\n<p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p>\n<p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p>\n<h2 id=\"WoLF-Policy-Hill-Climbing\"><a href=\"#WoLF-Policy-Hill-Climbing\" class=\"headerlink\" title=\"WoLF Policy Hill-Climbing\"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href=\"https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk\">Multiagent learning using a variable learning rate</a></p>\n<p><img src=\"/../image/MARL/img_6.png\" alt=\"img_6.png\"></p>\n<p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p>\n<p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_7.png\" alt=\"img_7.png\"></p>\n<p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p>\n<p>其算法流程如下所示：</p>\n<p><img src=\"/../image/MARL/img_8.png\" alt=\"img_8.png\"></p>\n<blockquote>\n<p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href=\"https://www.cnblogs.com/zuti666/p/16909220.html\">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/53563792\">https://zhuanlan.zhihu.com/p/53563792</a></p>\n</blockquote>\n<h2 id=\"MADDPG\"><a href=\"#MADDPG\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.02275\">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p>\n<p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p>\n<p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p>\n<p>MADDPG算法具有以下三点特征： </p>\n<ol>\n<li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li>\n<li>不需要知道环境的动力学模型以及特殊的通信需求。 </li>\n<li>该算法不仅能用于合作环境，也能用于竞争环境。</li>\n</ol>\n<p>MADDPG算法具有以下三点技巧：</p>\n<ol>\n<li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li>\n<li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li>\n<li>利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li>\n</ol>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4><p>深度Q网络（deep Q-network）<br><img src=\"/../image/MARL/img_9.png\" alt=\"img_9.png\"></p>\n<h4 id=\"SPG\"><a href=\"#SPG\" class=\"headerlink\" title=\"SPG\"></a>SPG</h4><p>随机策略梯度（stochastic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_10.png\" alt=\"img_10.png\"></p>\n<h4 id=\"DPG\"><a href=\"#DPG\" class=\"headerlink\" title=\"DPG\"></a>DPG</h4><p>确定性策略梯度（deterministic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_11.png\" alt=\"img_11.png\"></p>\n<h3 id=\"MADDPG-1\"><a href=\"#MADDPG-1\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h3><h4 id=\"多智能体AC设计\"><a href=\"#多智能体AC设计\" class=\"headerlink\" title=\"多智能体AC设计\"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src=\"/../image/MARL/img_12.png\" alt=\"img_12.png\"><br><img src=\"/../image/MARL/img_13.png\" alt=\"img_13.png\"></p>\n<h4 id=\"估计其他智能体策略\"><a href=\"#估计其他智能体策略\" class=\"headerlink\" title=\"估计其他智能体策略\"></a>估计其他智能体策略</h4><p><img src=\"/../image/MARL/img_14.png\" alt=\"img_14.png\"></p>\n<h4 id=\"策略集合优化\"><a href=\"#策略集合优化\" class=\"headerlink\" title=\"策略集合优化\"></a>策略集合优化</h4><p><img src=\"/../image/MARL/img_15.png\" alt=\"img_15.png\"></p>\n<h3 id=\"相关PPT\"><a href=\"#相关PPT\" class=\"headerlink\" title=\"相关PPT\"></a>相关PPT</h3><p><img src=\"/../image/MARL/img_16.png\" alt=\"img_16.png\"><br><img src=\"/../image/MARL/img_17.png\" alt=\"img_17.png\"><br><img src=\"/../image/MARL/img_18.png\" alt=\"img_18.png\"><br><img src=\"/../image/MARL/img_19.png\" alt=\"img_19.png\"><br><img src=\"/../image/MARL/img_20.png\" alt=\"img_20.png\"></p>\n<h2 id=\"IQL\"><a href=\"#IQL\" class=\"headerlink\" title=\"IQL\"></a>IQL</h2><p>论文：<a href=\"https://arxiv.org/abs/1511.08779\">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p>\n<p>Independent Q-Learning</p>\n<p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。</p>\n<p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p>\n<p>IQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p>\n<p>其他没啥要讲的。。。</p>\n<p><img src=\"/../image/MARL/img_21.png\" alt=\"img_21.png\"></p>\n<h2 id=\"COMA\"><a href=\"#COMA\" class=\"headerlink\" title=\"COMA\"></a>COMA</h2><p>论文：<a href=\"https://arxiv.org/abs/1705.08926\">Counterfactual Multi-Agent Policy Gradients</a></p>\n<p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src=\"/../image/MARL/img_23.png\" alt=\"img_23.png\"></p>\n<p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p>\n<p>那么这些算法都在解决什么问题呢？</p>\n<p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。</p>\n<p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。</p>\n<p><img src=\"/../image/MARL/img_24.png\" alt=\"img_24.png\"></p>\n<p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p>\n<p><img src=\"/../image/MARL/img_25.png\" alt=\"img_25.png\"></p>\n<p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p>\n<p>COMA算法具体框架如下图所示：<br><img src=\"/../image/MARL/img_22.png\" alt=\"img_22.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_26.png\" alt=\"img_26.png\"></p>\n<h2 id=\"VDN\"><a href=\"#VDN\" class=\"headerlink\" title=\"VDN\"></a>VDN</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.05296\">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p>\n<p>VDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p>\n<p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src=\"/../image/MARL/img_27.png\" alt=\"img_27.png\"></p>\n<p>作者假定如下等式成立：<br><img src=\"/../image/MARL/img_29.png\" alt=\"img_29.png\"></p>\n<p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p>\n<p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src=\"/../image/MARL/img_30.png\" alt=\"img_30.png\"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src=\"/../image/MARL/img_31.png\" alt=\"img_31.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_28.png\" alt=\"img_28.png\"></p>\n<p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p>\n<h2 id=\"QMIX\"><a href=\"#QMIX\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h2><p>论文：<a href=\"https://arxiv.org/abs/1803.11485\">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p>\n<p>深度多智能体强化学习的单调值函数分解</p>\n<p>QMIX是一个多智能体强化学习算法，具有如下特点： </p>\n<ol>\n<li>学习得到分布式策略。 </li>\n<li>本质是一个值函数逼近算法。 </li>\n<li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li>\n<li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li>\n<li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li>\n<li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li>\n<li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li>\n<li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li>\n<li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。</li>\n</ol>\n<h3 id=\"背景知识-1\"><a href=\"#背景知识-1\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"MARL核心问题\"><a href=\"#MARL核心问题\" class=\"headerlink\" title=\"MARL核心问题\"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p>\n<h4 id=\"Dec-POMDP\"><a href=\"#Dec-POMDP\" class=\"headerlink\" title=\"Dec-POMDP\"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src=\"/../image/MARL/img_32.png\" alt=\"img_32.png\"></p>\n<h4 id=\"IQL-1\"><a href=\"#IQL-1\" class=\"headerlink\" title=\"IQL\"></a>IQL</h4><p>IQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p>\n<h4 id=\"VDN-1\"><a href=\"#VDN-1\" class=\"headerlink\" title=\"VDN\"></a>VDN</h4><p>如前介绍：<br><img src=\"/../image/MARL/img_33.png\" alt=\"img_33.png\"></p>\n<h4 id=\"DRQN\"><a href=\"#DRQN\" class=\"headerlink\" title=\"DRQN\"></a>DRQN</h4><p>DRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p>\n<h3 id=\"QMIX-1\"><a href=\"#QMIX-1\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p>\n<p>QMIX约束条件：<br><img src=\"/../image/MARL/img_34.png\" alt=\"img_34.png\"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。</p>\n<p>具体网络结构如下：<br><img src=\"/../image/MARL/img_35.png\" alt=\"img_35.png\"></p>\n<p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p>\n<p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p>\n<p>为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p>\n<p>QMIX的Loss：<br><img src=\"/../image/MARL/img_36.png\" alt=\"img_36.png\"></p>\n<p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src=\"/../image/MARL/img_37.png\" alt=\"img_37.png\"></p>\n<p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p>\n<h2 id=\"QTRAN\"><a href=\"#QTRAN\" class=\"headerlink\" title=\"QTRAN\"></a>QTRAN</h2><p>论文：<a href=\"https://arxiv.org/abs/1905.05408\">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p>\n<p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p>\n<p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p>\n<p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p>\n<p><img src=\"/../image/MARL/img_38.png\" alt=\"img_38.png\"></p>\n<p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p>\n<p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src=\"/../image/MARL/img_41.png\" alt=\"img_41.png\"></p>\n<h3 id=\"TRAN-base\"><a href=\"#TRAN-base\" class=\"headerlink\" title=\"TRAN-base\"></a>TRAN-base</h3><p>分为三部分：</p>\n<ol>\n<li>独立 Q 网络</li>\n<li>联合 Q 网络</li>\n<li>联合 V 网络</li>\n</ol>\n<p>整体的Loss如下：<br><img src=\"/../image/MARL/img_39.png\" alt=\"img_39.png\"><br><img src=\"/../image/MARL/img_40.png\" alt=\"img_40.png\"></p>\n<h3 id=\"TRAN-alt\"><a href=\"#TRAN-alt\" class=\"headerlink\" title=\"TRAN-alt\"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p>\n<p>作者认为约束：<br><img src=\"/../image/MARL/img_42.png\" alt=\"img_42.png\"></p>\n<p>在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p>\n<p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src=\"/../image/MARL/img_43.png\" alt=\"img_43.png\"><br>这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p>\n<p><img src=\"/../image/MARL/img_44.png\" alt=\"img_44.png\"></p>\n<p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img.png\" alt=\"img.png\"></p>\n<h2 id=\"MFMARL\"><a href=\"#MFMARL\" class=\"headerlink\" title=\"MFMARL\"></a>MFMARL</h2><p>论文：<a href=\"https://arxiv.org/abs/1802.05438v4\">Mean Field Multi-Agent Reinforcement Learning</a></p>\n<p>平均场多智能体强化学习</p>\n<p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p>\n<p>MFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p>\n<p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p>\n<h3 id=\"背景知识-2\"><a href=\"#背景知识-2\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"随机博弈\"><a href=\"#随机博弈\" class=\"headerlink\" title=\"随机博弈\"></a>随机博弈</h4><p><img src=\"/../image/MARL/img_45.png\" alt=\"img_45.png\"></p>\n<h4 id=\"Nash-Q\"><a href=\"#Nash-Q\" class=\"headerlink\" title=\"Nash-Q\"></a>Nash-Q</h4><p><img src=\"/../image/MARL/img_46.png\" alt=\"img_46.png\"></p>\n<h3 id=\"Mean-Field-MARL\"><a href=\"#Mean-Field-MARL\" class=\"headerlink\" title=\"Mean Field MARL\"></a>Mean Field MARL</h3><p><img src=\"/../image/MARL/img_50.png\" alt=\"img_50.png\"></p>\n<h4 id=\"平均场近似\"><a href=\"#平均场近似\" class=\"headerlink\" title=\"平均场近似\"></a>平均场近似</h4><p><img src=\"/../image/MARL/img_47.png\" alt=\"img_47.png\"></p>\n<p><img src=\"/../image/MARL/img_48.png\" alt=\"img_48.png\"></p>\n<p><img src=\"/../image/MARL/img_49.png\" alt=\"img_49.png\"></p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p>\n<h4 id=\"MF-Q\"><a href=\"#MF-Q\" class=\"headerlink\" title=\"MF-Q\"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src=\"/../image/MARL/img_51.png\" alt=\"img_51.png\"></p>\n<p>对上式求导可以得出参数梯度方向如下:<br><img src=\"/../image/MARL/img_52.png\" alt=\"img_52.png\"></p>\n<p>通过梯度下降法可以得到参数更新公式。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img_53.png\" alt=\"img_53.png\"></p>\n<h4 id=\"MF-AC\"><a href=\"#MF-AC\" class=\"headerlink\" title=\"MF-AC\"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p>\n<p>类似SPG，actor策略梯度公式可以写为：<br><img src=\"/../image/MARL/img_54.png\" alt=\"img_54.png\"></p>\n<p>critic类似于MF-Q的更新方式(9)</p>\n<p><img src=\"/../image/MARL/img_55.png\" alt=\"img_55.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"/../image/MARL/img_56.png\" alt=\"img_56.png\"></p>\n<blockquote>\n<p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p>\n</blockquote>\n<blockquote>\n<p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p>\n</blockquote>\n<p>知乎专栏：<a href=\"https://www.zhihu.com/column/c_1061939147282915328\">https://www.zhihu.com/column/c_1061939147282915328</a></p>\n<h2 id=\"基础知识与博弈\"><a href=\"#基础知识与博弈\" class=\"headerlink\" title=\"基础知识与博弈\"></a>基础知识与博弈</h2><h3 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p>\n<p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p>\n<ol>\n<li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li>\n<li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li>\n<li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li>\n<li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li>\n</ol>\n<p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p>\n<h3 id=\"纳什均衡\"><a href=\"#纳什均衡\" class=\"headerlink\" title=\"纳什均衡\"></a>纳什均衡</h3><p><img src=\"/../image/MARL/img_1.png\" alt=\"img_1.png\"></p>\n<h3 id=\"完全混合策略\"><a href=\"#完全混合策略\" class=\"headerlink\" title=\"完全混合策略\"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p>\n<h3 id=\"纯策略\"><a href=\"#纯策略\" class=\"headerlink\" title=\"纯策略\"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p>\n<h3 id=\"零和博弈\"><a href=\"#零和博弈\" class=\"headerlink\" title=\"零和博弈\"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p>\n<h3 id=\"一般和博弈\"><a href=\"#一般和博弈\" class=\"headerlink\" title=\"一般和博弈\"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p>\n<blockquote>\n<p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href=\"https://zhuanlan.zhihu.com/p/53474965\">https://zhuanlan.zhihu.com/p/53474965</a></p>\n</blockquote>\n<h2 id=\"Minimax-Q\"><a href=\"#Minimax-Q\" class=\"headerlink\" title=\"Minimax-Q\"></a>Minimax-Q</h2><p>论文：<a href=\"https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf\">Markov games as a framework for multi-agent reinforcement learning</a></p>\n<p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p>\n<p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p>\n<p><img src=\"/../image/MARL/img_2.png\" alt=\"img_2.png\"></p>\n<p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p>\n<ol>\n<li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li>\n<li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li>\n<li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li>\n</ol>\n<h2 id=\"Nash-Q-Learning\"><a href=\"#Nash-Q-Learning\" class=\"headerlink\" title=\"Nash Q-Learning\"></a>Nash Q-Learning</h2><p>论文：<a href=\"https://www.jmlr.org/papers/volume4/temp/hu03a.pdf\">Nash Q-learning for general-sum stochastic games</a></p>\n<p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_3.png\" alt=\"img_3.png\"></p>\n<p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p>\n<h2 id=\"Friend-or-Foe-Q-Learning\"><a href=\"#Friend-or-Foe-Q-Learning\" class=\"headerlink\" title=\"Friend-or-Foe Q-Learning\"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href=\"https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf\">Friend-or-foe Q-learning in general-sum games</a></p>\n<p>Friend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p>\n<p>其纳什均衡策略求解方法如下所示：</p>\n<p><img src=\"/../image/MARL/img_4.png\" alt=\"img_4.png\"></p>\n<p>算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_5.png\" alt=\"img_5.png\"></p>\n<p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p>\n<p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p>\n<p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p>\n<h2 id=\"WoLF-Policy-Hill-Climbing\"><a href=\"#WoLF-Policy-Hill-Climbing\" class=\"headerlink\" title=\"WoLF Policy Hill-Climbing\"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href=\"https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk\">Multiagent learning using a variable learning rate</a></p>\n<p><img src=\"/../image/MARL/img_6.png\" alt=\"img_6.png\"></p>\n<p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p>\n<p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p>\n<p>其算法流程如下：</p>\n<p><img src=\"/../image/MARL/img_7.png\" alt=\"img_7.png\"></p>\n<p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p>\n<p>其算法流程如下所示：</p>\n<p><img src=\"/../image/MARL/img_8.png\" alt=\"img_8.png\"></p>\n<blockquote>\n<p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href=\"https://www.cnblogs.com/zuti666/p/16909220.html\">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href=\"https://zhuanlan.zhihu.com/p/53563792\">https://zhuanlan.zhihu.com/p/53563792</a></p>\n</blockquote>\n<h2 id=\"MADDPG\"><a href=\"#MADDPG\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.02275\">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p>\n<p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p>\n<p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p>\n<p>MADDPG算法具有以下三点特征： </p>\n<ol>\n<li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li>\n<li>不需要知道环境的动力学模型以及特殊的通信需求。 </li>\n<li>该算法不仅能用于合作环境，也能用于竞争环境。</li>\n</ol>\n<p>MADDPG算法具有以下三点技巧：</p>\n<ol>\n<li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li>\n<li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li>\n<li>利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li>\n</ol>\n<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4><p>深度Q网络（deep Q-network）<br><img src=\"/../image/MARL/img_9.png\" alt=\"img_9.png\"></p>\n<h4 id=\"SPG\"><a href=\"#SPG\" class=\"headerlink\" title=\"SPG\"></a>SPG</h4><p>随机策略梯度（stochastic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_10.png\" alt=\"img_10.png\"></p>\n<h4 id=\"DPG\"><a href=\"#DPG\" class=\"headerlink\" title=\"DPG\"></a>DPG</h4><p>确定性策略梯度（deterministic policy gradient）</p>\n<p><img src=\"/../image/MARL/img_11.png\" alt=\"img_11.png\"></p>\n<h3 id=\"MADDPG-1\"><a href=\"#MADDPG-1\" class=\"headerlink\" title=\"MADDPG\"></a>MADDPG</h3><h4 id=\"多智能体AC设计\"><a href=\"#多智能体AC设计\" class=\"headerlink\" title=\"多智能体AC设计\"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src=\"/../image/MARL/img_12.png\" alt=\"img_12.png\"><br><img src=\"/../image/MARL/img_13.png\" alt=\"img_13.png\"></p>\n<h4 id=\"估计其他智能体策略\"><a href=\"#估计其他智能体策略\" class=\"headerlink\" title=\"估计其他智能体策略\"></a>估计其他智能体策略</h4><p><img src=\"/../image/MARL/img_14.png\" alt=\"img_14.png\"></p>\n<h4 id=\"策略集合优化\"><a href=\"#策略集合优化\" class=\"headerlink\" title=\"策略集合优化\"></a>策略集合优化</h4><p><img src=\"/../image/MARL/img_15.png\" alt=\"img_15.png\"></p>\n<h3 id=\"相关PPT\"><a href=\"#相关PPT\" class=\"headerlink\" title=\"相关PPT\"></a>相关PPT</h3><p><img src=\"/../image/MARL/img_16.png\" alt=\"img_16.png\"><br><img src=\"/../image/MARL/img_17.png\" alt=\"img_17.png\"><br><img src=\"/../image/MARL/img_18.png\" alt=\"img_18.png\"><br><img src=\"/../image/MARL/img_19.png\" alt=\"img_19.png\"><br><img src=\"/../image/MARL/img_20.png\" alt=\"img_20.png\"></p>\n<h2 id=\"IQL\"><a href=\"#IQL\" class=\"headerlink\" title=\"IQL\"></a>IQL</h2><p>论文：<a href=\"https://arxiv.org/abs/1511.08779\">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p>\n<p>Independent Q-Learning</p>\n<p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。</p>\n<p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p>\n<p>IQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p>\n<p>其他没啥要讲的。。。</p>\n<p><img src=\"/../image/MARL/img_21.png\" alt=\"img_21.png\"></p>\n<h2 id=\"COMA\"><a href=\"#COMA\" class=\"headerlink\" title=\"COMA\"></a>COMA</h2><p>论文：<a href=\"https://arxiv.org/abs/1705.08926\">Counterfactual Multi-Agent Policy Gradients</a></p>\n<p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src=\"/../image/MARL/img_23.png\" alt=\"img_23.png\"></p>\n<p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p>\n<p>那么这些算法都在解决什么问题呢？</p>\n<p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。</p>\n<p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。</p>\n<p><img src=\"/../image/MARL/img_24.png\" alt=\"img_24.png\"></p>\n<p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p>\n<p><img src=\"/../image/MARL/img_25.png\" alt=\"img_25.png\"></p>\n<p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p>\n<p>COMA算法具体框架如下图所示：<br><img src=\"/../image/MARL/img_22.png\" alt=\"img_22.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_26.png\" alt=\"img_26.png\"></p>\n<h2 id=\"VDN\"><a href=\"#VDN\" class=\"headerlink\" title=\"VDN\"></a>VDN</h2><p>论文：<a href=\"https://arxiv.org/abs/1706.05296\">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p>\n<p>VDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p>\n<p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src=\"/../image/MARL/img_27.png\" alt=\"img_27.png\"></p>\n<p>作者假定如下等式成立：<br><img src=\"/../image/MARL/img_29.png\" alt=\"img_29.png\"></p>\n<p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p>\n<p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src=\"/../image/MARL/img_30.png\" alt=\"img_30.png\"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src=\"/../image/MARL/img_31.png\" alt=\"img_31.png\"></p>\n<p>网络架构：<br><img src=\"/../image/MARL/img_28.png\" alt=\"img_28.png\"></p>\n<p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p>\n<h2 id=\"QMIX\"><a href=\"#QMIX\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h2><p>论文：<a href=\"https://arxiv.org/abs/1803.11485\">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p>\n<p>深度多智能体强化学习的单调值函数分解</p>\n<p>QMIX是一个多智能体强化学习算法，具有如下特点： </p>\n<ol>\n<li>学习得到分布式策略。 </li>\n<li>本质是一个值函数逼近算法。 </li>\n<li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li>\n<li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li>\n<li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li>\n<li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li>\n<li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li>\n<li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li>\n<li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。</li>\n</ol>\n<h3 id=\"背景知识-1\"><a href=\"#背景知识-1\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"MARL核心问题\"><a href=\"#MARL核心问题\" class=\"headerlink\" title=\"MARL核心问题\"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p>\n<h4 id=\"Dec-POMDP\"><a href=\"#Dec-POMDP\" class=\"headerlink\" title=\"Dec-POMDP\"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src=\"/../image/MARL/img_32.png\" alt=\"img_32.png\"></p>\n<h4 id=\"IQL-1\"><a href=\"#IQL-1\" class=\"headerlink\" title=\"IQL\"></a>IQL</h4><p>IQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p>\n<h4 id=\"VDN-1\"><a href=\"#VDN-1\" class=\"headerlink\" title=\"VDN\"></a>VDN</h4><p>如前介绍：<br><img src=\"/../image/MARL/img_33.png\" alt=\"img_33.png\"></p>\n<h4 id=\"DRQN\"><a href=\"#DRQN\" class=\"headerlink\" title=\"DRQN\"></a>DRQN</h4><p>DRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p>\n<h3 id=\"QMIX-1\"><a href=\"#QMIX-1\" class=\"headerlink\" title=\"QMIX\"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p>\n<p>QMIX约束条件：<br><img src=\"/../image/MARL/img_34.png\" alt=\"img_34.png\"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。</p>\n<p>具体网络结构如下：<br><img src=\"/../image/MARL/img_35.png\" alt=\"img_35.png\"></p>\n<p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p>\n<p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p>\n<p>为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p>\n<p>QMIX的Loss：<br><img src=\"/../image/MARL/img_36.png\" alt=\"img_36.png\"></p>\n<p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src=\"/../image/MARL/img_37.png\" alt=\"img_37.png\"></p>\n<p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p>\n<h2 id=\"QTRAN\"><a href=\"#QTRAN\" class=\"headerlink\" title=\"QTRAN\"></a>QTRAN</h2><p>论文：<a href=\"https://arxiv.org/abs/1905.05408\">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p>\n<p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p>\n<p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p>\n<p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p>\n<p><img src=\"/../image/MARL/img_38.png\" alt=\"img_38.png\"></p>\n<p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p>\n<p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src=\"/../image/MARL/img_41.png\" alt=\"img_41.png\"></p>\n<h3 id=\"TRAN-base\"><a href=\"#TRAN-base\" class=\"headerlink\" title=\"TRAN-base\"></a>TRAN-base</h3><p>分为三部分：</p>\n<ol>\n<li>独立 Q 网络</li>\n<li>联合 Q 网络</li>\n<li>联合 V 网络</li>\n</ol>\n<p>整体的Loss如下：<br><img src=\"/../image/MARL/img_39.png\" alt=\"img_39.png\"><br><img src=\"/../image/MARL/img_40.png\" alt=\"img_40.png\"></p>\n<h3 id=\"TRAN-alt\"><a href=\"#TRAN-alt\" class=\"headerlink\" title=\"TRAN-alt\"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p>\n<p>作者认为约束：<br><img src=\"/../image/MARL/img_42.png\" alt=\"img_42.png\"></p>\n<p>在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p>\n<p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src=\"/../image/MARL/img_43.png\" alt=\"img_43.png\"><br>这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p>\n<p><img src=\"/../image/MARL/img_44.png\" alt=\"img_44.png\"></p>\n<p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img.png\" alt=\"img.png\"></p>\n<h2 id=\"MFMARL\"><a href=\"#MFMARL\" class=\"headerlink\" title=\"MFMARL\"></a>MFMARL</h2><p>论文：<a href=\"https://arxiv.org/abs/1802.05438v4\">Mean Field Multi-Agent Reinforcement Learning</a></p>\n<p>平均场多智能体强化学习</p>\n<p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p>\n<p>MFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p>\n<p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p>\n<h3 id=\"背景知识-2\"><a href=\"#背景知识-2\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><h4 id=\"随机博弈\"><a href=\"#随机博弈\" class=\"headerlink\" title=\"随机博弈\"></a>随机博弈</h4><p><img src=\"/../image/MARL/img_45.png\" alt=\"img_45.png\"></p>\n<h4 id=\"Nash-Q\"><a href=\"#Nash-Q\" class=\"headerlink\" title=\"Nash-Q\"></a>Nash-Q</h4><p><img src=\"/../image/MARL/img_46.png\" alt=\"img_46.png\"></p>\n<h3 id=\"Mean-Field-MARL\"><a href=\"#Mean-Field-MARL\" class=\"headerlink\" title=\"Mean Field MARL\"></a>Mean Field MARL</h3><p><img src=\"/../image/MARL/img_50.png\" alt=\"img_50.png\"></p>\n<h4 id=\"平均场近似\"><a href=\"#平均场近似\" class=\"headerlink\" title=\"平均场近似\"></a>平均场近似</h4><p><img src=\"/../image/MARL/img_47.png\" alt=\"img_47.png\"></p>\n<p><img src=\"/../image/MARL/img_48.png\" alt=\"img_48.png\"></p>\n<p><img src=\"/../image/MARL/img_49.png\" alt=\"img_49.png\"></p>\n<h3 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p>\n<h4 id=\"MF-Q\"><a href=\"#MF-Q\" class=\"headerlink\" title=\"MF-Q\"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src=\"/../image/MARL/img_51.png\" alt=\"img_51.png\"></p>\n<p>对上式求导可以得出参数梯度方向如下:<br><img src=\"/../image/MARL/img_52.png\" alt=\"img_52.png\"></p>\n<p>通过梯度下降法可以得到参数更新公式。</p>\n<p>算法流程：<br><img src=\"/../image/MARL/img_53.png\" alt=\"img_53.png\"></p>\n<h4 id=\"MF-AC\"><a href=\"#MF-AC\" class=\"headerlink\" title=\"MF-AC\"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p>\n<p>类似SPG，actor策略梯度公式可以写为：<br><img src=\"/../image/MARL/img_54.png\" alt=\"img_54.png\"></p>\n<p>critic类似于MF-Q的更新方式(9)</p>\n<p><img src=\"/../image/MARL/img_55.png\" alt=\"img_55.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"/../image/MARL/img_56.png\" alt=\"img_56.png\"></p>\n<blockquote>\n<p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p>\n</blockquote>\n"},{"title":"Hello World","abbrlink":16107,"date":"2018-01-04T16:00:00.000Z","updated":"2023-09-13T16:10:00.000Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - hexo\n  - 教程\ncategories:\n  - hexo\nabbrlink: 16107\ndate: 2018-01-05 00:00:00\nupdated: 2023-09-14 00:10:00\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v30007uugn5t0e1ey5","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"k8s部署云笔记系统","description":"在k8s服务器上部署云笔记系统","top_img":"../image/k8s部署云笔记系统/可莉.png","abbrlink":16330,"date":"2023-09-19T14:35:00.000Z","updated":"2023-09-20T05:35:00.000Z","keywords":null,"comments":1,"cover":"https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。\n\n## 创建namespace\n\n```kubernetes helm\n# 创建namespace\nkubectl create namespace note\n```\n\n## 1. 部署MySQL\n\n创建mysql文件夹\n\n```shell\nsudo mkdir -p /home/mysql/data\n```\n\n### 1.1 挂载数据卷\n\nnote-mysql-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n\tstorage: 1Gi\n  accessModes:\n\t- ReadWriteOnce\n  hostPath:\n\tpath: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n\t- ReadWriteOnce\n  resources:\n\trequests:\n\t  storage: 1Gi\n  storageClassName: \"\"\n\tvolumeName: note-mysql-pv\n```\n\n部署\n\n```kubernetes helm\nkubectl create -f note-mysql-pvc.yaml -n note\n```\n\n查看是否部署成功：\n\n![mysql是否部署成功](../image/k8s部署云笔记系统/1.png)\n\n### 1.2 部署mysql\n\nnote-mysql.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n\tmatchLabels:\n\t  app: note-mysql-pod\n  template:\n\tmetadata:\n\t  labels:\n\t\tapp: note-mysql-pod\n\tspec:\n\t  containers:\n\t\t- name: note-mysql\n\t\t  image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n\t\t  imagePullPolicy: IfNotPresent\n\t\t  env:\n\t\t\t- name: MYSQL_ROOT_PASSWORD\n\t\t\t  value: dfa6f1b032ee42ed95d12647225f2ff4\n\t\t  ports:\n\t\t\t- containerPort: 3306\n\t\t  volumeMounts:\n\t\t\t- name: note-mysql-persistent-storage\n\t\t\t  mountPath: /var/lib/mysql\n\tvolumes:\n\t  - name: note-mysql-persistent-storage\n\t\tpersistentVolumeClaim:\n\t\t  claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n\tapp: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n\tnodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n\ttargetPort: 3306\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-mysql.yaml -n note\n```\n\n## 2. 部署redis\n\nnote-redis.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-redis-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-redis-pod\n  template:\n    metadata:\n      labels:\n        app: note-redis-pod\n    spec:\n      containers:\n        - name: note-redis\n          image: redis:latest\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: REDIS_PASSWORD\n              value: adcc64a4a9b04324914626590fb52a1a\n          ports:\n            - containerPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-redis-service\nspec:\n  selector:\n    app: note-redis-pod\n  type: NodePort # service类型\n  ports:\n  - port: 6379\n    nodePort: 30079 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 6379\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-redis.yaml -n note\n```\n\n## 3. 部署mongodb\n\n创建mongodb文件夹\n\n```shell\nsudo mkdir -p /home/mongodb/data\n```\n\n### 3.1 挂载数据卷\n\nnote-mongodb-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 1Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n使用\n\n```kubernetes helm\nkubectl create -f note-mongodb-pvc.yaml -n note\n```\n\n查看是否装好：\n\n![mongodb-pvc](../image/k8s部署云笔记系统/2.png)\n\n### 3.2 部署\n\nnote-mongodb.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n```kubernetes helm\nkubectl create -f note-mongodb.yaml -n note\n```\n\n检查部署情况\n\n![mongodb](../image/k8s部署云笔记系统/3.png)\n\n## 4. 部署服务bert_flask\n\nbert_flask.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: bert-flask-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: bert-flask-pod\n  template:\n    metadata:\n      labels:\n        app: bert-flask-pod\n    spec:\n      containers:\n      - name: bert-flask\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: bert-flask-service\nspec:\n  selector:\n    app: bert-flask-pod\n  type: NodePort # service类型\n  ports:\n  - port: 5000\n    nodePort: 30050 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 5000\n```\n\n```kubernetes helm\nkubectl create -f bert_flask.yaml -n note\n```\n\n检查部署情况\n![bert_flask](../image/k8s部署云笔记系统/4.png)\n\n## 5. 部署服务note_cloud\n\n### 5.1 配置ConfigMap\n\n   新建application-prod.yml\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /api\nspring:\n  datasource:\n    url: jdbc:mysql://note-mysql-service:3306/db_note\n    username: root\n    password: dfa6f1b032ee42ed95d12647225f2ff4\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n  redis:\n    host: note-redis-service\n    port: 6379\n    password: adcc64a4a9b04324914626590fb52a1a\n    lettuce:\n      pool:\n        max-active: 10\n        max-idle: 10\n        min-idle: 1\n        time-between-eviction-runs: 10s\n    jackson:\n      default-property-inclusion: non_null # JSON处理时忽略非空字段\n  data:\n    mongodb:\n      uri: mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note\n  servlet:\n    multipart:\n      max-file-size: 10MB\n      max-request-size: 10MB\njwt:\n  base64-encoded-secret-key: lab_of_njust_cloud_computing # jwt的签名密码\nbert-base-chinese-service:\n  host: bert-flask-service\n  port: 5000\n```\n\n```kubernetes helm\nkubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml\n```\n\n   查看部署状态\n   ![部署效果](../image/k8s部署云笔记系统/4.png)\n\n### 5.2 部署服务\n\nnote-cloud.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-cloud-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-cloud-pod\n  template:\n    metadata:\n      labels:\n        app: note-cloud-pod\n    spec:\n      containers:\n      - name: note-cloud\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/config # 配置文件将挂载到容器的/app/config目录\n      volumes:\n      - name: config-volume\n        configMap:\n          name: note-cloud-config # 引用之前创建的 ConfigMap\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-cloud-service\nspec:\n  selector:\n    app: note-cloud-pod\n  type: NodePort # service类型\n  ports:\n  - port: 8080\n    nodePort: 30080 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 8080\n```\n\n```kubernetes helm\nkubectl create -f note-cloud.yaml -n note\n```\n\n查看日志\n\n```kubernetes helm\nkubectl get pod -n note\nkubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note\n```\n\n## 6. 部署前端\n\nnote-nginx.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-nginx-pod\n  template:\n    metadata:\n      labels:\n        app: note-nginx-pod\n    spec:\n      containers:\n        - name: note-nginx\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-nginx-service\nspec:\n  selector:\n    app: note-nginx-pod\n  type: NodePort # service类型\n  ports:\n  - port: 80\n    nodePort: 30088 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 80\n```\n\n```kubernetes helm\nkubectl create -f note-nginx.yaml -n note\n```\n\n## 最终部署pod查看\n\n![pod](../image/k8s部署云笔记系统/5.png)\n\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n账号：姓名小写拼音\n密码：123456\n\n\n最终效果：\n![6](../image/k8s部署云笔记系统/6.png)\n","source":"_posts/k8s部署云笔记系统.md","raw":"---\ntitle: k8s部署云笔记系统\ntags:\n  - k8s\n  - Kubernetes\n  - 教程\ncategories:\n  - Kubernetes\ndescription: 在k8s服务器上部署云笔记系统\ntop_img: ../image/k8s部署云笔记系统/可莉.png\nabbrlink: 16330\ndate: 2023-09-19 22:35:00\nupdated: 2023-09-20 13:35:00\nkeywords:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。\n\n## 创建namespace\n\n```kubernetes helm\n# 创建namespace\nkubectl create namespace note\n```\n\n## 1. 部署MySQL\n\n创建mysql文件夹\n\n```shell\nsudo mkdir -p /home/mysql/data\n```\n\n### 1.1 挂载数据卷\n\nnote-mysql-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n\tstorage: 1Gi\n  accessModes:\n\t- ReadWriteOnce\n  hostPath:\n\tpath: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n\t- ReadWriteOnce\n  resources:\n\trequests:\n\t  storage: 1Gi\n  storageClassName: \"\"\n\tvolumeName: note-mysql-pv\n```\n\n部署\n\n```kubernetes helm\nkubectl create -f note-mysql-pvc.yaml -n note\n```\n\n查看是否部署成功：\n\n![mysql是否部署成功](../image/k8s部署云笔记系统/1.png)\n\n### 1.2 部署mysql\n\nnote-mysql.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n\tmatchLabels:\n\t  app: note-mysql-pod\n  template:\n\tmetadata:\n\t  labels:\n\t\tapp: note-mysql-pod\n\tspec:\n\t  containers:\n\t\t- name: note-mysql\n\t\t  image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n\t\t  imagePullPolicy: IfNotPresent\n\t\t  env:\n\t\t\t- name: MYSQL_ROOT_PASSWORD\n\t\t\t  value: dfa6f1b032ee42ed95d12647225f2ff4\n\t\t  ports:\n\t\t\t- containerPort: 3306\n\t\t  volumeMounts:\n\t\t\t- name: note-mysql-persistent-storage\n\t\t\t  mountPath: /var/lib/mysql\n\tvolumes:\n\t  - name: note-mysql-persistent-storage\n\t\tpersistentVolumeClaim:\n\t\t  claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n\tapp: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n\tnodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n\ttargetPort: 3306\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-mysql.yaml -n note\n```\n\n## 2. 部署redis\n\nnote-redis.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-redis-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-redis-pod\n  template:\n    metadata:\n      labels:\n        app: note-redis-pod\n    spec:\n      containers:\n        - name: note-redis\n          image: redis:latest\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: REDIS_PASSWORD\n              value: adcc64a4a9b04324914626590fb52a1a\n          ports:\n            - containerPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-redis-service\nspec:\n  selector:\n    app: note-redis-pod\n  type: NodePort # service类型\n  ports:\n  - port: 6379\n    nodePort: 30079 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 6379\n```\n\n部署：\n\n```kubernetes helm\nkubectl create -f note-redis.yaml -n note\n```\n\n## 3. 部署mongodb\n\n创建mongodb文件夹\n\n```shell\nsudo mkdir -p /home/mongodb/data\n```\n\n### 3.1 挂载数据卷\n\nnote-mongodb-pvc.yaml\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 1Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n使用\n\n```kubernetes helm\nkubectl create -f note-mongodb-pvc.yaml -n note\n```\n\n查看是否装好：\n\n![mongodb-pvc](../image/k8s部署云笔记系统/2.png)\n\n### 3.2 部署\n\nnote-mongodb.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n```kubernetes helm\nkubectl create -f note-mongodb.yaml -n note\n```\n\n检查部署情况\n\n![mongodb](../image/k8s部署云笔记系统/3.png)\n\n## 4. 部署服务bert_flask\n\nbert_flask.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: bert-flask-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: bert-flask-pod\n  template:\n    metadata:\n      labels:\n        app: bert-flask-pod\n    spec:\n      containers:\n      - name: bert-flask\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: bert-flask-service\nspec:\n  selector:\n    app: bert-flask-pod\n  type: NodePort # service类型\n  ports:\n  - port: 5000\n    nodePort: 30050 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 5000\n```\n\n```kubernetes helm\nkubectl create -f bert_flask.yaml -n note\n```\n\n检查部署情况\n![bert_flask](../image/k8s部署云笔记系统/4.png)\n\n## 5. 部署服务note_cloud\n\n### 5.1 配置ConfigMap\n\n   新建application-prod.yml\n\n```yaml\nserver:\n  port: 8080\n  servlet:\n    context-path: /api\nspring:\n  datasource:\n    url: jdbc:mysql://note-mysql-service:3306/db_note\n    username: root\n    password: dfa6f1b032ee42ed95d12647225f2ff4\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n  redis:\n    host: note-redis-service\n    port: 6379\n    password: adcc64a4a9b04324914626590fb52a1a\n    lettuce:\n      pool:\n        max-active: 10\n        max-idle: 10\n        min-idle: 1\n        time-between-eviction-runs: 10s\n    jackson:\n      default-property-inclusion: non_null # JSON处理时忽略非空字段\n  data:\n    mongodb:\n      uri: mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note\n  servlet:\n    multipart:\n      max-file-size: 10MB\n      max-request-size: 10MB\njwt:\n  base64-encoded-secret-key: lab_of_njust_cloud_computing # jwt的签名密码\nbert-base-chinese-service:\n  host: bert-flask-service\n  port: 5000\n```\n\n```kubernetes helm\nkubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml\n```\n\n   查看部署状态\n   ![部署效果](../image/k8s部署云笔记系统/4.png)\n\n### 5.2 部署服务\n\nnote-cloud.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-cloud-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-cloud-pod\n  template:\n    metadata:\n      labels:\n        app: note-cloud-pod\n    spec:\n      containers:\n      - name: note-cloud\n        image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0\n        imagePullPolicy: IfNotPresent # Always\n        ports:\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /app/config # 配置文件将挂载到容器的/app/config目录\n      volumes:\n      - name: config-volume\n        configMap:\n          name: note-cloud-config # 引用之前创建的 ConfigMap\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-cloud-service\nspec:\n  selector:\n    app: note-cloud-pod\n  type: NodePort # service类型\n  ports:\n  - port: 8080\n    nodePort: 30080 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 8080\n```\n\n```kubernetes helm\nkubectl create -f note-cloud.yaml -n note\n```\n\n查看日志\n\n```kubernetes helm\nkubectl get pod -n note\nkubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note\n```\n\n## 6. 部署前端\n\nnote-nginx.yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-nginx-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-nginx-pod\n  template:\n    metadata:\n      labels:\n        app: note-nginx-pod\n    spec:\n      containers:\n        - name: note-nginx\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-nginx-service\nspec:\n  selector:\n    app: note-nginx-pod\n  type: NodePort # service类型\n  ports:\n  - port: 80\n    nodePort: 30088 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 80\n```\n\n```kubernetes helm\nkubectl create -f note-nginx.yaml -n note\n```\n\n## 最终部署pod查看\n\n![pod](../image/k8s部署云笔记系统/5.png)\n\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n账号：姓名小写拼音\n密码：123456\n\n\n最终效果：\n![6](../image/k8s部署云笔记系统/6.png)\n","slug":"k8s部署云笔记系统","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v40009uugndinqgq81","content":"<blockquote>\n<p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p>\n</blockquote>\n<h2 id=\"创建namespace\"><a href=\"#创建namespace\" class=\"headerlink\" title=\"创建namespace\"></a>创建namespace</h2><figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建namespace</span><br><span class=\"line\">kubectl create namespace note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-部署MySQL\"><a href=\"#1-部署MySQL\" class=\"headerlink\" title=\"1. 部署MySQL\"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-挂载数据卷\"><a href=\"#1-1-挂载数据卷\" class=\"headerlink\" title=\"1.1 挂载数据卷\"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">\t<span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">\t<span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">\t<span class=\"attr\">requests:</span></span><br><span class=\"line\">\t  <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t<span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>部署</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否部署成功：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png\" alt=\"mysql是否部署成功\"></p>\n<h3 id=\"1-2-部署mysql\"><a href=\"#1-2-部署mysql\" class=\"headerlink\" title=\"1.2 部署mysql\"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">\t  <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">\t<span class=\"attr\">metadata:</span></span><br><span class=\"line\">\t  <span class=\"attr\">labels:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">\t<span class=\"attr\">spec:</span></span><br><span class=\"line\">\t  <span class=\"attr\">containers:</span></span><br><span class=\"line\">\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">env:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">ports:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">\t<span class=\"attr\">volumes:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t<span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t<span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">\t<span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-部署redis\"><a href=\"#2-部署redis\" class=\"headerlink\" title=\"2. 部署redis\"></a>2. 部署redis</h2><p>note-redis.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-redis</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">redis:latest</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">REDIS_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30079</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-部署mongodb\"><a href=\"#3-部署mongodb\" class=\"headerlink\" title=\"3. 部署mongodb\"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-挂载数据卷\"><a href=\"#3-1-挂载数据卷\" class=\"headerlink\" title=\"3.1 挂载数据卷\"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否装好：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png\" alt=\"mongodb-pvc\"></p>\n<h3 id=\"3-2-部署\"><a href=\"#3-2-部署\" class=\"headerlink\" title=\"3.2 部署\"></a>3.2 部署</h3><p>note-mongodb.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png\" alt=\"mongodb\"></p>\n<h2 id=\"4-部署服务bert-flask\"><a href=\"#4-部署服务bert-flask\" class=\"headerlink\" title=\"4. 部署服务bert_flask\"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">bert-flask</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5000</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30050</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"bert_flask\"></p>\n<h2 id=\"5-部署服务note-cloud\"><a href=\"#5-部署服务note-cloud\" class=\"headerlink\" title=\"5. 部署服务note_cloud\"></a>5. 部署服务note_cloud</h2><h3 id=\"5-1-配置ConfigMap\"><a href=\"#5-1-配置ConfigMap\" class=\"headerlink\" title=\"5.1 配置ConfigMap\"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/api</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">time-between-eviction-runs:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">    <span class=\"attr\">jackson:</span></span><br><span class=\"line\">      <span class=\"attr\">default-property-inclusion:</span> <span class=\"string\">non_null</span> <span class=\"comment\"># JSON处理时忽略非空字段</span></span><br><span class=\"line\">  <span class=\"attr\">data:</span></span><br><span class=\"line\">    <span class=\"attr\">mongodb:</span></span><br><span class=\"line\">      <span class=\"attr\">uri:</span> <span class=\"string\">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">multipart:</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\">      <span class=\"attr\">max-request-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\"><span class=\"attr\">jwt:</span></span><br><span class=\"line\">  <span class=\"attr\">base64-encoded-secret-key:</span> <span class=\"string\">lab_of_njust_cloud_computing</span> <span class=\"comment\"># jwt的签名密码</span></span><br><span class=\"line\"><span class=\"attr\">bert-base-chinese-service:</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure>\n\n<p>   查看部署状态<br>   <img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"部署效果\"></p>\n<h3 id=\"5-2-部署服务\"><a href=\"#5-2-部署服务\" class=\"headerlink\" title=\"5.2 部署服务\"></a>5.2 部署服务</h3><p>note-cloud.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-cloud</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/app/config</span> <span class=\"comment\"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">        <span class=\"attr\">configMap:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-config</span> <span class=\"comment\"># 引用之前创建的 ConfigMap</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看日志</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br><span class=\"line\">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-部署前端\"><a href=\"#6-部署前端\" class=\"headerlink\" title=\"6. 部署前端\"></a>6. 部署前端</h2><p>note-nginx.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-nginx</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30088</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最终部署pod查看\"><a href=\"#最终部署pod查看\" class=\"headerlink\" title=\"最终部署pod查看\"></a>最终部署pod查看</h2><p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png\" alt=\"pod\"></p>\n<p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p>\n<p>最终效果：<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png\" alt=\"6\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p>\n</blockquote>\n<h2 id=\"创建namespace\"><a href=\"#创建namespace\" class=\"headerlink\" title=\"创建namespace\"></a>创建namespace</h2><figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建namespace</span><br><span class=\"line\">kubectl create namespace note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-部署MySQL\"><a href=\"#1-部署MySQL\" class=\"headerlink\" title=\"1. 部署MySQL\"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-挂载数据卷\"><a href=\"#1-1-挂载数据卷\" class=\"headerlink\" title=\"1.1 挂载数据卷\"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">\t<span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">\t<span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">\t<span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">\t<span class=\"attr\">requests:</span></span><br><span class=\"line\">\t  <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t<span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>部署</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否部署成功：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png\" alt=\"mysql是否部署成功\"></p>\n<h3 id=\"1-2-部署mysql\"><a href=\"#1-2-部署mysql\" class=\"headerlink\" title=\"1.2 部署mysql\"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">\t  <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">\t<span class=\"attr\">metadata:</span></span><br><span class=\"line\">\t  <span class=\"attr\">labels:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">\t<span class=\"attr\">spec:</span></span><br><span class=\"line\">\t  <span class=\"attr\">containers:</span></span><br><span class=\"line\">\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">env:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">ports:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">\t\t\t<span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t\t  <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">\t<span class=\"attr\">volumes:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">\t\t<span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">\t\t  <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">\t<span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">\t<span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">\t<span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-部署redis\"><a href=\"#2-部署redis\" class=\"headerlink\" title=\"2. 部署redis\"></a>2. 部署redis</h2><p>note-redis.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-redis</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">redis:latest</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">REDIS_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-redis-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30079</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<p>部署：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-部署mongodb\"><a href=\"#3-部署mongodb\" class=\"headerlink\" title=\"3. 部署mongodb\"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-挂载数据卷\"><a href=\"#3-1-挂载数据卷\" class=\"headerlink\" title=\"3.1 挂载数据卷\"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看是否装好：</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png\" alt=\"mongodb-pvc\"></p>\n<h3 id=\"3-2-部署\"><a href=\"#3-2-部署\" class=\"headerlink\" title=\"3.2 部署\"></a>3.2 部署</h3><p>note-mongodb.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况</p>\n<p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png\" alt=\"mongodb\"></p>\n<h2 id=\"4-部署服务bert-flask\"><a href=\"#4-部署服务bert-flask\" class=\"headerlink\" title=\"4. 部署服务bert_flask\"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">bert-flask</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5000</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">bert-flask-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30050</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>检查部署情况<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"bert_flask\"></p>\n<h2 id=\"5-部署服务note-cloud\"><a href=\"#5-部署服务note-cloud\" class=\"headerlink\" title=\"5. 部署服务note_cloud\"></a>5. 部署服务note_cloud</h2><h3 id=\"5-1-配置ConfigMap\"><a href=\"#5-1-配置ConfigMap\" class=\"headerlink\" title=\"5.1 配置ConfigMap\"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/api</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">note-redis-service</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class=\"line\">    <span class=\"attr\">lettuce:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">max-active:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">max-idle:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">min-idle:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">time-between-eviction-runs:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">    <span class=\"attr\">jackson:</span></span><br><span class=\"line\">      <span class=\"attr\">default-property-inclusion:</span> <span class=\"string\">non_null</span> <span class=\"comment\"># JSON处理时忽略非空字段</span></span><br><span class=\"line\">  <span class=\"attr\">data:</span></span><br><span class=\"line\">    <span class=\"attr\">mongodb:</span></span><br><span class=\"line\">      <span class=\"attr\">uri:</span> <span class=\"string\">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">multipart:</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\">      <span class=\"attr\">max-request-size:</span> <span class=\"string\">10MB</span></span><br><span class=\"line\"><span class=\"attr\">jwt:</span></span><br><span class=\"line\">  <span class=\"attr\">base64-encoded-secret-key:</span> <span class=\"string\">lab_of_njust_cloud_computing</span> <span class=\"comment\"># jwt的签名密码</span></span><br><span class=\"line\"><span class=\"attr\">bert-base-chinese-service:</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span> <span class=\"string\">bert-flask-service</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure>\n\n<p>   查看部署状态<br>   <img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png\" alt=\"部署效果\"></p>\n<h3 id=\"5-2-部署服务\"><a href=\"#5-2-部署服务\" class=\"headerlink\" title=\"5.2 部署服务\"></a>5.2 部署服务</h3><p>note-cloud.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-cloud</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># Always</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/app/config</span> <span class=\"comment\"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">        <span class=\"attr\">configMap:</span></span><br><span class=\"line\">          <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-config</span> <span class=\"comment\"># 引用之前创建的 ConfigMap</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-cloud-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-cloud-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30080</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">8080</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<p>查看日志</p>\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br><span class=\"line\">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-部署前端\"><a href=\"#6-部署前端\" class=\"headerlink\" title=\"6. 部署前端\"></a>6. 部署前端</h2><p>note-nginx.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-nginx</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-nginx-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30088</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>helm</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最终部署pod查看\"><a href=\"#最终部署pod查看\" class=\"headerlink\" title=\"最终部署pod查看\"></a>最终部署pod查看</h2><p><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png\" alt=\"pod\"></p>\n<p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p>\n<p>最终效果：<br><img src=\"/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png\" alt=\"6\"></p>\n"},{"title":"react技巧","keywords":["react"],"description":"写代码的时候对react-native使用的一些技巧","abbrlink":56292,"date":"2023-10-07T07:03:23.000Z","updated":"2023-10-07T07:30:23.000Z","top_img":"https://s2.loli.net/2024/02/06/lhsVBAGIouNxRUa.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/u1DMChx86N93wPR.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：[casdoor-app](https://github.com/cwp0/casdoor-app)\n\n> 后面如果做react的话可能也会做一些总结，到时候再加。\n\n# react-native\n\n## React Context\n\n用于在不同的组件中或者 `js` 文件中共享同一个数据。\n\n使用方法：\n\n例如要共享 `userInfo`\n\n1. 在应用程序中创建一个 `React Context`，用于共享 `userInfo`。\n\n   `UserContext.js`\n\n    ```jsx\n    import React from \"react\";\n    \n    const UserContext = React.createContext();\n    export const UserProvider = UserContext.Provider;\n    export const UserConsumer = UserContext.Consumer;\n    export default UserContext;\n    ```\n\n\n1. 在 `App.js` 中使用 **`UserProvider`** 包裹应用程序\n\n   注意这里要设置需要共享的数据 `value={{userInfo, setUserInfo}}`\n\n    ```jsx\n    import * as React from \"react\";\n    import {PaperProvider} from \"react-native-paper\";\n    import NavigationBar from \"./NavigationBar\";\n    import {NavigationContainer} from \"@react-navigation/native\";\n    import Header from \"./Header\";\n    import {UserProvider} from \"./UserContext\";\n    \n    const App = () => {\n      const [userInfo, setUserInfo] = React.useState(null);\n      return (\n        <UserProvider value={{userInfo, setUserInfo}} >\n          <NavigationContainer>\n            <PaperProvider>\n              <Header />\n              <NavigationBar />\n            </PaperProvider>\n          </NavigationContainer>\n        </UserProvider>\n      );\n    };\n    export default App;\n    ```\n\n\n1. 在其他组件中，通过导入 `UserContext.js` 进行使用共享的数据。\n\n   注意：声明新的 `React.useContext`的时候需要用花括号。\n\n   `Header.js`\n\n    ```jsx\n    import * as React from \"react\";\n    import {Appbar, Avatar, Button, Menu, Text} from \"react-native-paper\";\n    import UserContext from \"./UserContext\";\n    import {View} from \"react-native\";\n    import CasdoorLoginPage, {CasdoorLogout} from \"./CasdoorLoginPage\";\n    \n    const Header = () => {\n      const {userInfo, setUserInfo} = React.useContext(UserContext);\n      const [showLoginPage, setShowLoginPage] = React.useState(false);\n      const [menuVisible, setMenuVisible] = React.useState(false);\n      const openMenu = () => setMenuVisible(true);\n      const closeMenu = () => setMenuVisible(false);\n      const handleMenuLogoutClicked = () => {\n        handleCasdoorLogout();\n        closeMenu();\n      };\n    \n      const handleCasdoorLogin = () => {\n        setShowLoginPage(true);\n      };\n      const handleCasdoorLogout = () => {\n        CasdoorLogout();\n        setUserInfo(null);\n      };\n      const handleHideLoginPage = () => {\n        setShowLoginPage(false);\n      };\n      return (\n        <View>\n          <Appbar.Header style={{height: 40}}>\n            <Appbar.Content title=\"Casdoor\" />\n            <Menu\n              visible={menuVisible}\n              anchor={\n                <Button\n                  style={{marginRight: 10, backgroundColor: \"transparent\", height: 40}}\n                  onPress={userInfo === null ? handleCasdoorLogin : openMenu}\n                >\n                  {\n                    userInfo === null ?\n                      null :\n                      <Avatar.Image\n                        size={32}\n                        source={{uri: userInfo.avatar}}\n                        style={{marginRight: 10, backgroundColor: \"transparent\"}}\n                      />\n                  }\n                  <Text style={{marginRight: 10}} variant=\"titleMedium\">\n                    {userInfo === null ? \"Login\" : userInfo.name}\n                  </Text>\n                </Button>\n              }\n              onDismiss={closeMenu}\n            >\n              <Menu.Item onPress={() => handleMenuLogoutClicked()} title=\"Logout\" />\n            </Menu>\n          </Appbar.Header>\n          {showLoginPage && <CasdoorLoginPage onWebviewClose={handleHideLoginPage} />}\n        </View>\n      );\n    };\n    \n    export default Header;\n    ```\n\n\n## 子组件使用父组件的函数等参数\n\n在父组件中：\n\n定义好相关函数及变量，将参数传递给子组件。\n\n```jsx\nconst [placeholder, setPlaceholder] = React.useState(\"\");\n\nconst closeEditAccountModal = () => {\n    setShowEditAccountModal(false);\n};\n\nconst onAccountEdit = (accountDescp) => {\n    const accountToEdit = accountList.find(account => account.getEditStatus() === true);\n    if (accountToEdit) {\n      accountToEdit.setTitle(accountDescp);\n    }\n    setPlaceholder(\"\");\n    closeEditAccountModal();\n}\n\n<EditAccountDetails onClose={closeEditAccountModal} onEdit={onAccountEdit} placeholder={placeholder} />\n```\n\n在子组件中：\n\n添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。\n\n```jsx\nimport React, {useState} from \"react\";\nimport {Text, TextInput, View} from \"react-native\";\nimport {Button, IconButton} from \"react-native-paper\";\nimport PropTypes from \"prop-types\";\n\nexport default function EnterAccountDetails({onClose, onEdit, placeholder}) {\n  EnterAccountDetails.propTypes = {\n    onClose: PropTypes.func.isRequired,\n    onEdit: PropTypes.func.isRequired,\n    placeholder: PropTypes.string.isRequired,\n  };\n\n  const [description, setDescription] = useState(\"\");\n\n  const handleConfirm = () => {\n    onEdit(description);\n  };\n  return (\n    <View style={{flex: 1, justifyContent: \"center\", alignItems: \"center\"}}>\n      <Text style={{fontSize: 24, marginBottom: 5}}>Enter new description</Text>\n      <View style={{flexDirection: \"row\", alignItems: \"center\"}}>\n        <IconButton icon=\"account-details\" size={35} />\n        <TextInput\n          placeholder={placeholder}\n          value={description}\n          onChangeText={(text) => setDescription(text)}\n          style={{borderWidth: 3, borderColor: \"white\", margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: \"gray\", paddingLeft: 10}}\n        />\n      </View>\n      <Button\n        style={{\n          backgroundColor: \"#E6DFF3\",\n          borderRadius: 5,\n          margin: 10,\n          alignItems: \"center\",\n          position: \"absolute\",\n          top: 160,\n          width: 300,\n        }}\n        onPress={handleConfirm}\n      >\n        <Text style={{fontSize: 18, width: 280}}>Confirm</Text>\n      </Button>\n      <IconButton icon={\"close\"} size={30} onPress={onClose} style={{position: \"absolute\", top: 5, right: 5}} />\n    </View>\n  );\n}\n```\n\n## 父组件使用自组件的函数等参数\n\n在子组件中：\n\n将父组件要使用的函数导出：\n\n```jsx\nimport React, {useEffect} from \"react\";\nimport {WebView} from \"react-native-webview\";\nimport {View} from \"react-native\";\nimport {Portal} from \"react-native-paper\";\nimport CasdoorSdkConfig from \"./CasdoorSdkConfig\";\nimport SDK from \"casdoor-react-native-sdk\";\nimport UserContext from \"./UserContext\";\nimport PropTypes from \"prop-types\";\n// import {LogBox} from \"react-native\";\n// LogBox.ignoreAllLogs();\nconst sdk = new SDK(CasdoorSdkConfig);\n\nconst CasdoorLoginPage = ({onWebviewClose}) => {\n  CasdoorLoginPage.propTypes = {\n    onWebviewClose: PropTypes.func.isRequired,\n  };\n  const [casdoorLoginURL, setCasdoorLoginURL] = React.useState(\"\");\n  const {setUserInfo} = React.useContext(UserContext);\n  const getCasdoorSignInUrl = async() => {\n    const signinUrl = await sdk.getSigninUrl();\n    setCasdoorLoginURL(signinUrl);\n  };\n\n  useEffect(() => {\n    getCasdoorSignInUrl();\n  }, []);\n\n  const onNavigationStateChange = async(navState) => {\n    if (navState.url.startsWith(CasdoorSdkConfig.redirectPath)) {\n      onWebviewClose();\n      const token = await sdk.getAccessToken(navState.url);\n      const userInfo = sdk.JwtDecode(token);\n      setUserInfo(userInfo);\n    }\n  };\n\n  return (\n    <Portal>\n      <View style={{flex: 1}}>\n        {casdoorLoginURL !== \"\" && (\n          <WebView\n            source={{uri: casdoorLoginURL}}\n            onNavigationStateChange={onNavigationStateChange}\n            style={{flex: 1}}\n            mixedContentMode=\"always\"\n            javaScriptEnabled={true}\n          />\n        )}\n      </View>\n    </Portal>\n  );\n};\n\nexport const CasdoorLogout = () => {\n  sdk.clearState();\n};\nexport default CasdoorLoginPage;\n```\n\n在父组件中：\n\n导入子组件及其导出的函数，注意导出的方式，导出的组件直接 `import` ，导出的组件的函数要使用花括号来包裹。\n","source":"_posts/react技巧.md","raw":"---\ntitle: react技巧\ntags:\n  - 移动端\n  - 前端\n  - react\n  - react-native\ncategories:\n  - react\nkeywords:\n  - react\ndescription: 写代码的时候对react-native使用的一些技巧\nabbrlink: 56292\ndate: 2023-10-07 15:03:23\nupdated: 2023-10-07 15:30:23\ntop_img: https://s2.loli.net/2024/02/06/lhsVBAGIouNxRUa.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/u1DMChx86N93wPR.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：[casdoor-app](https://github.com/cwp0/casdoor-app)\n\n> 后面如果做react的话可能也会做一些总结，到时候再加。\n\n# react-native\n\n## React Context\n\n用于在不同的组件中或者 `js` 文件中共享同一个数据。\n\n使用方法：\n\n例如要共享 `userInfo`\n\n1. 在应用程序中创建一个 `React Context`，用于共享 `userInfo`。\n\n   `UserContext.js`\n\n    ```jsx\n    import React from \"react\";\n    \n    const UserContext = React.createContext();\n    export const UserProvider = UserContext.Provider;\n    export const UserConsumer = UserContext.Consumer;\n    export default UserContext;\n    ```\n\n\n1. 在 `App.js` 中使用 **`UserProvider`** 包裹应用程序\n\n   注意这里要设置需要共享的数据 `value={{userInfo, setUserInfo}}`\n\n    ```jsx\n    import * as React from \"react\";\n    import {PaperProvider} from \"react-native-paper\";\n    import NavigationBar from \"./NavigationBar\";\n    import {NavigationContainer} from \"@react-navigation/native\";\n    import Header from \"./Header\";\n    import {UserProvider} from \"./UserContext\";\n    \n    const App = () => {\n      const [userInfo, setUserInfo] = React.useState(null);\n      return (\n        <UserProvider value={{userInfo, setUserInfo}} >\n          <NavigationContainer>\n            <PaperProvider>\n              <Header />\n              <NavigationBar />\n            </PaperProvider>\n          </NavigationContainer>\n        </UserProvider>\n      );\n    };\n    export default App;\n    ```\n\n\n1. 在其他组件中，通过导入 `UserContext.js` 进行使用共享的数据。\n\n   注意：声明新的 `React.useContext`的时候需要用花括号。\n\n   `Header.js`\n\n    ```jsx\n    import * as React from \"react\";\n    import {Appbar, Avatar, Button, Menu, Text} from \"react-native-paper\";\n    import UserContext from \"./UserContext\";\n    import {View} from \"react-native\";\n    import CasdoorLoginPage, {CasdoorLogout} from \"./CasdoorLoginPage\";\n    \n    const Header = () => {\n      const {userInfo, setUserInfo} = React.useContext(UserContext);\n      const [showLoginPage, setShowLoginPage] = React.useState(false);\n      const [menuVisible, setMenuVisible] = React.useState(false);\n      const openMenu = () => setMenuVisible(true);\n      const closeMenu = () => setMenuVisible(false);\n      const handleMenuLogoutClicked = () => {\n        handleCasdoorLogout();\n        closeMenu();\n      };\n    \n      const handleCasdoorLogin = () => {\n        setShowLoginPage(true);\n      };\n      const handleCasdoorLogout = () => {\n        CasdoorLogout();\n        setUserInfo(null);\n      };\n      const handleHideLoginPage = () => {\n        setShowLoginPage(false);\n      };\n      return (\n        <View>\n          <Appbar.Header style={{height: 40}}>\n            <Appbar.Content title=\"Casdoor\" />\n            <Menu\n              visible={menuVisible}\n              anchor={\n                <Button\n                  style={{marginRight: 10, backgroundColor: \"transparent\", height: 40}}\n                  onPress={userInfo === null ? handleCasdoorLogin : openMenu}\n                >\n                  {\n                    userInfo === null ?\n                      null :\n                      <Avatar.Image\n                        size={32}\n                        source={{uri: userInfo.avatar}}\n                        style={{marginRight: 10, backgroundColor: \"transparent\"}}\n                      />\n                  }\n                  <Text style={{marginRight: 10}} variant=\"titleMedium\">\n                    {userInfo === null ? \"Login\" : userInfo.name}\n                  </Text>\n                </Button>\n              }\n              onDismiss={closeMenu}\n            >\n              <Menu.Item onPress={() => handleMenuLogoutClicked()} title=\"Logout\" />\n            </Menu>\n          </Appbar.Header>\n          {showLoginPage && <CasdoorLoginPage onWebviewClose={handleHideLoginPage} />}\n        </View>\n      );\n    };\n    \n    export default Header;\n    ```\n\n\n## 子组件使用父组件的函数等参数\n\n在父组件中：\n\n定义好相关函数及变量，将参数传递给子组件。\n\n```jsx\nconst [placeholder, setPlaceholder] = React.useState(\"\");\n\nconst closeEditAccountModal = () => {\n    setShowEditAccountModal(false);\n};\n\nconst onAccountEdit = (accountDescp) => {\n    const accountToEdit = accountList.find(account => account.getEditStatus() === true);\n    if (accountToEdit) {\n      accountToEdit.setTitle(accountDescp);\n    }\n    setPlaceholder(\"\");\n    closeEditAccountModal();\n}\n\n<EditAccountDetails onClose={closeEditAccountModal} onEdit={onAccountEdit} placeholder={placeholder} />\n```\n\n在子组件中：\n\n添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。\n\n```jsx\nimport React, {useState} from \"react\";\nimport {Text, TextInput, View} from \"react-native\";\nimport {Button, IconButton} from \"react-native-paper\";\nimport PropTypes from \"prop-types\";\n\nexport default function EnterAccountDetails({onClose, onEdit, placeholder}) {\n  EnterAccountDetails.propTypes = {\n    onClose: PropTypes.func.isRequired,\n    onEdit: PropTypes.func.isRequired,\n    placeholder: PropTypes.string.isRequired,\n  };\n\n  const [description, setDescription] = useState(\"\");\n\n  const handleConfirm = () => {\n    onEdit(description);\n  };\n  return (\n    <View style={{flex: 1, justifyContent: \"center\", alignItems: \"center\"}}>\n      <Text style={{fontSize: 24, marginBottom: 5}}>Enter new description</Text>\n      <View style={{flexDirection: \"row\", alignItems: \"center\"}}>\n        <IconButton icon=\"account-details\" size={35} />\n        <TextInput\n          placeholder={placeholder}\n          value={description}\n          onChangeText={(text) => setDescription(text)}\n          style={{borderWidth: 3, borderColor: \"white\", margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: \"gray\", paddingLeft: 10}}\n        />\n      </View>\n      <Button\n        style={{\n          backgroundColor: \"#E6DFF3\",\n          borderRadius: 5,\n          margin: 10,\n          alignItems: \"center\",\n          position: \"absolute\",\n          top: 160,\n          width: 300,\n        }}\n        onPress={handleConfirm}\n      >\n        <Text style={{fontSize: 18, width: 280}}>Confirm</Text>\n      </Button>\n      <IconButton icon={\"close\"} size={30} onPress={onClose} style={{position: \"absolute\", top: 5, right: 5}} />\n    </View>\n  );\n}\n```\n\n## 父组件使用自组件的函数等参数\n\n在子组件中：\n\n将父组件要使用的函数导出：\n\n```jsx\nimport React, {useEffect} from \"react\";\nimport {WebView} from \"react-native-webview\";\nimport {View} from \"react-native\";\nimport {Portal} from \"react-native-paper\";\nimport CasdoorSdkConfig from \"./CasdoorSdkConfig\";\nimport SDK from \"casdoor-react-native-sdk\";\nimport UserContext from \"./UserContext\";\nimport PropTypes from \"prop-types\";\n// import {LogBox} from \"react-native\";\n// LogBox.ignoreAllLogs();\nconst sdk = new SDK(CasdoorSdkConfig);\n\nconst CasdoorLoginPage = ({onWebviewClose}) => {\n  CasdoorLoginPage.propTypes = {\n    onWebviewClose: PropTypes.func.isRequired,\n  };\n  const [casdoorLoginURL, setCasdoorLoginURL] = React.useState(\"\");\n  const {setUserInfo} = React.useContext(UserContext);\n  const getCasdoorSignInUrl = async() => {\n    const signinUrl = await sdk.getSigninUrl();\n    setCasdoorLoginURL(signinUrl);\n  };\n\n  useEffect(() => {\n    getCasdoorSignInUrl();\n  }, []);\n\n  const onNavigationStateChange = async(navState) => {\n    if (navState.url.startsWith(CasdoorSdkConfig.redirectPath)) {\n      onWebviewClose();\n      const token = await sdk.getAccessToken(navState.url);\n      const userInfo = sdk.JwtDecode(token);\n      setUserInfo(userInfo);\n    }\n  };\n\n  return (\n    <Portal>\n      <View style={{flex: 1}}>\n        {casdoorLoginURL !== \"\" && (\n          <WebView\n            source={{uri: casdoorLoginURL}}\n            onNavigationStateChange={onNavigationStateChange}\n            style={{flex: 1}}\n            mixedContentMode=\"always\"\n            javaScriptEnabled={true}\n          />\n        )}\n      </View>\n    </Portal>\n  );\n};\n\nexport const CasdoorLogout = () => {\n  sdk.clearState();\n};\nexport default CasdoorLoginPage;\n```\n\n在父组件中：\n\n导入子组件及其导出的函数，注意导出的方式，导出的组件直接 `import` ，导出的组件的函数要使用花括号来包裹。\n","slug":"react技巧","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v4000buugn5zny9zgj","content":"<blockquote>\n<p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href=\"https://github.com/cwp0/casdoor-app\">casdoor-app</a></p>\n</blockquote>\n<blockquote>\n<p>后面如果做react的话可能也会做一些总结，到时候再加。</p>\n</blockquote>\n<h1 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h1><h2 id=\"React-Context\"><a href=\"#React-Context\" class=\"headerlink\" title=\"React Context\"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p>\n<p>使用方法：</p>\n<p>例如要共享 <code>userInfo</code></p>\n<ol>\n<li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p>\n<p><code>UserContext.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">UserContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserProvider</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Provider</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserConsumer</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Consumer</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">UserContext</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p>\n<p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">PaperProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">NavigationBar</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./NavigationBar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">NavigationContainer</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@react-navigation/native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Header</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Header&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">UserProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [userInfo, setUserInfo] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserProvider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;userInfo,</span> <span class=\"attr\">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Header</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">NavigationBar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">UserProvider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p>\n<p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p>\n<p><code>Header.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Appbar</span>, <span class=\"title class_\">Avatar</span>, <span class=\"title class_\">Button</span>, <span class=\"title class_\">Menu</span>, <span class=\"title class_\">Text</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorLoginPage</span>, &#123;<span class=\"title class_\">CasdoorLogout</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Header</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;userInfo, setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [showLoginPage, setShowLoginPage] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [menuVisible, setMenuVisible] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">openMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">closeMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleMenuLogoutClicked</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleCasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">closeMenu</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogin</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setUserInfo</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleHideLoginPage</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Appbar.Header</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;height:</span> <span class=\"attr\">40</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Appbar.Content</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Menu</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">visible</span>=<span class=\"string\">&#123;menuVisible&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">anchor</span>=<span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &lt;<span class=\"attr\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;, <span class=\"attr\">height:</span> <span class=\"attr\">40</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;userInfo</span> === <span class=\"string\">null</span> ? <span class=\"attr\">handleCasdoorLogin</span> <span class=\"attr\">:</span> <span class=\"attr\">openMenu</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                userInfo === null ?</span></span><br><span class=\"line\"><span class=\"language-xml\">                  null :</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">Avatar.Image</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">size</span>=<span class=\"string\">&#123;32&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>&#125;&#125; <span class=\"attr\">variant</span>=<span class=\"string\">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        &gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Menu.Item</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Menu</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Appbar.Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;showLoginPage &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">CasdoorLoginPage</span> <span class=\"attr\">onWebviewClose</span>=<span class=\"string\">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Header</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件使用父组件的函数等参数\"><a href=\"#子组件使用父组件的函数等参数\" class=\"headerlink\" title=\"子组件使用父组件的函数等参数\"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p>\n<p>定义好相关函数及变量，将参数传递给子组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [placeholder, setPlaceholder] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">closeEditAccountModal</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowEditAccountModal</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">onAccountEdit</span> = (<span class=\"params\">accountDescp</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accountToEdit = accountList.<span class=\"title function_\">find</span>(<span class=\"function\"><span class=\"params\">account</span> =&gt;</span> account.<span class=\"title function_\">getEditStatus</span>() === <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accountToEdit) &#123;</span><br><span class=\"line\">      accountToEdit.<span class=\"title function_\">setTitle</span>(accountDescp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">setPlaceholder</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_\">closeEditAccountModal</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"title class_\">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在子组件中：</p>\n<p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Text</span>, <span class=\"title class_\">TextInput</span>, <span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Button</span>, <span class=\"title class_\">IconButton</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">EnterAccountDetails</span>(<span class=\"params\">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">EnterAccountDetails</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">onEdit</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [description, setDescription] = <span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleConfirm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">onEdit</span>(description);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>, <span class=\"attr\">justifyContent:</span> &quot;<span class=\"attr\">center</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">24</span>, <span class=\"attr\">marginBottom:</span> <span class=\"attr\">5</span>&#125;&#125;&gt;</span>Enter new description<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flexDirection:</span> &quot;<span class=\"attr\">row</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&quot;account-details&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">&#123;35&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TextInput</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">placeholder</span>=<span class=\"string\">&#123;placeholder&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">value</span>=<span class=\"string\">&#123;description&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChangeText</span>=<span class=\"string\">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">backgroundColor:</span> &quot;#<span class=\"attr\">E6DFF3</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">borderRadius:</span> <span class=\"attr\">5</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">margin:</span> <span class=\"attr\">10</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">position:</span> &quot;<span class=\"attr\">absolute</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">top:</span> <span class=\"attr\">160</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">width:</span> <span class=\"attr\">300</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;handleConfirm&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">18</span>, <span class=\"attr\">width:</span> <span class=\"attr\">280</span>&#125;&#125;&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&#123;</span>&quot;<span class=\"attr\">close</span>&quot;&#125; <span class=\"attr\">size</span>=<span class=\"string\">&#123;30&#125;</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;onClose&#125;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;position:</span> &quot;<span class=\"attr\">absolute</span>&quot;, <span class=\"attr\">top:</span> <span class=\"attr\">5</span>, <span class=\"attr\">right:</span> <span class=\"attr\">5</span>&#125;&#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"父组件使用自组件的函数等参数\"><a href=\"#父组件使用自组件的函数等参数\" class=\"headerlink\" title=\"父组件使用自组件的函数等参数\"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p>\n<p>将父组件要使用的函数导出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">WebView</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-webview&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Portal</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorSdkConfig</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"variable constant_\">SDK</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// LogBox.ignoreAllLogs();</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sdk = <span class=\"keyword\">new</span> <span class=\"title function_\">SDK</span>(<span class=\"title class_\">CasdoorSdkConfig</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLoginPage</span> = (<span class=\"params\">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CasdoorLoginPage</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onWebviewClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">getCasdoorSignInUrl</span> = <span class=\"keyword\">async</span>(<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> signinUrl = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getSigninUrl</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setCasdoorLoginURL</span>(signinUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getCasdoorSignInUrl</span>();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onNavigationStateChange</span> = <span class=\"keyword\">async</span>(<span class=\"params\">navState</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navState.<span class=\"property\">url</span>.<span class=\"title function_\">startsWith</span>(<span class=\"title class_\">CasdoorSdkConfig</span>.<span class=\"property\">redirectPath</span>)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onWebviewClose</span>();</span><br><span class=\"line\">      <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getAccessToken</span>(navState.<span class=\"property\">url</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> userInfo = sdk.<span class=\"title class_\">JwtDecode</span>(token);</span><br><span class=\"line\">      <span class=\"title function_\">setUserInfo</span>(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">WebView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">onNavigationStateChange</span>=<span class=\"string\">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">mixedContentMode</span>=<span class=\"string\">&quot;always&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">javaScriptEnabled</span>=<span class=\"string\">&#123;true&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  sdk.<span class=\"title function_\">clearState</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在父组件中：</p>\n<p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href=\"https://github.com/cwp0/casdoor-app\">casdoor-app</a></p>\n</blockquote>\n<blockquote>\n<p>后面如果做react的话可能也会做一些总结，到时候再加。</p>\n</blockquote>\n<h1 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react-native\"></a>react-native</h1><h2 id=\"React-Context\"><a href=\"#React-Context\" class=\"headerlink\" title=\"React Context\"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p>\n<p>使用方法：</p>\n<p>例如要共享 <code>userInfo</code></p>\n<ol>\n<li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p>\n<p><code>UserContext.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">UserContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserProvider</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Provider</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UserConsumer</span> = <span class=\"title class_\">UserContext</span>.<span class=\"property\">Consumer</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">UserContext</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p>\n<p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">PaperProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">NavigationBar</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./NavigationBar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">NavigationContainer</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@react-navigation/native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Header</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Header&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">UserProvider</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [userInfo, setUserInfo] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">UserProvider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;userInfo,</span> <span class=\"attr\">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Header</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">NavigationBar</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">PaperProvider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">NavigationContainer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">UserProvider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p>\n<p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p>\n<p><code>Header.js</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Appbar</span>, <span class=\"title class_\">Avatar</span>, <span class=\"title class_\">Button</span>, <span class=\"title class_\">Menu</span>, <span class=\"title class_\">Text</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorLoginPage</span>, &#123;<span class=\"title class_\">CasdoorLogout</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Header</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;userInfo, setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [showLoginPage, setShowLoginPage] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [menuVisible, setMenuVisible] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">openMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">closeMenu</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">setMenuVisible</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleMenuLogoutClicked</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">handleCasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">closeMenu</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogin</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleCasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">CasdoorLogout</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setUserInfo</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleHideLoginPage</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowLoginPage</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Appbar.Header</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;height:</span> <span class=\"attr\">40</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Appbar.Content</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Menu</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">visible</span>=<span class=\"string\">&#123;menuVisible&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">anchor</span>=<span class=\"string\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &lt;<span class=\"attr\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;, <span class=\"attr\">height:</span> <span class=\"attr\">40</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;userInfo</span> === <span class=\"string\">null</span> ? <span class=\"attr\">handleCasdoorLogin</span> <span class=\"attr\">:</span> <span class=\"attr\">openMenu</span>&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">                userInfo === null ?</span></span><br><span class=\"line\"><span class=\"language-xml\">                  null :</span></span><br><span class=\"line\"><span class=\"language-xml\">                  <span class=\"tag\">&lt;<span class=\"name\">Avatar.Image</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">size</span>=<span class=\"string\">&#123;32&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>, <span class=\"attr\">backgroundColor:</span> &quot;<span class=\"attr\">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">              &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;marginRight:</span> <span class=\"attr\">10</span>&#125;&#125; <span class=\"attr\">variant</span>=<span class=\"string\">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">              <span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        &gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">Menu.Item</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Menu</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Appbar.Header</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;showLoginPage &amp;&amp; <span class=\"tag\">&lt;<span class=\"name\">CasdoorLoginPage</span> <span class=\"attr\">onWebviewClose</span>=<span class=\"string\">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Header</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件使用父组件的函数等参数\"><a href=\"#子组件使用父组件的函数等参数\" class=\"headerlink\" title=\"子组件使用父组件的函数等参数\"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p>\n<p>定义好相关函数及变量，将参数传递给子组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [placeholder, setPlaceholder] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">closeEditAccountModal</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setShowEditAccountModal</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">onAccountEdit</span> = (<span class=\"params\">accountDescp</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accountToEdit = accountList.<span class=\"title function_\">find</span>(<span class=\"function\"><span class=\"params\">account</span> =&gt;</span> account.<span class=\"title function_\">getEditStatus</span>() === <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accountToEdit) &#123;</span><br><span class=\"line\">      accountToEdit.<span class=\"title function_\">setTitle</span>(accountDescp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">setPlaceholder</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_\">closeEditAccountModal</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"title class_\">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在子组件中：</p>\n<p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Text</span>, <span class=\"title class_\">TextInput</span>, <span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Button</span>, <span class=\"title class_\">IconButton</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">EnterAccountDetails</span>(<span class=\"params\">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">EnterAccountDetails</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">onEdit</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [description, setDescription] = <span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleConfirm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">onEdit</span>(description);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>, <span class=\"attr\">justifyContent:</span> &quot;<span class=\"attr\">center</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">24</span>, <span class=\"attr\">marginBottom:</span> <span class=\"attr\">5</span>&#125;&#125;&gt;</span>Enter new description<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flexDirection:</span> &quot;<span class=\"attr\">row</span>&quot;, <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&quot;account-details&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">&#123;35&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TextInput</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">placeholder</span>=<span class=\"string\">&#123;placeholder&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">value</span>=<span class=\"string\">&#123;description&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChangeText</span>=<span class=\"string\">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">backgroundColor:</span> &quot;#<span class=\"attr\">E6DFF3</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">borderRadius:</span> <span class=\"attr\">5</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">margin:</span> <span class=\"attr\">10</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">alignItems:</span> &quot;<span class=\"attr\">center</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">position:</span> &quot;<span class=\"attr\">absolute</span>&quot;,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">top:</span> <span class=\"attr\">160</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">width:</span> <span class=\"attr\">300</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;handleConfirm&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Text</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;fontSize:</span> <span class=\"attr\">18</span>, <span class=\"attr\">width:</span> <span class=\"attr\">280</span>&#125;&#125;&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">Text</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">IconButton</span> <span class=\"attr\">icon</span>=<span class=\"string\">&#123;</span>&quot;<span class=\"attr\">close</span>&quot;&#125; <span class=\"attr\">size</span>=<span class=\"string\">&#123;30&#125;</span> <span class=\"attr\">onPress</span>=<span class=\"string\">&#123;onClose&#125;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;position:</span> &quot;<span class=\"attr\">absolute</span>&quot;, <span class=\"attr\">top:</span> <span class=\"attr\">5</span>, <span class=\"attr\">right:</span> <span class=\"attr\">5</span>&#125;&#125; /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"父组件使用自组件的函数等参数\"><a href=\"#父组件使用自组件的函数等参数\" class=\"headerlink\" title=\"父组件使用自组件的函数等参数\"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p>\n<p>将父组件要使用的函数导出：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123;useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">WebView</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-webview&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">View</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">Portal</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-native-paper&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CasdoorSdkConfig</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"variable constant_\">SDK</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UserContext</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./UserContext&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// LogBox.ignoreAllLogs();</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sdk = <span class=\"keyword\">new</span> <span class=\"title function_\">SDK</span>(<span class=\"title class_\">CasdoorSdkConfig</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLoginPage</span> = (<span class=\"params\">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">CasdoorLoginPage</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onWebviewClose</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123;setUserInfo&#125; = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">UserContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">getCasdoorSignInUrl</span> = <span class=\"keyword\">async</span>(<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> signinUrl = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getSigninUrl</span>();</span><br><span class=\"line\">    <span class=\"title function_\">setCasdoorLoginURL</span>(signinUrl);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getCasdoorSignInUrl</span>();</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onNavigationStateChange</span> = <span class=\"keyword\">async</span>(<span class=\"params\">navState</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (navState.<span class=\"property\">url</span>.<span class=\"title function_\">startsWith</span>(<span class=\"title class_\">CasdoorSdkConfig</span>.<span class=\"property\">redirectPath</span>)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onWebviewClose</span>();</span><br><span class=\"line\">      <span class=\"keyword\">const</span> token = <span class=\"keyword\">await</span> sdk.<span class=\"title function_\">getAccessToken</span>(navState.<span class=\"property\">url</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> userInfo = sdk.<span class=\"title class_\">JwtDecode</span>(token);</span><br><span class=\"line\">      <span class=\"title function_\">setUserInfo</span>(userInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">View</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">WebView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">source</span>=<span class=\"string\">&#123;&#123;uri:</span> <span class=\"attr\">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">onNavigationStateChange</span>=<span class=\"string\">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;flex:</span> <span class=\"attr\">1</span>&#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">mixedContentMode</span>=<span class=\"string\">&quot;always&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">javaScriptEnabled</span>=<span class=\"string\">&#123;true&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">View</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Portal</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">CasdoorLogout</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  sdk.<span class=\"title function_\">clearState</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在父组件中：</p>\n<p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>\n"},{"title":"前端&移动端面经","keywords":["面经"],"description":"前端&移动端面经","abbrlink":17767,"date":"2024-05-27T12:14:47.000Z","updated":"2024-05-27T12:58:53.000Z","top_img":"https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\nthis is a test file.\n","source":"_posts/前端-移动端面经.md","raw":"---\ntitle: 前端&移动端面经\ntags:\n  - 前端\n  - 移动端\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 前端&移动端面经\nabbrlink: 17767\ndate: 2024-05-27 20:14:47\nupdated: 2024-05-27 20:58:53\ntop_img: https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\nthis is a test file.\n","slug":"前端-移动端面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v5000guugnfo500ze1","content":"<p>this is a test file.</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<p>this is a test file.</p>\n"},{"title":"云笔记系统扩容","keywords":["k8s"],"description":"对k8s服务器上部署的云笔记系统进行扩容","abbrlink":36313,"date":"2023-09-20T06:50:58.000Z","updated":"2023-09-20T07:00:00.000Z","top_img":"https://s2.loli.net/2024/02/06/MemxlCZb8nKTBXp.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/ENM4lTRwfKyOtJB.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n### 起因\n\n之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 `mysql`和存储笔记信息的 `mongodb`在部署的时候我都设置了 `1G`的存储卷，这是远远不够的，因此需对其进行扩容。\n\n根据老师要求，需将内存从 `1G`扩展到  `50G`，这是针对存笔记系统的 `mongodb`，为了更加稳妥，跟学弟协商后决定将存用户数据的 `mysql`也扩充到 `10G`。\n\n### 大体思路：\n\n1. 确定 `mongodb`和 `mysql`的 `pod`所在的 `node`节点。\n2. 备份数据\n3. 删除旧的 `pod`\n4. 分别修改 `mongodb`和 `mysql`的 `pv`、 `pvc`为 `50Gi`、 `10Gi`。\n5. 指定 `mongodb`和 `mysql`的 `pv`、 `pvc`及 `mongodb`、 `mysql`部署的亲和性，让其部署在指定 `node`节点，便于扩容。\n6. 重新部署相应 `pod`\n7. 扩容指定的 `mongodb`、 `mysql`部署的节点的虚拟机。\n\n> 注：本笔记图片里的 `deployment`的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。\n\n## 1. 确定pod所在的node节点\n\n首先远程连接 `131`服务器。\n\n云笔记系统有 `6`个 `pod`，在 `note`空间里，如下所示：\n\n```bash\nkubectl get pod -n note\n```\n\n![pod](../image/云笔记系统扩容/pod.png)\n\n需确定 `mongodb`、 `mysql`所在的 `node`节点，命令如下：\n\n```bash\nkubectl get pod -n note -o wide\n```\n\n![pod-node](../image/云笔记系统扩容/pod-node.png)\n\n由上图可知， `mongodb`和 `mysql`的 `pod`分别被部署到了 `k8s-node6`、 `k8s-node7`节点。\n\n## 2. 备份数据\n\n问学长得知， `k8s-node6`、 `k8s-node7`节点位于 `122`服务器\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，登录 `node6`节点：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n账号密码为 `root 123456`，登陆后如下：\n\n![login](../image/云笔记系统扩容/login.png)\n\n按下面命令将数据拷贝到 `tmp/backup`文件夹下进行备份：\n\n![backup](../image/云笔记系统扩容/backup.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n为了保险起见，使用 `xShell`中的 `xftp`将备份的文件再备份到桌面一份：\n\n![xftp](../image/云笔记系统扩容/xftp.png)\n\n打开 `xshell`点击新建文件传输，将 `/home`下的 `mongodb`文件夹拖动到桌面。\n\n![backup-desktop](../image/云笔记系统扩容/backup-desktop.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n## 3. 删除旧的pod\n\n删除旧的 `pod`：\n\n```yaml\nkubectl delete -f note-mysql-pvc.yaml -n note\nkubectl delete -f note-mysql.yaml -n note\nkubectl delete -f note-mongodb-pvc.yaml -n note\nkubectl delete -f note-mongodb.yaml -n note\n```\n\n![delete-pod](../image/云笔记系统扩容/delete-pod.png)\n\n此时查看 `pod`结果：\n\n```yaml\nkubectl get pod -n note\n```\n\n![pod-after-deleted](../image/云笔记系统扩容/pod-after-deleted.png)\n\n`mongodb`和 `mysql`的 `pod`已经被删掉。\n\n## 4. 修改pv、pvc\n\n将相关的 `yaml`文件修改为如下内容：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`yaml`文件里已经将内存修改为目标内存。\n\n## 5. 指定亲和性\n\n这里的亲和性是 `Affinity`，指定了这个后会让其部署在指定标签的 `node`节点上。这样仅需将指定的 `node`节点的虚拟机扩容即可。\n\n首先需要为 `node`节点添加标签。如下所示：\n\n```bash\nkubectl get nodes --show-labels\n\n# 为节点6和7添加label\nkubectl label nodes k8s-node6 notelabel=mongodb\nkubectl label nodes k8s-node7 notelabel=mysql\n```\n\n![add-labels](../image/云笔记系统扩容/add-labels.png)\n\n指定完标签就可以添加亲和性了，如下：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mongodb\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mysql\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`note-mongodb.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mongodb\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n`note-mysql.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mysql-pod\n  template:\n    metadata:\n      labels:\n        app: note-mysql-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mysql\n      containers:\n        - name: note-mysql\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: MYSQL_ROOT_PASSWORD\n              value: dfa6f1b032ee42ed95d12647225f2ff4\n          ports:\n            - containerPort: 3306\n          volumeMounts:\n            - name: note-mysql-persistent-storage\n              mountPath: /var/lib/mysql\n      volumes:\n        - name: note-mysql-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n    app: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n    nodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n    targetPort: 3306\n```\n\n这样，亲和性就修改完毕了。\n\n## 6. 重新部署相应的pod\n\n接下来按 `5. 指定亲和性` 所修改的 `yaml`重新进行 `pod`部署：\n\n```yaml\nkubectl create -f note-mysql-pvc.yaml -n note\nkubectl create -f note-mysql.yaml -n note\nkubectl create -f note-mongodb-pvc.yaml -n note\nkubectl create -f note-mongodb.yaml -n note\n```\n\n![pod-deploy](../image/云笔记系统扩容/pod-deploy.png)\n\n查看部署的结果：\n\n```yaml\nkubectl get pod -n note -o wide\n```\n\n![pod-after-deploy](../image/云笔记系统扩容/pod-after-deploy.png)\n\n可以看到已经将 `mongodb`和 `mysql`分别部署到了节点 `6`和 `7`上。\n\n## 7. 扩容节点的虚拟机\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，如下：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n对于 `sx-k8s-node6`，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。\n\n![shutdown](../image/云笔记系统扩容/shutdown.png)\n\n然后右键 `sx-k8s-node6`，点设置\n\n![setting](../image/云笔记系统扩容/setting.png)\n\n点击硬盘后点击右下角扩展\n\n![expand](../image/云笔记系统扩容/expand.png)\n\n对硬盘容量进行修改。\n\n这里原本是 `40G`，我增加了 `50G`后变为了 `90G`。\n\n`sx-k8s-node7`的操作类似，不再赘述。\n\n此时打开网址，访问成功！扩容成功！\n\n## 访问\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n\n账号：姓名小写拼音\n\n密码：123456\n\n效果：\n\n![6](../image/云笔记系统扩容/6.png)\n","source":"_posts/云笔记系统扩容.md","raw":"---\ntitle: 云笔记系统扩容\ntags:\n  - k8s\n  - Kubernetes\n  - 教程\ncategories:\n  - Kubernetes\nkeywords:\n  - k8s\ndescription: 对k8s服务器上部署的云笔记系统进行扩容\nabbrlink: 36313\ndate: 2023-09-20 14:50:58\nupdated: 2023-09-20 15:00:00\ntop_img: https://s2.loli.net/2024/02/06/MemxlCZb8nKTBXp.png\ncomments:\ncover: https://s2.loli.net/2024/02/06/ENM4lTRwfKyOtJB.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n### 起因\n\n之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 `mysql`和存储笔记信息的 `mongodb`在部署的时候我都设置了 `1G`的存储卷，这是远远不够的，因此需对其进行扩容。\n\n根据老师要求，需将内存从 `1G`扩展到  `50G`，这是针对存笔记系统的 `mongodb`，为了更加稳妥，跟学弟协商后决定将存用户数据的 `mysql`也扩充到 `10G`。\n\n### 大体思路：\n\n1. 确定 `mongodb`和 `mysql`的 `pod`所在的 `node`节点。\n2. 备份数据\n3. 删除旧的 `pod`\n4. 分别修改 `mongodb`和 `mysql`的 `pv`、 `pvc`为 `50Gi`、 `10Gi`。\n5. 指定 `mongodb`和 `mysql`的 `pv`、 `pvc`及 `mongodb`、 `mysql`部署的亲和性，让其部署在指定 `node`节点，便于扩容。\n6. 重新部署相应 `pod`\n7. 扩容指定的 `mongodb`、 `mysql`部署的节点的虚拟机。\n\n> 注：本笔记图片里的 `deployment`的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。\n\n## 1. 确定pod所在的node节点\n\n首先远程连接 `131`服务器。\n\n云笔记系统有 `6`个 `pod`，在 `note`空间里，如下所示：\n\n```bash\nkubectl get pod -n note\n```\n\n![pod](../image/云笔记系统扩容/pod.png)\n\n需确定 `mongodb`、 `mysql`所在的 `node`节点，命令如下：\n\n```bash\nkubectl get pod -n note -o wide\n```\n\n![pod-node](../image/云笔记系统扩容/pod-node.png)\n\n由上图可知， `mongodb`和 `mysql`的 `pod`分别被部署到了 `k8s-node6`、 `k8s-node7`节点。\n\n## 2. 备份数据\n\n问学长得知， `k8s-node6`、 `k8s-node7`节点位于 `122`服务器\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，登录 `node6`节点：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n账号密码为 `root 123456`，登陆后如下：\n\n![login](../image/云笔记系统扩容/login.png)\n\n按下面命令将数据拷贝到 `tmp/backup`文件夹下进行备份：\n\n![backup](../image/云笔记系统扩容/backup.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n为了保险起见，使用 `xShell`中的 `xftp`将备份的文件再备份到桌面一份：\n\n![xftp](../image/云笔记系统扩容/xftp.png)\n\n打开 `xshell`点击新建文件传输，将 `/home`下的 `mongodb`文件夹拖动到桌面。\n\n![backup-desktop](../image/云笔记系统扩容/backup-desktop.png)\n\n对 `node7`下的 `mysql`进行同样操作，不再赘述。\n\n## 3. 删除旧的pod\n\n删除旧的 `pod`：\n\n```yaml\nkubectl delete -f note-mysql-pvc.yaml -n note\nkubectl delete -f note-mysql.yaml -n note\nkubectl delete -f note-mongodb-pvc.yaml -n note\nkubectl delete -f note-mongodb.yaml -n note\n```\n\n![delete-pod](../image/云笔记系统扩容/delete-pod.png)\n\n此时查看 `pod`结果：\n\n```yaml\nkubectl get pod -n note\n```\n\n![pod-after-deleted](../image/云笔记系统扩容/pod-after-deleted.png)\n\n`mongodb`和 `mysql`的 `pod`已经被删掉。\n\n## 4. 修改pv、pvc\n\n将相关的 `yaml`文件修改为如下内容：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`yaml`文件里已经将内存修改为目标内存。\n\n## 5. 指定亲和性\n\n这里的亲和性是 `Affinity`，指定了这个后会让其部署在指定标签的 `node`节点上。这样仅需将指定的 `node`节点的虚拟机扩容即可。\n\n首先需要为 `node`节点添加标签。如下所示：\n\n```bash\nkubectl get nodes --show-labels\n\n# 为节点6和7添加label\nkubectl label nodes k8s-node6 notelabel=mongodb\nkubectl label nodes k8s-node7 notelabel=mysql\n```\n\n![add-labels](../image/云笔记系统扩容/add-labels.png)\n\n指定完标签就可以添加亲和性了，如下：\n\n`note-mongodb-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mongodb-pv\nspec:\n  capacity:\n    storage: 50Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mongodb/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mongodb\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mongodb-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: \"\"\n  volumeName: note-mongodb-pv\n```\n\n`note-mysql-pvc.yaml`\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: note-mysql-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: /home/mysql/data # 主机上的数据存储路径\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: notelabel\n          operator: In\n          values:\n          - mysql\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: note-mysql-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: \"\"\n  volumeName: note-mysql-pv\n```\n\n`note-mongodb.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mongodb-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mongodb-pod\n  template:\n    metadata:\n      labels:\n        app: note-mongodb-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mongodb\n      containers:\n        - name: note-mongodb\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 27017\n          env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: admin\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: 5c8b18289f7848e9b0af98e81562649d\n          volumeMounts:\n            - name: note-mongodb-persistent-storage\n              mountPath: /data/db\n      volumes:\n        - name: note-mongodb-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mongodb-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mongodb-service\nspec:\n  selector:\n    app: note-mongodb-pod\n  type: NodePort # service类型\n  ports:\n  - port: 27017\n    nodePort: 30017 # 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配\n    targetPort: 27017\n```\n\n`note-mysql.yaml`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: note-mysql-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: note-mysql-pod\n  template:\n    metadata:\n      labels:\n        app: note-mysql-pod\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: notelabel\n                operator: In\n                values:\n                - mysql\n      containers:\n        - name: note-mysql\n          image: registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0\n          imagePullPolicy: IfNotPresent\n          env:\n            - name: MYSQL_ROOT_PASSWORD\n              value: dfa6f1b032ee42ed95d12647225f2ff4\n          ports:\n            - containerPort: 3306\n          volumeMounts:\n            - name: note-mysql-persistent-storage\n              mountPath: /var/lib/mysql\n      volumes:\n        - name: note-mysql-persistent-storage\n          persistentVolumeClaim:\n            claimName: note-mysql-pvc # 使用之前创建的持久卷声明\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: note-mysql-service\nspec:\n  selector:\n    app: note-mysql-pod\n  type: NodePort # service类型\n  ports:\n  - port: 3306\n    nodePort: 30006 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配\n    targetPort: 3306\n```\n\n这样，亲和性就修改完毕了。\n\n## 6. 重新部署相应的pod\n\n接下来按 `5. 指定亲和性` 所修改的 `yaml`重新进行 `pod`部署：\n\n```yaml\nkubectl create -f note-mysql-pvc.yaml -n note\nkubectl create -f note-mysql.yaml -n note\nkubectl create -f note-mongodb-pvc.yaml -n note\nkubectl create -f note-mongodb.yaml -n note\n```\n\n![pod-deploy](../image/云笔记系统扩容/pod-deploy.png)\n\n查看部署的结果：\n\n```yaml\nkubectl get pod -n note -o wide\n```\n\n![pod-after-deploy](../image/云笔记系统扩容/pod-after-deploy.png)\n\n可以看到已经将 `mongodb`和 `mysql`分别部署到了节点 `6`和 `7`上。\n\n## 7. 扩容节点的虚拟机\n\n远程连接 `122`服务器后，打开 `VMWare Workstation Pro`，如下：\n\n![vmware](../image/云笔记系统扩容/vmware.png)\n\n对于 `sx-k8s-node6`，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。\n\n![shutdown](../image/云笔记系统扩容/shutdown.png)\n\n然后右键 `sx-k8s-node6`，点设置\n\n![setting](../image/云笔记系统扩容/setting.png)\n\n点击硬盘后点击右下角扩展\n\n![expand](../image/云笔记系统扩容/expand.png)\n\n对硬盘容量进行修改。\n\n这里原本是 `40G`，我增加了 `50G`后变为了 `90G`。\n\n`sx-k8s-node7`的操作类似，不再赘述。\n\n此时打开网址，访问成功！扩容成功！\n\n## 访问\n访问（连校园网，关梯子）：\n\nhttp://192.10.84.209:33395/cloudNote/\n\n账号：姓名小写拼音\n\n密码：123456\n\n效果：\n\n![6](../image/云笔记系统扩容/6.png)\n","slug":"云笔记系统扩容","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0v6000iuugnfift2gu4","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p>\n<p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p>\n<h3 id=\"大体思路：\"><a href=\"#大体思路：\" class=\"headerlink\" title=\"大体思路：\"></a>大体思路：</h3><ol>\n<li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li>\n<li>备份数据</li>\n<li>删除旧的 <code>pod</code></li>\n<li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li>\n<li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li>\n<li>重新部署相应 <code>pod</code></li>\n<li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li>\n</ol>\n<blockquote>\n<p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p>\n</blockquote>\n<h2 id=\"1-确定pod所在的node节点\"><a href=\"#1-确定pod所在的node节点\" class=\"headerlink\" title=\"1. 确定pod所在的node节点\"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p>\n<p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png\" alt=\"pod\"></p>\n<p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png\" alt=\"pod-node\"></p>\n<p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p>\n<h2 id=\"2-备份数据\"><a href=\"#2-备份数据\" class=\"headerlink\" title=\"2. 备份数据\"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p>\n<p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>账号密码为 <code>root 123456</code>，登陆后如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png\" alt=\"login\"></p>\n<p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png\" alt=\"backup\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png\" alt=\"xftp\"></p>\n<p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png\" alt=\"backup-desktop\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<h2 id=\"3-删除旧的pod\"><a href=\"#3-删除旧的pod\" class=\"headerlink\" title=\"3. 删除旧的pod\"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png\" alt=\"delete-pod\"></p>\n<p>此时查看 <code>pod</code>结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png\" alt=\"pod-after-deleted\"></p>\n<p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p>\n<h2 id=\"4-修改pv、pvc\"><a href=\"#4-修改pv、pvc\" class=\"headerlink\" title=\"4. 修改pv、pvc\"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>yaml</code>文件里已经将内存修改为目标内存。</p>\n<h2 id=\"5-指定亲和性\"><a href=\"#5-指定亲和性\" class=\"headerlink\" title=\"5. 指定亲和性\"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p>\n<p>首先需要为 <code>node</code>节点添加标签。如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为节点6和7添加label</span></span><br><span class=\"line\">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class=\"line\">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png\" alt=\"add-labels\"></p>\n<p>指定完标签就可以添加亲和性了，如下：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mongodb.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，亲和性就修改完毕了。</p>\n<h2 id=\"6-重新部署相应的pod\"><a href=\"#6-重新部署相应的pod\" class=\"headerlink\" title=\"6. 重新部署相应的pod\"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png\" alt=\"pod-deploy\"></p>\n<p>查看部署的结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span> <span class=\"string\">-o</span> <span class=\"string\">wide</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png\" alt=\"pod-after-deploy\"></p>\n<p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p>\n<h2 id=\"7-扩容节点的虚拟机\"><a href=\"#7-扩容节点的虚拟机\" class=\"headerlink\" title=\"7. 扩容节点的虚拟机\"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png\" alt=\"shutdown\"></p>\n<p>然后右键 <code>sx-k8s-node6</code>，点设置</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png\" alt=\"setting\"></p>\n<p>点击硬盘后点击右下角扩展</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png\" alt=\"expand\"></p>\n<p>对硬盘容量进行修改。</p>\n<p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p>\n<p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p>\n<p>此时打开网址，访问成功！扩容成功！</p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a></p>\n<p>账号：姓名小写拼音</p>\n<p>密码：123456</p>\n<p>效果：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png\" alt=\"6\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p>\n<p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p>\n<h3 id=\"大体思路：\"><a href=\"#大体思路：\" class=\"headerlink\" title=\"大体思路：\"></a>大体思路：</h3><ol>\n<li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li>\n<li>备份数据</li>\n<li>删除旧的 <code>pod</code></li>\n<li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li>\n<li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li>\n<li>重新部署相应 <code>pod</code></li>\n<li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li>\n</ol>\n<blockquote>\n<p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p>\n</blockquote>\n<h2 id=\"1-确定pod所在的node节点\"><a href=\"#1-确定pod所在的node节点\" class=\"headerlink\" title=\"1. 确定pod所在的node节点\"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p>\n<p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png\" alt=\"pod\"></p>\n<p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png\" alt=\"pod-node\"></p>\n<p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p>\n<h2 id=\"2-备份数据\"><a href=\"#2-备份数据\" class=\"headerlink\" title=\"2. 备份数据\"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p>\n<p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>账号密码为 <code>root 123456</code>，登陆后如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png\" alt=\"login\"></p>\n<p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png\" alt=\"backup\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png\" alt=\"xftp\"></p>\n<p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png\" alt=\"backup-desktop\"></p>\n<p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p>\n<h2 id=\"3-删除旧的pod\"><a href=\"#3-删除旧的pod\" class=\"headerlink\" title=\"3. 删除旧的pod\"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">delete</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png\" alt=\"delete-pod\"></p>\n<p>此时查看 <code>pod</code>结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png\" alt=\"pod-after-deleted\"></p>\n<p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p>\n<h2 id=\"4-修改pv、pvc\"><a href=\"#4-修改pv、pvc\" class=\"headerlink\" title=\"4. 修改pv、pvc\"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>yaml</code>文件里已经将内存修改为目标内存。</p>\n<h2 id=\"5-指定亲和性\"><a href=\"#5-指定亲和性\" class=\"headerlink\" title=\"5. 指定亲和性\"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p>\n<p>首先需要为 <code>node</code>节点添加标签。如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get nodes --show-labels</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为节点6和7添加label</span></span><br><span class=\"line\">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class=\"line\">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png\" alt=\"add-labels\"></p>\n<p>指定完标签就可以添加亲和性了，如下：</p>\n<p><code>note-mongodb-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mongodb/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">50Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mongodb-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql-pvc.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/mysql/data</span> <span class=\"comment\"># 主机上的数据存储路径</span></span><br><span class=\"line\">  <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">    <span class=\"attr\">required:</span></span><br><span class=\"line\">      <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">          <span class=\"attr\">values:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">10Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">volumeName:</span> <span class=\"string\">note-mysql-pv</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mongodb.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mongodb</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">admin</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/data/db</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mongodb-pvc</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mongodb-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mongodb-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">27017</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30017</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">27017</span></span><br></pre></td></tr></table></figure>\n\n<p><code>note-mysql.yaml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">affinity:</span></span><br><span class=\"line\">        <span class=\"attr\">nodeAffinity:</span></span><br><span class=\"line\">          <span class=\"attr\">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class=\"line\">            <span class=\"attr\">nodeSelectorTerms:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">matchExpressions:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">notelabel</span></span><br><span class=\"line\">                <span class=\"attr\">operator:</span> <span class=\"string\">In</span></span><br><span class=\"line\">                <span class=\"attr\">values:</span></span><br><span class=\"line\">                <span class=\"bullet\">-</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-persistent-storage</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">note-mysql-pvc</span> <span class=\"comment\"># 使用之前创建的持久卷声明</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">note-mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">note-mysql-pod</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span> <span class=\"comment\"># service类型</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span> <span class=\"comment\"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，亲和性就修改完毕了。</p>\n<h2 id=\"6-重新部署相应的pod\"><a href=\"#6-重新部署相应的pod\" class=\"headerlink\" title=\"6. 重新部署相应的pod\"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mysql.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb-pvc.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">create</span> <span class=\"string\">-f</span> <span class=\"string\">note-mongodb.yaml</span> <span class=\"string\">-n</span> <span class=\"string\">note</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png\" alt=\"pod-deploy\"></p>\n<p>查看部署的结果：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">kubectl</span> <span class=\"string\">get</span> <span class=\"string\">pod</span> <span class=\"string\">-n</span> <span class=\"string\">note</span> <span class=\"string\">-o</span> <span class=\"string\">wide</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png\" alt=\"pod-after-deploy\"></p>\n<p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p>\n<h2 id=\"7-扩容节点的虚拟机\"><a href=\"#7-扩容节点的虚拟机\" class=\"headerlink\" title=\"7. 扩容节点的虚拟机\"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png\" alt=\"vmware\"></p>\n<p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png\" alt=\"shutdown\"></p>\n<p>然后右键 <code>sx-k8s-node6</code>，点设置</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png\" alt=\"setting\"></p>\n<p>点击硬盘后点击右下角扩展</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png\" alt=\"expand\"></p>\n<p>对硬盘容量进行修改。</p>\n<p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p>\n<p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p>\n<p>此时打开网址，访问成功！扩容成功！</p>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p>访问（连校园网，关梯子）：</p>\n<p><a href=\"http://192.10.84.209:33395/cloudNote/\">http://192.10.84.209:33395/cloudNote/</a></p>\n<p>账号：姓名小写拼音</p>\n<p>密码：123456</p>\n<p>效果：</p>\n<p><img src=\"/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png\" alt=\"6\"></p>\n"},{"title":"强化学习","keywords":["强化学习"],"description":"强化学习的算法和思路总结","abbrlink":17762,"date":"2023-10-19T08:19:24.000Z","updated":"2023-10-30T09:03:11.000Z","top_img":"https://s2.loli.net/2024/02/06/T9HwPmcoaKpNXBY.png","comments":1,"cover":"https://s2.loli.net/2024/02/06/IUOjJBRnM3Zf1Pr.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。\n\n原文： https://zhuanlan.zhihu.com/p/111895463\n\n卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！\n\n后面可能会自己写一下 `MADDPG` 和 `MATD3` 的相关内容，到时候再更新。\n\n> 2023/10/23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！\n\n学习路线：\n![学习路线](../image/强化学习/学习路线.png)\n\n## 马尔可夫树\n\n强化学习的任务：\n- 我们希望用强化学习的方式，使某个**智能体**获得**独立自主**地完成某种任务的能力。 \n- 智能体学习和工作的地方，称为**环境**。\n- 所谓独立自主，就是智能体一旦启动，就不需要人指挥了。\n\n### 经典马尔可夫链\n![马尔科夫链.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png)\n\n- 状态(state)：智能体观察到的当前环境的部分或者全部特征。\n  - 注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。\n- 动作(action)：智能体做出的具体行为。\n  - **动作空间**就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。\n- 奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。\n  - 奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。\n\n### RL一般步骤\n1. 智能体在环境中，观察到状态(S)；\n2. 状态(S)被输入到智能体，智能体经过计算，选择动作(A);\n3. 动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。\n4. 智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。\n\n### 马尔可夫树\n马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种\"不确定性\"， 即\"马尔可夫树\"。\n\n![马尔科夫树.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png)\n\n这种\"不确定性\"来自两个方面： \n- 智能体的行动选择(策略)。\n- 环境的不确定性。\n\n## RL中的Q值和V值\n\n并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。\n\n我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。\n\n- 评估动作的价值称为**Q值**：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。\n- 评估状态的价值称为**V值**：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。\n\n价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。\n\n### V值的定义\n\n![V值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n假设现在需要求某状态S的V值，可以这样：\n\n1. 从S点出发，并影分身出若干个自己;\n2. 每个分身按照当前的策略 选择行为;\n3. 每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;\n4. 计算每个影分身获得的平均值,这个平均值就是要求的V值。\n\n总结：`从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。`\n\n`V值跟选择的策略有很大的关系` 。\n\n看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。\n\n![例子1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BE%8B%E5%AD%901.png)\n\n![策略1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A51.png)\n\n![策略2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A52.png)\n\n可以看出不同的策略，计算出的V值是不一样的。\n\n### Q值的定义\n![Q值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n现在需要计算，某个状态S0下的一个动作A的Q值： \n1. 从A这个节点出发，使用影分身之术； \n2. 每个影分身走到最终状态,并记录所获得的奖励； \n3. 求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。\n\n总结：`从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。`\n\n与V值不同，Q值和策略并没有直接相关，而`与环境的状态转移概率相关，而环境的状态转移概率是不变的。`\n\n### V值和Q值关系\n`Q和V之间是可以相互换算的`。\n\n#### Q值转V值\n\n![Q值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。\n\nS状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。\n\n假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。\n\n![Q值转V值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F1.png)\n\n解释：`一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。`\n\n#### V值转Q值\n\n`Q是V的期望。`而这里不需要关注策略，这里是环境的状态转移概率决定的。\n\n![V值转Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC.png)\n\n`当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！`\n\n![V值转Q值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F2.png)\n\n> 折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。\n\n### V值转V值\n实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。\n\n![V值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n## MC\n蒙地卡罗方法(Monte-Carlo)\n\n### 蒙地卡罗算法\n\n1. 把智能体放到环境的任意状态；\n2. 从这个状态开始按照策略进行选择动作，并进入新的状态。\n3. 重复步骤2，直到最终状态；\n4. 从最终状态开始向前回溯：计算每个状态的G值。\n5. 重复1-4多次，然后平均每个状态的G值，这就是要求的V值。\n\n### G值的意义\n\n重要：`G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。`\n\n![G值的意义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FG%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png)\n\n- 第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。\n- 第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G'),乘以一定的折扣(gamma),再加上r。\n\n所以G值的意义在于，`在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。`\n\n当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。`而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。`\n\n理解：\n1. `G的意义：在某个路径上，状态S到最终状态的总收获。 `\n2. `V和G的关系：V是G的平均数。`\n\n### V和策略相关\n![策略3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A53.png)\n\n![策略4.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A54.png)\n\n由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。\n\n### 蒙地卡罗算法的缺点\n\n每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。\n\n### MC的更新公式\n上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。\n\n那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是`增量更新`。\n\n#### 增量更新\n现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 \n\n`V_new = (V_old - G) * (1 / N) + V_old`\n\n- V_old：原来的V值\n- G：这一次回溯后，计算出来的G值\n- N: 这个状态被经过多少次\n- V_new：新计算出来的V值\n\n#### 更进一步\n\n这样计算还是比较麻烦，我们甚至可以不用记录N，把(1/N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为`学习率`。\n\n这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。\n\n这里的G，也称为V的更新目标。\n\n而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。\n\n#### 两种理解方式\n\n![两种理解方式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png)\n\n## TD\n时序差分算法TD(Temporal-Difference)\n\n### TD和MC的比较\nTD算法对蒙地卡罗(MC)进行了改进：\n1. 和蒙地卡罗(MC)不同：`TD算法只需要走N步，不用走到终点，就可以开始回溯更新。` \n2. 和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 \n3. 那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。\n   - 假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. \n   - 假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。\n\n### 直观理解\n\n从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时`N = 0`，也叫做`TD(0)`。\n\n但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。\n\n![TD(0).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29.png)\n\n假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。\n\n### 更新公式\n\nTD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 `所以只需要把MC的更新目标，改为TD的更新目标即可。`\n\n`在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V`\n\n![更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n\n## Q-learning\n\n之前用TD(0)预估状态价值V:\n![TD(0)更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n图解：\n![TD(0)图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E5%9B%BE%E8%A7%A3.png)\n\nTD能够用在V值，那么也能用在计算Q值上。\n\n### TD之于Q值估算\n\n现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。 \n![用TD估计Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png)\n- V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 \n- Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。\n\n在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。\n![用下一个动作的Q代替V.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png)\n\n但是，这里就有个坑：`虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。`\n\n因为`马尔可夫树!`\n![坑的解释.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png)\n\n`在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。`\n\n虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。\n1. 在相同策略下产生的动作At+1。这就是`SARSA`。\n2. 选择能够产生最大Q值的动作At+1。这就是`Qlearning`。\n\n### SARSA\n\n![SARSA.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA.png)\n\n其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n![TD(0)与SARSA对比.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png)\n\n注意: `这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。`\n\n### Qlearning\n`Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。`\n\n![Qlearning图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%9B%BE%E8%A7%A3.png)\n\n理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。\n![Qlearning公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%85%AC%E5%BC%8F.png)\n\n`Q(S,a)的更新目标`：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n\nQleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。\n\n### 总结\n1. Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 \n2. Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 \n3. 既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 \n4. Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 \n   - SARSA 选择的是在St同一个策略产生的动作。 \n   - Qlearning 选择的是能够产生最大的Q值的动作。\n\n### Qlearning 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## 深度神经网络\n\n深度强化学习：用深度神经网络辅助强化学习。\n\n#### 原理\n假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)=y。\n\n这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。\n![Magic(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%28X%29.png)\n\n现在假设有另外一个函数Magic'(),这个函数是由深度神经网络构成。\n\n在刚开始的时候，很明显Magic'(X) 并不等于y，例如输入手写图片8，Magic'()计算后，认为数字8只有20%，但数字9有40%。\n\n...但这没所谓，因为这是刚开始。我们的任务是让Magic'(X)产生的结果y' 和 y尽量接近。\n\ny'和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic'(X)越来越靠近这个目标。\n\n衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。\n\nloss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic'(X)和Magic(X)函数非常接近，可以通过Magic'(X)计算出y。\n\n当有许许多多这样的y，经过许许多多轮后。Magic'就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。\n\n![Magic'(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%27%28X%29.png)\n\n#### 放大镜下的深度神经网络\n![数据加工厂.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png)\n\n现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。\n\n为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更`标准`一些。\n\n例如图片的尺寸大小，有多少通道的颜色等等，然后`分批(batch)`，输入工厂。\n\n在输入工厂的时候，会有一个‘大门’，称为`输入层`，去检查数据是否已经按照工厂的标准整理好。\n\n数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。\n\n一般称这些车间叫`层`。`这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了`。常用的层包括：`Dense、Conv2D、LSTM、Reshape、Flatten`等。\n\n最终，数据工厂会把原数据X，加工成产品`y'(也叫做：logits)`。从源数据加工成产品的过程，叫`正向传播`。\n\n但产品y'是否是一个合格的产品，我们还需要我们真正的`y(lables)`作为标准去鉴定。把`鉴定出来的差距就是loss`。\n\n工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y'能够对应起来。\n\n经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。\n\n\n## DQN\n> `DQN: TD + 神经网络`\n\n在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。\n\nQtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。\n\n这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。\n\n`用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。`\n\n`Deep network + Qlearning = DQN`\n\n神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。\n\n### 理解DQN中的神经网络\n\nQtable三维可视化：\n![Qtable三维可视化.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png)\n\n图中每根柱子的高度，表示状态S下，选择动作A的Q值。\n\n`现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。`\n\n![扭曲的曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png)\n\n从二维状态看：\n![二维曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png)\n\n所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。\n\n现在就很清楚了，其实Qlearning和DQN并没有根本的区别。`只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。`\n\n### 更新目标\n\n更新目标就是Magic(X)，最终要向这个Magix(X)靠近。\n\n在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。\n\nDQN和Qlearning一样：\n![DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN.png)\n假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： \n1. 执行A，往前一步，到达St+1; \n2. 把St+1输入Q网络，计算St+1下所有动作的Q值； \n3. 获得最大的Q值加上奖励R作为更新目标； \n4. 计算损失 \n   - Q(S,A)相当于有监督学习中的logits\n   - maxQ(St+1) + R 相当于有监督学习中的lables \n   - 用mse函数，得出两者的loss \n   - Loss = (Q(S, A) - [gamma * maxQ(St+1) + R])^2\n5. 用loss更新Q网络。(反向传播)\n\n> 通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。\n\n也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标\n`Target = R + gamma * maxQ(St+1)`\n\n![DQN公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E5%85%AC%E5%BC%8F.png)\n\n总结：\n1. 其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。\n2. 解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。\n3. 和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。\n\n### DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Double DQN\n\n### 经验回放\n经验回放解决了强化学习中的两个问题： `训练网络数据采集慢` 和 `过度拟合`\n\n\n当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。\n\n把每一步的s，选择的a，进入新的状态s'，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。\n当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ....\n当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。\n训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里...\n就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。\n\n使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。\n过度拟合，放到人身上就是`过度依赖局部经验`了。\n就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。\n同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。\n\n\n\n\n### DQN的问题\nDQN的目标：\n`Target = R + gamma * maxQ(St+1)`\n\n目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。\n\n如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。\n\n要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是`Fixed Q-targets`的思路。\n\n### Fixed Q-targets\n\n![fix-Q-targets.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2Ffix-Q-targets.png)\n\n其他地方和DQN一样，唯一不同是用了两个Q网络。\n\n- 原来的Q网络，用于估算Q(s);\n- targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。\n  - `y = r + gamma * max(targetQ(s'))`\n  - 进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。\n\n### Double DQN\n\nDQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s'的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值...，这就导致了Q值往往会有偏大的的情况出现。\n\n这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。\n\n另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。\n\n\n### Double DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Duel DQN\n\n### Dueling DQN原理\n回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即`Q = S + A`\n- S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。\n- A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。\n\n![Q=S+A表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%3DS%2BA%E8%A1%A8%E6%A0%BC.png)\n\n普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。\n\n![普通DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%99%AE%E9%80%9ADQN.png)\n\n普通DQN在提升某个状态下的S值时，只会提升某个动作。\n\nDueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。\n\n![DuelDQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN.png)\n\n如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。\n\n> 这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。\n\n### 网络架构\n![DuelDQN网络架构.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png)\n\n可以把dueling DQN分为三部分：\n- 第一部分：和普通DQN一样，用来处理和学习数据。\n- 第二部分：计算svalue，就是让网络预估的平均值。\n- 第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。\n  - 归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)\n\nDeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。\n\n### Duel DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PG\n策略梯度(Policy Gradient)\n\n之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。\n\n这就是`策略梯度(Policy Gradient)`\n\n### PG原理\n\n认识到：\n> `DQN: TD + 神经网络`\n> `PG: MC + 神经网络`\n\nPG中的Magic(state):\n当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： = magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。\n\n复习一下蒙地卡罗：\n从某个state出发，然后一直走，直到`最终状态`。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。\n![复习MC.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%A4%8D%E4%B9%A0MC.png)\n\n### 直观感受PG\n\n从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 = [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G = 1。\n\n![直观感受PG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png)\n\n更新策略，因为该路径选择了A而产生的，并获得G = 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 = [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G = -1。\n\n![直观感受PG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png)\n\n此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 = [55%,15%,30%]。最后随机到C，回溯计算后，计算得G = 5。\n\n![直观感受PG3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png)\n\nC比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 = [20%,5%,75%]。\n\n### PG 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## AC\n> `AC: PG + DQN(TD + 神经网络)`\n\nPG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。\n\n改为TD可以解决上面的问题。接下来又面临另一个问题：\n在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。\n\n也就是说，Actor-Critic，其实是用了两个网络：\n\n两网络都输入状态S，Critic比Actor多一个St+1: \n- 一个网络输出策略，负责选择动作，把这个网络成为Actor； \n- 一个网络负责计算每个动作的分数，把这个网络成为Critic。\n\n### TD-error\n`在DQN预估的是Q值，在AC中的Critic，估算的是V值。`不估算Q值是因为效果不好。\n![为什么不估算Q.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png)\n\n假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高...\n\n这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？\n因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。\n\n但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而`Q值的期望(均值)就是V。`\n\n![TD-error.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD-error.png)\n\n可以得到更新的权重：`Q(s,a)-V(s)`，Q(s,a)用`gamma * V(s') + r` 代替。\n得到TD-error：`TD-error = gamma * V(s') + r - V(s)`\n\n和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。\n\n至于为啥TD-error是用来更新Critic的loss呢？\n取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。\n再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。\n\n#### 总结\n1. 为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：`Q(s,a)-V(s)`\n2. 为了避免需要预估V值和Q值，把Q和V统一；由于`Q(s,a) = gamma * V(s') + r - V(s)`。所以我们得到TD-error公式： `TD-error = gamma * V(s') + r - V(s)`\n3. `TD-error就是Actor更新策略时候，带权重更新中的权重值`；\n4. 现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。\n\n### 算法\n1. 定义两个network：Actor 和 Critic\n2. 进行N次更新。\n    1. 从状态s开始，执行动作a，得到奖励r，进入状态s'\n    2. 记录的数据。\n    3. 把输入到Critic，根据公式： TD-error = gamma * V(s') + r - V(s) 求 TD-error，并缩小TD-error\n    4. 把输入到Actor，计算策略分布。\n\n![AC算法.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FAC%E7%AE%97%E6%B3%95.png)\n\n可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。\n\n### AC 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PPO\nPPO是基于AC框架的\n\n### 正态分布\n首先要想办法处理连续动作的输出问题。\n\n- 离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。\n- 连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。\n\n在离散动作空间的问题中，最终输出的策略呈现出下面形式：\n![离散动作-策略分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png)\n\n假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi = [0.4, 0.6]。\n![连续型概率分布示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P = （action）代表在策略下，选择某个action的概率P。\n\n用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。\n\n这样，只用两个参数就可以表示了。\n![正态分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png)\n\n正态分布：\n- sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。\n- mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。\n\n神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。\n\n### AC的问题\n\n上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。\n\n- 行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。\n- 目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。\n\n- 在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。\n  - 实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。\n  - 依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。\n- 离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。\n  - 离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。\n  - 无需环境互动：训练过程中不需要实时环境反馈。\n\n例子：\n如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2... 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。\n\n例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。\n\n\n**为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？**\n\n看一个例子：\n![策略P和策略B.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png)\n\n> TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大\n\n假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]\n\n现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？\n\n答案是不行，回顾PG算法，`PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。`\n\n但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。\n\n![策略P和策略B更新示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。\n\n**为什么DQN可以多次重复使用数据？**\n\n![DQN更新的是Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png)\n\n两个角度：\n- 更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。\n- 在DQN的更新中是有\"目标\"的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。\n\n> 在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。\n\n### 重要性采样技术\n\n在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。\n\n在这里`IW = P（a）/ B（a）`\n\n就是 `IW = 目标策略出现动作a的概率 / 行为策略出现a的概率`。\n- 目标策略：要更新的策略。\n- 行为策略：数据的策略。\n\n这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。\n![重要性权重表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png)\n\n现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。\n\nPPO使用重要性采样技术把AC从在线策略变成离线策略。\n\n### N步更新\n\n之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。\n\n![TD(N).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%28N%29.png)\n\n如图，实际上只需要计算最后的V(s')，根据这个估算的V(s'), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。\n\n`V = R + gamma * V(s')`\n\n\n### 总结\n实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。\n\n1. 用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； \n2. PPO延展了TD(0)，变成TD(N)的N步更新； \n3. AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。\n\n### PPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## DDPG\nDDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。\n\n- deep: 深度网络。\n- policy gradient: PG\n- deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。\n\nDDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。\n\n\n### 回顾DQN\n\n![回顾DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9B%9E%E9%A1%BEDQN.png)\n\n从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s',a')函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s',a')的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。\n\n### 理解DDPG\nDDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n\n当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n> 注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。\n\nActor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。\n\n### DDPG\n\n![DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG1.png)\n\n整理下：\n#### Critic\n1. Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；\n2. 注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；\n3. Critic网络的loss其还是和AC一样，用的是TD-error。\n\n#### Actor\n1. 和AC不同，Actor输出的是一个动作；\n2. Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。\n3. Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。\n\n和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。\n\n所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。\n\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n> 目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。\n\n### DDPG 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n\n\n## TD3\nTwin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度\n\nTD3是对DDPG的优化，三个重要优化。\n\n### double network\n\nDDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s')去代替V(s')，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。\n\n在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。\n\n回顾DDPG：\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。\n\nTD3需要用到6个网络：\n![TD3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD3.png)\n\n在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。\n\n#### Critic部分的学习\n只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A'；两个critic target Q network ,用于计算两个Q值：Q1(A') 和Q2(A')。\n\nQ1(A') 和Q2(A') 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a') 计算更新目标，也就是说： target = min(Q1,Q2) * gamma + r\n\ntarget 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。\n\n`TD-error_1 = gamma * min(Q1,Q2) + r - Q1`\n`TD-error_2 = gamma * min(Q1,Q2) + r - Q2`\n\n既然更新目标是一样的，那么为什么还需要两个网络呢?\n\n虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。\n\n\n#### Actor部分的学习\n\nDDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。\n\n而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。\n\n对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。\n\n### actor延迟更新\n\nactor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。\n\n为什么要这样做呢？\n\n回到qnet拟合出来的那块\"布\"上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。\n\n所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。\n\n### target网络噪声\n\nTD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization\n\n为什么要这样呢？\n\n回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。\n![Q'估算Q 1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E7%AE%97Q%201.png)\n\n在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。\n\n好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。\n![Q'估计Q 2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E8%AE%A1Q%202.png)\n\n这里注意三个地方：\n1. 在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。\n2. 计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。\n3. 更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。\n\n### TD3 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。\n\n\n\n## A3C\n强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。\n\n在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。\n\n由此诞生了A3C。\n\n![A3C.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C.png)\n\n注意几点：\n1. 在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。\n> 在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。\n2. worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数...... 如此循环。\n\n![A3C1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C1.png)\n\n### A3C 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## DPPO\n\nDPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。\n\n在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。\n\n但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。\n\n### DPPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## 写在最后\n\n到这里，传统强化学习的总结就结束了，后面由于我的科研方向是`多智能体强化学习`，会更新关于多智能体强化学习的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/强化学习.md","raw":"---\ntitle: 强化学习\ntags:\n  - 强化学习\n  - 算法\ncategories:\n  - 强化学习\nkeywords:\n  - 强化学习\ndescription: 强化学习的算法和思路总结\nabbrlink: 17762\ndate: 2023-10-19 16:19:24\nupdated: 2023-10-30 17:03:11\ntop_img: https://s2.loli.net/2024/02/06/T9HwPmcoaKpNXBY.png\ncomments: \ncover: https://s2.loli.net/2024/02/06/IUOjJBRnM3Zf1Pr.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。\n\n原文： https://zhuanlan.zhihu.com/p/111895463\n\n卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！\n\n后面可能会自己写一下 `MADDPG` 和 `MATD3` 的相关内容，到时候再更新。\n\n> 2023/10/23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！\n\n学习路线：\n![学习路线](../image/强化学习/学习路线.png)\n\n## 马尔可夫树\n\n强化学习的任务：\n- 我们希望用强化学习的方式，使某个**智能体**获得**独立自主**地完成某种任务的能力。 \n- 智能体学习和工作的地方，称为**环境**。\n- 所谓独立自主，就是智能体一旦启动，就不需要人指挥了。\n\n### 经典马尔可夫链\n![马尔科夫链.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png)\n\n- 状态(state)：智能体观察到的当前环境的部分或者全部特征。\n  - 注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。\n- 动作(action)：智能体做出的具体行为。\n  - **动作空间**就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。\n- 奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。\n  - 奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。\n\n### RL一般步骤\n1. 智能体在环境中，观察到状态(S)；\n2. 状态(S)被输入到智能体，智能体经过计算，选择动作(A);\n3. 动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。\n4. 智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。\n\n### 马尔可夫树\n马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种\"不确定性\"， 即\"马尔可夫树\"。\n\n![马尔科夫树.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png)\n\n这种\"不确定性\"来自两个方面： \n- 智能体的行动选择(策略)。\n- 环境的不确定性。\n\n## RL中的Q值和V值\n\n并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。\n\n我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。\n\n- 评估动作的价值称为**Q值**：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。\n- 评估状态的价值称为**V值**：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。\n\n价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。\n\n### V值的定义\n\n![V值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n假设现在需要求某状态S的V值，可以这样：\n\n1. 从S点出发，并影分身出若干个自己;\n2. 每个分身按照当前的策略 选择行为;\n3. 每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;\n4. 计算每个影分身获得的平均值,这个平均值就是要求的V值。\n\n总结：`从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。`\n\n`V值跟选择的策略有很大的关系` 。\n\n看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。\n\n![例子1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BE%8B%E5%AD%901.png)\n\n![策略1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A51.png)\n\n![策略2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A52.png)\n\n可以看出不同的策略，计算出的V值是不一样的。\n\n### Q值的定义\n![Q值的定义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png)\n\n现在需要计算，某个状态S0下的一个动作A的Q值： \n1. 从A这个节点出发，使用影分身之术； \n2. 每个影分身走到最终状态,并记录所获得的奖励； \n3. 求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。\n\n总结：`从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。`\n\n与V值不同，Q值和策略并没有直接相关，而`与环境的状态转移概率相关，而环境的状态转移概率是不变的。`\n\n### V值和Q值关系\n`Q和V之间是可以相互换算的`。\n\n#### Q值转V值\n\n![Q值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。\n\nS状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。\n\n假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。\n\n![Q值转V值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%E5%80%BC%E8%BD%ACV%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F1.png)\n\n解释：`一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。`\n\n#### V值转Q值\n\n`Q是V的期望。`而这里不需要关注策略，这里是环境的状态转移概率决定的。\n\n![V值转Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC.png)\n\n`当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！`\n\n![V值转Q值1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png)\n\n更正式的公式如下：\n![公式2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%85%AC%E5%BC%8F2.png)\n\n> 折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。\n\n### V值转V值\n实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。\n\n![V值转V值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FV%E5%80%BC%E8%BD%ACV%E5%80%BC.png)\n\n## MC\n蒙地卡罗方法(Monte-Carlo)\n\n### 蒙地卡罗算法\n\n1. 把智能体放到环境的任意状态；\n2. 从这个状态开始按照策略进行选择动作，并进入新的状态。\n3. 重复步骤2，直到最终状态；\n4. 从最终状态开始向前回溯：计算每个状态的G值。\n5. 重复1-4多次，然后平均每个状态的G值，这就是要求的V值。\n\n### G值的意义\n\n重要：`G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。`\n\n![G值的意义.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FG%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png)\n\n- 第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。\n- 第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G'),乘以一定的折扣(gamma),再加上r。\n\n所以G值的意义在于，`在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。`\n\n当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。`而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。`\n\n理解：\n1. `G的意义：在某个路径上，状态S到最终状态的总收获。 `\n2. `V和G的关系：V是G的平均数。`\n\n### V和策略相关\n![策略3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A53.png)\n\n![策略4.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A54.png)\n\n由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。\n\n### 蒙地卡罗算法的缺点\n\n每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。\n\n### MC的更新公式\n上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。\n\n那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是`增量更新`。\n\n#### 增量更新\n现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 \n\n`V_new = (V_old - G) * (1 / N) + V_old`\n\n- V_old：原来的V值\n- G：这一次回溯后，计算出来的G值\n- N: 这个状态被经过多少次\n- V_new：新计算出来的V值\n\n#### 更进一步\n\n这样计算还是比较麻烦，我们甚至可以不用记录N，把(1/N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为`学习率`。\n\n这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。\n\n这里的G，也称为V的更新目标。\n\n而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。\n\n#### 两种理解方式\n\n![两种理解方式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png)\n\n## TD\n时序差分算法TD(Temporal-Difference)\n\n### TD和MC的比较\nTD算法对蒙地卡罗(MC)进行了改进：\n1. 和蒙地卡罗(MC)不同：`TD算法只需要走N步，不用走到终点，就可以开始回溯更新。` \n2. 和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 \n3. 那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。\n   - 假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. \n   - 假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。\n\n### 直观理解\n\n从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时`N = 0`，也叫做`TD(0)`。\n\n但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。\n\n![TD(0).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29.png)\n\n假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。\n\n### 更新公式\n\nTD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 `所以只需要把MC的更新目标，改为TD的更新目标即可。`\n\n`在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V`\n\n![更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n\n## Q-learning\n\n之前用TD(0)预估状态价值V:\n![TD(0)更新公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png)\n\n图解：\n![TD(0)图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E5%9B%BE%E8%A7%A3.png)\n\nTD能够用在V值，那么也能用在计算Q值上。\n\n### TD之于Q值估算\n\n现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。 \n![用TD估计Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png)\n- V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 \n- Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。\n\n在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。\n![用下一个动作的Q代替V.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png)\n\n但是，这里就有个坑：`虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。`\n\n因为`马尔可夫树!`\n![坑的解释.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png)\n\n`在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。`\n\n虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。\n1. 在相同策略下产生的动作At+1。这就是`SARSA`。\n2. 选择能够产生最大Q值的动作At+1。这就是`Qlearning`。\n\n### SARSA\n\n![SARSA.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA.png)\n\n其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n![TD(0)与SARSA对比.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%280%29%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png)\n\n注意: `这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。`\n\n### Qlearning\n`Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。`\n\n![Qlearning图解.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%9B%BE%E8%A7%A3.png)\n\n理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。\n![Qlearning公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQlearning%E5%85%AC%E5%BC%8F.png)\n\n`Q(S,a)的更新目标`：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。\n\n![SARSA公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FSARSA%E5%85%AC%E5%BC%8F.png)\n\nQleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。\n\n### 总结\n1. Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 \n2. Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 \n3. 既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 \n4. Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 \n   - SARSA 选择的是在St同一个策略产生的动作。 \n   - Qlearning 选择的是能够产生最大的Q值的动作。\n\n### Qlearning 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## 深度神经网络\n\n深度强化学习：用深度神经网络辅助强化学习。\n\n#### 原理\n假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)=y。\n\n这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。\n![Magic(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%28X%29.png)\n\n现在假设有另外一个函数Magic'(),这个函数是由深度神经网络构成。\n\n在刚开始的时候，很明显Magic'(X) 并不等于y，例如输入手写图片8，Magic'()计算后，认为数字8只有20%，但数字9有40%。\n\n...但这没所谓，因为这是刚开始。我们的任务是让Magic'(X)产生的结果y' 和 y尽量接近。\n\ny'和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic'(X)越来越靠近这个目标。\n\n衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。\n\nloss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic'(X)和Magic(X)函数非常接近，可以通过Magic'(X)计算出y。\n\n当有许许多多这样的y，经过许许多多轮后。Magic'就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。\n\n![Magic'(X).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FMagic%27%28X%29.png)\n\n#### 放大镜下的深度神经网络\n![数据加工厂.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png)\n\n现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。\n\n为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更`标准`一些。\n\n例如图片的尺寸大小，有多少通道的颜色等等，然后`分批(batch)`，输入工厂。\n\n在输入工厂的时候，会有一个‘大门’，称为`输入层`，去检查数据是否已经按照工厂的标准整理好。\n\n数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。\n\n一般称这些车间叫`层`。`这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了`。常用的层包括：`Dense、Conv2D、LSTM、Reshape、Flatten`等。\n\n最终，数据工厂会把原数据X，加工成产品`y'(也叫做：logits)`。从源数据加工成产品的过程，叫`正向传播`。\n\n但产品y'是否是一个合格的产品，我们还需要我们真正的`y(lables)`作为标准去鉴定。把`鉴定出来的差距就是loss`。\n\n工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y'能够对应起来。\n\n经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。\n\n\n## DQN\n> `DQN: TD + 神经网络`\n\n在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。\n\nQtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。\n\n这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。\n\n`用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。`\n\n`Deep network + Qlearning = DQN`\n\n神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。\n\n### 理解DQN中的神经网络\n\nQtable三维可视化：\n![Qtable三维可视化.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png)\n\n图中每根柱子的高度，表示状态S下，选择动作A的Q值。\n\n`现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。`\n\n![扭曲的曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png)\n\n从二维状态看：\n![二维曲线.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png)\n\n所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。\n\n现在就很清楚了，其实Qlearning和DQN并没有根本的区别。`只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。`\n\n### 更新目标\n\n更新目标就是Magic(X)，最终要向这个Magix(X)靠近。\n\n在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。\n\nDQN和Qlearning一样：\n![DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN.png)\n假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： \n1. 执行A，往前一步，到达St+1; \n2. 把St+1输入Q网络，计算St+1下所有动作的Q值； \n3. 获得最大的Q值加上奖励R作为更新目标； \n4. 计算损失 \n   - Q(S,A)相当于有监督学习中的logits\n   - maxQ(St+1) + R 相当于有监督学习中的lables \n   - 用mse函数，得出两者的loss \n   - Loss = (Q(S, A) - [gamma * maxQ(St+1) + R])^2\n5. 用loss更新Q网络。(反向传播)\n\n> 通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。\n\n也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标\n`Target = R + gamma * maxQ(St+1)`\n\n![DQN公式.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E5%85%AC%E5%BC%8F.png)\n\n总结：\n1. 其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。\n2. 解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。\n3. 和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。\n\n### DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Double DQN\n\n### 经验回放\n经验回放解决了强化学习中的两个问题： `训练网络数据采集慢` 和 `过度拟合`\n\n\n当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。\n\n把每一步的s，选择的a，进入新的状态s'，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。\n当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ....\n当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。\n训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里...\n就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。\n\n使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。\n过度拟合，放到人身上就是`过度依赖局部经验`了。\n就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。\n同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。\n\n\n\n\n### DQN的问题\nDQN的目标：\n`Target = R + gamma * maxQ(St+1)`\n\n目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。\n\n如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。\n\n要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是`Fixed Q-targets`的思路。\n\n### Fixed Q-targets\n\n![fix-Q-targets.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2Ffix-Q-targets.png)\n\n其他地方和DQN一样，唯一不同是用了两个Q网络。\n\n- 原来的Q网络，用于估算Q(s);\n- targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。\n  - `y = r + gamma * max(targetQ(s'))`\n  - 进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。\n\n### Double DQN\n\nDQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s'的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值...，这就导致了Q值往往会有偏大的的情况出现。\n\n这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。\n\n另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。\n\n\n### Double DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## Duel DQN\n\n### Dueling DQN原理\n回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即`Q = S + A`\n- S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。\n- A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。\n\n![Q=S+A表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%3DS%2BA%E8%A1%A8%E6%A0%BC.png)\n\n普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。\n\n![普通DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%99%AE%E9%80%9ADQN.png)\n\n普通DQN在提升某个状态下的S值时，只会提升某个动作。\n\nDueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。\n\n![DuelDQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN.png)\n\n如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。\n\n> 这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。\n\n### 网络架构\n![DuelDQN网络架构.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png)\n\n可以把dueling DQN分为三部分：\n- 第一部分：和普通DQN一样，用来处理和学习数据。\n- 第二部分：计算svalue，就是让网络预估的平均值。\n- 第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。\n  - 归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)\n\nDeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。\n\n### Duel DQN 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PG\n策略梯度(Policy Gradient)\n\n之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。\n\n这就是`策略梯度(Policy Gradient)`\n\n### PG原理\n\n认识到：\n> `DQN: TD + 神经网络`\n> `PG: MC + 神经网络`\n\nPG中的Magic(state):\n当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： = magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。\n\n复习一下蒙地卡罗：\n从某个state出发，然后一直走，直到`最终状态`。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。\n![复习MC.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%A4%8D%E4%B9%A0MC.png)\n\n### 直观感受PG\n\n从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 = [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G = 1。\n\n![直观感受PG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png)\n\n更新策略，因为该路径选择了A而产生的，并获得G = 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 = [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G = -1。\n\n![直观感受PG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png)\n\n此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 = [55%,15%,30%]。最后随机到C，回溯计算后，计算得G = 5。\n\n![直观感受PG3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png)\n\nC比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 = [20%,5%,75%]。\n\n### PG 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## AC\n> `AC: PG + DQN(TD + 神经网络)`\n\nPG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。\n\n改为TD可以解决上面的问题。接下来又面临另一个问题：\n在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。\n\n也就是说，Actor-Critic，其实是用了两个网络：\n\n两网络都输入状态S，Critic比Actor多一个St+1: \n- 一个网络输出策略，负责选择动作，把这个网络成为Actor； \n- 一个网络负责计算每个动作的分数，把这个网络成为Critic。\n\n### TD-error\n`在DQN预估的是Q值，在AC中的Critic，估算的是V值。`不估算Q值是因为效果不好。\n![为什么不估算Q.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png)\n\n假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高...\n\n这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？\n因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。\n\n但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而`Q值的期望(均值)就是V。`\n\n![TD-error.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD-error.png)\n\n可以得到更新的权重：`Q(s,a)-V(s)`，Q(s,a)用`gamma * V(s') + r` 代替。\n得到TD-error：`TD-error = gamma * V(s') + r - V(s)`\n\n和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。\n\n至于为啥TD-error是用来更新Critic的loss呢？\n取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。\n再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。\n\n#### 总结\n1. 为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：`Q(s,a)-V(s)`\n2. 为了避免需要预估V值和Q值，把Q和V统一；由于`Q(s,a) = gamma * V(s') + r - V(s)`。所以我们得到TD-error公式： `TD-error = gamma * V(s') + r - V(s)`\n3. `TD-error就是Actor更新策略时候，带权重更新中的权重值`；\n4. 现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。\n\n### 算法\n1. 定义两个network：Actor 和 Critic\n2. 进行N次更新。\n    1. 从状态s开始，执行动作a，得到奖励r，进入状态s'\n    2. 记录的数据。\n    3. 把输入到Critic，根据公式： TD-error = gamma * V(s') + r - V(s) 求 TD-error，并缩小TD-error\n    4. 把输入到Actor，计算策略分布。\n\n![AC算法.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FAC%E7%AE%97%E6%B3%95.png)\n\n可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。\n\n### AC 实现\n\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## PPO\nPPO是基于AC框架的\n\n### 正态分布\n首先要想办法处理连续动作的输出问题。\n\n- 离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。\n- 连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。\n\n在离散动作空间的问题中，最终输出的策略呈现出下面形式：\n![离散动作-策略分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png)\n\n假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi = [0.4, 0.6]。\n![连续型概率分布示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P = （action）代表在策略下，选择某个action的概率P。\n\n用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。\n\n这样，只用两个参数就可以表示了。\n![正态分布.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png)\n\n正态分布：\n- sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。\n- mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。\n\n神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。\n\n### AC的问题\n\n上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。\n\n- 行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。\n- 目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。\n\n- 在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。\n  - 实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。\n  - 依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。\n- 离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。\n  - 离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。\n  - 无需环境互动：训练过程中不需要实时环境反馈。\n\n例子：\n如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2... 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。\n\n例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。\n\n\n**为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？**\n\n看一个例子：\n![策略P和策略B.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png)\n\n> TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大\n\n假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]\n\n现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？\n\n答案是不行，回顾PG算法，`PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。`\n\n但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。\n\n![策略P和策略B更新示意图.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。\n\n**为什么DQN可以多次重复使用数据？**\n\n![DQN更新的是Q值.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png)\n\n两个角度：\n- 更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。\n- 在DQN的更新中是有\"目标\"的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。\n\n> 在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。\n\n### 重要性采样技术\n\n在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。\n\n在这里`IW = P（a）/ B（a）`\n\n就是 `IW = 目标策略出现动作a的概率 / 行为策略出现a的概率`。\n- 目标策略：要更新的策略。\n- 行为策略：数据的策略。\n\n这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。\n![重要性权重表格.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png)\n\n现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。\n\nPPO使用重要性采样技术把AC从在线策略变成离线策略。\n\n### N步更新\n\n之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。\n\n![TD(N).png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD%28N%29.png)\n\n如图，实际上只需要计算最后的V(s')，根据这个估算的V(s'), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。\n\n`V = R + gamma * V(s')`\n\n\n### 总结\n实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。\n\n1. 用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； \n2. PPO延展了TD(0)，变成TD(N)的N步更新； \n3. AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。\n\n### PPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n## DDPG\nDDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。\n\n- deep: 深度网络。\n- policy gradient: PG\n- deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。\n\nDDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。\n\n\n### 回顾DQN\n\n![回顾DQN.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E5%9B%9E%E9%A1%BEDQN.png)\n\n从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s',a')函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s',a')的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。\n\n### 理解DDPG\nDDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n\n当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n> 注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。\n\nActor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。\n\n### DDPG\n\n![DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG1.png)\n\n整理下：\n#### Critic\n1. Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；\n2. 注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；\n3. Critic网络的loss其还是和AC一样，用的是TD-error。\n\n#### Actor\n1. 和AC不同，Actor输出的是一个动作；\n2. Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。\n3. Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。\n\n和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。\n\n所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。\n\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n> 目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。\n\n### DDPG 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n\n\n## TD3\nTwin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度\n\nTD3是对DDPG的优化，三个重要优化。\n\n### double network\n\nDDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s')去代替V(s')，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。\n\n在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。\n\n回顾DDPG：\n![DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FDDPG2.png)\n\n通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。\n\nTD3需要用到6个网络：\n![TD3.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FTD3.png)\n\n在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。\n\n#### Critic部分的学习\n只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A'；两个critic target Q network ,用于计算两个Q值：Q1(A') 和Q2(A')。\n\nQ1(A') 和Q2(A') 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a') 计算更新目标，也就是说： target = min(Q1,Q2) * gamma + r\n\ntarget 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。\n\n`TD-error_1 = gamma * min(Q1,Q2) + r - Q1`\n`TD-error_2 = gamma * min(Q1,Q2) + r - Q2`\n\n既然更新目标是一样的，那么为什么还需要两个网络呢?\n\n虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。\n\n\n#### Actor部分的学习\n\nDDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。\n\n而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。\n\n对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。\n\n### actor延迟更新\n\nactor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。\n\n为什么要这样做呢？\n\n回到qnet拟合出来的那块\"布\"上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。\n![理解DDPG1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG1.png)\n![理解DDPG2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F%E7%90%86%E8%A7%A3DDPG2.png)\n\n可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。\n\n所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。\n\n### target网络噪声\n\nTD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization\n\n为什么要这样呢？\n\n回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。\n![Q'估算Q 1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E7%AE%97Q%201.png)\n\n在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。\n\n好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。\n![Q'估计Q 2.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FQ%27%E4%BC%B0%E8%AE%A1Q%202.png)\n\n这里注意三个地方：\n1. 在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。\n2. 计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。\n3. 更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。\n\n### TD3 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。\n\n\n\n## A3C\n强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。\n\n在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。\n\n由此诞生了A3C。\n\n![A3C.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C.png)\n\n注意几点：\n1. 在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。\n> 在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。\n2. worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数...... 如此循环。\n\n![A3C1.png](..%2Fimage%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2FA3C1.png)\n\n### A3C 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## DPPO\n\nDPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。\n\n在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。\n\n但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。\n\n### DPPO 实现\nTODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。\n\n\n## 写在最后\n\n到这里，传统强化学习的总结就结束了，后面由于我的科研方向是`多智能体强化学习`，会更新关于多智能体强化学习的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"强化学习","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vb001zuugn5b5t6ms3","content":"<blockquote>\n<p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p>\n</blockquote>\n<p>原文： <a href=\"https://zhuanlan.zhihu.com/p/111895463\">https://zhuanlan.zhihu.com/p/111895463</a></p>\n<p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p>\n<p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p>\n<blockquote>\n<p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p>\n</blockquote>\n<p>学习路线：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png\" alt=\"学习路线\"></p>\n<h2 id=\"马尔可夫树\"><a href=\"#马尔可夫树\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h2><p>强化学习的任务：</p>\n<ul>\n<li>我们希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li>\n<li>智能体学习和工作的地方，称为<strong>环境</strong>。</li>\n<li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li>\n</ul>\n<h3 id=\"经典马尔可夫链\"><a href=\"#经典马尔可夫链\" class=\"headerlink\" title=\"经典马尔可夫链\"></a>经典马尔可夫链</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png\" alt=\"马尔科夫链.png\"></p>\n<ul>\n<li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul>\n<li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li>\n</ul>\n</li>\n<li>动作(action)：智能体做出的具体行为。<ul>\n<li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。</li>\n</ul>\n</li>\n<li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul>\n<li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RL一般步骤\"><a href=\"#RL一般步骤\" class=\"headerlink\" title=\"RL一般步骤\"></a>RL一般步骤</h3><ol>\n<li>智能体在环境中，观察到状态(S)；</li>\n<li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li>\n<li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li>\n<li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li>\n</ol>\n<h3 id=\"马尔可夫树-1\"><a href=\"#马尔可夫树-1\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h3><p>马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png\" alt=\"马尔科夫树.png\"></p>\n<p>这种”不确定性”来自两个方面： </p>\n<ul>\n<li>智能体的行动选择(策略)。</li>\n<li>环境的不确定性。</li>\n</ul>\n<h2 id=\"RL中的Q值和V值\"><a href=\"#RL中的Q值和V值\" class=\"headerlink\" title=\"RL中的Q值和V值\"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p>\n<p>我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p>\n<ul>\n<li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li>\n<li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li>\n</ul>\n<p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p>\n<h3 id=\"V值的定义\"><a href=\"#V值的定义\" class=\"headerlink\" title=\"V值的定义\"></a>V值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"V值的定义.png\"></p>\n<p>假设现在需要求某状态S的V值，可以这样：</p>\n<ol>\n<li>从S点出发，并影分身出若干个自己;</li>\n<li>每个分身按照当前的策略 选择行为;</li>\n<li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li>\n<li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li>\n</ol>\n<p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p>\n<p><code>V值跟选择的策略有很大的关系</code> 。</p>\n<p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png\" alt=\"例子1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png\" alt=\"策略1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png\" alt=\"策略2.png\"></p>\n<p>可以看出不同的策略，计算出的V值是不一样的。</p>\n<h3 id=\"Q值的定义\"><a href=\"#Q值的定义\" class=\"headerlink\" title=\"Q值的定义\"></a>Q值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"Q值的定义.png\"></p>\n<p>现在需要计算，某个状态S0下的一个动作A的Q值： </p>\n<ol>\n<li>从A这个节点出发，使用影分身之术； </li>\n<li>每个影分身走到最终状态,并记录所获得的奖励； </li>\n<li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li>\n</ol>\n<p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p>\n<p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p>\n<h3 id=\"V值和Q值关系\"><a href=\"#V值和Q值关系\" class=\"headerlink\" title=\"V值和Q值关系\"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p>\n<h4 id=\"Q值转V值\"><a href=\"#Q值转V值\" class=\"headerlink\" title=\"Q值转V值\"></a>Q值转V值</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"Q值转V值.png\"></p>\n<p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p>\n<p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p>\n<p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png\" alt=\"Q值转V值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png\" alt=\"公式1.png\"></p>\n<p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p>\n<h4 id=\"V值转Q值\"><a href=\"#V值转Q值\" class=\"headerlink\" title=\"V值转Q值\"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png\" alt=\"V值转Q值.png\"></p>\n<p><code>当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png\" alt=\"V值转Q值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png\" alt=\"公式2.png\"></p>\n<blockquote>\n<p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。</p>\n</blockquote>\n<h3 id=\"V值转V值\"><a href=\"#V值转V值\" class=\"headerlink\" title=\"V值转V值\"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"V值转V值.png\"></p>\n<h2 id=\"MC\"><a href=\"#MC\" class=\"headerlink\" title=\"MC\"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p>\n<h3 id=\"蒙地卡罗算法\"><a href=\"#蒙地卡罗算法\" class=\"headerlink\" title=\"蒙地卡罗算法\"></a>蒙地卡罗算法</h3><ol>\n<li>把智能体放到环境的任意状态；</li>\n<li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li>\n<li>重复步骤2，直到最终状态；</li>\n<li>从最终状态开始向前回溯：计算每个状态的G值。</li>\n<li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li>\n</ol>\n<h3 id=\"G值的意义\"><a href=\"#G值的意义\" class=\"headerlink\" title=\"G值的意义\"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png\" alt=\"G值的意义.png\"></p>\n<ul>\n<li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li>\n<li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li>\n</ul>\n<p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p>\n<p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p>\n<p>理解：</p>\n<ol>\n<li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li>\n<li><code>V和G的关系：V是G的平均数。</code></li>\n</ol>\n<h3 id=\"V和策略相关\"><a href=\"#V和策略相关\" class=\"headerlink\" title=\"V和策略相关\"></a>V和策略相关</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png\" alt=\"策略3.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png\" alt=\"策略4.png\"></p>\n<p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p>\n<h3 id=\"蒙地卡罗算法的缺点\"><a href=\"#蒙地卡罗算法的缺点\" class=\"headerlink\" title=\"蒙地卡罗算法的缺点\"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p>\n<h3 id=\"MC的更新公式\"><a href=\"#MC的更新公式\" class=\"headerlink\" title=\"MC的更新公式\"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p>\n<p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p>\n<h4 id=\"增量更新\"><a href=\"#增量更新\" class=\"headerlink\" title=\"增量更新\"></a>增量更新</h4><p>现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p>\n<p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p>\n<ul>\n<li>V_old：原来的V值</li>\n<li>G：这一次回溯后，计算出来的G值</li>\n<li>N: 这个状态被经过多少次</li>\n<li>V_new：新计算出来的V值</li>\n</ul>\n<h4 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h4><p>这样计算还是比较麻烦，我们甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<code>学习率</code>。</p>\n<p>这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p>\n<p>这里的G，也称为V的更新目标。</p>\n<p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p>\n<h4 id=\"两种理解方式\"><a href=\"#两种理解方式\" class=\"headerlink\" title=\"两种理解方式\"></a>两种理解方式</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png\" alt=\"两种理解方式.png\"></p>\n<h2 id=\"TD\"><a href=\"#TD\" class=\"headerlink\" title=\"TD\"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p>\n<h3 id=\"TD和MC的比较\"><a href=\"#TD和MC的比较\" class=\"headerlink\" title=\"TD和MC的比较\"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p>\n<ol>\n<li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li>\n<li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li>\n<li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul>\n<li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. </li>\n<li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"直观理解\"><a href=\"#直观理解\" class=\"headerlink\" title=\"直观理解\"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p>\n<p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png\" alt=\"TD(0).png\"></p>\n<p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p>\n<h3 id=\"更新公式\"><a href=\"#更新公式\" class=\"headerlink\" title=\"更新公式\"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p>\n<p><code>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"更新公式.png\"></p>\n<h2 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"TD(0)更新公式.png\"></p>\n<p>图解：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png\" alt=\"TD(0)图解.png\"></p>\n<p>TD能够用在V值，那么也能用在计算Q值上。</p>\n<h3 id=\"TD之于Q值估算\"><a href=\"#TD之于Q值估算\" class=\"headerlink\" title=\"TD之于Q值估算\"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png\" alt=\"用TD估计Q值.png\"></p>\n<ul>\n<li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li>\n<li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li>\n</ul>\n<p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png\" alt=\"用下一个动作的Q代替V.png\"></p>\n<p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p>\n<p>因为<code>马尔可夫树!</code><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png\" alt=\"坑的解释.png\"></p>\n<p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p>\n<p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p>\n<ol>\n<li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li>\n<li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li>\n</ol>\n<h3 id=\"SARSA\"><a href=\"#SARSA\" class=\"headerlink\" title=\"SARSA\"></a>SARSA</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png\" alt=\"SARSA.png\"></p>\n<p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png\" alt=\"TD(0)与SARSA对比.png\"></p>\n<p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p>\n<h3 id=\"Qlearning\"><a href=\"#Qlearning\" class=\"headerlink\" title=\"Qlearning\"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png\" alt=\"Qlearning图解.png\"></p>\n<p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png\" alt=\"Qlearning公式.png\"></p>\n<p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"></p>\n<p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li>\n<li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li>\n<li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li>\n<li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul>\n<li>SARSA 选择的是在St同一个策略产生的动作。 </li>\n<li>Qlearning 选择的是能够产生最大的Q值的动作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Qlearning-实现\"><a href=\"#Qlearning-实现\" class=\"headerlink\" title=\"Qlearning 实现\"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"深度神经网络\"><a href=\"#深度神经网络\" class=\"headerlink\" title=\"深度神经网络\"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p>\n<p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png\" alt=\"Magic(X).png\"></p>\n<p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p>\n<p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p>\n<p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p>\n<p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p>\n<p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p>\n<p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p>\n<p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png\" alt=\"Magic&#39;(X).png\"></p>\n<h4 id=\"放大镜下的深度神经网络\"><a href=\"#放大镜下的深度神经网络\" class=\"headerlink\" title=\"放大镜下的深度神经网络\"></a>放大镜下的深度神经网络</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png\" alt=\"数据加工厂.png\"></p>\n<p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p>\n<p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p>\n<p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p>\n<p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p>\n<p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p>\n<p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p>\n<p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p>\n<p>但产品y’是否是一个合格的产品，我们还需要我们真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p>\n<p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p>\n<p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p>\n<h2 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h2><blockquote>\n<p><code>DQN: TD + 神经网络</code></p>\n</blockquote>\n<p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p>\n<p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p>\n<p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p>\n<p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p>\n<p><code>Deep network + Qlearning = DQN</code></p>\n<p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p>\n<h3 id=\"理解DQN中的神经网络\"><a href=\"#理解DQN中的神经网络\" class=\"headerlink\" title=\"理解DQN中的神经网络\"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png\" alt=\"Qtable三维可视化.png\"></p>\n<p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p>\n<p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png\" alt=\"扭曲的曲线.png\"></p>\n<p>从二维状态看：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png\" alt=\"二维曲线.png\"></p>\n<p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p>\n<p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p>\n<h3 id=\"更新目标\"><a href=\"#更新目标\" class=\"headerlink\" title=\"更新目标\"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p>\n<p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p>\n<p>DQN和Qlearning一样：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png\" alt=\"DQN.png\"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p>\n<ol>\n<li>执行A，往前一步，到达St+1; </li>\n<li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li>\n<li>获得最大的Q值加上奖励R作为更新目标； </li>\n<li>计算损失 <ul>\n<li>Q(S,A)相当于有监督学习中的logits</li>\n<li>maxQ(St+1) + R 相当于有监督学习中的lables </li>\n<li>用mse函数，得出两者的loss </li>\n<li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li>\n</ul>\n</li>\n<li>用loss更新Q网络。(反向传播)</li>\n</ol>\n<blockquote>\n<p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p>\n</blockquote>\n<p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png\" alt=\"DQN公式.png\"></p>\n<p>总结：</p>\n<ol>\n<li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li>\n<li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li>\n<li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li>\n</ol>\n<h3 id=\"DQN-实现\"><a href=\"#DQN-实现\" class=\"headerlink\" title=\"DQN 实现\"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Double-DQN\"><a href=\"#Double-DQN\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h2><h3 id=\"经验回放\"><a href=\"#经验回放\" class=\"headerlink\" title=\"经验回放\"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p>\n<p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p>\n<p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p>\n<p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p>\n<h3 id=\"DQN的问题\"><a href=\"#DQN的问题\" class=\"headerlink\" title=\"DQN的问题\"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p>\n<p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p>\n<p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p>\n<h3 id=\"Fixed-Q-targets\"><a href=\"#Fixed-Q-targets\" class=\"headerlink\" title=\"Fixed Q-targets\"></a>Fixed Q-targets</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png\" alt=\"fix-Q-targets.png\"></p>\n<p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p>\n<ul>\n<li>原来的Q网络，用于估算Q(s);</li>\n<li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul>\n<li><code>y = r + gamma * max(targetQ(s&#39;))</code></li>\n<li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Double-DQN-1\"><a href=\"#Double-DQN-1\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p>\n<p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p>\n<p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p>\n<h3 id=\"Double-DQN-实现\"><a href=\"#Double-DQN-实现\" class=\"headerlink\" title=\"Double DQN 实现\"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Duel-DQN\"><a href=\"#Duel-DQN\" class=\"headerlink\" title=\"Duel DQN\"></a>Duel DQN</h2><h3 id=\"Dueling-DQN原理\"><a href=\"#Dueling-DQN原理\" class=\"headerlink\" title=\"Dueling DQN原理\"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p>\n<ul>\n<li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li>\n<li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li>\n</ul>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png\" alt=\"Q=S+A表格.png\"></p>\n<p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png\" alt=\"普通DQN.png\"></p>\n<p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p>\n<p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png\" alt=\"DuelDQN.png\"></p>\n<p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p>\n<blockquote>\n<p>这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。</p>\n</blockquote>\n<h3 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png\" alt=\"DuelDQN网络架构.png\"></p>\n<p>可以把dueling DQN分为三部分：</p>\n<ul>\n<li>第一部分：和普通DQN一样，用来处理和学习数据。</li>\n<li>第二部分：计算svalue，就是让网络预估的平均值。</li>\n<li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul>\n<li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li>\n</ul>\n</li>\n</ul>\n<p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p>\n<h3 id=\"Duel-DQN-实现\"><a href=\"#Duel-DQN-实现\" class=\"headerlink\" title=\"Duel DQN 实现\"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>策略梯度(Policy Gradient)</p>\n<p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。</p>\n<p>这就是<code>策略梯度(Policy Gradient)</code></p>\n<h3 id=\"PG原理\"><a href=\"#PG原理\" class=\"headerlink\" title=\"PG原理\"></a>PG原理</h3><p>认识到：</p>\n<blockquote>\n<p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p>\n</blockquote>\n<p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p>\n<p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png\" alt=\"复习MC.png\"></p>\n<h3 id=\"直观感受PG\"><a href=\"#直观感受PG\" class=\"headerlink\" title=\"直观感受PG\"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png\" alt=\"直观感受PG1.png\"></p>\n<p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png\" alt=\"直观感受PG2.png\"></p>\n<p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png\" alt=\"直观感受PG3.png\"></p>\n<p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p>\n<h3 id=\"PG-实现\"><a href=\"#PG-实现\" class=\"headerlink\" title=\"PG 实现\"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"AC\"><a href=\"#AC\" class=\"headerlink\" title=\"AC\"></a>AC</h2><blockquote>\n<p><code>AC: PG + DQN(TD + 神经网络)</code></p>\n</blockquote>\n<p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p>\n<p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。</p>\n<p>也就是说，Actor-Critic，其实是用了两个网络：</p>\n<p>两网络都输入状态S，Critic比Actor多一个St+1: </p>\n<ul>\n<li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li>\n<li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li>\n</ul>\n<h3 id=\"TD-error\"><a href=\"#TD-error\" class=\"headerlink\" title=\"TD-error\"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png\" alt=\"为什么不估算Q.png\"></p>\n<p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p>\n<p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p>\n<p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png\" alt=\"TD-error.png\"></p>\n<p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p>\n<p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p>\n<p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li>\n<li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以我们得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li>\n<li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li>\n<li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li>\n</ol>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ol>\n<li>定义两个network：Actor 和 Critic</li>\n<li>进行N次更新。<ol>\n<li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li>\n<li>记录的数据。</li>\n<li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li>\n<li>把输入到Actor，计算策略分布。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png\" alt=\"AC算法.png\"></p>\n<p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p>\n<h3 id=\"AC-实现\"><a href=\"#AC-实现\" class=\"headerlink\" title=\"AC 实现\"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PPO\"><a href=\"#PPO\" class=\"headerlink\" title=\"PPO\"></a>PPO</h2><p>PPO是基于AC框架的</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p>\n<ul>\n<li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li>\n<li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li>\n</ul>\n<p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png\" alt=\"离散动作-策略分布.png\"></p>\n<p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"连续型概率分布示意图.png\"></p>\n<p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; （action）代表在策略下，选择某个action的概率P。</p>\n<p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p>\n<p>这样，只用两个参数就可以表示了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png\" alt=\"正态分布.png\"></p>\n<p>正态分布：</p>\n<ul>\n<li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li>\n<li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li>\n</ul>\n<p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p>\n<h3 id=\"AC的问题\"><a href=\"#AC的问题\" class=\"headerlink\" title=\"AC的问题\"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p>\n<ul>\n<li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p>\n</li>\n<li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p>\n</li>\n<li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p>\n<ul>\n<li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li>\n<li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li>\n</ul>\n</li>\n<li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p>\n<ul>\n<li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li>\n<li>无需环境互动：训练过程中不需要实时环境反馈。</li>\n</ul>\n</li>\n</ul>\n<p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p>\n<p>例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p>\n<p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p>\n<p>看一个例子：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png\" alt=\"策略P和策略B.png\"></p>\n<blockquote>\n<p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p>\n</blockquote>\n<p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p>\n<p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p>\n<p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p>\n<p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"策略P和策略B更新示意图.png\"></p>\n<p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p>\n<p><strong>为什么DQN可以多次重复使用数据？</strong></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png\" alt=\"DQN更新的是Q值.png\"></p>\n<p>两个角度：</p>\n<ul>\n<li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li>\n<li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li>\n</ul>\n<blockquote>\n<p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。</p>\n</blockquote>\n<h3 id=\"重要性采样技术\"><a href=\"#重要性采样技术\" class=\"headerlink\" title=\"重要性采样技术\"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p>\n<p>在这里<code>IW = P（a）/ B（a）</code></p>\n<p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p>\n<ul>\n<li>目标策略：要更新的策略。</li>\n<li>行为策略：数据的策略。</li>\n</ul>\n<p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png\" alt=\"重要性权重表格.png\"></p>\n<p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p>\n<p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p>\n<h3 id=\"N步更新\"><a href=\"#N步更新\" class=\"headerlink\" title=\"N步更新\"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png\" alt=\"TD(N).png\"></p>\n<p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p>\n<p><code>V = R + gamma * V(s&#39;)</code></p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p>\n<ol>\n<li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li>\n<li>PPO延展了TD(0)，变成TD(N)的N步更新； </li>\n<li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li>\n</ol>\n<h3 id=\"PPO-实现\"><a href=\"#PPO-实现\" class=\"headerlink\" title=\"PPO 实现\"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DDPG\"><a href=\"#DDPG\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p>\n<ul>\n<li>deep: 深度网络。</li>\n<li>policy gradient: PG</li>\n<li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li>\n</ul>\n<p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p>\n<h3 id=\"回顾DQN\"><a href=\"#回顾DQN\" class=\"headerlink\" title=\"回顾DQN\"></a>回顾DQN</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png\" alt=\"回顾DQN.png\"></p>\n<p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。</p>\n<h3 id=\"理解DDPG\"><a href=\"#理解DDPG\" class=\"headerlink\" title=\"理解DDPG\"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"></p>\n<p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<blockquote>\n<p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p>\n</blockquote>\n<p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p>\n<h3 id=\"DDPG-1\"><a href=\"#DDPG-1\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png\" alt=\"DDPG1.png\"></p>\n<p>整理下：</p>\n<h4 id=\"Critic\"><a href=\"#Critic\" class=\"headerlink\" title=\"Critic\"></a>Critic</h4><ol>\n<li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li>\n<li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li>\n<li>Critic网络的loss其还是和AC一样，用的是TD-error。</li>\n</ol>\n<h4 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h4><ol>\n<li>和AC不同，Actor输出的是一个动作；</li>\n<li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li>\n<li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li>\n</ol>\n<p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p>\n<p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<blockquote>\n<p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p>\n</blockquote>\n<h3 id=\"DDPG-实现\"><a href=\"#DDPG-实现\" class=\"headerlink\" title=\"DDPG 实现\"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"TD3\"><a href=\"#TD3\" class=\"headerlink\" title=\"TD3\"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p>\n<p>TD3是对DDPG的优化，三个重要优化。</p>\n<h3 id=\"double-network\"><a href=\"#double-network\" class=\"headerlink\" title=\"double network\"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p>\n<p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p>\n<p>回顾DDPG：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p>\n<p>TD3需要用到6个网络：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png\" alt=\"TD3.png\"></p>\n<p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p>\n<h4 id=\"Critic部分的学习\"><a href=\"#Critic部分的学习\" class=\"headerlink\" title=\"Critic部分的学习\"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p>\n<p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p>\n<p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p>\n<p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p>\n<p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p>\n<p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p>\n<h4 id=\"Actor部分的学习\"><a href=\"#Actor部分的学习\" class=\"headerlink\" title=\"Actor部分的学习\"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p>\n<p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p>\n<p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p>\n<h3 id=\"actor延迟更新\"><a href=\"#actor延迟更新\" class=\"headerlink\" title=\"actor延迟更新\"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p>\n<p>为什么要这样做呢？</p>\n<p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p>\n<p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p>\n<h3 id=\"target网络噪声\"><a href=\"#target网络噪声\" class=\"headerlink\" title=\"target网络噪声\"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p>\n<p>为什么要这样呢？</p>\n<p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png\" alt=\"Q&#39;估算Q 1.png\"></p>\n<p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p>\n<p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png\" alt=\"Q&#39;估计Q 2.png\"></p>\n<p>这里注意三个地方：</p>\n<ol>\n<li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li>\n<li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li>\n<li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li>\n</ol>\n<h3 id=\"TD3-实现\"><a href=\"#TD3-实现\" class=\"headerlink\" title=\"TD3 实现\"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p>\n<h2 id=\"A3C\"><a href=\"#A3C\" class=\"headerlink\" title=\"A3C\"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p>\n<p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p>\n<p>由此诞生了A3C。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png\" alt=\"A3C.png\"></p>\n<p>注意几点：</p>\n<ol>\n<li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote>\n<p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p>\n</blockquote>\n</li>\n<li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png\" alt=\"A3C1.png\"></p>\n<h3 id=\"A3C-实现\"><a href=\"#A3C-实现\" class=\"headerlink\" title=\"A3C 实现\"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DPPO\"><a href=\"#DPPO\" class=\"headerlink\" title=\"DPPO\"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p>\n<p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p>\n<p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p>\n<h3 id=\"DPPO-实现\"><a href=\"#DPPO-实现\" class=\"headerlink\" title=\"DPPO 实现\"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p>\n</blockquote>\n<p>原文： <a href=\"https://zhuanlan.zhihu.com/p/111895463\">https://zhuanlan.zhihu.com/p/111895463</a></p>\n<p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p>\n<p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p>\n<blockquote>\n<p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p>\n</blockquote>\n<p>学习路线：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png\" alt=\"学习路线\"></p>\n<h2 id=\"马尔可夫树\"><a href=\"#马尔可夫树\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h2><p>强化学习的任务：</p>\n<ul>\n<li>我们希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li>\n<li>智能体学习和工作的地方，称为<strong>环境</strong>。</li>\n<li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li>\n</ul>\n<h3 id=\"经典马尔可夫链\"><a href=\"#经典马尔可夫链\" class=\"headerlink\" title=\"经典马尔可夫链\"></a>经典马尔可夫链</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png\" alt=\"马尔科夫链.png\"></p>\n<ul>\n<li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul>\n<li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li>\n</ul>\n</li>\n<li>动作(action)：智能体做出的具体行为。<ul>\n<li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。</li>\n</ul>\n</li>\n<li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul>\n<li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RL一般步骤\"><a href=\"#RL一般步骤\" class=\"headerlink\" title=\"RL一般步骤\"></a>RL一般步骤</h3><ol>\n<li>智能体在环境中，观察到状态(S)；</li>\n<li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li>\n<li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li>\n<li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li>\n</ol>\n<h3 id=\"马尔可夫树-1\"><a href=\"#马尔可夫树-1\" class=\"headerlink\" title=\"马尔可夫树\"></a>马尔可夫树</h3><p>马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png\" alt=\"马尔科夫树.png\"></p>\n<p>这种”不确定性”来自两个方面： </p>\n<ul>\n<li>智能体的行动选择(策略)。</li>\n<li>环境的不确定性。</li>\n</ul>\n<h2 id=\"RL中的Q值和V值\"><a href=\"#RL中的Q值和V值\" class=\"headerlink\" title=\"RL中的Q值和V值\"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p>\n<p>我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p>\n<ul>\n<li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li>\n<li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li>\n</ul>\n<p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p>\n<h3 id=\"V值的定义\"><a href=\"#V值的定义\" class=\"headerlink\" title=\"V值的定义\"></a>V值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"V值的定义.png\"></p>\n<p>假设现在需要求某状态S的V值，可以这样：</p>\n<ol>\n<li>从S点出发，并影分身出若干个自己;</li>\n<li>每个分身按照当前的策略 选择行为;</li>\n<li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li>\n<li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li>\n</ol>\n<p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p>\n<p><code>V值跟选择的策略有很大的关系</code> 。</p>\n<p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png\" alt=\"例子1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png\" alt=\"策略1.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png\" alt=\"策略2.png\"></p>\n<p>可以看出不同的策略，计算出的V值是不一样的。</p>\n<h3 id=\"Q值的定义\"><a href=\"#Q值的定义\" class=\"headerlink\" title=\"Q值的定义\"></a>Q值的定义</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png\" alt=\"Q值的定义.png\"></p>\n<p>现在需要计算，某个状态S0下的一个动作A的Q值： </p>\n<ol>\n<li>从A这个节点出发，使用影分身之术； </li>\n<li>每个影分身走到最终状态,并记录所获得的奖励； </li>\n<li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li>\n</ol>\n<p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p>\n<p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p>\n<h3 id=\"V值和Q值关系\"><a href=\"#V值和Q值关系\" class=\"headerlink\" title=\"V值和Q值关系\"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p>\n<h4 id=\"Q值转V值\"><a href=\"#Q值转V值\" class=\"headerlink\" title=\"Q值转V值\"></a>Q值转V值</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"Q值转V值.png\"></p>\n<p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p>\n<p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p>\n<p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png\" alt=\"Q值转V值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png\" alt=\"公式1.png\"></p>\n<p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p>\n<h4 id=\"V值转Q值\"><a href=\"#V值转Q值\" class=\"headerlink\" title=\"V值转Q值\"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png\" alt=\"V值转Q值.png\"></p>\n<p><code>当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png\" alt=\"V值转Q值1.png\"></p>\n<p>更正式的公式如下：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png\" alt=\"公式2.png\"></p>\n<blockquote>\n<p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。</p>\n</blockquote>\n<h3 id=\"V值转V值\"><a href=\"#V值转V值\" class=\"headerlink\" title=\"V值转V值\"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png\" alt=\"V值转V值.png\"></p>\n<h2 id=\"MC\"><a href=\"#MC\" class=\"headerlink\" title=\"MC\"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p>\n<h3 id=\"蒙地卡罗算法\"><a href=\"#蒙地卡罗算法\" class=\"headerlink\" title=\"蒙地卡罗算法\"></a>蒙地卡罗算法</h3><ol>\n<li>把智能体放到环境的任意状态；</li>\n<li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li>\n<li>重复步骤2，直到最终状态；</li>\n<li>从最终状态开始向前回溯：计算每个状态的G值。</li>\n<li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li>\n</ol>\n<h3 id=\"G值的意义\"><a href=\"#G值的意义\" class=\"headerlink\" title=\"G值的意义\"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png\" alt=\"G值的意义.png\"></p>\n<ul>\n<li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li>\n<li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li>\n</ul>\n<p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p>\n<p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p>\n<p>理解：</p>\n<ol>\n<li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li>\n<li><code>V和G的关系：V是G的平均数。</code></li>\n</ol>\n<h3 id=\"V和策略相关\"><a href=\"#V和策略相关\" class=\"headerlink\" title=\"V和策略相关\"></a>V和策略相关</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png\" alt=\"策略3.png\"></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png\" alt=\"策略4.png\"></p>\n<p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p>\n<h3 id=\"蒙地卡罗算法的缺点\"><a href=\"#蒙地卡罗算法的缺点\" class=\"headerlink\" title=\"蒙地卡罗算法的缺点\"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p>\n<h3 id=\"MC的更新公式\"><a href=\"#MC的更新公式\" class=\"headerlink\" title=\"MC的更新公式\"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p>\n<p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p>\n<h4 id=\"增量更新\"><a href=\"#增量更新\" class=\"headerlink\" title=\"增量更新\"></a>增量更新</h4><p>现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p>\n<p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p>\n<ul>\n<li>V_old：原来的V值</li>\n<li>G：这一次回溯后，计算出来的G值</li>\n<li>N: 这个状态被经过多少次</li>\n<li>V_new：新计算出来的V值</li>\n</ul>\n<h4 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h4><p>这样计算还是比较麻烦，我们甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<code>学习率</code>。</p>\n<p>这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p>\n<p>这里的G，也称为V的更新目标。</p>\n<p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p>\n<h4 id=\"两种理解方式\"><a href=\"#两种理解方式\" class=\"headerlink\" title=\"两种理解方式\"></a>两种理解方式</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png\" alt=\"两种理解方式.png\"></p>\n<h2 id=\"TD\"><a href=\"#TD\" class=\"headerlink\" title=\"TD\"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p>\n<h3 id=\"TD和MC的比较\"><a href=\"#TD和MC的比较\" class=\"headerlink\" title=\"TD和MC的比较\"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p>\n<ol>\n<li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li>\n<li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li>\n<li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul>\n<li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. </li>\n<li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"直观理解\"><a href=\"#直观理解\" class=\"headerlink\" title=\"直观理解\"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p>\n<p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png\" alt=\"TD(0).png\"></p>\n<p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p>\n<h3 id=\"更新公式\"><a href=\"#更新公式\" class=\"headerlink\" title=\"更新公式\"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p>\n<p><code>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"更新公式.png\"></p>\n<h2 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png\" alt=\"TD(0)更新公式.png\"></p>\n<p>图解：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png\" alt=\"TD(0)图解.png\"></p>\n<p>TD能够用在V值，那么也能用在计算Q值上。</p>\n<h3 id=\"TD之于Q值估算\"><a href=\"#TD之于Q值估算\" class=\"headerlink\" title=\"TD之于Q值估算\"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png\" alt=\"用TD估计Q值.png\"></p>\n<ul>\n<li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li>\n<li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li>\n</ul>\n<p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png\" alt=\"用下一个动作的Q代替V.png\"></p>\n<p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p>\n<p>因为<code>马尔可夫树!</code><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png\" alt=\"坑的解释.png\"></p>\n<p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p>\n<p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p>\n<ol>\n<li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li>\n<li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li>\n</ol>\n<h3 id=\"SARSA\"><a href=\"#SARSA\" class=\"headerlink\" title=\"SARSA\"></a>SARSA</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png\" alt=\"SARSA.png\"></p>\n<p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png\" alt=\"TD(0)与SARSA对比.png\"></p>\n<p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p>\n<h3 id=\"Qlearning\"><a href=\"#Qlearning\" class=\"headerlink\" title=\"Qlearning\"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png\" alt=\"Qlearning图解.png\"></p>\n<p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png\" alt=\"Qlearning公式.png\"></p>\n<p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png\" alt=\"SARSA公式.png\"></p>\n<p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li>\n<li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li>\n<li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li>\n<li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul>\n<li>SARSA 选择的是在St同一个策略产生的动作。 </li>\n<li>Qlearning 选择的是能够产生最大的Q值的动作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Qlearning-实现\"><a href=\"#Qlearning-实现\" class=\"headerlink\" title=\"Qlearning 实现\"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"深度神经网络\"><a href=\"#深度神经网络\" class=\"headerlink\" title=\"深度神经网络\"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p>\n<p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png\" alt=\"Magic(X).png\"></p>\n<p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p>\n<p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p>\n<p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p>\n<p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p>\n<p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p>\n<p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p>\n<p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png\" alt=\"Magic&#39;(X).png\"></p>\n<h4 id=\"放大镜下的深度神经网络\"><a href=\"#放大镜下的深度神经网络\" class=\"headerlink\" title=\"放大镜下的深度神经网络\"></a>放大镜下的深度神经网络</h4><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png\" alt=\"数据加工厂.png\"></p>\n<p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p>\n<p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p>\n<p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p>\n<p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p>\n<p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p>\n<p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p>\n<p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p>\n<p>但产品y’是否是一个合格的产品，我们还需要我们真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p>\n<p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p>\n<p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p>\n<h2 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h2><blockquote>\n<p><code>DQN: TD + 神经网络</code></p>\n</blockquote>\n<p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p>\n<p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p>\n<p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p>\n<p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p>\n<p><code>Deep network + Qlearning = DQN</code></p>\n<p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p>\n<h3 id=\"理解DQN中的神经网络\"><a href=\"#理解DQN中的神经网络\" class=\"headerlink\" title=\"理解DQN中的神经网络\"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png\" alt=\"Qtable三维可视化.png\"></p>\n<p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p>\n<p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png\" alt=\"扭曲的曲线.png\"></p>\n<p>从二维状态看：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png\" alt=\"二维曲线.png\"></p>\n<p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p>\n<p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p>\n<h3 id=\"更新目标\"><a href=\"#更新目标\" class=\"headerlink\" title=\"更新目标\"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p>\n<p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p>\n<p>DQN和Qlearning一样：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png\" alt=\"DQN.png\"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p>\n<ol>\n<li>执行A，往前一步，到达St+1; </li>\n<li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li>\n<li>获得最大的Q值加上奖励R作为更新目标； </li>\n<li>计算损失 <ul>\n<li>Q(S,A)相当于有监督学习中的logits</li>\n<li>maxQ(St+1) + R 相当于有监督学习中的lables </li>\n<li>用mse函数，得出两者的loss </li>\n<li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li>\n</ul>\n</li>\n<li>用loss更新Q网络。(反向传播)</li>\n</ol>\n<blockquote>\n<p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p>\n</blockquote>\n<p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png\" alt=\"DQN公式.png\"></p>\n<p>总结：</p>\n<ol>\n<li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li>\n<li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li>\n<li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li>\n</ol>\n<h3 id=\"DQN-实现\"><a href=\"#DQN-实现\" class=\"headerlink\" title=\"DQN 实现\"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Double-DQN\"><a href=\"#Double-DQN\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h2><h3 id=\"经验回放\"><a href=\"#经验回放\" class=\"headerlink\" title=\"经验回放\"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p>\n<p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p>\n<p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p>\n<p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p>\n<h3 id=\"DQN的问题\"><a href=\"#DQN的问题\" class=\"headerlink\" title=\"DQN的问题\"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p>\n<p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p>\n<p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p>\n<p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p>\n<h3 id=\"Fixed-Q-targets\"><a href=\"#Fixed-Q-targets\" class=\"headerlink\" title=\"Fixed Q-targets\"></a>Fixed Q-targets</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png\" alt=\"fix-Q-targets.png\"></p>\n<p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p>\n<ul>\n<li>原来的Q网络，用于估算Q(s);</li>\n<li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul>\n<li><code>y = r + gamma * max(targetQ(s&#39;))</code></li>\n<li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Double-DQN-1\"><a href=\"#Double-DQN-1\" class=\"headerlink\" title=\"Double DQN\"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p>\n<p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p>\n<p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p>\n<h3 id=\"Double-DQN-实现\"><a href=\"#Double-DQN-实现\" class=\"headerlink\" title=\"Double DQN 实现\"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"Duel-DQN\"><a href=\"#Duel-DQN\" class=\"headerlink\" title=\"Duel DQN\"></a>Duel DQN</h2><h3 id=\"Dueling-DQN原理\"><a href=\"#Dueling-DQN原理\" class=\"headerlink\" title=\"Dueling DQN原理\"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p>\n<ul>\n<li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li>\n<li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li>\n</ul>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png\" alt=\"Q=S+A表格.png\"></p>\n<p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png\" alt=\"普通DQN.png\"></p>\n<p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p>\n<p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png\" alt=\"DuelDQN.png\"></p>\n<p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p>\n<blockquote>\n<p>这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。</p>\n</blockquote>\n<h3 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png\" alt=\"DuelDQN网络架构.png\"></p>\n<p>可以把dueling DQN分为三部分：</p>\n<ul>\n<li>第一部分：和普通DQN一样，用来处理和学习数据。</li>\n<li>第二部分：计算svalue，就是让网络预估的平均值。</li>\n<li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul>\n<li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li>\n</ul>\n</li>\n</ul>\n<p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p>\n<h3 id=\"Duel-DQN-实现\"><a href=\"#Duel-DQN-实现\" class=\"headerlink\" title=\"Duel DQN 实现\"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>策略梯度(Policy Gradient)</p>\n<p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。</p>\n<p>这就是<code>策略梯度(Policy Gradient)</code></p>\n<h3 id=\"PG原理\"><a href=\"#PG原理\" class=\"headerlink\" title=\"PG原理\"></a>PG原理</h3><p>认识到：</p>\n<blockquote>\n<p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p>\n</blockquote>\n<p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p>\n<p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png\" alt=\"复习MC.png\"></p>\n<h3 id=\"直观感受PG\"><a href=\"#直观感受PG\" class=\"headerlink\" title=\"直观感受PG\"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png\" alt=\"直观感受PG1.png\"></p>\n<p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png\" alt=\"直观感受PG2.png\"></p>\n<p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png\" alt=\"直观感受PG3.png\"></p>\n<p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p>\n<h3 id=\"PG-实现\"><a href=\"#PG-实现\" class=\"headerlink\" title=\"PG 实现\"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"AC\"><a href=\"#AC\" class=\"headerlink\" title=\"AC\"></a>AC</h2><blockquote>\n<p><code>AC: PG + DQN(TD + 神经网络)</code></p>\n</blockquote>\n<p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p>\n<p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。</p>\n<p>也就是说，Actor-Critic，其实是用了两个网络：</p>\n<p>两网络都输入状态S，Critic比Actor多一个St+1: </p>\n<ul>\n<li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li>\n<li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li>\n</ul>\n<h3 id=\"TD-error\"><a href=\"#TD-error\" class=\"headerlink\" title=\"TD-error\"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png\" alt=\"为什么不估算Q.png\"></p>\n<p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p>\n<p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p>\n<p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png\" alt=\"TD-error.png\"></p>\n<p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p>\n<p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p>\n<p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li>\n<li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以我们得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li>\n<li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li>\n<li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li>\n</ol>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><ol>\n<li>定义两个network：Actor 和 Critic</li>\n<li>进行N次更新。<ol>\n<li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li>\n<li>记录的数据。</li>\n<li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li>\n<li>把输入到Actor，计算策略分布。</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png\" alt=\"AC算法.png\"></p>\n<p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p>\n<h3 id=\"AC-实现\"><a href=\"#AC-实现\" class=\"headerlink\" title=\"AC 实现\"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"PPO\"><a href=\"#PPO\" class=\"headerlink\" title=\"PPO\"></a>PPO</h2><p>PPO是基于AC框架的</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p>\n<ul>\n<li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li>\n<li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li>\n</ul>\n<p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png\" alt=\"离散动作-策略分布.png\"></p>\n<p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"连续型概率分布示意图.png\"></p>\n<p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; （action）代表在策略下，选择某个action的概率P。</p>\n<p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p>\n<p>这样，只用两个参数就可以表示了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png\" alt=\"正态分布.png\"></p>\n<p>正态分布：</p>\n<ul>\n<li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li>\n<li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li>\n</ul>\n<p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p>\n<h3 id=\"AC的问题\"><a href=\"#AC的问题\" class=\"headerlink\" title=\"AC的问题\"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p>\n<ul>\n<li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p>\n</li>\n<li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p>\n</li>\n<li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p>\n<ul>\n<li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li>\n<li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li>\n</ul>\n</li>\n<li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p>\n<ul>\n<li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li>\n<li>无需环境互动：训练过程中不需要实时环境反馈。</li>\n</ul>\n</li>\n</ul>\n<p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p>\n<p>例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p>\n<p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p>\n<p>看一个例子：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png\" alt=\"策略P和策略B.png\"></p>\n<blockquote>\n<p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p>\n</blockquote>\n<p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p>\n<p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p>\n<p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p>\n<p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"策略P和策略B更新示意图.png\"></p>\n<p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p>\n<p><strong>为什么DQN可以多次重复使用数据？</strong></p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png\" alt=\"DQN更新的是Q值.png\"></p>\n<p>两个角度：</p>\n<ul>\n<li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li>\n<li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li>\n</ul>\n<blockquote>\n<p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。</p>\n</blockquote>\n<h3 id=\"重要性采样技术\"><a href=\"#重要性采样技术\" class=\"headerlink\" title=\"重要性采样技术\"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p>\n<p>在这里<code>IW = P（a）/ B（a）</code></p>\n<p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p>\n<ul>\n<li>目标策略：要更新的策略。</li>\n<li>行为策略：数据的策略。</li>\n</ul>\n<p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png\" alt=\"重要性权重表格.png\"></p>\n<p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p>\n<p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p>\n<h3 id=\"N步更新\"><a href=\"#N步更新\" class=\"headerlink\" title=\"N步更新\"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png\" alt=\"TD(N).png\"></p>\n<p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p>\n<p><code>V = R + gamma * V(s&#39;)</code></p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p>\n<ol>\n<li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li>\n<li>PPO延展了TD(0)，变成TD(N)的N步更新； </li>\n<li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li>\n</ol>\n<h3 id=\"PPO-实现\"><a href=\"#PPO-实现\" class=\"headerlink\" title=\"PPO 实现\"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DDPG\"><a href=\"#DDPG\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p>\n<ul>\n<li>deep: 深度网络。</li>\n<li>policy gradient: PG</li>\n<li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li>\n</ul>\n<p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p>\n<h3 id=\"回顾DQN\"><a href=\"#回顾DQN\" class=\"headerlink\" title=\"回顾DQN\"></a>回顾DQN</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png\" alt=\"回顾DQN.png\"></p>\n<p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。</p>\n<h3 id=\"理解DDPG\"><a href=\"#理解DDPG\" class=\"headerlink\" title=\"理解DDPG\"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"></p>\n<p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<blockquote>\n<p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p>\n</blockquote>\n<p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p>\n<h3 id=\"DDPG-1\"><a href=\"#DDPG-1\" class=\"headerlink\" title=\"DDPG\"></a>DDPG</h3><p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png\" alt=\"DDPG1.png\"></p>\n<p>整理下：</p>\n<h4 id=\"Critic\"><a href=\"#Critic\" class=\"headerlink\" title=\"Critic\"></a>Critic</h4><ol>\n<li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li>\n<li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li>\n<li>Critic网络的loss其还是和AC一样，用的是TD-error。</li>\n</ol>\n<h4 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h4><ol>\n<li>和AC不同，Actor输出的是一个动作；</li>\n<li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li>\n<li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li>\n</ol>\n<p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p>\n<p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<blockquote>\n<p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p>\n</blockquote>\n<h3 id=\"DDPG-实现\"><a href=\"#DDPG-实现\" class=\"headerlink\" title=\"DDPG 实现\"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"TD3\"><a href=\"#TD3\" class=\"headerlink\" title=\"TD3\"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p>\n<p>TD3是对DDPG的优化，三个重要优化。</p>\n<h3 id=\"double-network\"><a href=\"#double-network\" class=\"headerlink\" title=\"double network\"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p>\n<p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p>\n<p>回顾DDPG：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png\" alt=\"DDPG2.png\"></p>\n<p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p>\n<p>TD3需要用到6个网络：<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png\" alt=\"TD3.png\"></p>\n<p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p>\n<h4 id=\"Critic部分的学习\"><a href=\"#Critic部分的学习\" class=\"headerlink\" title=\"Critic部分的学习\"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p>\n<p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p>\n<p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p>\n<p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p>\n<p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p>\n<p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p>\n<h4 id=\"Actor部分的学习\"><a href=\"#Actor部分的学习\" class=\"headerlink\" title=\"Actor部分的学习\"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p>\n<p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p>\n<p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p>\n<h3 id=\"actor延迟更新\"><a href=\"#actor延迟更新\" class=\"headerlink\" title=\"actor延迟更新\"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p>\n<p>为什么要这样做呢？</p>\n<p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png\" alt=\"理解DDPG1.png\"><br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png\" alt=\"理解DDPG2.png\"></p>\n<p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p>\n<p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p>\n<h3 id=\"target网络噪声\"><a href=\"#target网络噪声\" class=\"headerlink\" title=\"target网络噪声\"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p>\n<p>为什么要这样呢？</p>\n<p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png\" alt=\"Q&#39;估算Q 1.png\"></p>\n<p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p>\n<p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png\" alt=\"Q&#39;估计Q 2.png\"></p>\n<p>这里注意三个地方：</p>\n<ol>\n<li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li>\n<li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li>\n<li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li>\n</ol>\n<h3 id=\"TD3-实现\"><a href=\"#TD3-实现\" class=\"headerlink\" title=\"TD3 实现\"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p>\n<h2 id=\"A3C\"><a href=\"#A3C\" class=\"headerlink\" title=\"A3C\"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p>\n<p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p>\n<p>由此诞生了A3C。</p>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png\" alt=\"A3C.png\"></p>\n<p>注意几点：</p>\n<ol>\n<li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote>\n<p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p>\n</blockquote>\n</li>\n<li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li>\n</ol>\n<p><img src=\"/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png\" alt=\"A3C1.png\"></p>\n<h3 id=\"A3C-实现\"><a href=\"#A3C-实现\" class=\"headerlink\" title=\"A3C 实现\"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"DPPO\"><a href=\"#DPPO\" class=\"headerlink\" title=\"DPPO\"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p>\n<p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p>\n<p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p>\n<h3 id=\"DPPO-实现\"><a href=\"#DPPO-实现\" class=\"headerlink\" title=\"DPPO 实现\"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>\n"},{"title":"框架等面经","keywords":["面经"],"description":"框架等方面的面经","abbrlink":17771,"date":"2024-06-12T14:49:36.000Z","updated":"2024-06-13T08:17:41.000Z","top_img":"https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png","comments":1,"cover":"https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n## spring boot/cloud ???\n\n\n## Linux\n\n\n## 其他\n","source":"_posts/框架等面经.md","raw":"---\ntitle: 框架等面经\ntags:\n  - 框架\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 框架等方面的面经\nabbrlink: 17771\ndate: 2024-06-12 22:49:36\nupdated: 2024-06-13 16:17:41\ntop_img: https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png\ncomments:\ncover: https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n## spring boot/cloud ???\n\n\n## Linux\n\n\n## 其他\n","slug":"框架等面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vc0020uugnhyvug30s","content":"<h2 id=\"spring-boot-cloud\"><a href=\"#spring-boot-cloud\" class=\"headerlink\" title=\"spring boot&#x2F;cloud ???\"></a>spring boot&#x2F;cloud ???</h2><h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"spring-boot-cloud\"><a href=\"#spring-boot-cloud\" class=\"headerlink\" title=\"spring boot&#x2F;cloud ???\"></a>spring boot&#x2F;cloud ???</h2><h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2>"},{"title":"手撕相关","keywords":["面经"],"description":"手撕代码技巧","abbrlink":17772,"date":"2024-06-13T08:18:26.000Z","updated":"2024-06-13T08:18:26.000Z","top_img":"https://s2.loli.net/2024/06/13/YBqXTWpEVFg6hSl.png","comments":1,"cover":"https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\nthis is a test file.\n","source":"_posts/手撕相关.md","raw":"---\ntitle: 手撕相关\ntags:\n  - 手撕技巧\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 手撕代码技巧\nabbrlink: 17772\ndate: 2024-06-13 16:18:26\nupdated: 2024-06-13 16:18:26\ntop_img: https://s2.loli.net/2024/06/13/YBqXTWpEVFg6hSl.png\ncomments:\ncover: https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\nthis is a test file.\n","slug":"手撕相关","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vc0022uugn752y8adl","content":"<p>this is a test file.</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<p>this is a test file.</p>\n"},{"title":"计算机基础","keywords":["面经"],"description":"计算机网络和操作系统面经","abbrlink":17770,"date":"2024-06-12T14:47:24.000Z","updated":"2024-06-13T08:17:24.000Z","top_img":"https://s2.loli.net/2024/06/12/LYyWClAmBc36PrZ.png","comments":1,"cover":"https://s2.loli.net/2024/06/12/WHlmQVSb9NM8oXe.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n## 网络\n### http 和 https\n**基本概念**\n- http: 是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。\n- https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\n\n**http 和 https 的区别及优缺点？**\n- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议`安全`，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。\n- http 协议的`默认端口`为 80，https 的默认端口为 443。\n- http 的连接很简单，是无状态的。https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电。\n- https `缓存`不如 http 高效，会增加数据开销。\n- Https 协议需要 ca 证书，费用较高，功能越强大的`证书费`用越高。\n- SSL 证书需要绑定 `域名`。\n\n**https 协议的工作原理**\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：\n1. 客户端使用 https url 访问服务器，则要求 web 服务器`建立 ssl 链接`。\n2. web 服务器接收到客户端的请求之后，会`将网站的证书(证书中包含了公钥)，传输给客户端`。\n3. 客户端和 web 服务器端开始`协商 SSL 链接的安全等级`，也就是加密等级。\n4. 客户端浏览器通过双方协商一致的安全等级，`建立会话密钥`，然后通过网站的公钥来加密会话密钥，并传送给网站。\n5. web 服务器`通过自己的私钥解密出会话密钥`。\n6. web 服务器`通过会话密钥加密与客户端之间的通信`。\n\n### TCP、UDP区别\n二者都是常见的传输层协议。\n- **TCP(Transmission Control Protocol，传输控制协议 )**：提供 **面向连接** 的，**可靠** 的数据传输服务。\n- **UDP(User Datagram Protocol，用户数据协议)**：提供 **无连接** 的，**尽最大努力** 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n>TCP与UDP区别总结：\n> 1、TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接\n> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的\n> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)\n> 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n> 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节\n> 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n>\n> 原文链接：https://blog.csdn.net/Li_Ning_/article/details/52117463\n\n### TCP/UDP应用场景\nhttps://blog.csdn.net/qq_44273429/article/details/131375961\n\n由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：\n- 文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。\n- 网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。\n- 电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。\n- 远程登录：TCP提供了稳定的连接，适合远程登录操作。\n- 数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。\n\n由于UDP具有低延迟和高效性的特点，它适用于以下场景：\n- 视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。\n- 实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。\n- DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。\n- 实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等\n\n### 三次握手四次挥手\n建立一个 TCP 连接需要“三次握手”，缺一不可：\n- 一次握手:客户端发送带有 SYN(SEQ=x) 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；\n- 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态；\n- 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！\n\n断开一个 TCP 连接则需要“四次挥手”，缺一不可：\n- 第一次挥手：客户端发送一个 FIN(SEQ=x) 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。\n- 第二次挥手：服务端收到这个 FIN(SEQ=X) 标志的数据包，它发送一个 ACK (ACK=x+1)标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。\n- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。\n- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n### OSI七层模型\nhttps://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\nhttps://learn.skyofit.com/archives/1313\n\n- 应用层、为计算机提供服务\n- 表示层、数据处理(编码、解码、加密解密、压缩解压缩)\n- 会话层、管理(建立、维护、重连)应用程序之间的会话\n- 传输层、为两台主机进程之间的通信提供通用的数据传输服务\n- 网络层、路由和寻址(决定数据在网络中的游走路径)\n- 数据链路层、帧编码和误差纠正控制\n- 物理层、透明地传送比特流传输\n\n### TCP/IP四层模型\n\n1. 应用层\n2. 传输层\n3. 网络层\n4. 网络接口层\n\n## 操作系统\n\n\n","source":"_posts/计算机基础.md","raw":"---\ntitle: 计算机基础\ntags:\n  - 计算机网络\n  - 操作系统\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 计算机网络和操作系统面经\nabbrlink: 17770\ndate: 2024-06-12 22:47:24\nupdated: 2024-06-13 16:17:24\ntop_img: https://s2.loli.net/2024/06/12/LYyWClAmBc36PrZ.png\ncomments:\ncover: https://s2.loli.net/2024/06/12/WHlmQVSb9NM8oXe.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n## 网络\n### http 和 https\n**基本概念**\n- http: 是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。\n- https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\n\n**http 和 https 的区别及优缺点？**\n- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议`安全`，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。\n- http 协议的`默认端口`为 80，https 的默认端口为 443。\n- http 的连接很简单，是无状态的。https 握手阶段比较`费时`，会使页面加载时间延长 50%，增加 10%~20%的耗电。\n- https `缓存`不如 http 高效，会增加数据开销。\n- Https 协议需要 ca 证书，费用较高，功能越强大的`证书费`用越高。\n- SSL 证书需要绑定 `域名`。\n\n**https 协议的工作原理**\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：\n1. 客户端使用 https url 访问服务器，则要求 web 服务器`建立 ssl 链接`。\n2. web 服务器接收到客户端的请求之后，会`将网站的证书(证书中包含了公钥)，传输给客户端`。\n3. 客户端和 web 服务器端开始`协商 SSL 链接的安全等级`，也就是加密等级。\n4. 客户端浏览器通过双方协商一致的安全等级，`建立会话密钥`，然后通过网站的公钥来加密会话密钥，并传送给网站。\n5. web 服务器`通过自己的私钥解密出会话密钥`。\n6. web 服务器`通过会话密钥加密与客户端之间的通信`。\n\n### TCP、UDP区别\n二者都是常见的传输层协议。\n- **TCP(Transmission Control Protocol，传输控制协议 )**：提供 **面向连接** 的，**可靠** 的数据传输服务。\n- **UDP(User Datagram Protocol，用户数据协议)**：提供 **无连接** 的，**尽最大努力** 的数据传输服务(不保证数据传输的可靠性)，简单高效。\n\n>TCP与UDP区别总结：\n> 1、TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接\n> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付\n> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的\n> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)\n> 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n> 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节\n> 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n>\n> 原文链接：https://blog.csdn.net/Li_Ning_/article/details/52117463\n\n### TCP/UDP应用场景\nhttps://blog.csdn.net/qq_44273429/article/details/131375961\n\n由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：\n- 文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。\n- 网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。\n- 电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。\n- 远程登录：TCP提供了稳定的连接，适合远程登录操作。\n- 数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。\n\n由于UDP具有低延迟和高效性的特点，它适用于以下场景：\n- 视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。\n- 实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。\n- DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。\n- 实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等\n\n### 三次握手四次挥手\n建立一个 TCP 连接需要“三次握手”，缺一不可：\n- 一次握手:客户端发送带有 SYN(SEQ=x) 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；\n- 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态；\n- 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！\n\n断开一个 TCP 连接则需要“四次挥手”，缺一不可：\n- 第一次挥手：客户端发送一个 FIN(SEQ=x) 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。\n- 第二次挥手：服务端收到这个 FIN(SEQ=X) 标志的数据包，它发送一个 ACK (ACK=x+1)标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。\n- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。\n- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n### OSI七层模型\nhttps://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\nhttps://learn.skyofit.com/archives/1313\n\n- 应用层、为计算机提供服务\n- 表示层、数据处理(编码、解码、加密解密、压缩解压缩)\n- 会话层、管理(建立、维护、重连)应用程序之间的会话\n- 传输层、为两台主机进程之间的通信提供通用的数据传输服务\n- 网络层、路由和寻址(决定数据在网络中的游走路径)\n- 数据链路层、帧编码和误差纠正控制\n- 物理层、透明地传送比特流传输\n\n### TCP/IP四层模型\n\n1. 应用层\n2. 传输层\n3. 网络层\n4. 网络接口层\n\n## 操作系统\n\n\n","slug":"计算机基础","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vd0025uugnfhwt9vh3","content":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"http-和-https\"><a href=\"#http-和-https\" class=\"headerlink\" title=\"http 和 https\"></a>http 和 https</h3><p><strong>基本概念</strong></p>\n<ul>\n<li>http: 是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</li>\n<li>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>\n</ul>\n<p><strong>http 和 https 的区别及优缺点？</strong></p>\n<ul>\n<li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li>\n<li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li>\n<li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>\n<li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li>\n<li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li>\n<li>SSL 证书需要绑定 <code>域名</code>。</li>\n</ul>\n<p><strong>https 协议的工作原理</strong><br>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>\n<ol>\n<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>\n<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书(证书中包含了公钥)，传输给客户端</code>。</li>\n<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>\n<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>\n<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>\n<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>\n</ol>\n<h3 id=\"TCP、UDP区别\"><a href=\"#TCP、UDP区别\" class=\"headerlink\" title=\"TCP、UDP区别\"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p>\n<ul>\n<li><strong>TCP(Transmission Control Protocol，传输控制协议 )<strong>：提供 <strong>面向连接</strong> 的，</strong>可靠</strong> 的数据传输服务。</li>\n<li><strong>UDP(User Datagram Protocol，用户数据协议)<strong>：提供 <strong>无连接</strong> 的，</strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<blockquote>\n<p>TCP与UDP区别总结：<br>1、TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Li_Ning_/article/details/52117463\">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p>\n</blockquote>\n<h3 id=\"TCP-UDP应用场景\"><a href=\"#TCP-UDP应用场景\" class=\"headerlink\" title=\"TCP&#x2F;UDP应用场景\"></a>TCP&#x2F;UDP应用场景</h3><p><a href=\"https://blog.csdn.net/qq_44273429/article/details/131375961\">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p>\n<p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p>\n<ul>\n<li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li>\n<li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li>\n<li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li>\n<li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li>\n<li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li>\n</ul>\n<p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p>\n<ul>\n<li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li>\n<li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li>\n<li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li>\n<li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li>\n</ul>\n<h3 id=\"三次握手四次挥手\"><a href=\"#三次握手四次挥手\" class=\"headerlink\" title=\"三次握手四次挥手\"></a>三次握手四次挥手</h3><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>\n<ul>\n<li>一次握手:客户端发送带有 SYN(SEQ&#x3D;x) 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；</li>\n<li>二次握手:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态；</li>\n<li>三次握手:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li>\n</ul>\n<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>\n<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>\n<ul>\n<li>第一次挥手：客户端发送一个 FIN(SEQ&#x3D;x) 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li>\n<li>第二次挥手：服务端收到这个 FIN(SEQ&#x3D;X) 标志的数据包，它发送一个 ACK (ACK&#x3D;x+1)标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li>\n<li>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li>\n<li>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>\n</ul>\n<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>\n<h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><p><a href=\"https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\">https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B</a><br><a href=\"https://learn.skyofit.com/archives/1313\">https://learn.skyofit.com/archives/1313</a></p>\n<ul>\n<li>应用层、为计算机提供服务</li>\n<li>表示层、数据处理(编码、解码、加密解密、压缩解压缩)</li>\n<li>会话层、管理(建立、维护、重连)应用程序之间的会话</li>\n<li>传输层、为两台主机进程之间的通信提供通用的数据传输服务</li>\n<li>网络层、路由和寻址(决定数据在网络中的游走路径)</li>\n<li>数据链路层、帧编码和误差纠正控制</li>\n<li>物理层、透明地传送比特流传输</li>\n</ul>\n<h3 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"http-和-https\"><a href=\"#http-和-https\" class=\"headerlink\" title=\"http 和 https\"></a>http 和 https</h3><p><strong>基本概念</strong></p>\n<ul>\n<li>http: 是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</li>\n<li>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>\n</ul>\n<p><strong>http 和 https 的区别及优缺点？</strong></p>\n<ul>\n<li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li>\n<li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li>\n<li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>\n<li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li>\n<li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li>\n<li>SSL 证书需要绑定 <code>域名</code>。</li>\n</ul>\n<p><strong>https 协议的工作原理</strong><br>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>\n<ol>\n<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>\n<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书(证书中包含了公钥)，传输给客户端</code>。</li>\n<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>\n<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>\n<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>\n<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>\n</ol>\n<h3 id=\"TCP、UDP区别\"><a href=\"#TCP、UDP区别\" class=\"headerlink\" title=\"TCP、UDP区别\"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p>\n<ul>\n<li><strong>TCP(Transmission Control Protocol，传输控制协议 )<strong>：提供 <strong>面向连接</strong> 的，</strong>可靠</strong> 的数据传输服务。</li>\n<li><strong>UDP(User Datagram Protocol，用户数据协议)<strong>：提供 <strong>无连接</strong> 的，</strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li>\n</ul>\n<blockquote>\n<p>TCP与UDP区别总结：<br>1、TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Li_Ning_/article/details/52117463\">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p>\n</blockquote>\n<h3 id=\"TCP-UDP应用场景\"><a href=\"#TCP-UDP应用场景\" class=\"headerlink\" title=\"TCP&#x2F;UDP应用场景\"></a>TCP&#x2F;UDP应用场景</h3><p><a href=\"https://blog.csdn.net/qq_44273429/article/details/131375961\">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p>\n<p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p>\n<ul>\n<li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li>\n<li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li>\n<li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li>\n<li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li>\n<li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li>\n</ul>\n<p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p>\n<ul>\n<li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li>\n<li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li>\n<li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li>\n<li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li>\n</ul>\n<h3 id=\"三次握手四次挥手\"><a href=\"#三次握手四次挥手\" class=\"headerlink\" title=\"三次握手四次挥手\"></a>三次握手四次挥手</h3><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>\n<ul>\n<li>一次握手:客户端发送带有 SYN(SEQ&#x3D;x) 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；</li>\n<li>二次握手:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态；</li>\n<li>三次握手:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li>\n</ul>\n<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>\n<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>\n<ul>\n<li>第一次挥手：客户端发送一个 FIN(SEQ&#x3D;x) 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li>\n<li>第二次挥手：服务端收到这个 FIN(SEQ&#x3D;X) 标志的数据包，它发送一个 ACK (ACK&#x3D;x+1)标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li>\n<li>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li>\n<li>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>\n</ul>\n<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>\n<h3 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h3><p><a href=\"https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B\">https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B</a><br><a href=\"https://learn.skyofit.com/archives/1313\">https://learn.skyofit.com/archives/1313</a></p>\n<ul>\n<li>应用层、为计算机提供服务</li>\n<li>表示层、数据处理(编码、解码、加密解密、压缩解压缩)</li>\n<li>会话层、管理(建立、维护、重连)应用程序之间的会话</li>\n<li>传输层、为两台主机进程之间的通信提供通用的数据传输服务</li>\n<li>网络层、路由和寻址(决定数据在网络中的游走路径)</li>\n<li>数据链路层、帧编码和误差纠正控制</li>\n<li>物理层、透明地传送比特流传输</li>\n</ul>\n<h3 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP&#x2F;IP四层模型\"></a>TCP&#x2F;IP四层模型</h3><ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2>"},{"title":"测开面经","keywords":["面经"],"description":"测开面经","abbrlink":17768,"date":"2024-05-27T12:15:34.000Z","updated":"2024-05-27T12:58:53.000Z","top_img":"https://s2.loli.net/2024/05/27/BLZiDeVdQokmptg.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/drCF3NnMKboz1AQ.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 注：下面内容一部分来自于我舍友的博客\n\n### 测开自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **测试开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！\n\n\n### 为什么选择测开\n之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。\n\n> 需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。\n\n### 做过哪些关于测开的工作\n之前负责给社区写一个适配器。\n\nCasbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 `SQLAlchemy` 适配器。这种适配器允许在异步环境中使用 `SQLAlchemy` 作为持久化层，管理 Casbin 的策略存储。\n\n主要工作：\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。 \n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n  - 测试添加一个策略，添加多个策略\n  - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n  - 测试更新一个策略，测试更新多个策略。\n\n还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。\n\n### 黑盒测试\n又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。\n\n### 白盒测试\n又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。\n\n### 测试用例\n描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束\n\n### 测试用例的设计方法\n- 等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。\n- 边界值分析：测试边界值\n- 决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果\n- 随机测试：随机生成输入数据进行测试\n\n### 如何理解测试开发中的开发\n- 编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。\n- 编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如`JUnit`、`TestNG`、`Selenium`等）来组织和运行测试。\n- 开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。\n- 维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。\n- 参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。\n\n### 如何测试一个Java项目？\n- 单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。\n- 集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。\n- 性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。\n- 持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。\n\n### 如何判断所写接口功能正常？\n- 功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。\n- 性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。\n- 安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。\n- 兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。\n\n### 怎么构造无用测试用例？\n- 随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。\n- 非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。\n- 重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。\n\n### 如何感知线上项目出现问题\n日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。\n性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。\n自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。\n\n### 小红书购物搜索框设计测试用例\n测试用例名称：搜索框输入有效关键词\n- 输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示与输入关键词相关的商品列表。\n\n测试用例名称：搜索框输入无效关键词\n- 输入：在搜索框中输入无效的商品关键词，例如“@@@”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面提示“未找到相关商品”。\n\n测试用例名称：搜索框输入空关键词\n- 输入：在搜索框中不输入任何内容。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示全部商品列表。\n\n测试用例名称：搜索框联想功能\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：等待几秒钟，观察搜索框下方是否出现联想词。\n- 预期结果：搜索框下方显示与输入关键词相关的联想词列表。\n\n测试用例名称：搜索框输入并选择联想词\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：从联想词列表中选择一个词，例如“连衣裙”。\n- 预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。\n\n测试用例名称：搜索框清空功能\n- 输入：在搜索框中输入关键词，例如“连衣裙”。\n- 操作：点击搜索框右侧的清空按钮。\n- 预期结果：搜索框中的文本被清空，搜索框恢复为空状态。\n\n### 登录设计测试样例\n测试用例名称：输入有效的用户名和密码登录\n- 输入：有效的用户名和密码。\n- 操作：在登录页面输入用户名和密码，点击登录按钮。\n- 预期结果：成功登录，跳转到用户的个人资料页面或首页。\n\n测试用例名称：输入无效的用户名和密码登录\n- 输入：无效的用户名和密码。\n- 操作：在登录页面输入错误的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码错误的错误信息。\n\n测试用例名称：输入不存在的用户名登录\n- 输入：不存在的用户名和有效密码。\n- 操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不存在的错误信息。\n\n测试用例名称：输入正确的用户名和空密码登录\n- 输入：有效的用户名和空密码。\n- 操作：在登录页面输入正确的用户名和空密码，点击登录按钮。\n- 预期结果：登录失败，提示密码不能为空的错误信息。\n\n测试用例名称：输入空用户名和正确密码登录\n- 输入：空用户名和有效的密码。\n- 操作：在登录页面输入空用户名和正确的密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不能为空的错误信息。\n\n测试用例名称：输入特殊字符的用户名和密码登录\n- 输入：包含特殊字符的用户名和密码。\n- 操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码格式不正确的错误信息。\n\n测试用例名称：记住登录状态\n- 输入：有效的用户名和密码。\n- 操作：在登录页面勾选“记住我”选项后登录。\n- 预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。\n\n测试用例名称：登录页链接验证\n- 输入：无。\n- 操作：检查登录页面上的链接。\n- 预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。\n\n测试用例名称：跳转到登录页面\n- 输入：未登录状态。\n- 操作：尝试访问需要登录权限的页面。\n- 预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。\n\n测试用例名称：登录界面的响应速度\n- 输入：无。\n- 操作：在不同网络环境下打开登录页面。\n- 预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。\n\n### 微信发送文件的测试用例\n功能测试\n- 正常发送文件\n- 发送支持的文件类型\n\n边界值测试\n- 发送最大允许大小的文件\n- 发送超过最大允许大小的文件\n\n异常情况测试\n- 发送空文件\n- 发送损坏文件\n- 网络中断后重新发送\n\n性能测试\n- 同时发送多个文件\n- 选择一个接近最大允许大小的文件\n\n用户体验测试\n- 发送文件时的用户提示\n- 文件发送记录\n\n安全性测试\n- 发送包含敏感信息的文件\n- 病毒文件检测\n\n跨平台测试\n\n### 微信发送红包的测试用例\n- 功能测试\n正常发送红包\n发送拼手气红包\n发送定向红包\n\n- 边界值测试\n发送最低和最高金额的红包\n发送超过最高金额的红包\n\n- 异常情况测试\n余额不足时发送红包\n网络中断后重新发送\n取消发送红包\n\n- 安全性测试\n多测领取红包\n红包过期\n未实名验证用户发送红包\n单方删除好友后发送红包\n\n用户体验测试\n\n跨平台测试\n\n性能测试\n- 高频发送红包\n- 大规模红包领取（拼手气红包）\n\n### 电影订票功能的测试样例\n功能测试\n- 检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确\n- 验证不同支付方式是否可用\n- 验证电子票是否包含必要信息、是否能通过扫描进入影院\n\n边界和异常情况测试\n- 无效的账户或者账户余额不足进行支付\n- 用户选择座位但未完成支付，座位在一定时间后能否自动释放\n\n性能测试\n- 系统负载测试：高并发访问\n- 正常负载和高负载下的响应时间是否正常\n\n兼容性测试\n\n### Github Workflow自动化测试\nGitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：\n\n1. **持续集成（CI）：** 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。\n2. **持续部署（CD）：** 自动将代码部署到生产环境或其他目标环境。\n3. **代码分析和质量检查：** 运行静态代码分析工具，以检查代码质量和一致性。\n4. **构建和发布：** 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。\n5. **自动化任务：** 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。\n\n在 GitHub Actions 中，workflow 文件是通过 `.yml` 或 `.yaml` 文件定义的，通常放在 `.github/workflows/` 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。\n\n**示例：**\n\n以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：\n\n```yaml\nname: CI\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run tests\n      run: npm test\n```\n\n在这个示例中，workflow 文件名为 `ci.yml`，它定义了一个名为 `build` 的 job，该 job 在 `ubuntu-latest` 的环境上运行。整个过程包括以下步骤：\n1. **Checkout code**：检出代码仓库。\n2. **Set up Node.js**：设置 Node.js 环境。\n3. **Install dependencies**：安装依赖。\n4. **Run tests**：运行测试。\n\n所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。\n\n### 测试工具\n- JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。\n- TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。\n- Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。\n- JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。\n\n\n\n\n","source":"_posts/测开面经.md","raw":"---\ntitle: 测开面经\ntags:\n  - 测试开发\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 测开面经\nabbrlink: 17768\ndate: 2024-05-27 20:15:34\nupdated: 2024-05-27 20:58:53\ntop_img: https://s2.loli.net/2024/05/27/BLZiDeVdQokmptg.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/drCF3NnMKboz1AQ.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 注：下面内容一部分来自于我舍友的博客\n\n### 测开自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **测试开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！\n\n\n### 为什么选择测开\n之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。\n\n> 需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。\n\n### 做过哪些关于测开的工作\n之前负责给社区写一个适配器。\n\nCasbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 `SQLAlchemy` 适配器。这种适配器允许在异步环境中使用 `SQLAlchemy` 作为持久化层，管理 Casbin 的策略存储。\n\n主要工作：\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。 \n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n  - 测试添加一个策略，添加多个策略\n  - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n  - 测试更新一个策略，测试更新多个策略。\n\n还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。\n\n### 黑盒测试\n又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。\n\n### 白盒测试\n又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。\n\n### 测试用例\n描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束\n\n### 测试用例的设计方法\n- 等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。\n- 边界值分析：测试边界值\n- 决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果\n- 随机测试：随机生成输入数据进行测试\n\n### 如何理解测试开发中的开发\n- 编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。\n- 编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如`JUnit`、`TestNG`、`Selenium`等）来组织和运行测试。\n- 开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。\n- 维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。\n- 参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。\n\n### 如何测试一个Java项目？\n- 单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。\n- 集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。\n- 性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。\n- 持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。\n\n### 如何判断所写接口功能正常？\n- 功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。\n- 性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。\n- 安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。\n- 兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。\n\n### 怎么构造无用测试用例？\n- 随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。\n- 非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。\n- 重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。\n\n### 如何感知线上项目出现问题\n日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。\n性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。\n自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。\n\n### 小红书购物搜索框设计测试用例\n测试用例名称：搜索框输入有效关键词\n- 输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示与输入关键词相关的商品列表。\n\n测试用例名称：搜索框输入无效关键词\n- 输入：在搜索框中输入无效的商品关键词，例如“@@@”。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面提示“未找到相关商品”。\n\n测试用例名称：搜索框输入空关键词\n- 输入：在搜索框中不输入任何内容。\n- 操作：点击搜索按钮或按下回车键。\n- 预期结果：搜索结果页面显示全部商品列表。\n\n测试用例名称：搜索框联想功能\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：等待几秒钟，观察搜索框下方是否出现联想词。\n- 预期结果：搜索框下方显示与输入关键词相关的联想词列表。\n\n测试用例名称：搜索框输入并选择联想词\n- 输入：在搜索框中输入部分关键词，例如“连衣”。\n- 操作：从联想词列表中选择一个词，例如“连衣裙”。\n- 预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。\n\n测试用例名称：搜索框清空功能\n- 输入：在搜索框中输入关键词，例如“连衣裙”。\n- 操作：点击搜索框右侧的清空按钮。\n- 预期结果：搜索框中的文本被清空，搜索框恢复为空状态。\n\n### 登录设计测试样例\n测试用例名称：输入有效的用户名和密码登录\n- 输入：有效的用户名和密码。\n- 操作：在登录页面输入用户名和密码，点击登录按钮。\n- 预期结果：成功登录，跳转到用户的个人资料页面或首页。\n\n测试用例名称：输入无效的用户名和密码登录\n- 输入：无效的用户名和密码。\n- 操作：在登录页面输入错误的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码错误的错误信息。\n\n测试用例名称：输入不存在的用户名登录\n- 输入：不存在的用户名和有效密码。\n- 操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不存在的错误信息。\n\n测试用例名称：输入正确的用户名和空密码登录\n- 输入：有效的用户名和空密码。\n- 操作：在登录页面输入正确的用户名和空密码，点击登录按钮。\n- 预期结果：登录失败，提示密码不能为空的错误信息。\n\n测试用例名称：输入空用户名和正确密码登录\n- 输入：空用户名和有效的密码。\n- 操作：在登录页面输入空用户名和正确的密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名不能为空的错误信息。\n\n测试用例名称：输入特殊字符的用户名和密码登录\n- 输入：包含特殊字符的用户名和密码。\n- 操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。\n- 预期结果：登录失败，提示用户名或密码格式不正确的错误信息。\n\n测试用例名称：记住登录状态\n- 输入：有效的用户名和密码。\n- 操作：在登录页面勾选“记住我”选项后登录。\n- 预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。\n\n测试用例名称：登录页链接验证\n- 输入：无。\n- 操作：检查登录页面上的链接。\n- 预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。\n\n测试用例名称：跳转到登录页面\n- 输入：未登录状态。\n- 操作：尝试访问需要登录权限的页面。\n- 预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。\n\n测试用例名称：登录界面的响应速度\n- 输入：无。\n- 操作：在不同网络环境下打开登录页面。\n- 预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。\n\n### 微信发送文件的测试用例\n功能测试\n- 正常发送文件\n- 发送支持的文件类型\n\n边界值测试\n- 发送最大允许大小的文件\n- 发送超过最大允许大小的文件\n\n异常情况测试\n- 发送空文件\n- 发送损坏文件\n- 网络中断后重新发送\n\n性能测试\n- 同时发送多个文件\n- 选择一个接近最大允许大小的文件\n\n用户体验测试\n- 发送文件时的用户提示\n- 文件发送记录\n\n安全性测试\n- 发送包含敏感信息的文件\n- 病毒文件检测\n\n跨平台测试\n\n### 微信发送红包的测试用例\n- 功能测试\n正常发送红包\n发送拼手气红包\n发送定向红包\n\n- 边界值测试\n发送最低和最高金额的红包\n发送超过最高金额的红包\n\n- 异常情况测试\n余额不足时发送红包\n网络中断后重新发送\n取消发送红包\n\n- 安全性测试\n多测领取红包\n红包过期\n未实名验证用户发送红包\n单方删除好友后发送红包\n\n用户体验测试\n\n跨平台测试\n\n性能测试\n- 高频发送红包\n- 大规模红包领取（拼手气红包）\n\n### 电影订票功能的测试样例\n功能测试\n- 检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确\n- 验证不同支付方式是否可用\n- 验证电子票是否包含必要信息、是否能通过扫描进入影院\n\n边界和异常情况测试\n- 无效的账户或者账户余额不足进行支付\n- 用户选择座位但未完成支付，座位在一定时间后能否自动释放\n\n性能测试\n- 系统负载测试：高并发访问\n- 正常负载和高负载下的响应时间是否正常\n\n兼容性测试\n\n### Github Workflow自动化测试\nGitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：\n\n1. **持续集成（CI）：** 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。\n2. **持续部署（CD）：** 自动将代码部署到生产环境或其他目标环境。\n3. **代码分析和质量检查：** 运行静态代码分析工具，以检查代码质量和一致性。\n4. **构建和发布：** 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。\n5. **自动化任务：** 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。\n\n在 GitHub Actions 中，workflow 文件是通过 `.yml` 或 `.yaml` 文件定义的，通常放在 `.github/workflows/` 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。\n\n**示例：**\n\n以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：\n\n```yaml\nname: CI\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '14'\n\n    - name: Install dependencies\n      run: npm install\n\n    - name: Run tests\n      run: npm test\n```\n\n在这个示例中，workflow 文件名为 `ci.yml`，它定义了一个名为 `build` 的 job，该 job 在 `ubuntu-latest` 的环境上运行。整个过程包括以下步骤：\n1. **Checkout code**：检出代码仓库。\n2. **Set up Node.js**：设置 Node.js 环境。\n3. **Install dependencies**：安装依赖。\n4. **Run tests**：运行测试。\n\n所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。\n\n### 测试工具\n- JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。\n- TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。\n- Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。\n- JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。\n\n\n\n\n","slug":"测开面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vd0027uugn2ji3hgg3","content":"<blockquote>\n<p>注：下面内容一部分来自于我舍友的博客</p>\n</blockquote>\n<h3 id=\"测开自我介绍\"><a href=\"#测开自我介绍\" class=\"headerlink\" title=\"测开自我介绍\"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>测试开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p>\n<h3 id=\"为什么选择测开\"><a href=\"#为什么选择测开\" class=\"headerlink\" title=\"为什么选择测开\"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p>\n<blockquote>\n<p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p>\n</blockquote>\n<h3 id=\"做过哪些关于测开的工作\"><a href=\"#做过哪些关于测开的工作\" class=\"headerlink\" title=\"做过哪些关于测开的工作\"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p>\n<p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p>\n<p>主要工作：</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p>\n<h3 id=\"黑盒测试\"><a href=\"#黑盒测试\" class=\"headerlink\" title=\"黑盒测试\"></a>黑盒测试</h3><p>又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>\n<h3 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h3><p>又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p>\n<h3 id=\"测试用例的设计方法\"><a href=\"#测试用例的设计方法\" class=\"headerlink\" title=\"测试用例的设计方法\"></a>测试用例的设计方法</h3><ul>\n<li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li>\n<li>边界值分析：测试边界值</li>\n<li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li>\n<li>随机测试：随机生成输入数据进行测试</li>\n</ul>\n<h3 id=\"如何理解测试开发中的开发\"><a href=\"#如何理解测试开发中的开发\" class=\"headerlink\" title=\"如何理解测试开发中的开发\"></a>如何理解测试开发中的开发</h3><ul>\n<li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>\n<li>编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等）来组织和运行测试。</li>\n<li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>\n<li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>\n<li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>\n</ul>\n<h3 id=\"如何测试一个Java项目？\"><a href=\"#如何测试一个Java项目？\" class=\"headerlink\" title=\"如何测试一个Java项目？\"></a>如何测试一个Java项目？</h3><ul>\n<li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>\n<li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>\n<li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>\n<li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>\n</ul>\n<h3 id=\"如何判断所写接口功能正常？\"><a href=\"#如何判断所写接口功能正常？\" class=\"headerlink\" title=\"如何判断所写接口功能正常？\"></a>如何判断所写接口功能正常？</h3><ul>\n<li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>\n<li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>\n<li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>\n<li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>\n</ul>\n<h3 id=\"怎么构造无用测试用例？\"><a href=\"#怎么构造无用测试用例？\" class=\"headerlink\" title=\"怎么构造无用测试用例？\"></a>怎么构造无用测试用例？</h3><ul>\n<li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>\n<li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>\n<li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>\n</ul>\n<h3 id=\"如何感知线上项目出现问题\"><a href=\"#如何感知线上项目出现问题\" class=\"headerlink\" title=\"如何感知线上项目出现问题\"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p>\n<h3 id=\"小红书购物搜索框设计测试用例\"><a href=\"#小红书购物搜索框设计测试用例\" class=\"headerlink\" title=\"小红书购物搜索框设计测试用例\"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p>\n<ul>\n<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入无效关键词</p>\n<ul>\n<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>\n</ul>\n<p>测试用例名称：搜索框输入空关键词</p>\n<ul>\n<li>输入：在搜索框中不输入任何内容。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示全部商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框联想功能</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>\n<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入并选择联想词</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>\n<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>\n</ul>\n<p>测试用例名称：搜索框清空功能</p>\n<ul>\n<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索框右侧的清空按钮。</li>\n<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>\n</ul>\n<h3 id=\"登录设计测试样例\"><a href=\"#登录设计测试样例\" class=\"headerlink\" title=\"登录设计测试样例\"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>\n<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>\n</ul>\n<p>测试用例名称：输入无效的用户名和密码登录</p>\n<ul>\n<li>输入：无效的用户名和密码。</li>\n<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>\n</ul>\n<p>测试用例名称：输入不存在的用户名登录</p>\n<ul>\n<li>输入：不存在的用户名和有效密码。</li>\n<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>\n</ul>\n<p>测试用例名称：输入正确的用户名和空密码登录</p>\n<ul>\n<li>输入：有效的用户名和空密码。</li>\n<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入空用户名和正确密码登录</p>\n<ul>\n<li>输入：空用户名和有效的密码。</li>\n<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入特殊字符的用户名和密码登录</p>\n<ul>\n<li>输入：包含特殊字符的用户名和密码。</li>\n<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>\n</ul>\n<p>测试用例名称：记住登录状态</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面勾选“记住我”选项后登录。</li>\n<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>\n</ul>\n<p>测试用例名称：登录页链接验证</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：检查登录页面上的链接。</li>\n<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>\n</ul>\n<p>测试用例名称：跳转到登录页面</p>\n<ul>\n<li>输入：未登录状态。</li>\n<li>操作：尝试访问需要登录权限的页面。</li>\n<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>\n</ul>\n<p>测试用例名称：登录界面的响应速度</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：在不同网络环境下打开登录页面。</li>\n<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>\n</ul>\n<h3 id=\"微信发送文件的测试用例\"><a href=\"#微信发送文件的测试用例\" class=\"headerlink\" title=\"微信发送文件的测试用例\"></a>微信发送文件的测试用例</h3><p>功能测试</p>\n<ul>\n<li>正常发送文件</li>\n<li>发送支持的文件类型</li>\n</ul>\n<p>边界值测试</p>\n<ul>\n<li>发送最大允许大小的文件</li>\n<li>发送超过最大允许大小的文件</li>\n</ul>\n<p>异常情况测试</p>\n<ul>\n<li>发送空文件</li>\n<li>发送损坏文件</li>\n<li>网络中断后重新发送</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>同时发送多个文件</li>\n<li>选择一个接近最大允许大小的文件</li>\n</ul>\n<p>用户体验测试</p>\n<ul>\n<li>发送文件时的用户提示</li>\n<li>文件发送记录</li>\n</ul>\n<p>安全性测试</p>\n<ul>\n<li>发送包含敏感信息的文件</li>\n<li>病毒文件检测</li>\n</ul>\n<p>跨平台测试</p>\n<h3 id=\"微信发送红包的测试用例\"><a href=\"#微信发送红包的测试用例\" class=\"headerlink\" title=\"微信发送红包的测试用例\"></a>微信发送红包的测试用例</h3><ul>\n<li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p>\n</li>\n<li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p>\n</li>\n<li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p>\n</li>\n<li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p>\n</li>\n</ul>\n<p>用户体验测试</p>\n<p>跨平台测试</p>\n<p>性能测试</p>\n<ul>\n<li>高频发送红包</li>\n<li>大规模红包领取（拼手气红包）</li>\n</ul>\n<h3 id=\"电影订票功能的测试样例\"><a href=\"#电影订票功能的测试样例\" class=\"headerlink\" title=\"电影订票功能的测试样例\"></a>电影订票功能的测试样例</h3><p>功能测试</p>\n<ul>\n<li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li>\n<li>验证不同支付方式是否可用</li>\n<li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li>\n</ul>\n<p>边界和异常情况测试</p>\n<ul>\n<li>无效的账户或者账户余额不足进行支付</li>\n<li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>系统负载测试：高并发访问</li>\n<li>正常负载和高负载下的响应时间是否正常</li>\n</ul>\n<p>兼容性测试</p>\n<h3 id=\"Github-Workflow自动化测试\"><a href=\"#Github-Workflow自动化测试\" class=\"headerlink\" title=\"Github Workflow自动化测试\"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p>\n<ol>\n<li><strong>持续集成（CI）：</strong> 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li>\n<li><strong>持续部署（CD）：</strong> 自动将代码部署到生产环境或其他目标环境。</li>\n<li><strong>代码分析和质量检查：</strong> 运行静态代码分析工具，以检查代码质量和一致性。</li>\n<li><strong>构建和发布：</strong> 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。</li>\n<li><strong>自动化任务：</strong> 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li>\n</ol>\n<p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p>\n<p><strong>示例：</strong></p>\n<p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">code</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">Node.js</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;14&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Run</span> <span class=\"string\">tests</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">test</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p>\n<ol>\n<li><strong>Checkout code</strong>：检出代码仓库。</li>\n<li><strong>Set up Node.js</strong>：设置 Node.js 环境。</li>\n<li><strong>Install dependencies</strong>：安装依赖。</li>\n<li><strong>Run tests</strong>：运行测试。</li>\n</ol>\n<p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p>\n<h3 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h3><ul>\n<li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>\n<li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>\n<li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>\n<li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>注：下面内容一部分来自于我舍友的博客</p>\n</blockquote>\n<h3 id=\"测开自我介绍\"><a href=\"#测开自我介绍\" class=\"headerlink\" title=\"测开自我介绍\"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>测试开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p>\n<h3 id=\"为什么选择测开\"><a href=\"#为什么选择测开\" class=\"headerlink\" title=\"为什么选择测开\"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p>\n<blockquote>\n<p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p>\n</blockquote>\n<h3 id=\"做过哪些关于测开的工作\"><a href=\"#做过哪些关于测开的工作\" class=\"headerlink\" title=\"做过哪些关于测开的工作\"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p>\n<p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p>\n<p>主要工作：</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p>\n<h3 id=\"黑盒测试\"><a href=\"#黑盒测试\" class=\"headerlink\" title=\"黑盒测试\"></a>黑盒测试</h3><p>又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p>\n<h3 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h3><p>又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。</p>\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p>\n<h3 id=\"测试用例的设计方法\"><a href=\"#测试用例的设计方法\" class=\"headerlink\" title=\"测试用例的设计方法\"></a>测试用例的设计方法</h3><ul>\n<li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li>\n<li>边界值分析：测试边界值</li>\n<li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li>\n<li>随机测试：随机生成输入数据进行测试</li>\n</ul>\n<h3 id=\"如何理解测试开发中的开发\"><a href=\"#如何理解测试开发中的开发\" class=\"headerlink\" title=\"如何理解测试开发中的开发\"></a>如何理解测试开发中的开发</h3><ul>\n<li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li>\n<li>编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等）来组织和运行测试。</li>\n<li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li>\n<li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li>\n<li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li>\n</ul>\n<h3 id=\"如何测试一个Java项目？\"><a href=\"#如何测试一个Java项目？\" class=\"headerlink\" title=\"如何测试一个Java项目？\"></a>如何测试一个Java项目？</h3><ul>\n<li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li>\n<li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li>\n<li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li>\n<li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li>\n</ul>\n<h3 id=\"如何判断所写接口功能正常？\"><a href=\"#如何判断所写接口功能正常？\" class=\"headerlink\" title=\"如何判断所写接口功能正常？\"></a>如何判断所写接口功能正常？</h3><ul>\n<li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li>\n<li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li>\n<li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li>\n<li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li>\n</ul>\n<h3 id=\"怎么构造无用测试用例？\"><a href=\"#怎么构造无用测试用例？\" class=\"headerlink\" title=\"怎么构造无用测试用例？\"></a>怎么构造无用测试用例？</h3><ul>\n<li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li>\n<li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li>\n<li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li>\n</ul>\n<h3 id=\"如何感知线上项目出现问题\"><a href=\"#如何感知线上项目出现问题\" class=\"headerlink\" title=\"如何感知线上项目出现问题\"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p>\n<h3 id=\"小红书购物搜索框设计测试用例\"><a href=\"#小红书购物搜索框设计测试用例\" class=\"headerlink\" title=\"小红书购物搜索框设计测试用例\"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p>\n<ul>\n<li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入无效关键词</p>\n<ul>\n<li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面提示“未找到相关商品”。</li>\n</ul>\n<p>测试用例名称：搜索框输入空关键词</p>\n<ul>\n<li>输入：在搜索框中不输入任何内容。</li>\n<li>操作：点击搜索按钮或按下回车键。</li>\n<li>预期结果：搜索结果页面显示全部商品列表。</li>\n</ul>\n<p>测试用例名称：搜索框联想功能</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li>\n<li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li>\n</ul>\n<p>测试用例名称：搜索框输入并选择联想词</p>\n<ul>\n<li>输入：在搜索框中输入部分关键词，例如“连衣”。</li>\n<li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li>\n<li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li>\n</ul>\n<p>测试用例名称：搜索框清空功能</p>\n<ul>\n<li>输入：在搜索框中输入关键词，例如“连衣裙”。</li>\n<li>操作：点击搜索框右侧的清空按钮。</li>\n<li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li>\n</ul>\n<h3 id=\"登录设计测试样例\"><a href=\"#登录设计测试样例\" class=\"headerlink\" title=\"登录设计测试样例\"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面输入用户名和密码，点击登录按钮。</li>\n<li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li>\n</ul>\n<p>测试用例名称：输入无效的用户名和密码登录</p>\n<ul>\n<li>输入：无效的用户名和密码。</li>\n<li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li>\n</ul>\n<p>测试用例名称：输入不存在的用户名登录</p>\n<ul>\n<li>输入：不存在的用户名和有效密码。</li>\n<li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不存在的错误信息。</li>\n</ul>\n<p>测试用例名称：输入正确的用户名和空密码登录</p>\n<ul>\n<li>输入：有效的用户名和空密码。</li>\n<li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示密码不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入空用户名和正确密码登录</p>\n<ul>\n<li>输入：空用户名和有效的密码。</li>\n<li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名不能为空的错误信息。</li>\n</ul>\n<p>测试用例名称：输入特殊字符的用户名和密码登录</p>\n<ul>\n<li>输入：包含特殊字符的用户名和密码。</li>\n<li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li>\n<li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li>\n</ul>\n<p>测试用例名称：记住登录状态</p>\n<ul>\n<li>输入：有效的用户名和密码。</li>\n<li>操作：在登录页面勾选“记住我”选项后登录。</li>\n<li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li>\n</ul>\n<p>测试用例名称：登录页链接验证</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：检查登录页面上的链接。</li>\n<li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li>\n</ul>\n<p>测试用例名称：跳转到登录页面</p>\n<ul>\n<li>输入：未登录状态。</li>\n<li>操作：尝试访问需要登录权限的页面。</li>\n<li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li>\n</ul>\n<p>测试用例名称：登录界面的响应速度</p>\n<ul>\n<li>输入：无。</li>\n<li>操作：在不同网络环境下打开登录页面。</li>\n<li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li>\n</ul>\n<h3 id=\"微信发送文件的测试用例\"><a href=\"#微信发送文件的测试用例\" class=\"headerlink\" title=\"微信发送文件的测试用例\"></a>微信发送文件的测试用例</h3><p>功能测试</p>\n<ul>\n<li>正常发送文件</li>\n<li>发送支持的文件类型</li>\n</ul>\n<p>边界值测试</p>\n<ul>\n<li>发送最大允许大小的文件</li>\n<li>发送超过最大允许大小的文件</li>\n</ul>\n<p>异常情况测试</p>\n<ul>\n<li>发送空文件</li>\n<li>发送损坏文件</li>\n<li>网络中断后重新发送</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>同时发送多个文件</li>\n<li>选择一个接近最大允许大小的文件</li>\n</ul>\n<p>用户体验测试</p>\n<ul>\n<li>发送文件时的用户提示</li>\n<li>文件发送记录</li>\n</ul>\n<p>安全性测试</p>\n<ul>\n<li>发送包含敏感信息的文件</li>\n<li>病毒文件检测</li>\n</ul>\n<p>跨平台测试</p>\n<h3 id=\"微信发送红包的测试用例\"><a href=\"#微信发送红包的测试用例\" class=\"headerlink\" title=\"微信发送红包的测试用例\"></a>微信发送红包的测试用例</h3><ul>\n<li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p>\n</li>\n<li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p>\n</li>\n<li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p>\n</li>\n<li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p>\n</li>\n</ul>\n<p>用户体验测试</p>\n<p>跨平台测试</p>\n<p>性能测试</p>\n<ul>\n<li>高频发送红包</li>\n<li>大规模红包领取（拼手气红包）</li>\n</ul>\n<h3 id=\"电影订票功能的测试样例\"><a href=\"#电影订票功能的测试样例\" class=\"headerlink\" title=\"电影订票功能的测试样例\"></a>电影订票功能的测试样例</h3><p>功能测试</p>\n<ul>\n<li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li>\n<li>验证不同支付方式是否可用</li>\n<li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li>\n</ul>\n<p>边界和异常情况测试</p>\n<ul>\n<li>无效的账户或者账户余额不足进行支付</li>\n<li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li>\n</ul>\n<p>性能测试</p>\n<ul>\n<li>系统负载测试：高并发访问</li>\n<li>正常负载和高负载下的响应时间是否正常</li>\n</ul>\n<p>兼容性测试</p>\n<h3 id=\"Github-Workflow自动化测试\"><a href=\"#Github-Workflow自动化测试\" class=\"headerlink\" title=\"Github Workflow自动化测试\"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p>\n<ol>\n<li><strong>持续集成（CI）：</strong> 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li>\n<li><strong>持续部署（CD）：</strong> 自动将代码部署到生产环境或其他目标环境。</li>\n<li><strong>代码分析和质量检查：</strong> 运行静态代码分析工具，以检查代码质量和一致性。</li>\n<li><strong>构建和发布：</strong> 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。</li>\n<li><strong>自动化任务：</strong> 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li>\n</ol>\n<p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p>\n<p><strong>示例：</strong></p>\n<p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">code</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">Node.js</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v2</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">node-version:</span> <span class=\"string\">&#x27;14&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Run</span> <span class=\"string\">tests</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">test</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p>\n<ol>\n<li><strong>Checkout code</strong>：检出代码仓库。</li>\n<li><strong>Set up Node.js</strong>：设置 Node.js 环境。</li>\n<li><strong>Install dependencies</strong>：安装依赖。</li>\n<li><strong>Run tests</strong>：运行测试。</li>\n</ol>\n<p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p>\n<h3 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h3><ul>\n<li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li>\n<li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li>\n<li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li>\n<li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li>\n</ul>\n"},{"title":"Java后端面经","keywords":["面经"],"description":"Java后端面经","abbrlink":17766,"date":"2024-05-27T11:58:53.000Z","updated":"2024-06-13T11:22:23.000Z","top_img":"https://s2.loli.net/2024/05/27/ytcdAHzliRquNM2.png","comments":1,"cover":"https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## 简历相关\n\n### 自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！\n\n### 专业技能\n\n\n\n\n### Casbin明日之星实习\n\n1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。\n\n2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。\n\n3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。\n\n### 中科院开源之夏项目\n\n**简介**\nCasdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。\n\n**项目诉求**\n1. 对微信第三方登录的移动端支持\n    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。\n\n2. 对flutter、react-native、unity等sdk的开发及功能的增强\n    - 对flutter-sdk的增强如第一点\n\n3. 临时加上的开发casdoor-app诉求，对标Google Authenticator\n\n**技术细节**\n1. 在flutter-sdk中通过截取`session`中的`url`和`callbackURLscheme`判断其中是否有\"weixin\"字段，如果有，则进行微信第三方原生授权登录；\n\n    - 使用`WKWebView`替换原本的`ASWebAuthenticationSession`，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；\n    - 使用rb脚本文件自动化配置微信SDK导入后xcode中`xcodeproj`文件的相关配置；\n\n    - 接入`xcframework`的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；\n\n接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置`universal Link`，需付费几百美元，所以最终代码并未实际测试。\n\n2. 分为两部分\n    1. casdoor-unity-example\n        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；\n        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；\n        - 在casdoor服务端配置好应用的`clientCode`和`clientSecret`后，在Unity3D中向服务端发送认证请求(`cilentCode`等)，解析返回的`token`，就可以得到用户信息，也可以使用`session`保存`token`等信息。\n        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。\n    2. casdoor-react-native-sdk、example\n        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；\n        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。\n        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 `code_challenge` 和 `code_verifier` 。\n3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。\n    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。\n    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。\n\n> SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。\n\n**总结**\n参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。\n\n### 单点登录SSO原理\n单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。\n\n在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。\n\n流程：\n1. 用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的`session`里面，浏览器也会写入SSO域下的`cookie`。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到`session`中，并设置app域下的`cookie`，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。\n2. 此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到`session`，并在app2的域下写入一个`cookie`。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的`session`不共享，也没有任何问题。\n\nSSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，\n\n### OAuth 2.0原理\nhttps://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\n\nOAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。\n\n定义了4种角色：\n\n- 用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。\n- 应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。\n- 资源服务器：资源服务器托管受保护的用户帐户的资源。\n- 授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。\n\n步骤：\n1. 应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。\n2. 如果用户授权该请求，应用程序会收到授权准许(`Authorization Grant`)。\n3. 应用程序通过提供其自身的身份验证和授权准许(`Authorization Grant`)来向授权服务器 (API) 请求访问令牌(`access_token`)。\n4. 如果应用程序身份通过验证且授权准许(`Authorization Grant`)有效，则授权服务器(API)向应用程序颁发访问令牌(`access_token`)。授权完成。\n5. 应用程序从资源服务器(API)请求资源并提供访问令牌(`access_token`)进行身份验证。\n6. 如果访问令牌(`access_token`)有效，则资源服务器 (API) 向应用程序提供资源。\n\n授权准许(`Authorization Grant`)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：\n\n1. 授权码(`Authorization Code`)：与服务器端应用程序一起使用。\n2. 客户端凭证(`Client Credentials`)：与具有 API 访问权限的应用程序一起使用。\n3. 设备代码(`Device Code`)：用于缺少浏览器或有输入限制的设备。\n\n### Casbin Casdoor 介绍\n> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 \n> Casbin 的主要特点包括：\n> 1. **多种访问控制模型支持**：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。\n> 2. **灵活的策略管理**：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。\n> 3. **细粒度的权限控制**：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。\n> 4. **跨语言支持**：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。\n\n> Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。\n> 1. **单点登录(SSO)**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。\n> 2. **用户管理**：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。\n> 3. **权限控制**：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。\n> 4. **开源社区**：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。\n\n### RESTful API\n> RESTful API(`Representational State Transfer API`)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。\n> REST架构原则：\n> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。\n> - 统一接口： 资源：通过URL定位资源(通常是名词，如 `/users` 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： `GET`：获取资源 `POST`：创建资源 `PUT`：更新资源 `DELETE`：删除资源\n> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。\n> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。\n> - 按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。\n>\n> 特点：\n> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 \n> - 标准化操作：利用HTTP动词来描述对资源的操作。 \n> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 \n> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 \n> - 无状态交互：每个请求独立，不依赖于之前的请求。\n> \n> 优点 \n> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 \n> - 性能高：无状态和可缓存性提高了性能。 \n> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 \n> - 灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。\n> \n> 缺点 \n> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。\n> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 \n> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。\n> \n> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。\n\n### 国家电网项目\n\n**简介**\n\n自己导师接的项目，江苏省国家电网智能诊断数据分析平台\n\n**项目诉求**\n\n- 对相应指标进行增删改查\n- 可以导入、导出一些excel表格\n- 对数据进行智能诊断分析\n\n**技术细节**\n\nreact、Antd、Flask、mongodb\n\n\n### 江南布衣实习\n在公司实习期间，我担任网络工程师实习生，主要负责以下工作：\n\n1. **新入职员工设备管理**：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。\n\n2. **离职员工设备回收和资料销毁**：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>\n\n3. **订货会期间设备组装和网络连接**：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。\n\n4. **员工设备报修响应与问题解决**：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。\n\n通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。\n\n> **公司内网**：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。\n> 要使一台电脑接入公司内网，经过以下步骤：\n> \n> 1. **网络配置**：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。\n> 2. **身份验证**：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。\n> 3. **访问内部资源**：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。\n\n### 印象最深的一个项目\n之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。\n\n**亮点**\n1. **异步支持**：\n    - **亮点**：代码中使用了 `AsyncSession` 和 `async with` 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。\n    - **回答**：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。\n\n2. **灵活的过滤机制**：\n    - **亮点**：通过 `Filter` 类和 `filter_query` 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。\n    - **回答**：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。\n\n3. **可扩展性**：\n    - **亮点**：支持自定义 `db_class`，可以根据不同的需求定制存储策略。同时，默认的 `CasbinRule` 类提供了一个通用的实现。\n    - **回答**：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。\n\n4. **事务处理**：\n    - **亮点**：使用了 `_session_scope` 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。\n    - **回答**：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。\n\n**难点**\n1. **异步编程的复杂性**：\n    - **难点**：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。\n    - **回答**：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。\n2. **数据库模型的灵活性与一致性**：\n    - **难点**：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。\n    - **回答**：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。\n3. **复杂的策略更新逻辑**：\n    - **难点**：如 `update_policy` 和 `update_policies` 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。\n    - **回答**：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。\n4. **高效的批量操作**：\n    - **难点**：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。\n    - **回答**：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。\n\n测试方面\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：说明使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。\n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n    - 测试添加一个策略，添加多个策略\n    - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n    - 测试更新一个策略，测试更新多个策略。\n\n\n通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。\n\n## Java基础\n\n### Java和C++的区别\nJava 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：\n- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；\n- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；\n- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；\n- C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。\n\n> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。\n\n### 移位运算符\n`<<`：左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。\n`>>`：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。\n`>>>`：无符号右移，忽略符号位，空位都以 0 补齐。\n\n使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。\n\n如果移位的位数超过数值所占有的位数会怎样？\n当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余(%)** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作(32%32=0)，左移/右移 42 位相当于左移/右移 10 位(42%32=10)。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。\n\n### 基本数据类型/包装类型 及区别\n**8种基本数据类型**\n- 6 种数字类型： \n  - 4 种整数型：`byte`、`short`、`int`、`long`\n  - 2 种浮点型：`float`、`double`\n- 1 种字符类型：`char`\n- 1 种布尔型：`boolean`\n\n> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 \n> `char a = 'h'`，`char`： 单引号，`String a = \"hello\"`，`String`： 双引号。\n\n**8种包装类型** \n`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n**区别**\n- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。\n- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 `static` 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。\n- 占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。\n- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。\n- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。\n\n### 包装类的缓存机制\nJava 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。\n\n### 什么是自动拆装箱\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n- 装箱：将基本类型用它们对应的引用类型包装起来；\n- 拆箱：将包装类型转换为基本数据类型；\n\n从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。\n\n### 如何解决浮点数运算的精度丢失问题\n\n无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 `BigDecimal` 来做的。\n\n### 局部变量/成员变量/静态变量\n\n- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\n- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\n- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 `final` 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。\n\n静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。\n\n### 重载和重写\n- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\n  - 构造方法无法被重写\n\n### 面向对象和面向过程区别\n两者的主要区别在于解决问题的方式不同：\n- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\n- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\n\n另外，面向对象开发的程序一般更易维护、易复用、易扩展。\n\n### 接口和抽象类区别\n共同点： 都不能被实例化\nhttps://learn.skyofit.com/archives/351\n**区别**\n- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。\n- 抽象类可以有构造方法，接口不能有构造方法。\n- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。\n- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。\n- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。\n- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。\n\n### 堆和栈的区别\nhttps://blog.csdn.net/qq_44944221/article/details/126692973\n- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；\n- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；\n\n区别：\n- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；\n- 共享性不同：栈是线程私有，而堆是线程共享；\n- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；\n- 空间大小不同：堆空间大小远远大于栈的内存空间。\n\n### 深拷贝/浅拷贝/引用拷贝\n- 深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。\n- 浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n- 引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？\n\n### Object 类\nObject 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：\n```java\n//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\npublic final native Class<?> getClass()\n\n//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\npublic native int hashCode()\n\n//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\npublic boolean equals(Object obj)\n\n//native 方法，用于创建并返回当前对象的一份拷贝。\nprotected native Object clone() throws CloneNotSupportedException\n\n//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\npublic String toString()\n\n//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable { }\n```\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n  - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n  - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 形参&实参\n- 形参(形式参数，Parameters)：用于定义函数/方法，接收实参，不需要有确定的值。\n- 实参(实际参数，Arguments)：用于传递给函数/方法的参数，必须有确定的值。\n\n### 值传递&引用传递\n- 值传递：方法接收的是实参值的拷贝，会创建副本。\n- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。\n\nJava 中只有值传递，C++ 中有值传递和引用传递。\n\n### ==和equals()区别\n- `==` 可以用来比较基本数据类型和引用数据类型\n  - 基本数据类型：比较的是值是否相等\n  - 引用数据类型：比较的是引用地址是否相等\n  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。\n- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。\n  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。\n  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。\n\n### hashCode()和equal()\n`hashCode()` 的作用是获取哈希码(`int` 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n\n`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。\n- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等(**哈希碰撞**)。\n- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。\n- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。\n\n**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**\n因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。\n\n### String/StringBuffer/StringBuilder\n- `String` ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。\n- `StringBuffer` ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。\n- `StringBuilder` ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。\n\n- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。\n- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。\n- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n** `String` 为什么不可变？**\n- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。\n- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。\n\n### 字符串拼接使用+还是StringBuilder？\nJava中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。\n\n### String.equals()/Object.equals()\n`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。\n\n### 字符串常量池\n**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n\n### 异常\n异常的共同祖先是 `Throwable` 类，其有两个重要的子类：\n`Error`： 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。\n`Exception`： 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。\n\n### Checked/Unchecked Exception\n- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。\n  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。\n- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。\n  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。\n\n### try-catch-finally\n`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。\n`catch`：用于处理 `try` 捕获到的异常。\n`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。\n\n> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。\n\n### 泛型\n- 使用泛型参数，可以增强代码的可读性以及稳定性。\n- 泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。\n\n### 反射\n反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。\n\n- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n\n### 注解\n注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。\n\n### 序列化/反序列化\n如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n- 序列化：将数据结构或对象转换成二进制字节流的过程\n- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\n\n序列化和反序列化常见应用场景：\n- 对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；\n- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；\n- 将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；\n- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。\n\n### 语法糖\n语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。\n\nJava 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。\n\n## Java集合\n\n### List/Set/Queue/Map区别\n- List： 存储的元素是有序的、可重复的。\n- Set： 存储的元素不可重复的。\n- Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\n- Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n### 如何选用集合?\n主要根据集合的特点来选择合适的集合。如：\n- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。\n- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。\n\n### 为什么要使用集合？\n在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\n\n### ArrayList和Array区别\n`ArrayList` 内部基于动态数组实现，比 `Array`(静态数组) 更加灵活：\n- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。\n- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。\n- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。\n- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。\n- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。\n\n> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。\n\n### ArrayList和LinkedList区别\n- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。\n  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。\n  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。\n- 二者都是线程不安全的。\n- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。\n- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。\n\n> 项目中一般不会使用 `LinkedList`。\n\n### ArrayList和LinkedList插入/删除效率\n`ArrayList`\n- 头部插入/删除：O(n), 需要移动元素。\n- 指定位置插入/删除：O(n), 需要移动元素。\n- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\n`LinkedList`\n- 头部插入/删除：O(1), 只需改变指针指向。\n- 尾部插入/删除：O(1), 只需改变指针指向。\n- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。\n\n### CopyOnWriteArrayList\n`CopyOnWriteArrayList` 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 `Copy-On-Write(COW)`的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：\n- **读多写少**：大部分操作都是读取数据，写操作相对较少。\n- **不要求实时性**：因为写操作需要创建数组副本，可能会有短暂的延迟。\n\n`ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。\n\n**优点**\n- **线程安全**：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。\n- **简化并发控制**：不需要显式的同步块或锁定机制。\n- **迭代器安全**：迭代器不会抛出 `ConcurrentModificationException`，因为迭代时是基于快照的。\n\n**缺点**\n- **内存开销大**：每次写操作都会创建数组副本，可能会占用较多的内存。\n- **写操作开销大**：由于需要复制整个数组，写操作的时间复杂度为 O(n)。\n- **读取旧数据**：在高并发场景下，可能会读取到旧的数据。\n\n**适用场景**\n- 配置类数据：如系统配置参数、常量集合等。\n- 事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。\n\n**不适用场景**\n- 高并发写操作：如果有大量的写操作，那么 `CopyOnWriteArrayList` 的性能会变差。\n- 实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。\n\n**结论**\n`CopyOnWriteArrayList` 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 `ConcurrentHashMap` 或 `ConcurrentLinkedQueue`。\n\n### HashSet/LinkedHashSet/TreeSet\n- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。\n- 主要区别在于底层数据结构不同。\n  - `HashSet` 底层是哈希表(`HashMap`)。\n  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。\n  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。\n\n### Map(重要)\n### HashMap/HashTable区别\n- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。\n- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。\n- `HashTable`中有锁，所以效率比 `HashMap` 低。\n- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。\n- 初始容量大小和每次扩充容量大小的不同： \n  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。\n  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\n  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。\n\n> `HashTable` 已经被淘汰，不建议使用。\n> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`\n\n### HashMap长度为什么是2的幂次方\nkey经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。\n\n“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作(也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。\n\n### HashMap/TreeMap区别\n- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。\n- `HashMap` 是无序的，`TreeMap` 是有序的。\n- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。\n- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。\n\n相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\n\n### HashSet如何检查重复\n把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。\n\n在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。\n\n### HashMap底层实现\n**JDK1.8 之前**\n底层是数组和链表。哈希冲突使用“拉链法”解决。\n\n`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。\n\n- 扰动函数 `hash()` 可以减少碰撞。\n- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。\n\n**JDK1.8 之后**\n底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。\n\n- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。\n- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。\n\n### HashMap多线程扩容死循环问题\nJDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\n\n为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。\n\n> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。\n\n### HashMap为什么线程不安全\n- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。\n- JDK1.7 和 JDK 1.8 都存在数据丢失问题。\n\n**数据丢失**\n在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。\n> 例子：\n> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。\n> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\n> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\n\n### 遍历HashMap\n七种\n```java\nHashMap<Integer, String> map = new HashMap<>();\n// ForEach EntrySet\nfor (Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// ForEach KeySet\nfor (Integer key : map.keySet()) {\n    System.out.println(key + \":\" + map.get(key));\n}\n// 迭代器EntrySet\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry<Integer, String> entry = iterator.next();\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// 迭代器KeySet\nIterator<Integer> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    Integer key = iterator.next();\n    System.out.println(key + \":\" + map.get(key));\n}\n// Lambda\nmap.forEach((key, value) -> {\n    System.out.println(key);\n    System.out.println(value);\n});\n// Streams API 单线程\nmap.entrySet().stream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n// Streams API 多线程\nmap.entrySet().parallelStream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n```\n\n### ConcurrentHashMap/Hashtable区别\n- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。\n- 实现线程安全的方式：\n  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。\n  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - `Hashtable`(同一把锁) ：使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。\n\n### ConcurrentHashMap底层\n\nJDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。\n\n`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。\n\nJDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。\n\n\n### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\n- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。\n- Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。\n- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。\n\n### ConcurrentHashMap能保证复合操作的原子性吗？\n- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。\n- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。\n\n### 什么是LinkedHashMap\n继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性：\n- 支持遍历时会按照插入顺序有序进行迭代\n- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。\n\n> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。\n\n### LinkedHashMap如何按照访问顺序迭代元素？\n`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。\n\n### 如何实现LRU缓存\n- `accessOrder` = `true` \n- 继承`LinkedHashMap`\n- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。\n```java\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n```\n### LinkedHashMap和HashMap的区别\n- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。\n- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。\n\n### Queue/Deque区别\n- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。\n- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。\n\n### ArrayDeque/LinkedList区别\n- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。\n- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。\n- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。\n\n从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。\n\n### PriorityQueue\nPriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\n- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\n- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。\n- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。\n\n> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。\n\n### BlockingQueue及其实现类\n`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。\n\n**实现类**\n- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。\n- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。\n- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。\n- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。\n- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n### ArrayBlockingQueue\n- `put()`、`take()`：插入和删除元素时，如果队列已满或者为空，会阻塞等待。\n- `offer()`、`poll()`：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 `false` 或者 `null`。\n- 并发控制采用可重入锁 `ReentrantLock` 保证线程安全，插入/读取操作都需获取到锁才能进行，且支持公平/非公平两种方式的锁访问机制，默认是非公平锁。\n\n### ArrayBlockingQueue实现原理\n- `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。\n- 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。\n- 通过 `Condition` 接口实现线程间的等待和唤醒操作。\n\n线程间的等待和唤醒具体的实现：\n- 当队列已满时，生产者线程会调用 `notFull.await()` 方法让生产者进行等待，等待队列非满时插入(非满条件)。\n- 当队列为空时，消费者线程会调用 `notEmpty.await()`方法让消费者进行等待，等待队列非空时消费(非空条件)。\n- 当有新的元素被添加时，生产者线程会调用 `notEmpty.signal()`方法唤醒正在等待消费的消费者线程。\n- 当队列中有元素被取出时，消费者线程会调用 `notFull.signal()`方法唤醒正在等待插入元素的生产者线程。\n\n### ArrayBlockingQueue/LinkedBlockingQueue区别\n二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：\n- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。\n- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。\n- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。\n- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。\n\n### DelayQueue底层\n是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n**底层**\n`DelayQueue` 底层用 `PriorityQueue` 存储元素，`PriorityQueue` 采用**二叉小顶堆**的思想确保值小的元素排在最前面，使得 `DelayQueue` 对于延迟任务优先级的管理非常方便。同时 `DelayQueue` 为了保证线程安全还用到了可重入锁 `ReentrantLock`,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 `Condition`接口，通过 `Condition` 的 `await` 和 `signal` 方法完成多线程之间的等待唤醒。\n\n> ```java\n> //可重入锁，实现线程安全的关键\n> private final transient ReentrantLock lock = new ReentrantLock();\n> //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列\n> private final PriorityQueue<E> q = new PriorityQueue<E>();\n> //指向准备执行优先级最高的线程\n> private Thread leader = null;\n> //实现多线程之间等待唤醒的交互\n> private final Condition available = lock.newCondition();\n> ```\n> `leader` ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 `leader` 来管理延迟任务，只有 `leader` 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 `leader` 线程执行完手头的延迟任务后唤醒它。\n> `available` ： 等待唤醒操作的交互是通过 `available` 实现的，假如一个线程尝试在空的 `DelayQueue` 获取任务时，`available` 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 `available` 的 `signal` 方法将其唤醒。\n\n\n### DelayQueue是否线程安全？\n`DelayQueue`是线程安全的，它通过 `ReentrantLock` 实现了互斥访问和 `Condition` 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。\n\n### DelayQueue使用场景\n通常用于实现定时任务调度和缓存过期删除等场景。\n- 在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 `DelayQueue` 中，`DelayQueue` 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。\n- 缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 `key` 封装成一个延迟的删除任务，并将其添加到 `DelayQueue` 中，当数据过期时，拿到这个任务的 `key`，将这个 `key` 从内存中移除。\n\n### DelayQueue中Delayed接口的作用是什么？\n`DelayQueue` 中存放的元素必须实现 `Delayed` 接口，并且需要重写 `getDelay()`方法。`Delayed`接口定义了元素的剩余延迟时间(`getDelay()`)和元素之间的比较规则(继承 `Comparable` 接口),否则 `DelayQueue` 无法得知当前任务剩余时长和任务优先级的比较。\n\n### DelayQueue/Timer/TimerTask区别\n都可以用于实现定时任务调度，但实现方式不同。\n- `DelayQueue` 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；\n- `Timer/TimerTask` 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。\n- `DelayQueue` 支持动态添加/移除任务，`Timer/TimerTask` 只能在创建时指定任务。\n\n\n## Java并发\n\n### 进程/线程/协程\nhttps://blog.csdn.net/m0_60505735/article/details/131047046\nhttps://blog.csdn.net/weixin_49199646/article/details/109210547\n- 进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。\n- 线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n- 协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。\n\n**进程与线程的区别**\n- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。\n- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。\n- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。\n\n**进程与线程的联系**\n一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。\n\n*进程与线程的选择**\n- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；\n- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；\n- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程\n- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。\n\n综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。\n\n### Java线程和操作系统线程有何区别\n现在的 Java 线程的本质其实就是操作系统的线程。\n\n- JDK1.2之前Java线程基于绿色线程(`Green Threads`)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。\n- JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n\n线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。\n\n在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。\n\n### 程序计数器为啥是私有的\n程序计数器主要有下面两个作用：\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n- 如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n\n### 虚拟机栈和本地方法栈为啥是私有的\n- 虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n\n### 一句话简单了解堆和方法区\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n### 如何创建线程\n- 继承`Thread`类并重写`run()`方法\n- 实现`Runnable`接口并重写`run()`方法\n- 实现`Callable`接口并重写`call()`方法\n- 使用线程池`ThreadPoolExecutor`创建线程\n- 等等......\n\n其实只有一种方式可以创建线程，那就是通过 `new Thread().start()` 创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。\n\n### 线程的生命周期和状态\nJava 线程 6 种状态：\n`NEW`： 初始状态，线程被创建出来但没有被调用 `start()` 。\n`RUNNABLE`： 运行状态，线程被调用了 `start()`等待运行的状态。\n`BLOCKED`：阻塞状态，需要等待锁释放。\n`WAITING`：线程执行`wait()`方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。\n`TIME_WAITING`：超时等待状态，调用`sleep(long millis)`可以在指定的时间后自行返回而不是像 `WAITING` 那样一直等待。\n`TERMINATED`：执行完`run()`方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n### 线程上下文切换\n线程在执行过程中会有自己的运行条件和状态(也称**上下文**)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。\n- 时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。\n- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\n\n线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\n\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\n\n### Thread.sleep()方法和Object.wait()方法对比\n共同点：两者都可以暂停线程的执行。\n区别：\n- `sleep()` 方法没有释放锁，`wait()` 方法释放锁 。\n- `sleep()`通常被用于暂停执行，`wait()` 通常被用于线程间交互/通信。\n- `wait()`方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()`方法。`sleep()`方法执行完成后，线程会自动苏醒(或者也可以使用`wait(long timeout)`超时后线程会自动苏醒)。\n- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。\n\n### 锁的基本概念\nJava 中，每个对象都有一个与之关联的监视器(`monitor`)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。\n\n### 为什么wait()方法不定义在Thread中\n- 锁是对象级别的，每个对象都有一把锁。\n- `wait()` 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。\n\n### 为什么sleep()方法定义在Thread中\n- `sleep()` 是线程控制方法，作用对象是线程本身。\n- 线程暂停执行，不涉及到对象类，也不需要获得对象锁。\n\n### sleep()如何控制当前线程沉睡\n调用 `Thread.sleep()` 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。\n\n### 可以直接调用Thread类的run方法吗\n可以但不建议。`new` 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 `main` 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。\n\n### 并发/并行区别\n- 并发：两个及两个以上的作业在同一 **时间段** 内执行。\n- 并行：两个及两个以上的作业在同一 **时刻** 执行。\n\n### 同步/异步区别\n- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。\n- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。\n\n### 为什么要使用多线程\n- 线程切换和调度的成本远远小于进程。\n- 单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。\n- 多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。\n- 并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。\n\n### 使用多线程风险\n- 线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。\n- 死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。\n- 内存泄漏：线程未正确释放资源，导致内存泄漏。\n- 上下文切换：线程频繁切换，会增加系统开销。\n- ...\n\n### 如何理解线程安全和不安全\n线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性** 和**一致性** 的描述。\n- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。\n- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。\n\n### 单核CPU上运行多个线程效率一定会高吗\n如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。\n如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。\n\n### 死锁\n死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\n> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n产生死锁的四个必要条件：\n- 互斥条件：该资源任意一个时刻只由一个线程占用。\n- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n- 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n### 如何检测死锁\n- 一般死锁可能会导致 CPU 使用率飙升，线程处于 `BLOCKED` 状态，可以通过监控工具查看。\n- jConsole： 可以检测死锁，查看线程的状态。\n- jstack： 如有死锁，会输出`Found one Java-level deadlock: `线程的状态信息\n\n### 如何预防和避免死锁\n破坏死锁的产生的必要条件：\n- 破坏请求与保持条件：一次性申请所有的资源。\n- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n避免死锁就是在资源分配时，借助于算法(比如**银行家算法** )对资源分配进行计算评估，使其进入安全状态。\n\n> 安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\n\n### Java内存模型JMM\nJMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。\n\n### 为什么需要Java内存模型\n- Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\n- JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。\n- 对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 `volatile`、`synchronized`、各种 `Lock`)即可开发出并发安全的程序。\n\n### Java内存区域和Java内存模型有什么区别\n- Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。\n- Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。\n\n### JMM是如何抽象线程和主内存之间的关系\nJava内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。\n\n### 主内存与工作内存\n- 主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。\n- 工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。\n\n### 并发编程三大特性\n可见性、原子性和有序性\n- 可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、`volatile`关键字、`synchronized`块等手段来实现可见性。\n- 原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。\n- 有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的`happens-before`规则，确保代码的执行顺序对多线程环境是可预测的。\n\nJMM通过上面三种属性来确保线程之间的内存一致性。\n\n### 如何保证变量的可见性(volatile)\n`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n### 如何禁止指令重排序\n`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 `volatile` ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\n\n### volatile可以保证原子性\n`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。\n\n### 乐观锁/悲观锁\n- 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n  - `synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n  - 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。\n  - 悲观锁可能会存在死锁问题。\n  - 通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。\n- 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。\n  - 具体方法可以使用版本号机制或 CAS 算法，`AtomicInteger`、`LongAdder`等都是乐观锁的实现。\n  - 高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。\n  - 如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n    - `LongAdder`以空间换时间的方式就解决了大量重试问题。\n  - 通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。\n\n### 如何实现乐观锁\n- 版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。\n- CAS算法：`compare and swap`，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。\n  - V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n\n> 举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V = 1，E=1，N=6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\n\n### CAS算法存在问题\n\n### ABA问题\n变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \"ABA\"问题。\n\nABA问题的解决思路是在变量前面追加上版本号或者时间戳。\n\n**循环时间长开销大**\nCAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。\n\n**只能保证一个共享变量的原子操作**\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用`AtomicReference`。\n\n### synchronized关键字\n`synchronized` 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n### JDK1.6之后synchronized的优化\n在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，`synchronized`引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。\n\n### 锁升级原理了解吗\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n### 如何使用synchronized\n- 修饰实例方法：锁住当前实例对象。\n```java\nsynchronized void method() {\n    //业务代码\n}\n```\n- 修饰静态方法：锁住当前类的 Class 对象。\n```java\nsynchronized static void method() {\n    //业务代码\n}\n```\n- 修饰代码块：锁住括号里面的对象。\n  - `synchronized(object)` 表示进入同步代码库前要获得 给定对象的锁。\n  - `synchronized(类.class)` 表示进入同步代码前要获得 给定 `Class` 的锁\n\n```\nsynchronized(对象) {\n    //业务代码\n}\nsynchronized(类.class) {\n    //业务代码\n}\n```\n\n### synchronized底层原理\n`synchronized` 关键字是通过对象内部的一个叫做监视器锁(`monitor`)来实现的。\n\n- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。\n- `synchronized` 修饰的方法使用 `ACC_SYNCHRONIZED` 标识，JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n两者的本质都是对对象监视器 `monitor` 的获取。\n\n### ReentrantLock\n`ReentrantLock` 是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\n\n`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承抽象类 `AQS(AbstractQueuedSynchronizer，抽象队列同步器)`，添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。\n\n### AQS核心思想\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于`CLH`锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。\n\n以可重入互斥锁 `ReentrantLock` 为例，其内部维护了一个使用`volatile`修饰(保证线程可见性)的`state`变量，用来表示锁的占用状态。`state` 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 `lock()` 方法时，会尝试通过 `tryAcquire()` 方法独占该锁，并让 `state` 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(`CLH` 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(`state` 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 `state` 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\n\n> `CLH`锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 `CLH` 队列锁的一个结点(`Node`)来实现锁的分配。在 `CLH` 队列锁中，一个节点表示一个线程，它保存着线程的引用(`thread`)、 当前节点在队列中的状态(`waitStatus`)、前驱节点(`prev`)、后继节点(`next`)。\n\n### AQS资源共享模式\nAQS 支持两种资源共享方式：独占和共享。\n- `Exclusive`(独占，只有一个线程能执行，如`ReentrantLock`)\n- `Share`(共享，多个线程可同时执行，如`Semaphore/CountDownLatch`)\n\n> 也可以自定义同步器同时实现独占和共享，如`ReentrantReadWriteLock`，读操作时多个线程可以同时进行，写操作时只能一个线程进行。\n\n### Semaphore\n`Semaphore` 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的`state`表示许可数(>=1)，当一个线程调用 `acquire()` 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 `release()` 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。\n\n### 公平锁/非公平锁\n- 公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n- 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n\n### synchronized和ReentrantLock有什么区别？\n两者都是可重入锁\n- `synchronized` 是关键字，是内置的语言实现，`ReentrantLock` 是一个类。\n- `synchronized` 是 JVM 实现的，`ReentrantLock` 是 JDK 实现的(也就是 API 层面，需要 `lock()` 和 `unlock()` 方法配合 `try/finally` 语句块来完成)\n- `ReentrantLock` 比 `synchronized` 增加了一些高级功能：\n  - 等待可中断 ： `ReentrantLock`提供一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()`实现。\n  - 可实现公平锁： `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。通过`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。\n  - 可实现选择性通知(锁可以绑定多个条件)： `synchronized`关键字与`wait()`和`notify()/notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以，但需借助`Condition`接口与`newCondition()`方法。\n\n> 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个`synchronized`修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\n\n### 可中断锁/不可中断锁\n- 可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。`ReentrantLock` 是可中断锁。\n- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 是不可中断锁。\n\n### ReentrantReadWriteLock\n是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n`ReentrantReadWriteLock` 其实是两把锁，一把是 `WriteLock` (写锁)，一把是 `ReadLock`(读锁) 。读锁是**共享锁**，写锁是**独占锁**。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n> 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\n> 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。\n\n### 共享锁/独占锁\n- 共享锁：一把锁可以被多个线程同时获得。\n- 独占锁：一把锁只能被一个线程获得。\n\n### 线程持有读锁还能获取写锁吗\n- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\n- 在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。\n\n### 读锁为什么不能升级为写锁\n- 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。\n- 可能会有死锁问题发生。\n\n### StampedLock\n`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，没有实现 `Lock`或 `ReadWriteLock`接口，而是基于 `CLH` 锁独立实现的。\n\n提供三种访问模式：\n- 写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。\n- 读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。\n- 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比`ReadWriteLock`更好的原因)\n\n### ThreadLocal\n`ThreadLocal` 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n### ThreadLocal原理\n`ThreadLocal` 通过 `ThreadLocalMap` 来实现线程内部的数据存储。`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，每个线程中都有一个 `ThreadLocalMap`，`ThreadLocal` 通过 `get()`、`set()` 方法访问 `ThreadLocalMap`。在一个线程中创造多个`ThreadLocal`对象，这个许多个`ThreadLocal`对象会被放到一个`ThreadLocalMap`中。\n\n> `ThreadLocalMap`可以理解为一个定制化的 `HashMap`，`key` 是 `ThreadLocal` 对象，`value` 是存储的值。\n> 可以存在这种情况： 在线程 1 中创建了两个 `ThreadLocal` 对象，在线程 1 中只有一个 `ThreadLocal` 对象。\n\n### ThreadLocal内存泄漏\n`ThreadLocalMap` 中使用的 `key` 为 `ThreadLocal` 的弱引用，而 `value` 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，`key` 会被清理掉，而 `value` 不会被清理掉。这样一来就会出现 `key` 为 `null` 的 键值对。如果不做任何措施的话，`value` 永远无法被 GC 回收，这个时候就可能会产生内存泄露。\n\n其实`ThreadLocalMap`实现中已经考虑了内存泄漏问题，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 `key` 为 `null` 的记录。不过使用完 `ThreadLocal`方法后最好手动调用`remove()`方法。\n\n> `HashMap` 的 `key` 和 `value` 都是强引用，因此不会存在弱引用导致的内存泄漏问题。\n\n### 线程池\n线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n### 为什么用线程池\n- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n> 在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n### 创建线程池的方式\n- 通过`ThreadPoolExecutor`构造函数来创建 _**(推荐)**_ 。\n- 通过`Executors`工具类来创建 _**(不推荐)**_ 。通过这种方式可以创建出多种类型的线程池\n  - `FixedThreadPool`：固定大小的线程池。\n  - `SingleThreadPool`：只有一个线程的线程池。\n  - `CachedThreadPool`：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。\n  - `ScheduledThreadPool`：定时任务的线程池。\n\n### 为什么不推荐使用内置线程池\n- `FixedThreadPool`，`SingleThreadPool`，`ScheduledThreadPool`：使用的是无界的 `LinkedBlockingQueue`，允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。\n- `CachedThreadPool`：使用同步队列`SynchronousQueue`，允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。\n\n### ThreadPoolExecutor参数\n3 个最重要的参数：\n- `corePoolSize` ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n- `maximumPoolSize` ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n- `workQueue`： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\n其他常见参数 ：\n- `keepAliveTime`：线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。\n- `unit` ： `keepAliveTime` 参数的时间单位。\n- `threadFactory` ：`executor` 创建新线程的时候会用到。\n- `handler` ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。\n\n### 线程池的拒绝策略\n- `AbortPolicy`：直接抛出异常，阻止系统正常工作。\n- `CallerRunsPolicy`：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。\n- `DiscardOldestPolicy`：丢弃最早的未处理的任务请求。\n- `DiscardPolicy`：不处理新任务，直接丢弃掉。\n\n### CallerRunsPolicy策略风险及解决方案\n**风险**\n`CallerRunsPolicy` 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n\n**解决方案**\n1. 使用`CallerRunsPolicy`是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列`BlockingQueue`中，这样在内存允许的情况下，可以增加阻塞队列`BlockingQueue`的大小以容纳更多的任务，同时调整线程池的`maximumPoolSize` (最大线程数)参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。\n2. 使用`ThreadPoolExecutor`的`setRejectedExecutionHandler`方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 `Redis`缓存任务。\n\n### 线程池常用阻塞队列\n- `LinkedBlockingQueue`：基于链表的阻塞队列，大小默认为 `Integer.MAX_VALUE`，即任务队列永远不会放满。`FixedThreadPool` 和 `SingleThreadExector`使用，前者只能创建核心线程数的线程，后者只能创建一个线程。\n- `SyncronousQueue`：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\n- `DelayedWorkQueue`：延迟阻塞队列，`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。\n\n### 线程池处理任务流程\n1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。\n3. 如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。\n\n### 线程池中线程异常后销毁还是复用？\n两种情况：\n- 使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；\n- 使用`ExecutorService.submit()`时，异常被封装在`Future`中，线程继续复用。\n\n### 如何设定线程池大小\n- CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。\n- I/O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I/O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。\n\n### 如何设计一个根据任务优先级执行的线程池\n- 使用`PriorityBlockingQueue`作为任务队列，队列中的任务按照优先级顺序执行。\n- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。\n\n这样还存在一些问题：\n- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。\n  - 解决方法：继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 `false 。\n- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。\n  - 解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。\n\n### 异步调用Future类\n\n`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n`Future`类是一个泛型接口，主要包含下面几个方法：\n```\n// V 代表了Future执行的任务返回值的类型\npublic interface Future<V> {\n    // 取消任务执行，成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 判断任务是否被取消\n    boolean isCancelled();\n    // 判断任务是否已经执行完成\n    boolean isDone();\n    // 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n}\n```\n\n### Callable和Future关系\n`Callable` 用于定义可以返回结果的任务，`Future` 用于获取 `Callable` 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。\n- 任务提交与执行：通常通过 `ExecutorService` 提交 `Callable` 任务，`submit` 方法返回一个 `Future` 对象。\n- 异步结果获取：`Future` 对象可以用来获取 `Callable` 任务的返回结果或处理异常。\n\n### CompletableFuture类有什么用？\n`CompletableFuture` 类是 Java 8 中引入的一个增强版 `Future`，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 `Future` 相比，`CompletableFuture` 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。\n\n### 虚拟线程\n虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\n\n虚拟线程(`Virtual Thread`)是 JDK 而不是操作系统实现的轻量级线程(`Lightweight Process，LWP`)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n\n在没有虚拟线程之前，JVM使用的是**平台线程**，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。\n\nJVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。\n\n**优点**\n- 非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。\n- 简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。\n- 减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。\n\n**缺点**\n不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。\n依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。\n\n## IO\n\nIO(`Input/Output`)即输入/输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。\n\nIO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\n- `InputStream/Reader`： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- `OutputStream/Writer`： 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n### Java为什么要分字节流和字符流\nJava 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。\n- 字符流自动处理字符编码问题，非常适合文本数据；\n- 字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。\n\n### 字节流和字符流区别\n- 字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。\n- 字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。\n- 字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。\n\n### IO设计模式总结\n- 装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。\n- 适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\n- 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n- 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。\n\n### 装饰器模式和适配器模式区别\n- 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n- 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n\n### 3种常见的IO模型\n- BIO(`Blocking IO`)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n  - 优点：编程简单，代码易于理解。\n  - 缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。\n- NIO(`Non-blocking IO`)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。\n  - 优点：单线程可以处理多个连接，提高并发性能。\n  - 缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n- AIO(`Asynchronous IO`)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。\n  - 优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。\n  - 缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。\n\n\n\n\n## JVM\n### 内存区域\nJava内存区域通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。\n\n线程私有的内存区域包括：\n- **程序计数器**：\n  - 这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。\n  - 如果正在执行的是本地方法，这个计数器是未指定值(undefined)。\n- **Java虚拟机栈**：\n  - Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。\n  - 栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。\n- **本地方法栈**：\n  - 本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。\n  - 一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。\n\n线程共享的内存区域包括：\n- **堆**：\n  - Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。\n  - 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。\n  - 堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。\n    - JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。\n- **方法区**：\n  - 方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n  - 方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。\n- **运行时常量池**：\n  - 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。\n  - JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。\n\n本地内存：\n- 直接内存：\n  - 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。\n  - JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。\n  - JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。\n\n\n**内存模型与内存管理**\n- **内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。\n- **垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。\n\n**总结**\nJava内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。\n\n### 对象的创建过程(5步)\n1. 类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n2. 分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n3. 初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n5. 执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 对象的内存布局\n对象在内存中的布局可以分为 3 块区域： \n- 对象头(`Header`)： \n  - 标记字段(`Mark Word`)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。\n  - 类型指针(`Klass Word`)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n- 实例数据(`Instance Data`)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n- 对齐填充(`Padding`)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。\n\n### 对象的访问定位\n建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。\n- 句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n- 直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n### 垃圾回收机制\n**垃圾回收机制定义**\n垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。\n\n**堆空间结构**\n堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。\n\n**内存分配和回收原则**\n- 对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。\n- 大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。\n- 长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。\n\n垃圾回收的基本步骤分两步：\n- 查找内存中不再使用的对象(GC判断策略)\n- 释放这些对象占用的内存(GC收集算法)\n\n**死亡对象/GC判断策略**\n- 引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。\n    - 循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n- 可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。\n    - 这些对象可以用作 GC Roots： \n      - 虚拟机栈(栈帧中的局部变量表)中引用的对象\n      - 本地方法栈(Native 方法)中引用的对象\n      - 方法区中类静态属性引用的对象\n      - 方法区中常量引用的对象\n      - 所有被同步锁持有的对象\n      - JNI(Java Native Interface)引用的对象\n\n> 对象被标记为不可达，就代表一定会被回收吗？\n> 不一定。真正宣告一个对象死亡至少要经过两次标记过程。\n\n**垃圾回收算法**\n- 标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。\n  - 存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。\n- 复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。\n  - 存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。\n- 标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。\n  - 问题：整理的过程效率也不高。\n- 分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。\n\n**垃圾回收器**\n默认收集器：\nJDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)\nJDK 9 ~ JDK20： G1(Garbage-First)收集器\n\n- Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( \"Stop The World\" )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。\n- ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。\n- Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。\n- Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。\n- Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。\n- CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。\n- G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。\n- ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。\n\n\n> HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\n> - 部分收集 (`Partial GC`)：\n>     - 新生代收集(Minor GC / Young GC)：只对新生代进行垃圾收集；\n>     - 老年代收集(Major GC / Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\n>     - 混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。\n> - 整堆收集 (Full GC)：收集整个 Java 堆和方法区。\n\n### 为什么要进行垃圾回收\n- **防止内存泄漏**：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。\n- **提高开发效率**：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。\n- **系统性能和稳定性**：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。\n\n### 强引用/软引用/弱引用/虚引用\nhttps://blog.csdn.net/u013718071/article/details/134789666\nJava中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。\n- 强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。\n- 软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。\n- 弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。\n- 虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(`ReferenceQueue`)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。\n\n以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。\n\n### 如何判断一个类是无用的\n类需要同时满足下面 3 个条件才能算是 “无用的类”：\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收\n\n### 类的生命周期\n加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。\n\n其中验证、准备、解析 3 部分统称为连接。\n\n### 类加载过程\n分三步：加载、连接(验证、准备、解析)、初始化。\n\n**加载**\n加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。加载主要分下面三步：\n1. 通过全类名获取定义此类的二进制字节流。\n2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。\n\n> 加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。\n\n**验证**\n连接的第一步，确保 `Class` 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：\n1. 文件格式验证：验证字节流是否符合 Class 文件格式规范。\n2. 元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。\n   - 如验证类是否有父类\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n   - 如验证函数的参数是否正确\n4. 符号引用验证：确保解析动作能正确执行。\n   - 如验证该类要使用的其他类、方法是否存在。\n\n**准备**\n连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。\n- 进行内存分配的仅包括类变量(被`static`修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\n- 初始值是数据类型的默认值，如 0、null 等。\n\n**解析**\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。\n\n**初始化**\n初始化阶段是执行初始化方法 `<clinit>()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\n\n### 类卸载\n卸载类即该类的 `Class` 对象被 GC。\n\n卸载类需要满足 3 个要求：\n- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。\n- 该类没有在其他任何地方被引用\n- 该类的类加载器的实例已被 GC\n\n在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如`BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。\n\n### 类加载器\n类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 `ClassLoader`。数组类不是通过 `ClassLoader` 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。\n\n> 类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。\n\nJVM内置三个重要的类加载器：\n`BootstrapClassLoader`(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 `null`，并且没有父级，主要用来加载 JDK 内部的核心类库。\n`ExtensionClassLoader`(扩展类加载器)：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。\n`AppClassLoader`(应用程序类加载器)：面向用户的加载器，负责加载当前应用 `classpath` 下的所有 jar 包和类。\n\n### 双亲委派模型\n双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。\n\n**优点**\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。\n\n如果需要打破双亲委派模型，需要自定义类加载器，并重写 `loadClass` 方法。\n\n\n## 面经\n\n\n","source":"_posts/Java后端面经.md","raw":"---\ntitle: Java后端面经\ntags:\n  - Java\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: Java后端面经\nabbrlink: 17766\ndate: 2024-05-27 19:58:53\nupdated: 2024-06-13 19:22:23\ntop_img: https://s2.loli.net/2024/05/27/ytcdAHzliRquNM2.png\ncomments:\ncover: https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## 简历相关\n\n### 自我介绍\n\n面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。\n\n我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。\n\n然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！\n\n### 专业技能\n\n\n\n\n### Casbin明日之星实习\n\n1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。\n\n2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。\n\n3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。\n\n### 中科院开源之夏项目\n\n**简介**\nCasdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。\n\n**项目诉求**\n1. 对微信第三方登录的移动端支持\n    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。\n\n2. 对flutter、react-native、unity等sdk的开发及功能的增强\n    - 对flutter-sdk的增强如第一点\n\n3. 临时加上的开发casdoor-app诉求，对标Google Authenticator\n\n**技术细节**\n1. 在flutter-sdk中通过截取`session`中的`url`和`callbackURLscheme`判断其中是否有\"weixin\"字段，如果有，则进行微信第三方原生授权登录；\n\n    - 使用`WKWebView`替换原本的`ASWebAuthenticationSession`，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；\n    - 使用rb脚本文件自动化配置微信SDK导入后xcode中`xcodeproj`文件的相关配置；\n\n    - 接入`xcframework`的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；\n\n接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置`universal Link`，需付费几百美元，所以最终代码并未实际测试。\n\n2. 分为两部分\n    1. casdoor-unity-example\n        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；\n        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；\n        - 在casdoor服务端配置好应用的`clientCode`和`clientSecret`后，在Unity3D中向服务端发送认证请求(`cilentCode`等)，解析返回的`token`，就可以得到用户信息，也可以使用`session`保存`token`等信息。\n        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。\n    2. casdoor-react-native-sdk、example\n        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；\n        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。\n        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 `code_challenge` 和 `code_verifier` 。\n3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。\n    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。\n    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。\n\n> SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。\n\n**总结**\n参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。\n\n### 单点登录SSO原理\n单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。\n\n在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。\n\n流程：\n1. 用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的`session`里面，浏览器也会写入SSO域下的`cookie`。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到`session`中，并设置app域下的`cookie`，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。\n2. 此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到`session`，并在app2的域下写入一个`cookie`。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的`session`不共享，也没有任何问题。\n\nSSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，\n\n### OAuth 2.0原理\nhttps://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\n\nOAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。\n\n定义了4种角色：\n\n- 用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。\n- 应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。\n- 资源服务器：资源服务器托管受保护的用户帐户的资源。\n- 授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。\n\n步骤：\n1. 应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。\n2. 如果用户授权该请求，应用程序会收到授权准许(`Authorization Grant`)。\n3. 应用程序通过提供其自身的身份验证和授权准许(`Authorization Grant`)来向授权服务器 (API) 请求访问令牌(`access_token`)。\n4. 如果应用程序身份通过验证且授权准许(`Authorization Grant`)有效，则授权服务器(API)向应用程序颁发访问令牌(`access_token`)。授权完成。\n5. 应用程序从资源服务器(API)请求资源并提供访问令牌(`access_token`)进行身份验证。\n6. 如果访问令牌(`access_token`)有效，则资源服务器 (API) 向应用程序提供资源。\n\n授权准许(`Authorization Grant`)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：\n\n1. 授权码(`Authorization Code`)：与服务器端应用程序一起使用。\n2. 客户端凭证(`Client Credentials`)：与具有 API 访问权限的应用程序一起使用。\n3. 设备代码(`Device Code`)：用于缺少浏览器或有输入限制的设备。\n\n### Casbin Casdoor 介绍\n> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 \n> Casbin 的主要特点包括：\n> 1. **多种访问控制模型支持**：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。\n> 2. **灵活的策略管理**：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。\n> 3. **细粒度的权限控制**：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。\n> 4. **跨语言支持**：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。\n\n> Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。\n> 1. **单点登录(SSO)**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。\n> 2. **用户管理**：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。\n> 3. **权限控制**：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。\n> 4. **开源社区**：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。\n\n### RESTful API\n> RESTful API(`Representational State Transfer API`)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。\n> REST架构原则：\n> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。\n> - 统一接口： 资源：通过URL定位资源(通常是名词，如 `/users` 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： `GET`：获取资源 `POST`：创建资源 `PUT`：更新资源 `DELETE`：删除资源\n> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。\n> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。\n> - 按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。\n>\n> 特点：\n> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 \n> - 标准化操作：利用HTTP动词来描述对资源的操作。 \n> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 \n> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 \n> - 无状态交互：每个请求独立，不依赖于之前的请求。\n> \n> 优点 \n> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 \n> - 性能高：无状态和可缓存性提高了性能。 \n> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 \n> - 灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。\n> \n> 缺点 \n> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。\n> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 \n> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。\n> \n> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。\n\n### 国家电网项目\n\n**简介**\n\n自己导师接的项目，江苏省国家电网智能诊断数据分析平台\n\n**项目诉求**\n\n- 对相应指标进行增删改查\n- 可以导入、导出一些excel表格\n- 对数据进行智能诊断分析\n\n**技术细节**\n\nreact、Antd、Flask、mongodb\n\n\n### 江南布衣实习\n在公司实习期间，我担任网络工程师实习生，主要负责以下工作：\n\n1. **新入职员工设备管理**：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。\n\n2. **离职员工设备回收和资料销毁**：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>\n\n3. **订货会期间设备组装和网络连接**：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。\n\n4. **员工设备报修响应与问题解决**：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。\n\n通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。\n\n> **公司内网**：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。\n> 要使一台电脑接入公司内网，经过以下步骤：\n> \n> 1. **网络配置**：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。\n> 2. **身份验证**：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。\n> 3. **访问内部资源**：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。\n\n### 印象最深的一个项目\n之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。\n\n**亮点**\n1. **异步支持**：\n    - **亮点**：代码中使用了 `AsyncSession` 和 `async with` 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。\n    - **回答**：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。\n\n2. **灵活的过滤机制**：\n    - **亮点**：通过 `Filter` 类和 `filter_query` 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。\n    - **回答**：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。\n\n3. **可扩展性**：\n    - **亮点**：支持自定义 `db_class`，可以根据不同的需求定制存储策略。同时，默认的 `CasbinRule` 类提供了一个通用的实现。\n    - **回答**：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。\n\n4. **事务处理**：\n    - **亮点**：使用了 `_session_scope` 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。\n    - **回答**：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。\n\n**难点**\n1. **异步编程的复杂性**：\n    - **难点**：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。\n    - **回答**：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。\n2. **数据库模型的灵活性与一致性**：\n    - **难点**：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。\n    - **回答**：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。\n3. **复杂的策略更新逻辑**：\n    - **难点**：如 `update_policy` 和 `update_policies` 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。\n    - **回答**：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。\n4. **高效的批量操作**：\n    - **难点**：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。\n    - **回答**：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。\n\n测试方面\n- 适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。\n- 测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。\n\n技术细节\n- 测试框架：说明使用了`unittest`库，并扩展了`IsolatedAsyncioTestCase`来测试异步功能。\n- 测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。\n    - 测试添加一个策略，添加多个策略\n    - 测试删除一个策略，删除多个策略，删除经过过滤的策略\n    - 测试更新一个策略，测试更新多个策略。\n\n\n通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。\n\n## Java基础\n\n### Java和C++的区别\nJava 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：\n- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；\n- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；\n- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；\n- C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。\n\n> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。\n\n### 移位运算符\n`<<`：左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。\n`>>`：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。\n`>>>`：无符号右移，忽略符号位，空位都以 0 补齐。\n\n使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。\n\n如果移位的位数超过数值所占有的位数会怎样？\n当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余(%)** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作(32%32=0)，左移/右移 42 位相当于左移/右移 10 位(42%32=10)。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。\n\n### 基本数据类型/包装类型 及区别\n**8种基本数据类型**\n- 6 种数字类型： \n  - 4 种整数型：`byte`、`short`、`int`、`long`\n  - 2 种浮点型：`float`、`double`\n- 1 种字符类型：`char`\n- 1 种布尔型：`boolean`\n\n> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 \n> `char a = 'h'`，`char`： 单引号，`String a = \"hello\"`，`String`： 双引号。\n\n**8种包装类型** \n`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。\n\n**区别**\n- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。\n- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 `static` 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。\n- 占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。\n- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。\n- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。\n\n### 包装类的缓存机制\nJava 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。\n\n### 什么是自动拆装箱\n```java\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n- 装箱：将基本类型用它们对应的引用类型包装起来；\n- 拆箱：将包装类型转换为基本数据类型；\n\n从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。\n\n### 如何解决浮点数运算的精度丢失问题\n\n无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 `BigDecimal` 来做的。\n\n### 局部变量/成员变量/静态变量\n\n- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\n- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\n- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\n- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 `final` 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。\n\n静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。\n\n### 重载和重写\n- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。\n- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。\n  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。\n  - 构造方法无法被重写\n\n### 面向对象和面向过程区别\n两者的主要区别在于解决问题的方式不同：\n- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。\n- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。\n\n另外，面向对象开发的程序一般更易维护、易复用、易扩展。\n\n### 接口和抽象类区别\n共同点： 都不能被实例化\nhttps://learn.skyofit.com/archives/351\n**区别**\n- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。\n- 抽象类可以有构造方法，接口不能有构造方法。\n- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。\n- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。\n- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。\n- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。\n\n### 堆和栈的区别\nhttps://blog.csdn.net/qq_44944221/article/details/126692973\n- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；\n- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；\n\n区别：\n- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；\n- 共享性不同：栈是线程私有，而堆是线程共享；\n- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；\n- 空间大小不同：堆空间大小远远大于栈的内存空间。\n\n### 深拷贝/浅拷贝/引用拷贝\n- 深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。\n- 浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n- 引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？\n\n### Object 类\nObject 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：\n```java\n//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\npublic final native Class<?> getClass()\n\n//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\npublic native int hashCode()\n\n//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\npublic boolean equals(Object obj)\n\n//native 方法，用于创建并返回当前对象的一份拷贝。\nprotected native Object clone() throws CloneNotSupportedException\n\n//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\npublic String toString()\n\n//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable { }\n```\n\n### 单例模式\n- 饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。\n- 懒汉式：懒汉式单例模式在第一次调用 `getInstance` 方法时创建实例，线程不安全，需要额外处理同步。\n- 线程安全的懒汉式\n  - 同步方法：在 `getInstance` 方法上加 `synchronized` 关键字，保证线程安全，但是效率低。\n  - 双重检查锁定：在 `getInstance` 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。\n- 静态内部类：利用静态内部类来实现懒加载和线程安全。\n- 枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。\n\n\n```java\n// 饿汉式\npublic class Singleton {\n    private static final Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n\n// 懒汉式\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-同步方法\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 线程安全的懒汉式-双重检查锁定\npublic class Singleton {\n    // 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。\n    private volatile static Singleton uniqueInstance;\n    // 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例\n    private Singleton() {\n    }\n    // 双重检查锁定的机制，实现对外提供的获取单例实例的方法。\n    public static Singleton getInstance() {\n        // 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。\n        if (uniqueInstance == null) {\n            // 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁\n            synchronized (Singleton.class) {\n                // 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。\n                // 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n    public static void main(String[] args) {\n        System.out.println(getInstance());\n    }\n\n}\n\n// 静态内部类\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n// 枚举\npublic enum Singleton {\n    // 注意 上面不是 class 是 enum\n    INSTANCE;\n    public void someMethod() {\n        // do something\n    }\n    public static void main(String[] args) {\n        Singelton singleton = Singleton.INSTANCE;\n        singleton.someMethod();\n    }\n}\n```\n\n### 形参&实参\n- 形参(形式参数，Parameters)：用于定义函数/方法，接收实参，不需要有确定的值。\n- 实参(实际参数，Arguments)：用于传递给函数/方法的参数，必须有确定的值。\n\n### 值传递&引用传递\n- 值传递：方法接收的是实参值的拷贝，会创建副本。\n- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。\n\nJava 中只有值传递，C++ 中有值传递和引用传递。\n\n### ==和equals()区别\n- `==` 可以用来比较基本数据类型和引用数据类型\n  - 基本数据类型：比较的是值是否相等\n  - 引用数据类型：比较的是引用地址是否相等\n  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。\n- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。\n  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。\n  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。\n\n### hashCode()和equal()\n`hashCode()` 的作用是获取哈希码(`int` 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。\n\n`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。\n- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等(**哈希碰撞**)。\n- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。\n- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。\n\n**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**\n因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。\n\n### String/StringBuffer/StringBuilder\n- `String` ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。\n- `StringBuffer` ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。\n- `StringBuilder` ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。\n\n- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。\n- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。\n- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n** `String` 为什么不可变？**\n- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。\n- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。\n\n### 字符串拼接使用+还是StringBuilder？\nJava中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。\n\n### String.equals()/Object.equals()\n`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。\n\n### 字符串常量池\n**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\n\n### 异常\n异常的共同祖先是 `Throwable` 类，其有两个重要的子类：\n`Error`： 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。\n`Exception`： 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。\n\n### Checked/Unchecked Exception\n- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。\n  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。\n- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。\n  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。\n\n### try-catch-finally\n`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。\n`catch`：用于处理 `try` 捕获到的异常。\n`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。\n\n> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。\n\n### 泛型\n- 使用泛型参数，可以增强代码的可读性以及稳定性。\n- 泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。\n\n### 反射\n反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。\n\n- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n\n### 注解\n注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。\n\n注解只有被解析之后才会生效，常见的解析方法有两种：\n- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。\n\n### 序列化/反序列化\n如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n- 序列化：将数据结构或对象转换成二进制字节流的过程\n- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程\n\n序列化和反序列化常见应用场景：\n- 对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；\n- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；\n- 将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；\n- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。\n\n### 语法糖\n语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。\n\nJava 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。\n\n## Java集合\n\n### List/Set/Queue/Map区别\n- List： 存储的元素是有序的、可重复的。\n- Set： 存储的元素不可重复的。\n- Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\n- Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n### 如何选用集合?\n主要根据集合的特点来选择合适的集合。如：\n- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。\n- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。\n\n### 为什么要使用集合？\n在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\n\n### ArrayList和Array区别\n`ArrayList` 内部基于动态数组实现，比 `Array`(静态数组) 更加灵活：\n- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。\n- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。\n- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。\n- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。\n- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。\n\n> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。\n\n### ArrayList和LinkedList区别\n- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。\n  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。\n  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。\n- 二者都是线程不安全的。\n- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。\n- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。\n\n> 项目中一般不会使用 `LinkedList`。\n\n### ArrayList和LinkedList插入/删除效率\n`ArrayList`\n- 头部插入/删除：O(n), 需要移动元素。\n- 指定位置插入/删除：O(n), 需要移动元素。\n- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\n`LinkedList`\n- 头部插入/删除：O(1), 只需改变指针指向。\n- 尾部插入/删除：O(1), 只需改变指针指向。\n- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。\n\n### CopyOnWriteArrayList\n`CopyOnWriteArrayList` 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 `Copy-On-Write(COW)`的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：\n- **读多写少**：大部分操作都是读取数据，写操作相对较少。\n- **不要求实时性**：因为写操作需要创建数组副本，可能会有短暂的延迟。\n\n`ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。\n\n**优点**\n- **线程安全**：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。\n- **简化并发控制**：不需要显式的同步块或锁定机制。\n- **迭代器安全**：迭代器不会抛出 `ConcurrentModificationException`，因为迭代时是基于快照的。\n\n**缺点**\n- **内存开销大**：每次写操作都会创建数组副本，可能会占用较多的内存。\n- **写操作开销大**：由于需要复制整个数组，写操作的时间复杂度为 O(n)。\n- **读取旧数据**：在高并发场景下，可能会读取到旧的数据。\n\n**适用场景**\n- 配置类数据：如系统配置参数、常量集合等。\n- 事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。\n\n**不适用场景**\n- 高并发写操作：如果有大量的写操作，那么 `CopyOnWriteArrayList` 的性能会变差。\n- 实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。\n\n**结论**\n`CopyOnWriteArrayList` 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 `ConcurrentHashMap` 或 `ConcurrentLinkedQueue`。\n\n### HashSet/LinkedHashSet/TreeSet\n- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。\n- 主要区别在于底层数据结构不同。\n  - `HashSet` 底层是哈希表(`HashMap`)。\n  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。\n  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\n- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。\n\n### Map(重要)\n### HashMap/HashTable区别\n- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。\n- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。\n- `HashTable`中有锁，所以效率比 `HashMap` 低。\n- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。\n- 初始容量大小和每次扩充容量大小的不同： \n  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。\n  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。\n  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。\n\n> `HashTable` 已经被淘汰，不建议使用。\n> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`\n\n### HashMap长度为什么是2的幂次方\nkey经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。\n\n“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作(也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。\n\n### HashMap/TreeMap区别\n- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。\n- `HashMap` 是无序的，`TreeMap` 是有序的。\n- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。\n- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。\n\n相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\n\n### HashSet如何检查重复\n把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。\n\n在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。\n\n### HashMap底层实现\n**JDK1.8 之前**\n底层是数组和链表。哈希冲突使用“拉链法”解决。\n\n`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。\n\n- 扰动函数 `hash()` 可以减少碰撞。\n- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。\n\n**JDK1.8 之后**\n底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。\n\n- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。\n- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。\n\n### HashMap多线程扩容死循环问题\nJDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\n\n为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。\n\n> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。\n\n### HashMap为什么线程不安全\n- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。\n- JDK1.7 和 JDK 1.8 都存在数据丢失问题。\n\n**数据丢失**\n在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。\n> 例子：\n> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。\n> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\n> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\n\n### 遍历HashMap\n七种\n```java\nHashMap<Integer, String> map = new HashMap<>();\n// ForEach EntrySet\nfor (Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// ForEach KeySet\nfor (Integer key : map.keySet()) {\n    System.out.println(key + \":\" + map.get(key));\n}\n// 迭代器EntrySet\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry<Integer, String> entry = iterator.next();\n    System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// 迭代器KeySet\nIterator<Integer> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    Integer key = iterator.next();\n    System.out.println(key + \":\" + map.get(key));\n}\n// Lambda\nmap.forEach((key, value) -> {\n    System.out.println(key);\n    System.out.println(value);\n});\n// Streams API 单线程\nmap.entrySet().stream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n// Streams API 多线程\nmap.entrySet().parallelStream().forEach(entry -> {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue());\n});\n```\n\n### ConcurrentHashMap/Hashtable区别\n- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。\n- 实现线程安全的方式：\n  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。\n  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - `Hashtable`(同一把锁) ：使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。\n\n### ConcurrentHashMap底层\n\nJDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。\n\n`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。\n\nJDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。\n\n\n### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\n- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。\n- Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。\n- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。\n\n### ConcurrentHashMap能保证复合操作的原子性吗？\n- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。\n- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。\n\n### 什么是LinkedHashMap\n继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性：\n- 支持遍历时会按照插入顺序有序进行迭代\n- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。\n- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。\n\n> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。\n\n### LinkedHashMap如何按照访问顺序迭代元素？\n`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。\n\n### 如何实现LRU缓存\n- `accessOrder` = `true` \n- 继承`LinkedHashMap`\n- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。\n```java\npublic class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 1f, true);\n        this.capacity = capacity;\n    }\n    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n```\n### LinkedHashMap和HashMap的区别\n- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。\n- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。\n\n### Queue/Deque区别\n- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。\n- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。\n\n### ArrayDeque/LinkedList区别\n- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。\n- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。\n- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。\n\n从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。\n\n### PriorityQueue\nPriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\n- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\n- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。\n- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。\n\n> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。\n\n### BlockingQueue及其实现类\n`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。\n\n**实现类**\n- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。\n- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。\n- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。\n- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。\n- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n### ArrayBlockingQueue\n- `put()`、`take()`：插入和删除元素时，如果队列已满或者为空，会阻塞等待。\n- `offer()`、`poll()`：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 `false` 或者 `null`。\n- 并发控制采用可重入锁 `ReentrantLock` 保证线程安全，插入/读取操作都需获取到锁才能进行，且支持公平/非公平两种方式的锁访问机制，默认是非公平锁。\n\n### ArrayBlockingQueue实现原理\n- `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。\n- 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。\n- 通过 `Condition` 接口实现线程间的等待和唤醒操作。\n\n线程间的等待和唤醒具体的实现：\n- 当队列已满时，生产者线程会调用 `notFull.await()` 方法让生产者进行等待，等待队列非满时插入(非满条件)。\n- 当队列为空时，消费者线程会调用 `notEmpty.await()`方法让消费者进行等待，等待队列非空时消费(非空条件)。\n- 当有新的元素被添加时，生产者线程会调用 `notEmpty.signal()`方法唤醒正在等待消费的消费者线程。\n- 当队列中有元素被取出时，消费者线程会调用 `notFull.signal()`方法唤醒正在等待插入元素的生产者线程。\n\n### ArrayBlockingQueue/LinkedBlockingQueue区别\n二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：\n- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。\n- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。\n- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。\n- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。\n\n### DelayQueue底层\n是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\n\n**底层**\n`DelayQueue` 底层用 `PriorityQueue` 存储元素，`PriorityQueue` 采用**二叉小顶堆**的思想确保值小的元素排在最前面，使得 `DelayQueue` 对于延迟任务优先级的管理非常方便。同时 `DelayQueue` 为了保证线程安全还用到了可重入锁 `ReentrantLock`,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 `Condition`接口，通过 `Condition` 的 `await` 和 `signal` 方法完成多线程之间的等待唤醒。\n\n> ```java\n> //可重入锁，实现线程安全的关键\n> private final transient ReentrantLock lock = new ReentrantLock();\n> //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列\n> private final PriorityQueue<E> q = new PriorityQueue<E>();\n> //指向准备执行优先级最高的线程\n> private Thread leader = null;\n> //实现多线程之间等待唤醒的交互\n> private final Condition available = lock.newCondition();\n> ```\n> `leader` ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 `leader` 来管理延迟任务，只有 `leader` 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 `leader` 线程执行完手头的延迟任务后唤醒它。\n> `available` ： 等待唤醒操作的交互是通过 `available` 实现的，假如一个线程尝试在空的 `DelayQueue` 获取任务时，`available` 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 `available` 的 `signal` 方法将其唤醒。\n\n\n### DelayQueue是否线程安全？\n`DelayQueue`是线程安全的，它通过 `ReentrantLock` 实现了互斥访问和 `Condition` 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。\n\n### DelayQueue使用场景\n通常用于实现定时任务调度和缓存过期删除等场景。\n- 在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 `DelayQueue` 中，`DelayQueue` 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。\n- 缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 `key` 封装成一个延迟的删除任务，并将其添加到 `DelayQueue` 中，当数据过期时，拿到这个任务的 `key`，将这个 `key` 从内存中移除。\n\n### DelayQueue中Delayed接口的作用是什么？\n`DelayQueue` 中存放的元素必须实现 `Delayed` 接口，并且需要重写 `getDelay()`方法。`Delayed`接口定义了元素的剩余延迟时间(`getDelay()`)和元素之间的比较规则(继承 `Comparable` 接口),否则 `DelayQueue` 无法得知当前任务剩余时长和任务优先级的比较。\n\n### DelayQueue/Timer/TimerTask区别\n都可以用于实现定时任务调度，但实现方式不同。\n- `DelayQueue` 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；\n- `Timer/TimerTask` 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。\n- `DelayQueue` 支持动态添加/移除任务，`Timer/TimerTask` 只能在创建时指定任务。\n\n\n## Java并发\n\n### 进程/线程/协程\nhttps://blog.csdn.net/m0_60505735/article/details/131047046\nhttps://blog.csdn.net/weixin_49199646/article/details/109210547\n- 进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。\n- 线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n- 协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。\n\n**进程与线程的区别**\n- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。\n- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。\n- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。\n\n**进程与线程的联系**\n一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。\n\n*进程与线程的选择**\n- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；\n- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；\n- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程\n- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。\n\n综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。\n\n### Java线程和操作系统线程有何区别\n现在的 Java 线程的本质其实就是操作系统的线程。\n\n- JDK1.2之前Java线程基于绿色线程(`Green Threads`)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。\n- JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n\n线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。\n\n在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。\n\n### 程序计数器为啥是私有的\n程序计数器主要有下面两个作用：\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n- 如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n\n### 虚拟机栈和本地方法栈为啥是私有的\n- 虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\n\n### 一句话简单了解堆和方法区\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n### 如何创建线程\n- 继承`Thread`类并重写`run()`方法\n- 实现`Runnable`接口并重写`run()`方法\n- 实现`Callable`接口并重写`call()`方法\n- 使用线程池`ThreadPoolExecutor`创建线程\n- 等等......\n\n其实只有一种方式可以创建线程，那就是通过 `new Thread().start()` 创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。\n\n### 线程的生命周期和状态\nJava 线程 6 种状态：\n`NEW`： 初始状态，线程被创建出来但没有被调用 `start()` 。\n`RUNNABLE`： 运行状态，线程被调用了 `start()`等待运行的状态。\n`BLOCKED`：阻塞状态，需要等待锁释放。\n`WAITING`：线程执行`wait()`方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。\n`TIME_WAITING`：超时等待状态，调用`sleep(long millis)`可以在指定的时间后自行返回而不是像 `WAITING` 那样一直等待。\n`TERMINATED`：执行完`run()`方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n### 线程上下文切换\n线程在执行过程中会有自己的运行条件和状态(也称**上下文**)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。\n- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。\n- 时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。\n- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\n\n线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\n\n上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\n\n### Thread.sleep()方法和Object.wait()方法对比\n共同点：两者都可以暂停线程的执行。\n区别：\n- `sleep()` 方法没有释放锁，`wait()` 方法释放锁 。\n- `sleep()`通常被用于暂停执行，`wait()` 通常被用于线程间交互/通信。\n- `wait()`方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()`方法。`sleep()`方法执行完成后，线程会自动苏醒(或者也可以使用`wait(long timeout)`超时后线程会自动苏醒)。\n- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。\n\n### 锁的基本概念\nJava 中，每个对象都有一个与之关联的监视器(`monitor`)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。\n\n### 为什么wait()方法不定义在Thread中\n- 锁是对象级别的，每个对象都有一把锁。\n- `wait()` 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。\n\n### 为什么sleep()方法定义在Thread中\n- `sleep()` 是线程控制方法，作用对象是线程本身。\n- 线程暂停执行，不涉及到对象类，也不需要获得对象锁。\n\n### sleep()如何控制当前线程沉睡\n调用 `Thread.sleep()` 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。\n\n### 可以直接调用Thread类的run方法吗\n可以但不建议。`new` 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 `main` 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。\n\n### 并发/并行区别\n- 并发：两个及两个以上的作业在同一 **时间段** 内执行。\n- 并行：两个及两个以上的作业在同一 **时刻** 执行。\n\n### 同步/异步区别\n- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。\n- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。\n\n### 为什么要使用多线程\n- 线程切换和调度的成本远远小于进程。\n- 单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。\n- 多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。\n- 并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。\n\n### 使用多线程风险\n- 线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。\n- 死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。\n- 内存泄漏：线程未正确释放资源，导致内存泄漏。\n- 上下文切换：线程频繁切换，会增加系统开销。\n- ...\n\n### 如何理解线程安全和不安全\n线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性** 和**一致性** 的描述。\n- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。\n- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。\n\n### 单核CPU上运行多个线程效率一定会高吗\n如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。\n如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。\n\n### 死锁\n死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\n\n> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n产生死锁的四个必要条件：\n- 互斥条件：该资源任意一个时刻只由一个线程占用。\n- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n- 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n### 如何检测死锁\n- 一般死锁可能会导致 CPU 使用率飙升，线程处于 `BLOCKED` 状态，可以通过监控工具查看。\n- jConsole： 可以检测死锁，查看线程的状态。\n- jstack： 如有死锁，会输出`Found one Java-level deadlock: `线程的状态信息\n\n### 如何预防和避免死锁\n破坏死锁的产生的必要条件：\n- 破坏请求与保持条件：一次性申请所有的资源。\n- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n避免死锁就是在资源分配时，借助于算法(比如**银行家算法** )对资源分配进行计算评估，使其进入安全状态。\n\n> 安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\n\n### Java内存模型JMM\nJMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。\n\n### 为什么需要Java内存模型\n- Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\n- JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。\n- 对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 `volatile`、`synchronized`、各种 `Lock`)即可开发出并发安全的程序。\n\n### Java内存区域和Java内存模型有什么区别\n- Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。\n- Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。\n\n### JMM是如何抽象线程和主内存之间的关系\nJava内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。\n\n### 主内存与工作内存\n- 主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。\n- 工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。\n\n### 并发编程三大特性\n可见性、原子性和有序性\n- 可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、`volatile`关键字、`synchronized`块等手段来实现可见性。\n- 原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。\n- 有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的`happens-before`规则，确保代码的执行顺序对多线程环境是可预测的。\n\nJMM通过上面三种属性来确保线程之间的内存一致性。\n\n### 如何保证变量的可见性(volatile)\n`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n### 如何禁止指令重排序\n`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 `volatile` ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\n\n### volatile可以保证原子性\n`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。\n\n### 乐观锁/悲观锁\n- 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n  - `synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。\n  - 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。\n  - 悲观锁可能会存在死锁问题。\n  - 通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。\n- 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。\n  - 具体方法可以使用版本号机制或 CAS 算法，`AtomicInteger`、`LongAdder`等都是乐观锁的实现。\n  - 高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。\n  - 如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\n    - `LongAdder`以空间换时间的方式就解决了大量重试问题。\n  - 通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。\n\n### 如何实现乐观锁\n- 版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。\n- CAS算法：`compare and swap`，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。\n  - V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\n\n> 举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V = 1，E=1，N=6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\n\n### CAS算法存在问题\n\n### ABA问题\n变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \"ABA\"问题。\n\nABA问题的解决思路是在变量前面追加上版本号或者时间戳。\n\n**循环时间长开销大**\nCAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。\n\n**只能保证一个共享变量的原子操作**\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用`AtomicReference`。\n\n### synchronized关键字\n`synchronized` 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n### JDK1.6之后synchronized的优化\n在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，`synchronized`引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。\n\n### 锁升级原理了解吗\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n### 如何使用synchronized\n- 修饰实例方法：锁住当前实例对象。\n```java\nsynchronized void method() {\n    //业务代码\n}\n```\n- 修饰静态方法：锁住当前类的 Class 对象。\n```java\nsynchronized static void method() {\n    //业务代码\n}\n```\n- 修饰代码块：锁住括号里面的对象。\n  - `synchronized(object)` 表示进入同步代码库前要获得 给定对象的锁。\n  - `synchronized(类.class)` 表示进入同步代码前要获得 给定 `Class` 的锁\n\n```\nsynchronized(对象) {\n    //业务代码\n}\nsynchronized(类.class) {\n    //业务代码\n}\n```\n\n### synchronized底层原理\n`synchronized` 关键字是通过对象内部的一个叫做监视器锁(`monitor`)来实现的。\n\n- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。\n- `synchronized` 修饰的方法使用 `ACC_SYNCHRONIZED` 标识，JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n两者的本质都是对对象监视器 `monitor` 的获取。\n\n### ReentrantLock\n`ReentrantLock` 是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\n\n`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承抽象类 `AQS(AbstractQueuedSynchronizer，抽象队列同步器)`，添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。\n\n### AQS核心思想\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于`CLH`锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。\n\n以可重入互斥锁 `ReentrantLock` 为例，其内部维护了一个使用`volatile`修饰(保证线程可见性)的`state`变量，用来表示锁的占用状态。`state` 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 `lock()` 方法时，会尝试通过 `tryAcquire()` 方法独占该锁，并让 `state` 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(`CLH` 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(`state` 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 `state` 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\n\n> `CLH`锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 `CLH` 队列锁的一个结点(`Node`)来实现锁的分配。在 `CLH` 队列锁中，一个节点表示一个线程，它保存着线程的引用(`thread`)、 当前节点在队列中的状态(`waitStatus`)、前驱节点(`prev`)、后继节点(`next`)。\n\n### AQS资源共享模式\nAQS 支持两种资源共享方式：独占和共享。\n- `Exclusive`(独占，只有一个线程能执行，如`ReentrantLock`)\n- `Share`(共享，多个线程可同时执行，如`Semaphore/CountDownLatch`)\n\n> 也可以自定义同步器同时实现独占和共享，如`ReentrantReadWriteLock`，读操作时多个线程可以同时进行，写操作时只能一个线程进行。\n\n### Semaphore\n`Semaphore` 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的`state`表示许可数(>=1)，当一个线程调用 `acquire()` 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 `release()` 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。\n\n### 公平锁/非公平锁\n- 公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n- 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n\n### synchronized和ReentrantLock有什么区别？\n两者都是可重入锁\n- `synchronized` 是关键字，是内置的语言实现，`ReentrantLock` 是一个类。\n- `synchronized` 是 JVM 实现的，`ReentrantLock` 是 JDK 实现的(也就是 API 层面，需要 `lock()` 和 `unlock()` 方法配合 `try/finally` 语句块来完成)\n- `ReentrantLock` 比 `synchronized` 增加了一些高级功能：\n  - 等待可中断 ： `ReentrantLock`提供一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()`实现。\n  - 可实现公平锁： `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。通过`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。\n  - 可实现选择性通知(锁可以绑定多个条件)： `synchronized`关键字与`wait()`和`notify()/notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以，但需借助`Condition`接口与`newCondition()`方法。\n\n> 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个`synchronized`修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\n\n### 可中断锁/不可中断锁\n- 可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。`ReentrantLock` 是可中断锁。\n- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 是不可中断锁。\n\n### ReentrantReadWriteLock\n是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n`ReentrantReadWriteLock` 其实是两把锁，一把是 `WriteLock` (写锁)，一把是 `ReadLock`(读锁) 。读锁是**共享锁**，写锁是**独占锁**。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n> 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\n> 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。\n\n### 共享锁/独占锁\n- 共享锁：一把锁可以被多个线程同时获得。\n- 独占锁：一把锁只能被一个线程获得。\n\n### 线程持有读锁还能获取写锁吗\n- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\n- 在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。\n\n### 读锁为什么不能升级为写锁\n- 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。\n- 可能会有死锁问题发生。\n\n### StampedLock\n`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，没有实现 `Lock`或 `ReadWriteLock`接口，而是基于 `CLH` 锁独立实现的。\n\n提供三种访问模式：\n- 写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。\n- 读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。\n- 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比`ReadWriteLock`更好的原因)\n\n### ThreadLocal\n`ThreadLocal` 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n### ThreadLocal原理\n`ThreadLocal` 通过 `ThreadLocalMap` 来实现线程内部的数据存储。`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，每个线程中都有一个 `ThreadLocalMap`，`ThreadLocal` 通过 `get()`、`set()` 方法访问 `ThreadLocalMap`。在一个线程中创造多个`ThreadLocal`对象，这个许多个`ThreadLocal`对象会被放到一个`ThreadLocalMap`中。\n\n> `ThreadLocalMap`可以理解为一个定制化的 `HashMap`，`key` 是 `ThreadLocal` 对象，`value` 是存储的值。\n> 可以存在这种情况： 在线程 1 中创建了两个 `ThreadLocal` 对象，在线程 1 中只有一个 `ThreadLocal` 对象。\n\n### ThreadLocal内存泄漏\n`ThreadLocalMap` 中使用的 `key` 为 `ThreadLocal` 的弱引用，而 `value` 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，`key` 会被清理掉，而 `value` 不会被清理掉。这样一来就会出现 `key` 为 `null` 的 键值对。如果不做任何措施的话，`value` 永远无法被 GC 回收，这个时候就可能会产生内存泄露。\n\n其实`ThreadLocalMap`实现中已经考虑了内存泄漏问题，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 `key` 为 `null` 的记录。不过使用完 `ThreadLocal`方法后最好手动调用`remove()`方法。\n\n> `HashMap` 的 `key` 和 `value` 都是强引用，因此不会存在弱引用导致的内存泄漏问题。\n\n### 线程池\n线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n### 为什么用线程池\n- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n> 在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n### 创建线程池的方式\n- 通过`ThreadPoolExecutor`构造函数来创建 _**(推荐)**_ 。\n- 通过`Executors`工具类来创建 _**(不推荐)**_ 。通过这种方式可以创建出多种类型的线程池\n  - `FixedThreadPool`：固定大小的线程池。\n  - `SingleThreadPool`：只有一个线程的线程池。\n  - `CachedThreadPool`：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。\n  - `ScheduledThreadPool`：定时任务的线程池。\n\n### 为什么不推荐使用内置线程池\n- `FixedThreadPool`，`SingleThreadPool`，`ScheduledThreadPool`：使用的是无界的 `LinkedBlockingQueue`，允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。\n- `CachedThreadPool`：使用同步队列`SynchronousQueue`，允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。\n\n### ThreadPoolExecutor参数\n3 个最重要的参数：\n- `corePoolSize` ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n- `maximumPoolSize` ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n- `workQueue`： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\n其他常见参数 ：\n- `keepAliveTime`：线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。\n- `unit` ： `keepAliveTime` 参数的时间单位。\n- `threadFactory` ：`executor` 创建新线程的时候会用到。\n- `handler` ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。\n\n### 线程池的拒绝策略\n- `AbortPolicy`：直接抛出异常，阻止系统正常工作。\n- `CallerRunsPolicy`：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。\n- `DiscardOldestPolicy`：丢弃最早的未处理的任务请求。\n- `DiscardPolicy`：不处理新任务，直接丢弃掉。\n\n### CallerRunsPolicy策略风险及解决方案\n**风险**\n`CallerRunsPolicy` 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n\n**解决方案**\n1. 使用`CallerRunsPolicy`是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列`BlockingQueue`中，这样在内存允许的情况下，可以增加阻塞队列`BlockingQueue`的大小以容纳更多的任务，同时调整线程池的`maximumPoolSize` (最大线程数)参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。\n2. 使用`ThreadPoolExecutor`的`setRejectedExecutionHandler`方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 `Redis`缓存任务。\n\n### 线程池常用阻塞队列\n- `LinkedBlockingQueue`：基于链表的阻塞队列，大小默认为 `Integer.MAX_VALUE`，即任务队列永远不会放满。`FixedThreadPool` 和 `SingleThreadExector`使用，前者只能创建核心线程数的线程，后者只能创建一个线程。\n- `SyncronousQueue`：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\n- `DelayedWorkQueue`：延迟阻塞队列，`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。\n\n### 线程池处理任务流程\n1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。\n3. 如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。\n\n### 线程池中线程异常后销毁还是复用？\n两种情况：\n- 使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；\n- 使用`ExecutorService.submit()`时，异常被封装在`Future`中，线程继续复用。\n\n### 如何设定线程池大小\n- CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。\n- I/O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I/O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。\n\n### 如何设计一个根据任务优先级执行的线程池\n- 使用`PriorityBlockingQueue`作为任务队列，队列中的任务按照优先级顺序执行。\n- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。\n\n这样还存在一些问题：\n- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。\n  - 解决方法：继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 `false 。\n- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。\n  - 解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。\n\n### 异步调用Future类\n\n`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n`Future`类是一个泛型接口，主要包含下面几个方法：\n```\n// V 代表了Future执行的任务返回值的类型\npublic interface Future<V> {\n    // 取消任务执行，成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 判断任务是否被取消\n    boolean isCancelled();\n    // 判断任务是否已经执行完成\n    boolean isDone();\n    // 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n}\n```\n\n### Callable和Future关系\n`Callable` 用于定义可以返回结果的任务，`Future` 用于获取 `Callable` 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。\n- 任务提交与执行：通常通过 `ExecutorService` 提交 `Callable` 任务，`submit` 方法返回一个 `Future` 对象。\n- 异步结果获取：`Future` 对象可以用来获取 `Callable` 任务的返回结果或处理异常。\n\n### CompletableFuture类有什么用？\n`CompletableFuture` 类是 Java 8 中引入的一个增强版 `Future`，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 `Future` 相比，`CompletableFuture` 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。\n\n### 虚拟线程\n虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\n\n虚拟线程(`Virtual Thread`)是 JDK 而不是操作系统实现的轻量级线程(`Lightweight Process，LWP`)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n\n在没有虚拟线程之前，JVM使用的是**平台线程**，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。\n\nJVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。\n\n**优点**\n- 非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。\n- 简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。\n- 减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。\n\n**缺点**\n不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。\n依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。\n\n## IO\n\nIO(`Input/Output`)即输入/输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。\n\nIO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\n- `InputStream/Reader`： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- `OutputStream/Writer`： 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n### Java为什么要分字节流和字符流\nJava 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。\n- 字符流自动处理字符编码问题，非常适合文本数据；\n- 字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。\n\n### 字节流和字符流区别\n- 字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。\n- 字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。\n- 字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。\n\n### IO设计模式总结\n- 装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。\n- 适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。\n- 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。\n- 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。\n\n### 装饰器模式和适配器模式区别\n- 装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。\n- 适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。\n\n### 3种常见的IO模型\n- BIO(`Blocking IO`)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。\n  - 优点：编程简单，代码易于理解。\n  - 缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。\n- NIO(`Non-blocking IO`)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。\n  - 优点：单线程可以处理多个连接，提高并发性能。\n  - 缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\n- AIO(`Asynchronous IO`)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。\n  - 优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。\n  - 缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。\n\n\n\n\n## JVM\n### 内存区域\nJava内存区域通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。\n\n线程私有的内存区域包括：\n- **程序计数器**：\n  - 这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。\n  - 如果正在执行的是本地方法，这个计数器是未指定值(undefined)。\n- **Java虚拟机栈**：\n  - Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。\n  - 栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。\n- **本地方法栈**：\n  - 本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。\n  - 一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。\n\n线程共享的内存区域包括：\n- **堆**：\n  - Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。\n  - 堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。\n  - 堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。\n    - JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。\n- **方法区**：\n  - 方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n  - 方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。\n- **运行时常量池**：\n  - 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。\n  - JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。\n\n本地内存：\n- 直接内存：\n  - 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。\n  - JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。\n  - JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。\n\n\n**内存模型与内存管理**\n- **内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。\n- **垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。\n\n**总结**\nJava内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。\n\n### 对象的创建过程(5步)\n1. 类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n2. 分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n3. 初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n5. 执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 对象的内存布局\n对象在内存中的布局可以分为 3 块区域： \n- 对象头(`Header`)： \n  - 标记字段(`Mark Word`)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。\n  - 类型指针(`Klass Word`)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n- 实例数据(`Instance Data`)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\n- 对齐填充(`Padding`)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。\n\n### 对象的访问定位\n建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。\n- 句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n- 直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n### 垃圾回收机制\n**垃圾回收机制定义**\n垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。\n\n**堆空间结构**\n堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。\n\n**内存分配和回收原则**\n- 对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。\n- 大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。\n- 长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。\n\n垃圾回收的基本步骤分两步：\n- 查找内存中不再使用的对象(GC判断策略)\n- 释放这些对象占用的内存(GC收集算法)\n\n**死亡对象/GC判断策略**\n- 引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。\n    - 循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n- 可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。\n    - 这些对象可以用作 GC Roots： \n      - 虚拟机栈(栈帧中的局部变量表)中引用的对象\n      - 本地方法栈(Native 方法)中引用的对象\n      - 方法区中类静态属性引用的对象\n      - 方法区中常量引用的对象\n      - 所有被同步锁持有的对象\n      - JNI(Java Native Interface)引用的对象\n\n> 对象被标记为不可达，就代表一定会被回收吗？\n> 不一定。真正宣告一个对象死亡至少要经过两次标记过程。\n\n**垃圾回收算法**\n- 标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。\n  - 存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。\n- 复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。\n  - 存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。\n- 标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。\n  - 问题：整理的过程效率也不高。\n- 分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。\n\n**垃圾回收器**\n默认收集器：\nJDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)\nJDK 9 ~ JDK20： G1(Garbage-First)收集器\n\n- Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( \"Stop The World\" )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。\n- ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。\n- Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。\n- Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。\n- Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。\n- CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。\n- G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。\n- ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。\n\n\n> HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\n> - 部分收集 (`Partial GC`)：\n>     - 新生代收集(Minor GC / Young GC)：只对新生代进行垃圾收集；\n>     - 老年代收集(Major GC / Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\n>     - 混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。\n> - 整堆收集 (Full GC)：收集整个 Java 堆和方法区。\n\n### 为什么要进行垃圾回收\n- **防止内存泄漏**：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。\n- **提高开发效率**：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。\n- **系统性能和稳定性**：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。\n\n### 强引用/软引用/弱引用/虚引用\nhttps://blog.csdn.net/u013718071/article/details/134789666\nJava中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。\n- 强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。\n- 软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。\n- 弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。\n- 虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(`ReferenceQueue`)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。\n\n以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。\n\n### 如何判断一个类是无用的\n类需要同时满足下面 3 个条件才能算是 “无用的类”：\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收\n\n### 类的生命周期\n加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。\n\n其中验证、准备、解析 3 部分统称为连接。\n\n### 类加载过程\n分三步：加载、连接(验证、准备、解析)、初始化。\n\n**加载**\n加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。加载主要分下面三步：\n1. 通过全类名获取定义此类的二进制字节流。\n2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。\n\n> 加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。\n\n**验证**\n连接的第一步，确保 `Class` 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：\n1. 文件格式验证：验证字节流是否符合 Class 文件格式规范。\n2. 元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。\n   - 如验证类是否有父类\n3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n   - 如验证函数的参数是否正确\n4. 符号引用验证：确保解析动作能正确执行。\n   - 如验证该类要使用的其他类、方法是否存在。\n\n**准备**\n连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。\n- 进行内存分配的仅包括类变量(被`static`修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\n- 初始值是数据类型的默认值，如 0、null 等。\n\n**解析**\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。\n\n**初始化**\n初始化阶段是执行初始化方法 `<clinit>()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\n\n### 类卸载\n卸载类即该类的 `Class` 对象被 GC。\n\n卸载类需要满足 3 个要求：\n- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。\n- 该类没有在其他任何地方被引用\n- 该类的类加载器的实例已被 GC\n\n在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如`BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。\n\n### 类加载器\n类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 `ClassLoader`。数组类不是通过 `ClassLoader` 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。\n\n> 类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。\n\nJVM内置三个重要的类加载器：\n`BootstrapClassLoader`(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 `null`，并且没有父级，主要用来加载 JDK 内部的核心类库。\n`ExtensionClassLoader`(扩展类加载器)：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。\n`AppClassLoader`(应用程序类加载器)：面向用户的加载器，负责加载当前应用 `classpath` 下的所有 jar 包和类。\n\n### 双亲委派模型\n双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。\n\n**优点**\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。\n\n如果需要打破双亲委派模型，需要自定义类加载器，并重写 `loadClass` 方法。\n\n\n## 面经\n\n\n","slug":"Java后端面经","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0vd0029uugn4ungbfjb","content":"<blockquote>\n<p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"简历相关\"><a href=\"#简历相关\" class=\"headerlink\" title=\"简历相关\"></a>简历相关</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p>\n<h3 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h3><h3 id=\"Casbin明日之星实习\"><a href=\"#Casbin明日之星实习\" class=\"headerlink\" title=\"Casbin明日之星实习\"></a>Casbin明日之星实习</h3><ol>\n<li><p>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</p>\n</li>\n<li><p>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</p>\n</li>\n<li><p>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</p>\n</li>\n</ol>\n<h3 id=\"中科院开源之夏项目\"><a href=\"#中科院开源之夏项目\" class=\"headerlink\" title=\"中科院开源之夏项目\"></a>中科院开源之夏项目</h3><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p>\n<p><strong>项目诉求</strong></p>\n<ol>\n<li><p>对微信第三方登录的移动端支持</p>\n<ul>\n<li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li>\n</ul>\n</li>\n<li><p>对flutter、react-native、unity等sdk的开发及功能的增强</p>\n<ul>\n<li>对flutter-sdk的增强如第一点</li>\n</ul>\n</li>\n<li><p>临时加上的开发casdoor-app诉求，对标Google Authenticator</p>\n</li>\n</ol>\n<p><strong>技术细节</strong></p>\n<ol>\n<li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p>\n<ul>\n<li><p>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</p>\n</li>\n<li><p>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</p>\n</li>\n<li><p>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p>\n<ol start=\"2\">\n<li>分为两部分<ol>\n<li>casdoor-unity-example<ul>\n<li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li>\n<li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li>\n<li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li>\n<li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li>\n</ul>\n</li>\n<li>casdoor-react-native-sdk、example<ul>\n<li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li>\n<li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li>\n<li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。<ul>\n<li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li>\n<li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p>\n</blockquote>\n<p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p>\n<h3 id=\"单点登录SSO原理\"><a href=\"#单点登录SSO原理\" class=\"headerlink\" title=\"单点登录SSO原理\"></a>单点登录SSO原理</h3><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p>\n<p>在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。</p>\n<p>流程：</p>\n<ol>\n<li>用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li>\n<li>此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li>\n</ol>\n<p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p>\n<h3 id=\"OAuth-2-0原理\"><a href=\"#OAuth-2-0原理\" class=\"headerlink\" title=\"OAuth 2.0原理\"></a>OAuth 2.0原理</h3><p><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p>\n<p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。</p>\n<p>定义了4种角色：</p>\n<ul>\n<li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li>\n<li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。</li>\n<li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li>\n<li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。</li>\n<li>如果用户授权该请求，应用程序会收到授权准许(<code>Authorization Grant</code>)。</li>\n<li>应用程序通过提供其自身的身份验证和授权准许(<code>Authorization Grant</code>)来向授权服务器 (API) 请求访问令牌(<code>access_token</code>)。</li>\n<li>如果应用程序身份通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器(API)向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li>\n<li>应用程序从资源服务器(API)请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li>\n<li>如果访问令牌(<code>access_token</code>)有效，则资源服务器 (API) 向应用程序提供资源。</li>\n</ol>\n<p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p>\n<ol>\n<li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li>\n<li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li>\n<li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li>\n</ol>\n<h3 id=\"Casbin-Casdoor-介绍\"><a href=\"#Casbin-Casdoor-介绍\" class=\"headerlink\" title=\"Casbin Casdoor 介绍\"></a>Casbin Casdoor 介绍</h3><blockquote>\n<p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p>\n<ol>\n<li><strong>多种访问控制模型支持</strong>：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li>\n<li><strong>灵活的策略管理</strong>：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li>\n<li><strong>细粒度的权限控制</strong>：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li>\n<li><strong>跨语言支持</strong>：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p>\n<ol>\n<li>**单点登录(SSO)**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li>\n<li><strong>用户管理</strong>：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li>\n<li><strong>权限控制</strong>：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li>\n<li><strong>开源社区</strong>：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li>\n</ol>\n</blockquote>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><blockquote>\n<p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p>\n<ul>\n<li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li>\n<li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li>\n<li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li>\n<li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li>\n<li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li>\n<li>标准化操作：利用HTTP动词来描述对资源的操作。 </li>\n<li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li>\n<li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li>\n<li>无状态交互：每个请求独立，不依赖于之前的请求。</li>\n</ul>\n<p>优点 </p>\n<ul>\n<li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li>\n<li>性能高：无状态和可缓存性提高了性能。 </li>\n<li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li>\n<li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li>\n</ul>\n<p>缺点 </p>\n<ul>\n<li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li>\n<li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li>\n<li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li>\n</ul>\n<p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p>\n</blockquote>\n<h3 id=\"国家电网项目\"><a href=\"#国家电网项目\" class=\"headerlink\" title=\"国家电网项目\"></a>国家电网项目</h3><p><strong>简介</strong></p>\n<p>自己导师接的项目，江苏省国家电网智能诊断数据分析平台</p>\n<p><strong>项目诉求</strong></p>\n<ul>\n<li>对相应指标进行增删改查</li>\n<li>可以导入、导出一些excel表格</li>\n<li>对数据进行智能诊断分析</li>\n</ul>\n<p><strong>技术细节</strong></p>\n<p>react、Antd、Flask、mongodb</p>\n<h3 id=\"江南布衣实习\"><a href=\"#江南布衣实习\" class=\"headerlink\" title=\"江南布衣实习\"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p>\n<ol>\n<li><p><strong>新入职员工设备管理</strong>：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p>\n</li>\n<li><p><strong>离职员工设备回收和资料销毁</strong>：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p>\n</li>\n<li><p><strong>订货会期间设备组装和网络连接</strong>：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p>\n</li>\n<li><p><strong>员工设备报修响应与问题解决</strong>：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p>\n</li>\n</ol>\n<p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p>\n<blockquote>\n<p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p>\n<ol>\n<li><strong>网络配置</strong>：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li>\n<li><strong>身份验证</strong>：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li>\n<li><strong>访问内部资源</strong>：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li>\n</ol>\n</blockquote>\n<h3 id=\"印象最深的一个项目\"><a href=\"#印象最深的一个项目\" class=\"headerlink\" title=\"印象最深的一个项目\"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p>\n<p><strong>亮点</strong></p>\n<ol>\n<li><p><strong>异步支持</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li>\n<li><strong>回答</strong>：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li>\n</ul>\n</li>\n<li><p><strong>灵活的过滤机制</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li>\n<li><strong>回答</strong>：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li>\n</ul>\n</li>\n<li><p><strong>可扩展性</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li>\n<li><strong>回答</strong>：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li>\n</ul>\n</li>\n<li><p><strong>事务处理</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li>\n<li><strong>回答</strong>：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>难点</strong></p>\n<ol>\n<li><strong>异步编程的复杂性</strong>：<ul>\n<li><strong>难点</strong>：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li>\n<li><strong>回答</strong>：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li>\n</ul>\n</li>\n<li><strong>数据库模型的灵活性与一致性</strong>：<ul>\n<li><strong>难点</strong>：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li>\n<li><strong>回答</strong>：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li>\n</ul>\n</li>\n<li><strong>复杂的策略更新逻辑</strong>：<ul>\n<li><strong>难点</strong>：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li>\n<li><strong>回答</strong>：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li>\n</ul>\n</li>\n<li><strong>高效的批量操作</strong>：<ul>\n<li><strong>难点</strong>：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li>\n<li><strong>回答</strong>：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li>\n</ul>\n</li>\n</ol>\n<p>测试方面</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li>\n<li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li>\n<li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li>\n</ul>\n<blockquote>\n<p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p>\n</blockquote>\n<h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p><code>&lt;&lt;</code>：左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>：无符号右移，忽略符号位，空位都以 0 补齐。</p>\n<p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>\n<p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p>\n<h3 id=\"基本数据类型-包装类型-及区别\"><a href=\"#基本数据类型-包装类型-及区别\" class=\"headerlink\" title=\"基本数据类型&#x2F;包装类型 及区别\"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p>\n<ul>\n<li>6 种数字类型： <ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<blockquote>\n<p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>： 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>： 双引号。</p>\n</blockquote>\n<p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<p><strong>区别</strong></p>\n<ul>\n<li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li>\n<li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li>\n<li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li>\n<li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>\n<li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>\n</ul>\n<h3 id=\"包装类的缓存机制\"><a href=\"#包装类的缓存机制\" class=\"headerlink\" title=\"包装类的缓存机制\"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>\n<h3 id=\"什么是自动拆装箱\"><a href=\"#什么是自动拆装箱\" class=\"headerlink\" title=\"什么是自动拆装箱\"></a>什么是自动拆装箱</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;  <span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i;   <span class=\"comment\">//拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>\n<li>拆箱：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题\"><a href=\"#如何解决浮点数运算的精度丢失问题\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题\"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p>\n<h3 id=\"局部变量-成员变量-静态变量\"><a href=\"#局部变量-成员变量-静态变量\" class=\"headerlink\" title=\"局部变量&#x2F;成员变量&#x2F;静态变量\"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul>\n<li>语法形式：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>\n<li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>\n<li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li>\n</ul>\n<p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><ul>\n<li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>\n<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象和面向过程区别\"><a href=\"#面向对象和面向过程区别\" class=\"headerlink\" title=\"面向对象和面向过程区别\"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"接口和抽象类区别\"><a href=\"#接口和抽象类区别\" class=\"headerlink\" title=\"接口和抽象类区别\"></a>接口和抽象类区别</h3><p>共同点： 都不能被实例化<br><a href=\"https://learn.skyofit.com/archives/351\">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p>\n<ul>\n<li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li>\n<li>抽象类可以有构造方法，接口不能有构造方法。</li>\n<li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li>\n<li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li>\n<li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li>\n<li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li>\n</ul>\n<h3 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h3><p><a href=\"https://blog.csdn.net/qq_44944221/article/details/126692973\">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p>\n<ul>\n<li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li>\n<li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li>\n<li>共享性不同：栈是线程私有，而堆是线程共享；</li>\n<li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li>\n<li>空间大小不同：堆空间大小远远大于栈的内存空间。</li>\n</ul>\n<h3 id=\"深拷贝-浅拷贝-引用拷贝\"><a href=\"#深拷贝-浅拷贝-引用拷贝\" class=\"headerlink\" title=\"深拷贝&#x2F;浅拷贝&#x2F;引用拷贝\"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul>\n<li>深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。</li>\n<li>浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li>引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li>\n</ul>\n<h3 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"形参-实参\"><a href=\"#形参-实参\" class=\"headerlink\" title=\"形参&amp;实参\"></a>形参&amp;实参</h3><ul>\n<li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>\n<li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>\n</ul>\n<h3 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递&amp;引用传递\"></a>值传递&amp;引用传递</h3><ul>\n<li>值传递：方法接收的是实参值的拷贝，会创建副本。</li>\n<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p>Java 中只有值传递，C++ 中有值传递和引用传递。</p>\n<h3 id=\"和equals-区别\"><a href=\"#和equals-区别\" class=\"headerlink\" title=\"&#x3D;&#x3D;和equals()区别\"></a>&#x3D;&#x3D;和equals()区别</h3><ul>\n<li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul>\n<li>基本数据类型：比较的是值是否相等</li>\n<li>引用数据类型：比较的是引用地址是否相等</li>\n<li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li>\n</ul>\n</li>\n<li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul>\n<li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li>\n<li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hashCode-和equal\"><a href=\"#hashCode-和equal\" class=\"headerlink\" title=\"hashCode()和equal()\"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>\n<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li>\n</ul>\n<p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<h3 id=\"String-StringBuffer-StringBuilder\"><a href=\"#String-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"String&#x2F;StringBuffer&#x2F;StringBuilder\"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul>\n<li><p><code>String</code> ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuffer</code> ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuilder</code> ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p>\n</li>\n<li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>\n</li>\n<li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p>\n</li>\n<li><p><code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n</li>\n</ul>\n<p>** <code>String</code> 为什么不可变？**</p>\n<ul>\n<li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ul>\n<h3 id=\"字符串拼接使用-还是StringBuilder？\"><a href=\"#字符串拼接使用-还是StringBuilder？\" class=\"headerlink\" title=\"字符串拼接使用+还是StringBuilder？\"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p>\n<h3 id=\"String-equals-Object-equals\"><a href=\"#String-equals-Object-equals\" class=\"headerlink\" title=\"String.equals()&#x2F;Object.equals()\"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>： 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>： 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p>\n<h3 id=\"Checked-Unchecked-Exception\"><a href=\"#Checked-Unchecked-Exception\" class=\"headerlink\" title=\"Checked&#x2F;Unchecked Exception\"></a>Checked&#x2F;Unchecked Exception</h3><ul>\n<li><code>Checked Exception</code>即受检查异常 ，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<ul>\n<li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li>\n</ul>\n</li>\n<li><code>Unchecked Exception</code> 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。<ul>\n<li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"try-catch-finally\"><a href=\"#try-catch-finally\" class=\"headerlink\" title=\"try-catch-finally\"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>\n<blockquote>\n<p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p>\n</blockquote>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><ul>\n<li>使用泛型参数，可以增强代码的可读性以及稳定性。</li>\n<li>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>\n<ul>\n<li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>\n<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>\n</ul>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h3 id=\"序列化-反序列化\"><a href=\"#序列化-反序列化\" class=\"headerlink\" title=\"序列化&#x2F;反序列化\"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<ul>\n<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>\n<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>\n<p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p>\n<h2 id=\"Java集合\"><a href=\"#Java集合\" class=\"headerlink\" title=\"Java集合\"></a>Java集合</h2><h3 id=\"List-Set-Queue-Map区别\"><a href=\"#List-Set-Queue-Map区别\" class=\"headerlink\" title=\"List&#x2F;Set&#x2F;Queue&#x2F;Map区别\"></a>List&#x2F;Set&#x2F;Queue&#x2F;Map区别</h3><ul>\n<li>List： 存储的元素是有序的、可重复的。</li>\n<li>Set： 存储的元素不可重复的。</li>\n<li>Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li>Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>\n</ul>\n<h3 id=\"如何选用集合\"><a href=\"#如何选用集合\" class=\"headerlink\" title=\"如何选用集合?\"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p>\n<ul>\n<li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</li>\n<li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li>\n</ul>\n<h3 id=\"为什么要使用集合？\"><a href=\"#为什么要使用集合？\" class=\"headerlink\" title=\"为什么要使用集合？\"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>\n<h3 id=\"ArrayList和Array区别\"><a href=\"#ArrayList和Array区别\" class=\"headerlink\" title=\"ArrayList和Array区别\"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p>\n<ul>\n<li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li>\n<li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li>\n<li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li>\n<li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li>\n<li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li>\n</ul>\n<blockquote>\n<p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList区别\"><a href=\"#ArrayList和LinkedList区别\" class=\"headerlink\" title=\"ArrayList和LinkedList区别\"></a>ArrayList和LinkedList区别</h3><ul>\n<li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul>\n<li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li>\n<li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li>二者都是线程不安全的。</li>\n<li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li>\n<li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li>\n</ul>\n<blockquote>\n<p>项目中一般不会使用 <code>LinkedList</code>。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList插入-删除效率\"><a href=\"#ArrayList和LinkedList插入-删除效率\" class=\"headerlink\" title=\"ArrayList和LinkedList插入&#x2F;删除效率\"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p>\n<ul>\n<li>头部插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>尾部插入&#x2F;删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。<br><code>LinkedList</code></li>\n<li>头部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>尾部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要先移动到指定位置再插入和删除。</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p>\n<ul>\n<li><strong>读多写少</strong>：大部分操作都是读取数据，写操作相对较少。</li>\n<li><strong>不要求实时性</strong>：因为写操作需要创建数组副本，可能会有短暂的延迟。</li>\n</ul>\n<p><code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li><strong>线程安全</strong>：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li>\n<li><strong>简化并发控制</strong>：不需要显式的同步块或锁定机制。</li>\n<li><strong>迭代器安全</strong>：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li><strong>内存开销大</strong>：每次写操作都会创建数组副本，可能会占用较多的内存。</li>\n<li><strong>写操作开销大</strong>：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li>\n<li><strong>读取旧数据</strong>：在高并发场景下，可能会读取到旧的数据。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>配置类数据：如系统配置参数、常量集合等。</li>\n<li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li>\n</ul>\n<p><strong>不适用场景</strong></p>\n<ul>\n<li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li>\n<li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li>\n</ul>\n<p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p>\n<h3 id=\"HashSet-LinkedHashSet-TreeSet\"><a href=\"#HashSet-LinkedHashSet-TreeSet\" class=\"headerlink\" title=\"HashSet&#x2F;LinkedHashSet&#x2F;TreeSet\"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul>\n<li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li>\n<li>主要区别在于底层数据结构不同。<ul>\n<li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li>\n<li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>\n<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>\n</ul>\n</li>\n<li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>\n</ul>\n<h3 id=\"Map-重要\"><a href=\"#Map-重要\" class=\"headerlink\" title=\"Map(重要)\"></a>Map(重要)</h3><h3 id=\"HashMap-HashTable区别\"><a href=\"#HashMap-HashTable区别\" class=\"headerlink\" title=\"HashMap&#x2F;HashTable区别\"></a>HashMap&#x2F;HashTable区别</h3><ul>\n<li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li>\n<li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>\n<li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li>\n<li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和value，否则会报错<code>NullPointerException</code>。</li>\n<li>初始容量大小和每次扩充容量大小的不同： <ul>\n<li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li>\n<li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p>\n</blockquote>\n<h3 id=\"HashMap长度为什么是2的幂次方\"><a href=\"#HashMap长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap长度为什么是2的幂次方\"></a>HashMap长度为什么是2的幂次方</h3><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p>\n<p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p>\n<h3 id=\"HashMap-TreeMap区别\"><a href=\"#HashMap-TreeMap区别\" class=\"headerlink\" title=\"HashMap&#x2F;TreeMap区别\"></a>HashMap&#x2F;TreeMap区别</h3><ul>\n<li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li>\n<li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li>\n<li><code>HashMap</code> 的键值对允许有一个 <code>null</code> 键和多个 <code>null</code> 值，<code>TreeMap</code> 不允许有 <code>null</code> 键，但允许有 <code>null</code> 值。</li>\n<li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li>\n</ul>\n<p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>\n<h3 id=\"HashSet如何检查重复\"><a href=\"#HashSet如何检查重复\" class=\"headerlink\" title=\"HashSet如何检查重复\"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>\n<p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。</p>\n<h3 id=\"HashMap底层实现\"><a href=\"#HashMap底层实现\" class=\"headerlink\" title=\"HashMap底层实现\"></a>HashMap底层实现</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p>\n<p><code>HashMap</code> 通过 key 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p>\n<ul>\n<li>扰动函数 <code>hash()</code> 可以减少碰撞。</li>\n<li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>\n<li>“拉链法”中，数组的 index 就是通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li>\n</ul>\n<p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p>\n<ul>\n<li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li>\n<li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li>\n</ul>\n<h3 id=\"HashMap多线程扩容死循环问题\"><a href=\"#HashMap多线程扩容死循环问题\" class=\"headerlink\" title=\"HashMap多线程扩容死循环问题\"></a>HashMap多线程扩容死循环问题</h3><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>\n<p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>\n<blockquote>\n<p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p>\n</blockquote>\n<h3 id=\"HashMap为什么线程不安全\"><a href=\"#HashMap为什么线程不安全\" class=\"headerlink\" title=\"HashMap为什么线程不安全\"></a>HashMap为什么线程不安全</h3><ul>\n<li>JDK1.7及之前版本，存在多线程扩容死循环问题，如上。</li>\n<li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。</li>\n</ul>\n<p><strong>数据丢失</strong><br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>\n<blockquote>\n<p>例子：<br>线程 1,2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>\n</blockquote>\n<h3 id=\"遍历HashMap\"><a href=\"#遍历HashMap\" class=\"headerlink\" title=\"遍历HashMap\"></a>遍历HashMap</h3><p>七种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// ForEach EntrySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ForEach KeySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Integer key : map.keySet()) &#123;</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器EntrySet</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器KeySet</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(key);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 单线程</span></span><br><span class=\"line\">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 多线程</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-Hashtable区别\"><a href=\"#ConcurrentHashMap-Hashtable区别\" class=\"headerlink\" title=\"ConcurrentHashMap&#x2F;Hashtable区别\"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul>\n<li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong> 。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li>\n<li>实现线程安全的方式：<ul>\n<li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li>\n<li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li><code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConcurrentHashMap底层\"><a href=\"#ConcurrentHashMap底层\" class=\"headerlink\" title=\"ConcurrentHashMap底层\"></a>ConcurrentHashMap底层</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为**<code>Segment</code>数组+<code>HashEntry</code>数组+链表** 。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>\n<p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p>\n<p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，**<code>Node</code>数组+链表&#x2F;红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p>\n<h3 id=\"JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\"><a href=\"#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\" class=\"headerlink\" title=\"JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul>\n<li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>\n<li>Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li>\n<li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li>\n</ul>\n<h3 id=\"ConcurrentHashMap能保证复合操作的原子性吗？\"><a href=\"#ConcurrentHashMap能保证复合操作的原子性吗？\" class=\"headerlink\" title=\"ConcurrentHashMap能保证复合操作的原子性吗？\"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul>\n<li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li>\n<li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li>\n</ul>\n<h3 id=\"什么是LinkedHashMap\"><a href=\"#什么是LinkedHashMap\" class=\"headerlink\" title=\"什么是LinkedHashMap\"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代</li>\n<li>支持按照元素访问顺序排序,<em><strong>适用于封装 LRU 缓存工具</strong></em> 。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li>\n</ul>\n<blockquote>\n<p>在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n</blockquote>\n<h3 id=\"LinkedHashMap如何按照访问顺序迭代元素？\"><a href=\"#LinkedHashMap如何按照访问顺序迭代元素？\" class=\"headerlink\" title=\"LinkedHashMap如何按照访问顺序迭代元素？\"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>\n<h3 id=\"如何实现LRU缓存\"><a href=\"#如何实现LRU缓存\" class=\"headerlink\" title=\"如何实现LRU缓存\"></a>如何实现LRU缓存</h3><ul>\n<li><code>accessOrder</code> &#x3D; <code>true</code> </li>\n<li>继承<code>LinkedHashMap</code></li>\n<li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"LinkedHashMap和HashMap的区别\"><a href=\"#LinkedHashMap和HashMap的区别\" class=\"headerlink\" title=\"LinkedHashMap和HashMap的区别\"></a>LinkedHashMap和HashMap的区别</h3><ul>\n<li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li>\n<li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li>\n</ul>\n<h3 id=\"Queue-Deque区别\"><a href=\"#Queue-Deque区别\" class=\"headerlink\" title=\"Queue&#x2F;Deque区别\"></a>Queue&#x2F;Deque区别</h3><ul>\n<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li>\n<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li>\n</ul>\n<h3 id=\"ArrayDeque-LinkedList区别\"><a href=\"#ArrayDeque-LinkedList区别\" class=\"headerlink\" title=\"ArrayDeque&#x2F;LinkedList区别\"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul>\n<li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li>\n<li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li>\n<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li>\n</ul>\n<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>\n<h3 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>\n<ul>\n<li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>\n<li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>\n<li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>\n<li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>\n</ul>\n<blockquote>\n<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>\n</blockquote>\n<h3 id=\"BlockingQueue及其实现类\"><a href=\"#BlockingQueue及其实现类\" class=\"headerlink\" title=\"BlockingQueue及其实现类\"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p>\n<p><strong>实现类</strong></p>\n<ul>\n<li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>\n<li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。</li>\n<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li>\n<li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li>\n<li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li>\n<li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li>\n<li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue实现原理\"><a href=\"#ArrayBlockingQueue实现原理\" class=\"headerlink\" title=\"ArrayBlockingQueue实现原理\"></a>ArrayBlockingQueue实现原理</h3><ul>\n<li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li>\n<li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li>\n<li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li>\n</ul>\n<p>线程间的等待和唤醒具体的实现：</p>\n<ul>\n<li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li>\n<li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li>\n<li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li>\n<li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue区别\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue区别\" class=\"headerlink\" title=\"ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别\"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>\n<li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>\n<li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>\n</ul>\n<h3 id=\"DelayQueue底层\"><a href=\"#DelayQueue底层\" class=\"headerlink\" title=\"DelayQueue底层\"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>\n<p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可重入锁，实现线程安全的关键</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">//指向准备执行优先级最高的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Thread</span> <span class=\"variable\">leader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//实现多线程之间等待唤醒的交互</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>\n<p><code>leader</code> ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code> ： 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p>\n</blockquote>\n<h3 id=\"DelayQueue是否线程安全？\"><a href=\"#DelayQueue是否线程安全？\" class=\"headerlink\" title=\"DelayQueue是否线程安全？\"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>\n<h3 id=\"DelayQueue使用场景\"><a href=\"#DelayQueue使用场景\" class=\"headerlink\" title=\"DelayQueue使用场景\"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p>\n<ul>\n<li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li>\n<li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li>\n</ul>\n<h3 id=\"DelayQueue中Delayed接口的作用是什么？\"><a href=\"#DelayQueue中Delayed接口的作用是什么？\" class=\"headerlink\" title=\"DelayQueue中Delayed接口的作用是什么？\"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口),否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>\n<h3 id=\"DelayQueue-Timer-TimerTask区别\"><a href=\"#DelayQueue-Timer-TimerTask区别\" class=\"headerlink\" title=\"DelayQueue&#x2F;Timer&#x2F;TimerTask区别\"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p>\n<ul>\n<li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li>\n<li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li>\n<li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li>\n</ul>\n<h2 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程&#x2F;线程&#x2F;协程\"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href=\"https://blog.csdn.net/m0_60505735/article/details/131047046\">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href=\"https://blog.csdn.net/weixin_49199646/article/details/109210547\">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p>\n<ul>\n<li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li>\n<li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>\n<li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li>\n</ul>\n<p><strong>进程与线程的区别</strong></p>\n<ul>\n<li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li>\n<li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li>\n<li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li>\n</ul>\n<p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p>\n<p><em>进程与线程的选择</em>*</p>\n<ul>\n<li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li>\n<li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li>\n<li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li>\n<li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li>\n</ul>\n<p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p>\n<h3 id=\"Java线程和操作系统线程有何区别\"><a href=\"#Java线程和操作系统线程有何区别\" class=\"headerlink\" title=\"Java线程和操作系统线程有何区别\"></a>Java线程和操作系统线程有何区别</h3><p>现在的 Java 线程的本质其实就是操作系统的线程。</p>\n<ul>\n<li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li>\n<li>JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li>\n</ul>\n<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p>\n<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p>\n<h3 id=\"程序计数器为啥是私有的\"><a href=\"#程序计数器为啥是私有的\" class=\"headerlink\" title=\"程序计数器为啥是私有的\"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n<li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>\n</ul>\n<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>\n<h3 id=\"虚拟机栈和本地方法栈为啥是私有的\"><a href=\"#虚拟机栈和本地方法栈为啥是私有的\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈为啥是私有的\"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul>\n<li>虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>\n<li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>\n</ul>\n<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3 id=\"一句话简单了解堆和方法区\"><a href=\"#一句话简单了解堆和方法区\" class=\"headerlink\" title=\"一句话简单了解堆和方法区\"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h3 id=\"如何创建线程\"><a href=\"#如何创建线程\" class=\"headerlink\" title=\"如何创建线程\"></a>如何创建线程</h3><ul>\n<li>继承<code>Thread</code>类并重写<code>run()</code>方法</li>\n<li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li>\n<li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li>\n<li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li>\n<li>等等……</li>\n</ul>\n<p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>\n<h3 id=\"线程的生命周期和状态\"><a href=\"#线程的生命周期和状态\" class=\"headerlink\" title=\"线程的生命周期和状态\"></a>线程的生命周期和状态</h3><p>Java 线程 6 种状态：<br><code>NEW</code>： 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>： 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>\n<h3 id=\"线程上下文切换\"><a href=\"#线程上下文切换\" class=\"headerlink\" title=\"线程上下文切换\"></a>线程上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>\n<ul>\n<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>\n<li>时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n</ul>\n<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>\n<h3 id=\"Thread-sleep-方法和Object-wait-方法对比\"><a href=\"#Thread-sleep-方法和Object-wait-方法对比\" class=\"headerlink\" title=\"Thread.sleep()方法和Object.wait()方法对比\"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p>\n<ul>\n<li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁 。</li>\n<li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li>\n<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li>\n<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>\n</ul>\n<h3 id=\"锁的基本概念\"><a href=\"#锁的基本概念\" class=\"headerlink\" title=\"锁的基本概念\"></a>锁的基本概念</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p>\n<h3 id=\"为什么wait-方法不定义在Thread中\"><a href=\"#为什么wait-方法不定义在Thread中\" class=\"headerlink\" title=\"为什么wait()方法不定义在Thread中\"></a>为什么wait()方法不定义在Thread中</h3><ul>\n<li>锁是对象级别的，每个对象都有一把锁。</li>\n<li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li>\n</ul>\n<h3 id=\"为什么sleep-方法定义在Thread中\"><a href=\"#为什么sleep-方法定义在Thread中\" class=\"headerlink\" title=\"为什么sleep()方法定义在Thread中\"></a>为什么sleep()方法定义在Thread中</h3><ul>\n<li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li>\n<li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li>\n</ul>\n<h3 id=\"sleep-如何控制当前线程沉睡\"><a href=\"#sleep-如何控制当前线程沉睡\" class=\"headerlink\" title=\"sleep()如何控制当前线程沉睡\"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p>\n<h3 id=\"可以直接调用Thread类的run方法吗\"><a href=\"#可以直接调用Thread类的run方法吗\" class=\"headerlink\" title=\"可以直接调用Thread类的run方法吗\"></a>可以直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p>\n<h3 id=\"并发-并行区别\"><a href=\"#并发-并行区别\" class=\"headerlink\" title=\"并发&#x2F;并行区别\"></a>并发&#x2F;并行区别</h3><ul>\n<li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<h3 id=\"同步-异步区别\"><a href=\"#同步-异步区别\" class=\"headerlink\" title=\"同步&#x2F;异步区别\"></a>同步&#x2F;异步区别</h3><ul>\n<li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>\n<li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li>\n</ul>\n<h3 id=\"为什么要使用多线程\"><a href=\"#为什么要使用多线程\" class=\"headerlink\" title=\"为什么要使用多线程\"></a>为什么要使用多线程</h3><ul>\n<li>线程切换和调度的成本远远小于进程。</li>\n<li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li>\n<li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li>\n<li>并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。</li>\n</ul>\n<h3 id=\"使用多线程风险\"><a href=\"#使用多线程风险\" class=\"headerlink\" title=\"使用多线程风险\"></a>使用多线程风险</h3><ul>\n<li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li>\n<li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>\n<li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li>\n<li>上下文切换：线程频繁切换，会增加系统开销。</li>\n<li>…</li>\n</ul>\n<h3 id=\"如何理解线程安全和不安全\"><a href=\"#如何理解线程安全和不安全\" class=\"headerlink\" title=\"如何理解线程安全和不安全\"></a>如何理解线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p>\n<ul>\n<li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>\n<li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>\n</ul>\n<h3 id=\"单核CPU上运行多个线程效率一定会高吗\"><a href=\"#单核CPU上运行多个线程效率一定会高吗\" class=\"headerlink\" title=\"单核CPU上运行多个线程效率一定会高吗\"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<blockquote>\n<p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n</blockquote>\n<p>产生死锁的四个必要条件：</p>\n<ul>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"如何检测死锁\"><a href=\"#如何检测死锁\" class=\"headerlink\" title=\"如何检测死锁\"></a>如何检测死锁</h3><ul>\n<li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li>\n<li>jConsole： 可以检测死锁，查看线程的状态。</li>\n<li>jstack： 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li>\n</ul>\n<h3 id=\"如何预防和避免死锁\"><a href=\"#如何预防和避免死锁\" class=\"headerlink\" title=\"如何预防和避免死锁\"></a>如何预防和避免死锁</h3><p>破坏死锁的产生的必要条件：</p>\n<ul>\n<li>破坏请求与保持条件：一次性申请所有的资源。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ul>\n<p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong> )对资源分配进行计算评估，使其进入安全状态。</p>\n<blockquote>\n<p>安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</p>\n</blockquote>\n<h3 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<h3 id=\"为什么需要Java内存模型\"><a href=\"#为什么需要Java内存模型\" class=\"headerlink\" title=\"为什么需要Java内存模型\"></a>为什么需要Java内存模型</h3><ul>\n<li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li>\n<li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li>\n<li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li>\n</ul>\n<h3 id=\"Java内存区域和Java内存模型有什么区别\"><a href=\"#Java内存区域和Java内存模型有什么区别\" class=\"headerlink\" title=\"Java内存区域和Java内存模型有什么区别\"></a>Java内存区域和Java内存模型有什么区别</h3><ul>\n<li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li>\n<li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li>\n</ul>\n<h3 id=\"JMM是如何抽象线程和主内存之间的关系\"><a href=\"#JMM是如何抽象线程和主内存之间的关系\" class=\"headerlink\" title=\"JMM是如何抽象线程和主内存之间的关系\"></a>JMM是如何抽象线程和主内存之间的关系</h3><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。</p>\n<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li>\n<li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li>\n</ul>\n<h3 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h3><p>可见性、原子性和有序性</p>\n<ul>\n<li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li>\n<li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li>\n<li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li>\n</ul>\n<p>JMM通过上面三种属性来确保线程之间的内存一致性。</p>\n<h3 id=\"如何保证变量的可见性-volatile\"><a href=\"#如何保证变量的可见性-volatile\" class=\"headerlink\" title=\"如何保证变量的可见性(volatile)\"></a>如何保证变量的可见性(volatile)</h3><p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3 id=\"如何禁止指令重排序\"><a href=\"#如何禁止指令重排序\" class=\"headerlink\" title=\"如何禁止指令重排序\"></a>如何禁止指令重排序</h3><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p>\n<h3 id=\"volatile可以保证原子性\"><a href=\"#volatile可以保证原子性\" class=\"headerlink\" title=\"volatile可以保证原子性\"></a>volatile可以保证原子性</h3><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>\n<h3 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁&#x2F;悲观锁\"></a>乐观锁&#x2F;悲观锁</h3><ul>\n<li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul>\n<li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li>\n<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li>\n<li>悲观锁可能会存在死锁问题。</li>\n<li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>\n</ul>\n</li>\n<li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul>\n<li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li>\n<li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li>\n<li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul>\n<li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li>\n</ul>\n</li>\n<li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何实现乐观锁\"><a href=\"#如何实现乐观锁\" class=\"headerlink\" title=\"如何实现乐观锁\"></a>如何实现乐观锁</h3><ul>\n<li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li>\n<li>CAS算法：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul>\n<li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n</blockquote>\n<h3 id=\"CAS算法存在问题\"><a href=\"#CAS算法存在问题\" class=\"headerlink\" title=\"CAS算法存在问题\"></a>CAS算法存在问题</h3><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>\n<p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p>\n<p><strong>循环时间长开销大</strong><br>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p>\n<p><strong>只能保证一个共享变量的原子操作</strong><br>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p>\n<h3 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h3><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>\n<h3 id=\"JDK1-6之后synchronized的优化\"><a href=\"#JDK1-6之后synchronized的优化\" class=\"headerlink\" title=\"JDK1.6之后synchronized的优化\"></a>JDK1.6之后synchronized的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p>\n<h3 id=\"锁升级原理了解吗\"><a href=\"#锁升级原理了解吗\" class=\"headerlink\" title=\"锁升级原理了解吗\"></a>锁升级原理了解吗</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<h3 id=\"如何使用synchronized\"><a href=\"#如何使用synchronized\" class=\"headerlink\" title=\"如何使用synchronized\"></a>如何使用synchronized</h3><ul>\n<li>修饰实例方法：锁住当前实例对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰静态方法：锁住当前类的 Class 对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰代码块：锁住括号里面的对象。<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(对象) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">synchronized(类.class) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized底层原理\"><a href=\"#synchronized底层原理\" class=\"headerlink\" title=\"synchronized底层原理\"></a>synchronized底层原理</h3><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p>\n<ul>\n<li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li>\n<li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li>\n</ul>\n<p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>\n<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>\n<h3 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p>\n<p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>\n<blockquote>\n<p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p>\n</blockquote>\n<h3 id=\"AQS资源共享模式\"><a href=\"#AQS资源共享模式\" class=\"headerlink\" title=\"AQS资源共享模式\"></a>AQS资源共享模式</h3><p>AQS 支持两种资源共享方式：独占和共享。</p>\n<ul>\n<li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li>\n<li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li>\n</ul>\n<blockquote>\n<p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p>\n</blockquote>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p>\n<h3 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁&#x2F;非公平锁\"></a>公平锁&#x2F;非公平锁</h3><ul>\n<li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>\n</ul>\n<h3 id=\"synchronized和ReentrantLock有什么区别？\"><a href=\"#synchronized和ReentrantLock有什么区别？\" class=\"headerlink\" title=\"synchronized和ReentrantLock有什么区别？\"></a>synchronized和ReentrantLock有什么区别？</h3><p>两者都是可重入锁</p>\n<ul>\n<li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li>\n<li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li>\n<li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：<ul>\n<li>等待可中断 ： <code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li>\n<li>可实现公平锁： <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>\n<li>可实现选择性通知(锁可以绑定多个条件)： <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>\n</blockquote>\n<h3 id=\"可中断锁-不可中断锁\"><a href=\"#可中断锁-不可中断锁\" class=\"headerlink\" title=\"可中断锁&#x2F;不可中断锁\"></a>可中断锁&#x2F;不可中断锁</h3><ul>\n<li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li>\n<li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li>\n</ul>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>\n<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁) 。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>\n<blockquote>\n<p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p>\n</blockquote>\n<h3 id=\"共享锁-独占锁\"><a href=\"#共享锁-独占锁\" class=\"headerlink\" title=\"共享锁&#x2F;独占锁\"></a>共享锁&#x2F;独占锁</h3><ul>\n<li>共享锁：一把锁可以被多个线程同时获得。</li>\n<li>独占锁：一把锁只能被一个线程获得。</li>\n</ul>\n<h3 id=\"线程持有读锁还能获取写锁吗\"><a href=\"#线程持有读锁还能获取写锁吗\" class=\"headerlink\" title=\"线程持有读锁还能获取写锁吗\"></a>线程持有读锁还能获取写锁吗</h3><ul>\n<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>\n<li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li>\n</ul>\n<h3 id=\"读锁为什么不能升级为写锁\"><a href=\"#读锁为什么不能升级为写锁\" class=\"headerlink\" title=\"读锁为什么不能升级为写锁\"></a>读锁为什么不能升级为写锁</h3><ul>\n<li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li>\n<li>可能会有死锁问题发生。</li>\n</ul>\n<h3 id=\"StampedLock\"><a href=\"#StampedLock\" class=\"headerlink\" title=\"StampedLock\"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p>\n<p>提供三种访问模式：</p>\n<ul>\n<li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。</li>\n<li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。</li>\n<li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"ThreadLocal原理\"><a href=\"#ThreadLocal原理\" class=\"headerlink\" title=\"ThreadLocal原理\"></a>ThreadLocal原理</h3><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p>\n<blockquote>\n<p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p>\n</blockquote>\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>\n<p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>\n<blockquote>\n<p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p>\n</blockquote>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3 id=\"为什么用线程池\"><a href=\"#为什么用线程池\" class=\"headerlink\" title=\"为什么用线程池\"></a>为什么用线程池</h3><ul>\n<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<blockquote>\n<p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<h3 id=\"创建线程池的方式\"><a href=\"#创建线程池的方式\" class=\"headerlink\" title=\"创建线程池的方式\"></a>创建线程池的方式</h3><ul>\n<li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li>\n<li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul>\n<li><code>FixedThreadPool</code>：固定大小的线程池。</li>\n<li><code>SingleThreadPool</code>：只有一个线程的线程池。</li>\n<li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li>\n<li><code>ScheduledThreadPool</code>：定时任务的线程池。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么不推荐使用内置线程池\"><a href=\"#为什么不推荐使用内置线程池\" class=\"headerlink\" title=\"为什么不推荐使用内置线程池\"></a>为什么不推荐使用内置线程池</h3><ul>\n<li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li>\n<li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor参数\"><a href=\"#ThreadPoolExecutor参数\" class=\"headerlink\" title=\"ThreadPoolExecutor参数\"></a>ThreadPoolExecutor参数</h3><p>3 个最重要的参数：</p>\n<ul>\n<li><code>corePoolSize</code> ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><code>maximumPoolSize</code> ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><code>workQueue</code>： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>其他常见参数 ：</p>\n<ul>\n<li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li>\n<li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><code>threadFactory</code> ：<code>executor</code> 创建新线程的时候会用到。</li>\n<li><code>handler</code> ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li>\n</ul>\n<h3 id=\"线程池的拒绝策略\"><a href=\"#线程池的拒绝策略\" class=\"headerlink\" title=\"线程池的拒绝策略\"></a>线程池的拒绝策略</h3><ul>\n<li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li>\n<li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li>\n<li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li>\n<li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy策略风险及解决方案\"><a href=\"#CallerRunsPolicy策略风险及解决方案\" class=\"headerlink\" title=\"CallerRunsPolicy策略风险及解决方案\"></a>CallerRunsPolicy策略风险及解决方案</h3><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li>\n<li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li>\n</ol>\n<h3 id=\"线程池常用阻塞队列\"><a href=\"#线程池常用阻塞队列\" class=\"headerlink\" title=\"线程池常用阻塞队列\"></a>线程池常用阻塞队列</h3><ul>\n<li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li>\n<li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3 id=\"线程池处理任务流程\"><a href=\"#线程池处理任务流程\" class=\"headerlink\" title=\"线程池处理任务流程\"></a>线程池处理任务流程</h3><ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li>\n</ol>\n<h3 id=\"线程池中线程异常后销毁还是复用？\"><a href=\"#线程池中线程异常后销毁还是复用？\" class=\"headerlink\" title=\"线程池中线程异常后销毁还是复用？\"></a>线程池中线程异常后销毁还是复用？</h3><p>两种情况：</p>\n<ul>\n<li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li>\n<li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li>\n</ul>\n<h3 id=\"如何设定线程池大小\"><a href=\"#如何设定线程池大小\" class=\"headerlink\" title=\"如何设定线程池大小\"></a>如何设定线程池大小</h3><ul>\n<li>CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li>\n<li>I&#x2F;O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I&#x2F;O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。</li>\n</ul>\n<h3 id=\"如何设计一个根据任务优先级执行的线程池\"><a href=\"#如何设计一个根据任务优先级执行的线程池\" class=\"headerlink\" title=\"如何设计一个根据任务优先级执行的线程池\"></a>如何设计一个根据任务优先级执行的线程池</h3><ul>\n<li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li>\n<li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li>\n</ul>\n<p>这样还存在一些问题：</p>\n<ul>\n<li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul>\n<li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 &#96;false 。</li>\n</ul>\n</li>\n<li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul>\n<li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异步调用Future类\"><a href=\"#异步调用Future类\" class=\"headerlink\" title=\"异步调用Future类\"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V 代表了Future执行的任务返回值的类型</span><br><span class=\"line\">public interface Future&lt;V&gt; &#123;</span><br><span class=\"line\">    // 取消任务执行，成功取消返回 true，否则返回 false</span><br><span class=\"line\">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\">    // 判断任务是否被取消</span><br><span class=\"line\">    boolean isCancelled();</span><br><span class=\"line\">    // 判断任务是否已经执行完成</span><br><span class=\"line\">    boolean isDone();</span><br><span class=\"line\">    // 获取任务执行结果</span><br><span class=\"line\">    V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\">    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br><span class=\"line\">    V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">        throws InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Callable和Future关系\"><a href=\"#Callable和Future关系\" class=\"headerlink\" title=\"Callable和Future关系\"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p>\n<ul>\n<li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li>\n<li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li>\n</ul>\n<h3 id=\"CompletableFuture类有什么用？\"><a href=\"#CompletableFuture类有什么用？\" class=\"headerlink\" title=\"CompletableFuture类有什么用？\"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p>\n<h3 id=\"虚拟线程\"><a href=\"#虚拟线程\" class=\"headerlink\" title=\"虚拟线程\"></a>虚拟线程</h3><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p>\n<p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>\n<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li>\n<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>\n</ul>\n<p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p>\n<p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream/Reader</code>： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream/Writer</code>： 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h3 id=\"Java为什么要分字节流和字符流\"><a href=\"#Java为什么要分字节流和字符流\" class=\"headerlink\" title=\"Java为什么要分字节流和字符流\"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p>\n<ul>\n<li>字符流自动处理字符编码问题，非常适合文本数据；</li>\n<li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li>\n</ul>\n<h3 id=\"字节流和字符流区别\"><a href=\"#字节流和字符流区别\" class=\"headerlink\" title=\"字节流和字符流区别\"></a>字节流和字符流区别</h3><ul>\n<li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li>\n<li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li>\n<li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li>\n</ul>\n<h3 id=\"IO设计模式总结\"><a href=\"#IO设计模式总结\" class=\"headerlink\" title=\"IO设计模式总结\"></a>IO设计模式总结</h3><ul>\n<li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li>\n<li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li>\n<li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>\n<li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li>\n</ul>\n<h3 id=\"装饰器模式和适配器模式区别\"><a href=\"#装饰器模式和适配器模式区别\" class=\"headerlink\" title=\"装饰器模式和适配器模式区别\"></a>装饰器模式和适配器模式区别</h3><ul>\n<li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li>\n<li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li>\n</ul>\n<h3 id=\"3种常见的IO模型\"><a href=\"#3种常见的IO模型\" class=\"headerlink\" title=\"3种常见的IO模型\"></a>3种常见的IO模型</h3><ul>\n<li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul>\n<li>优点：编程简单，代码易于理解。</li>\n<li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li>\n</ul>\n</li>\n<li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul>\n<li>优点：单线程可以处理多个连接，提高并发性能。</li>\n<li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li>\n</ul>\n</li>\n<li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul>\n<li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li>\n<li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h3><p>Java内存区域通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p>\n<p>线程私有的内存区域包括：</p>\n<ul>\n<li><strong>程序计数器</strong>：<ul>\n<li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li>\n<li>如果正在执行的是本地方法，这个计数器是未指定值(undefined)。</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：<ul>\n<li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li>\n<li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li>\n</ul>\n</li>\n<li><strong>本地方法栈</strong>：<ul>\n<li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li>\n<li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li>\n</ul>\n</li>\n</ul>\n<p>线程共享的内存区域包括：</p>\n<ul>\n<li><strong>堆</strong>：<ul>\n<li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li>\n<li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li>\n<li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul>\n<li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>方法区</strong>：<ul>\n<li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n<li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li>\n</ul>\n</li>\n<li><strong>运行时常量池</strong>：<ul>\n<li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li>\n<li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li>\n</ul>\n</li>\n</ul>\n<p>本地内存：</p>\n<ul>\n<li>直接内存：<ul>\n<li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li>\n<li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li>\n<li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li>\n</ul>\n</li>\n</ul>\n<p><strong>内存模型与内存管理</strong></p>\n<ul>\n<li>**内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li>\n<li>**垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li>\n</ul>\n<p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p>\n<h3 id=\"对象的创建过程-5步\"><a href=\"#对象的创建过程-5步\" class=\"headerlink\" title=\"对象的创建过程(5步)\"></a>对象的创建过程(5步)</h3><ol>\n<li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>\n<li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>\n<li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>\n<li>执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域： </p>\n<ul>\n<li>对象头(<code>Header</code>)： <ul>\n<li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li>\n<li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n</li>\n<li>实例数据(<code>Instance Data</code>)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>\n<li>对齐填充(<code>Padding</code>)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li>\n</ul>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>\n<ul>\n<li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li>\n<li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li>\n</ul>\n<p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p>\n<p><strong>堆空间结构</strong><br>堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p>\n<p><strong>内存分配和回收原则</strong></p>\n<ul>\n<li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li>\n<li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li>\n</ul>\n<p>垃圾回收的基本步骤分两步：</p>\n<ul>\n<li>查找内存中不再使用的对象(GC判断策略)</li>\n<li>释放这些对象占用的内存(GC收集算法)</li>\n</ul>\n<p><strong>死亡对象&#x2F;GC判断策略</strong></p>\n<ul>\n<li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul>\n<li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n</ul>\n</li>\n<li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul>\n<li>这些对象可以用作 GC Roots： <ul>\n<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n<li>JNI(Java Native Interface)引用的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p>\n</blockquote>\n<p><strong>垃圾回收算法</strong></p>\n<ul>\n<li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul>\n<li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li>\n</ul>\n</li>\n<li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul>\n<li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li>\n</ul>\n</li>\n<li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul>\n<li>问题：整理的过程效率也不高。</li>\n</ul>\n</li>\n<li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li>\n</ul>\n<p><strong>垃圾回收器</strong><br>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20： G1(Garbage-First)收集器</p>\n<ul>\n<li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。</li>\n<li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。</li>\n<li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。</li>\n<li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。</li>\n<li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。</li>\n<li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。</li>\n<li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。</li>\n<li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。</li>\n</ul>\n<blockquote>\n<p>HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<ul>\n<li>部分收集 (<code>Partial GC</code>)：<ul>\n<li>新生代收集(Minor GC &#x2F; Young GC)：只对新生代进行垃圾收集；</li>\n<li>老年代收集(Major GC &#x2F; Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>\n</ul>\n</blockquote>\n<h3 id=\"为什么要进行垃圾回收\"><a href=\"#为什么要进行垃圾回收\" class=\"headerlink\" title=\"为什么要进行垃圾回收\"></a>为什么要进行垃圾回收</h3><ul>\n<li><strong>防止内存泄漏</strong>：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li>\n<li><strong>提高开发效率</strong>：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li>\n<li><strong>系统性能和稳定性</strong>：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li>\n</ul>\n<h3 id=\"强引用-软引用-弱引用-虚引用\"><a href=\"#强引用-软引用-弱引用-虚引用\" class=\"headerlink\" title=\"强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用\"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用</h3><p><a href=\"https://blog.csdn.net/u013718071/article/details/134789666\">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p>\n<ul>\n<li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li>\n<li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li>\n<li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li>\n<li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li>\n</ul>\n<p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p>\n<h3 id=\"如何判断一个类是无用的\"><a href=\"#如何判断一个类是无用的\" class=\"headerlink\" title=\"如何判断一个类是无用的\"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p>\n<h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p>\n<p>其中验证、准备、解析 3 部分统称为连接。</p>\n<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p>\n<p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流。</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>\n</ol>\n<blockquote>\n<p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p>\n</blockquote>\n<p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul>\n<li>如验证类是否有父类</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul>\n<li>如验证函数的参数是否正确</li>\n</ul>\n</li>\n<li>符号引用验证：确保解析动作能正确执行。<ul>\n<li>如验证该类要使用的其他类、方法是否存在。</li>\n</ul>\n</li>\n</ol>\n<p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p>\n<ul>\n<li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>\n<li>初始值是数据类型的默认值，如 0、null 等。</li>\n</ul>\n<p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p>\n<p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>\n<h3 id=\"类卸载\"><a href=\"#类卸载\" class=\"headerlink\" title=\"类卸载\"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p>\n<p>卸载类需要满足 3 个要求：</p>\n<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n<p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p>\n<blockquote>\n<p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p>\n</blockquote>\n<p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p>\n<p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p>\n<p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p>\n<h2 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h2>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"简历相关\"><a href=\"#简历相关\" class=\"headerlink\" title=\"简历相关\"></a>简历相关</h2><h3 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p>\n<p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p>\n<p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p>\n<h3 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h3><h3 id=\"Casbin明日之星实习\"><a href=\"#Casbin明日之星实习\" class=\"headerlink\" title=\"Casbin明日之星实习\"></a>Casbin明日之星实习</h3><ol>\n<li><p>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</p>\n</li>\n<li><p>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</p>\n</li>\n<li><p>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</p>\n</li>\n</ol>\n<h3 id=\"中科院开源之夏项目\"><a href=\"#中科院开源之夏项目\" class=\"headerlink\" title=\"中科院开源之夏项目\"></a>中科院开源之夏项目</h3><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p>\n<p><strong>项目诉求</strong></p>\n<ol>\n<li><p>对微信第三方登录的移动端支持</p>\n<ul>\n<li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li>\n</ul>\n</li>\n<li><p>对flutter、react-native、unity等sdk的开发及功能的增强</p>\n<ul>\n<li>对flutter-sdk的增强如第一点</li>\n</ul>\n</li>\n<li><p>临时加上的开发casdoor-app诉求，对标Google Authenticator</p>\n</li>\n</ol>\n<p><strong>技术细节</strong></p>\n<ol>\n<li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p>\n<ul>\n<li><p>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</p>\n</li>\n<li><p>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</p>\n</li>\n<li><p>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p>\n<ol start=\"2\">\n<li>分为两部分<ol>\n<li>casdoor-unity-example<ul>\n<li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li>\n<li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li>\n<li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li>\n<li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li>\n</ul>\n</li>\n<li>casdoor-react-native-sdk、example<ul>\n<li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li>\n<li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li>\n<li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。<ul>\n<li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li>\n<li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p>\n</blockquote>\n<p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p>\n<h3 id=\"单点登录SSO原理\"><a href=\"#单点登录SSO原理\" class=\"headerlink\" title=\"单点登录SSO原理\"></a>单点登录SSO原理</h3><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p>\n<p>在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。</p>\n<p>流程：</p>\n<ol>\n<li>用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li>\n<li>此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li>\n</ol>\n<p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p>\n<h3 id=\"OAuth-2-0原理\"><a href=\"#OAuth-2-0原理\" class=\"headerlink\" title=\"OAuth 2.0原理\"></a>OAuth 2.0原理</h3><p><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p>\n<p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。</p>\n<p>定义了4种角色：</p>\n<ul>\n<li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li>\n<li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。</li>\n<li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li>\n<li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。</li>\n<li>如果用户授权该请求，应用程序会收到授权准许(<code>Authorization Grant</code>)。</li>\n<li>应用程序通过提供其自身的身份验证和授权准许(<code>Authorization Grant</code>)来向授权服务器 (API) 请求访问令牌(<code>access_token</code>)。</li>\n<li>如果应用程序身份通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器(API)向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li>\n<li>应用程序从资源服务器(API)请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li>\n<li>如果访问令牌(<code>access_token</code>)有效，则资源服务器 (API) 向应用程序提供资源。</li>\n</ol>\n<p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p>\n<ol>\n<li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li>\n<li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li>\n<li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li>\n</ol>\n<h3 id=\"Casbin-Casdoor-介绍\"><a href=\"#Casbin-Casdoor-介绍\" class=\"headerlink\" title=\"Casbin Casdoor 介绍\"></a>Casbin Casdoor 介绍</h3><blockquote>\n<p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p>\n<ol>\n<li><strong>多种访问控制模型支持</strong>：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li>\n<li><strong>灵活的策略管理</strong>：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li>\n<li><strong>细粒度的权限控制</strong>：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li>\n<li><strong>跨语言支持</strong>：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p>\n<ol>\n<li>**单点登录(SSO)**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li>\n<li><strong>用户管理</strong>：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li>\n<li><strong>权限控制</strong>：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li>\n<li><strong>开源社区</strong>：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li>\n</ol>\n</blockquote>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><blockquote>\n<p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p>\n<ul>\n<li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li>\n<li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li>\n<li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li>\n<li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li>\n<li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li>\n<li>标准化操作：利用HTTP动词来描述对资源的操作。 </li>\n<li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li>\n<li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li>\n<li>无状态交互：每个请求独立，不依赖于之前的请求。</li>\n</ul>\n<p>优点 </p>\n<ul>\n<li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li>\n<li>性能高：无状态和可缓存性提高了性能。 </li>\n<li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li>\n<li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li>\n</ul>\n<p>缺点 </p>\n<ul>\n<li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li>\n<li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li>\n<li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li>\n</ul>\n<p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p>\n</blockquote>\n<h3 id=\"国家电网项目\"><a href=\"#国家电网项目\" class=\"headerlink\" title=\"国家电网项目\"></a>国家电网项目</h3><p><strong>简介</strong></p>\n<p>自己导师接的项目，江苏省国家电网智能诊断数据分析平台</p>\n<p><strong>项目诉求</strong></p>\n<ul>\n<li>对相应指标进行增删改查</li>\n<li>可以导入、导出一些excel表格</li>\n<li>对数据进行智能诊断分析</li>\n</ul>\n<p><strong>技术细节</strong></p>\n<p>react、Antd、Flask、mongodb</p>\n<h3 id=\"江南布衣实习\"><a href=\"#江南布衣实习\" class=\"headerlink\" title=\"江南布衣实习\"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p>\n<ol>\n<li><p><strong>新入职员工设备管理</strong>：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p>\n</li>\n<li><p><strong>离职员工设备回收和资料销毁</strong>：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p>\n</li>\n<li><p><strong>订货会期间设备组装和网络连接</strong>：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p>\n</li>\n<li><p><strong>员工设备报修响应与问题解决</strong>：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p>\n</li>\n</ol>\n<p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p>\n<blockquote>\n<p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p>\n<ol>\n<li><strong>网络配置</strong>：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li>\n<li><strong>身份验证</strong>：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li>\n<li><strong>访问内部资源</strong>：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li>\n</ol>\n</blockquote>\n<h3 id=\"印象最深的一个项目\"><a href=\"#印象最深的一个项目\" class=\"headerlink\" title=\"印象最深的一个项目\"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p>\n<p><strong>亮点</strong></p>\n<ol>\n<li><p><strong>异步支持</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li>\n<li><strong>回答</strong>：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li>\n</ul>\n</li>\n<li><p><strong>灵活的过滤机制</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li>\n<li><strong>回答</strong>：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li>\n</ul>\n</li>\n<li><p><strong>可扩展性</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li>\n<li><strong>回答</strong>：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li>\n</ul>\n</li>\n<li><p><strong>事务处理</strong>：</p>\n<ul>\n<li><strong>亮点</strong>：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li>\n<li><strong>回答</strong>：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>难点</strong></p>\n<ol>\n<li><strong>异步编程的复杂性</strong>：<ul>\n<li><strong>难点</strong>：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li>\n<li><strong>回答</strong>：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li>\n</ul>\n</li>\n<li><strong>数据库模型的灵活性与一致性</strong>：<ul>\n<li><strong>难点</strong>：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li>\n<li><strong>回答</strong>：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li>\n</ul>\n</li>\n<li><strong>复杂的策略更新逻辑</strong>：<ul>\n<li><strong>难点</strong>：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li>\n<li><strong>回答</strong>：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li>\n</ul>\n</li>\n<li><strong>高效的批量操作</strong>：<ul>\n<li><strong>难点</strong>：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li>\n<li><strong>回答</strong>：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li>\n</ul>\n</li>\n</ol>\n<p>测试方面</p>\n<ul>\n<li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li>\n<li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li>\n</ul>\n<p>技术细节</p>\n<ul>\n<li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li>\n<li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul>\n<li>测试添加一个策略，添加多个策略</li>\n<li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li>\n<li>测试更新一个策略，测试更新多个策略。</li>\n</ul>\n</li>\n</ul>\n<p>通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p>\n<h2 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h2><h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li>\n<li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li>\n<li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li>\n</ul>\n<blockquote>\n<p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p>\n</blockquote>\n<h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p><code>&lt;&lt;</code>：左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>：无符号右移，忽略符号位，空位都以 0 补齐。</p>\n<p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>\n<p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p>\n<h3 id=\"基本数据类型-包装类型-及区别\"><a href=\"#基本数据类型-包装类型-及区别\" class=\"headerlink\" title=\"基本数据类型&#x2F;包装类型 及区别\"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p>\n<ul>\n<li>6 种数字类型： <ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code></li>\n</ul>\n<blockquote>\n<p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>： 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>： 双引号。</p>\n</blockquote>\n<p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<p><strong>区别</strong></p>\n<ul>\n<li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li>\n<li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li>\n<li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li>\n<li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>\n<li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>\n</ul>\n<h3 id=\"包装类的缓存机制\"><a href=\"#包装类的缓存机制\" class=\"headerlink\" title=\"包装类的缓存机制\"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>\n<h3 id=\"什么是自动拆装箱\"><a href=\"#什么是自动拆装箱\" class=\"headerlink\" title=\"什么是自动拆装箱\"></a>什么是自动拆装箱</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;  <span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> i;   <span class=\"comment\">//拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>装箱：将基本类型用它们对应的引用类型包装起来；</li>\n<li>拆箱：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p>\n<h3 id=\"如何解决浮点数运算的精度丢失问题\"><a href=\"#如何解决浮点数运算的精度丢失问题\" class=\"headerlink\" title=\"如何解决浮点数运算的精度丢失问题\"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p>\n<h3 id=\"局部变量-成员变量-静态变量\"><a href=\"#局部变量-成员变量-静态变量\" class=\"headerlink\" title=\"局部变量&#x2F;成员变量&#x2F;静态变量\"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul>\n<li>语法形式：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>\n<li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>\n<li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>\n<li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li>\n</ul>\n<p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><ul>\n<li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>\n<li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul>\n<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面向对象和面向过程区别\"><a href=\"#面向对象和面向过程区别\" class=\"headerlink\" title=\"面向对象和面向过程区别\"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3 id=\"接口和抽象类区别\"><a href=\"#接口和抽象类区别\" class=\"headerlink\" title=\"接口和抽象类区别\"></a>接口和抽象类区别</h3><p>共同点： 都不能被实例化<br><a href=\"https://learn.skyofit.com/archives/351\">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p>\n<ul>\n<li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li>\n<li>抽象类可以有构造方法，接口不能有构造方法。</li>\n<li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li>\n<li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li>\n<li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li>\n<li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li>\n</ul>\n<h3 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h3><p><a href=\"https://blog.csdn.net/qq_44944221/article/details/126692973\">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p>\n<ul>\n<li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li>\n<li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li>\n<li>共享性不同：栈是线程私有，而堆是线程共享；</li>\n<li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li>\n<li>空间大小不同：堆空间大小远远大于栈的内存空间。</li>\n</ul>\n<h3 id=\"深拷贝-浅拷贝-引用拷贝\"><a href=\"#深拷贝-浅拷贝-引用拷贝\" class=\"headerlink\" title=\"深拷贝&#x2F;浅拷贝&#x2F;引用拷贝\"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul>\n<li>深拷贝： 完全复制整个对象，包括这个对象所包含的内部对象。</li>\n<li>浅拷贝： 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li>引用拷贝： 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li>\n</ul>\n<h3 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notify</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyAll</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">(<span class=\"type\">long</span> timeout, <span class=\"type\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><ul>\n<li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li>\n<li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li>\n<li>线程安全的懒汉式<ul>\n<li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li>\n<li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li>\n</ul>\n</li>\n<li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li>\n<li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 饿汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒汉式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-同步方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\">    <span class=\"comment\">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class=\"line\">                <span class=\"comment\">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(getInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonHolder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意 上面不是 class 是 enum</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singelton</span> <span class=\"variable\">singleton</span> <span class=\"operator\">=</span> Singleton.INSTANCE;</span><br><span class=\"line\">        singleton.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"形参-实参\"><a href=\"#形参-实参\" class=\"headerlink\" title=\"形参&amp;实参\"></a>形参&amp;实参</h3><ul>\n<li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li>\n<li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li>\n</ul>\n<h3 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递&amp;引用传递\"></a>值传递&amp;引用传递</h3><ul>\n<li>值传递：方法接收的是实参值的拷贝，会创建副本。</li>\n<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p>Java 中只有值传递，C++ 中有值传递和引用传递。</p>\n<h3 id=\"和equals-区别\"><a href=\"#和equals-区别\" class=\"headerlink\" title=\"&#x3D;&#x3D;和equals()区别\"></a>&#x3D;&#x3D;和equals()区别</h3><ul>\n<li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul>\n<li>基本数据类型：比较的是值是否相等</li>\n<li>引用数据类型：比较的是引用地址是否相等</li>\n<li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li>\n</ul>\n</li>\n<li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul>\n<li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li>\n<li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hashCode-和equal\"><a href=\"#hashCode-和equal\" class=\"headerlink\" title=\"hashCode()和equal()\"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>\n<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li>\n</ul>\n<p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<h3 id=\"String-StringBuffer-StringBuilder\"><a href=\"#String-StringBuffer-StringBuilder\" class=\"headerlink\" title=\"String&#x2F;StringBuffer&#x2F;StringBuilder\"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul>\n<li><p><code>String</code> ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuffer</code> ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p>\n</li>\n<li><p><code>StringBuilder</code> ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p>\n</li>\n<li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p>\n</li>\n<li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p>\n</li>\n<li><p><code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n</li>\n</ul>\n<p>** <code>String</code> 为什么不可变？**</p>\n<ul>\n<li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ul>\n<h3 id=\"字符串拼接使用-还是StringBuilder？\"><a href=\"#字符串拼接使用-还是StringBuilder？\" class=\"headerlink\" title=\"字符串拼接使用+还是StringBuilder？\"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p>\n<h3 id=\"String-equals-Object-equals\"><a href=\"#String-equals-Object-equals\" class=\"headerlink\" title=\"String.equals()&#x2F;Object.equals()\"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>： 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>： 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p>\n<h3 id=\"Checked-Unchecked-Exception\"><a href=\"#Checked-Unchecked-Exception\" class=\"headerlink\" title=\"Checked&#x2F;Unchecked Exception\"></a>Checked&#x2F;Unchecked Exception</h3><ul>\n<li><code>Checked Exception</code>即受检查异常 ，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<ul>\n<li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li>\n</ul>\n</li>\n<li><code>Unchecked Exception</code> 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。<ul>\n<li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"try-catch-finally\"><a href=\"#try-catch-finally\" class=\"headerlink\" title=\"try-catch-finally\"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>\n<blockquote>\n<p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p>\n</blockquote>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><ul>\n<li>使用泛型参数，可以增强代码的可读性以及稳定性。</li>\n<li>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</li>\n</ul>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>\n<ul>\n<li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>\n<li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>\n</ul>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h3 id=\"序列化-反序列化\"><a href=\"#序列化-反序列化\" class=\"headerlink\" title=\"序列化&#x2F;反序列化\"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<ul>\n<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>\n<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p>\n<p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p>\n<h2 id=\"Java集合\"><a href=\"#Java集合\" class=\"headerlink\" title=\"Java集合\"></a>Java集合</h2><h3 id=\"List-Set-Queue-Map区别\"><a href=\"#List-Set-Queue-Map区别\" class=\"headerlink\" title=\"List&#x2F;Set&#x2F;Queue&#x2F;Map区别\"></a>List&#x2F;Set&#x2F;Queue&#x2F;Map区别</h3><ul>\n<li>List： 存储的元素是有序的、可重复的。</li>\n<li>Set： 存储的元素不可重复的。</li>\n<li>Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>\n<li>Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>\n</ul>\n<h3 id=\"如何选用集合\"><a href=\"#如何选用集合\" class=\"headerlink\" title=\"如何选用集合?\"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p>\n<ul>\n<li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</li>\n<li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li>\n</ul>\n<h3 id=\"为什么要使用集合？\"><a href=\"#为什么要使用集合？\" class=\"headerlink\" title=\"为什么要使用集合？\"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>\n<h3 id=\"ArrayList和Array区别\"><a href=\"#ArrayList和Array区别\" class=\"headerlink\" title=\"ArrayList和Array区别\"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p>\n<ul>\n<li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li>\n<li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li>\n<li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li>\n<li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li>\n<li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li>\n</ul>\n<blockquote>\n<p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList区别\"><a href=\"#ArrayList和LinkedList区别\" class=\"headerlink\" title=\"ArrayList和LinkedList区别\"></a>ArrayList和LinkedList区别</h3><ul>\n<li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul>\n<li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li>\n<li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li>二者都是线程不安全的。</li>\n<li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li>\n<li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li>\n</ul>\n<blockquote>\n<p>项目中一般不会使用 <code>LinkedList</code>。</p>\n</blockquote>\n<h3 id=\"ArrayList和LinkedList插入-删除效率\"><a href=\"#ArrayList和LinkedList插入-删除效率\" class=\"headerlink\" title=\"ArrayList和LinkedList插入&#x2F;删除效率\"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p>\n<ul>\n<li>头部插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要移动元素。</li>\n<li>尾部插入&#x2F;删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。<br><code>LinkedList</code></li>\n<li>头部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>尾部插入&#x2F;删除：O(1), 只需改变指针指向。</li>\n<li>指定位置插入&#x2F;删除：O(n), 需要先移动到指定位置再插入和删除。</li>\n</ul>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p>\n<ul>\n<li><strong>读多写少</strong>：大部分操作都是读取数据，写操作相对较少。</li>\n<li><strong>不要求实时性</strong>：因为写操作需要创建数组副本，可能会有短暂的延迟。</li>\n</ul>\n<p><code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li><strong>线程安全</strong>：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li>\n<li><strong>简化并发控制</strong>：不需要显式的同步块或锁定机制。</li>\n<li><strong>迭代器安全</strong>：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li><strong>内存开销大</strong>：每次写操作都会创建数组副本，可能会占用较多的内存。</li>\n<li><strong>写操作开销大</strong>：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li>\n<li><strong>读取旧数据</strong>：在高并发场景下，可能会读取到旧的数据。</li>\n</ul>\n<p><strong>适用场景</strong></p>\n<ul>\n<li>配置类数据：如系统配置参数、常量集合等。</li>\n<li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li>\n</ul>\n<p><strong>不适用场景</strong></p>\n<ul>\n<li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li>\n<li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li>\n</ul>\n<p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p>\n<h3 id=\"HashSet-LinkedHashSet-TreeSet\"><a href=\"#HashSet-LinkedHashSet-TreeSet\" class=\"headerlink\" title=\"HashSet&#x2F;LinkedHashSet&#x2F;TreeSet\"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul>\n<li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li>\n<li>主要区别在于底层数据结构不同。<ul>\n<li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li>\n<li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>\n<li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>\n</ul>\n</li>\n<li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>\n</ul>\n<h3 id=\"Map-重要\"><a href=\"#Map-重要\" class=\"headerlink\" title=\"Map(重要)\"></a>Map(重要)</h3><h3 id=\"HashMap-HashTable区别\"><a href=\"#HashMap-HashTable区别\" class=\"headerlink\" title=\"HashMap&#x2F;HashTable区别\"></a>HashMap&#x2F;HashTable区别</h3><ul>\n<li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li>\n<li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li>\n<li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li>\n<li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和value，否则会报错<code>NullPointerException</code>。</li>\n<li>初始容量大小和每次扩充容量大小的不同： <ul>\n<li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li>\n<li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p>\n</blockquote>\n<h3 id=\"HashMap长度为什么是2的幂次方\"><a href=\"#HashMap长度为什么是2的幂次方\" class=\"headerlink\" title=\"HashMap长度为什么是2的幂次方\"></a>HashMap长度为什么是2的幂次方</h3><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p>\n<p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p>\n<h3 id=\"HashMap-TreeMap区别\"><a href=\"#HashMap-TreeMap区别\" class=\"headerlink\" title=\"HashMap&#x2F;TreeMap区别\"></a>HashMap&#x2F;TreeMap区别</h3><ul>\n<li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li>\n<li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li>\n<li><code>HashMap</code> 的键值对允许有一个 <code>null</code> 键和多个 <code>null</code> 值，<code>TreeMap</code> 不允许有 <code>null</code> 键，但允许有 <code>null</code> 值。</li>\n<li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li>\n</ul>\n<p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>\n<h3 id=\"HashSet如何检查重复\"><a href=\"#HashSet如何检查重复\" class=\"headerlink\" title=\"HashSet如何检查重复\"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>\n<p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。</p>\n<h3 id=\"HashMap底层实现\"><a href=\"#HashMap底层实现\" class=\"headerlink\" title=\"HashMap底层实现\"></a>HashMap底层实现</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p>\n<p><code>HashMap</code> 通过 key 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p>\n<ul>\n<li>扰动函数 <code>hash()</code> 可以减少碰撞。</li>\n<li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>\n<li>“拉链法”中，数组的 index 就是通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li>\n</ul>\n<p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p>\n<ul>\n<li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li>\n<li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li>\n</ul>\n<h3 id=\"HashMap多线程扩容死循环问题\"><a href=\"#HashMap多线程扩容死循环问题\" class=\"headerlink\" title=\"HashMap多线程扩容死循环问题\"></a>HashMap多线程扩容死循环问题</h3><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>\n<p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p>\n<blockquote>\n<p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p>\n</blockquote>\n<h3 id=\"HashMap为什么线程不安全\"><a href=\"#HashMap为什么线程不安全\" class=\"headerlink\" title=\"HashMap为什么线程不安全\"></a>HashMap为什么线程不安全</h3><ul>\n<li>JDK1.7及之前版本，存在多线程扩容死循环问题，如上。</li>\n<li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。</li>\n</ul>\n<p><strong>数据丢失</strong><br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p>\n<blockquote>\n<p>例子：<br>线程 1,2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>\n</blockquote>\n<h3 id=\"遍历HashMap\"><a href=\"#遍历HashMap\" class=\"headerlink\" title=\"遍历HashMap\"></a>遍历HashMap</h3><p>七种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// ForEach EntrySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ForEach KeySet</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Integer key : map.keySet()) &#123;</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器EntrySet</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器KeySet</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">    System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(key);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 单线程</span></span><br><span class=\"line\">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Streams API 多线程</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-Hashtable区别\"><a href=\"#ConcurrentHashMap-Hashtable区别\" class=\"headerlink\" title=\"ConcurrentHashMap&#x2F;Hashtable区别\"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul>\n<li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong> 。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li>\n<li>实现线程安全的方式：<ul>\n<li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li>\n<li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li><code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConcurrentHashMap底层\"><a href=\"#ConcurrentHashMap底层\" class=\"headerlink\" title=\"ConcurrentHashMap底层\"></a>ConcurrentHashMap底层</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为**<code>Segment</code>数组+<code>HashEntry</code>数组+链表** 。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>\n<p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p>\n<p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，**<code>Node</code>数组+链表&#x2F;红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p>\n<h3 id=\"JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\"><a href=\"#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？\" class=\"headerlink\" title=\"JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？\"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul>\n<li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>\n<li>Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li>\n<li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li>\n</ul>\n<h3 id=\"ConcurrentHashMap能保证复合操作的原子性吗？\"><a href=\"#ConcurrentHashMap能保证复合操作的原子性吗？\" class=\"headerlink\" title=\"ConcurrentHashMap能保证复合操作的原子性吗？\"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul>\n<li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li>\n<li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li>\n</ul>\n<h3 id=\"什么是LinkedHashMap\"><a href=\"#什么是LinkedHashMap\" class=\"headerlink\" title=\"什么是LinkedHashMap\"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性：</p>\n<ul>\n<li>支持遍历时会按照插入顺序有序进行迭代</li>\n<li>支持按照元素访问顺序排序,<em><strong>适用于封装 LRU 缓存工具</strong></em> 。</li>\n<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li>\n</ul>\n<blockquote>\n<p>在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>\n</blockquote>\n<h3 id=\"LinkedHashMap如何按照访问顺序迭代元素？\"><a href=\"#LinkedHashMap如何按照访问顺序迭代元素？\" class=\"headerlink\" title=\"LinkedHashMap如何按照访问顺序迭代元素？\"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>\n<h3 id=\"如何实现LRU缓存\"><a href=\"#如何实现LRU缓存\" class=\"headerlink\" title=\"如何实现LRU缓存\"></a>如何实现LRU缓存</h3><ul>\n<li><code>accessOrder</code> &#x3D; <code>true</code> </li>\n<li>继承<code>LinkedHashMap</code></li>\n<li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(capacity, <span class=\"number\">1f</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"LinkedHashMap和HashMap的区别\"><a href=\"#LinkedHashMap和HashMap的区别\" class=\"headerlink\" title=\"LinkedHashMap和HashMap的区别\"></a>LinkedHashMap和HashMap的区别</h3><ul>\n<li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li>\n<li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li>\n</ul>\n<h3 id=\"Queue-Deque区别\"><a href=\"#Queue-Deque区别\" class=\"headerlink\" title=\"Queue&#x2F;Deque区别\"></a>Queue&#x2F;Deque区别</h3><ul>\n<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li>\n<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li>\n</ul>\n<h3 id=\"ArrayDeque-LinkedList区别\"><a href=\"#ArrayDeque-LinkedList区别\" class=\"headerlink\" title=\"ArrayDeque&#x2F;LinkedList区别\"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul>\n<li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li>\n<li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li>\n<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li>\n</ul>\n<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>\n<h3 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>\n<ul>\n<li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>\n<li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>\n<li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>\n<li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>\n</ul>\n<blockquote>\n<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>\n</blockquote>\n<h3 id=\"BlockingQueue及其实现类\"><a href=\"#BlockingQueue及其实现类\" class=\"headerlink\" title=\"BlockingQueue及其实现类\"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p>\n<p><strong>实现类</strong></p>\n<ul>\n<li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>\n<li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。</li>\n<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li>\n<li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li>\n<li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h3><ul>\n<li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li>\n<li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li>\n<li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue实现原理\"><a href=\"#ArrayBlockingQueue实现原理\" class=\"headerlink\" title=\"ArrayBlockingQueue实现原理\"></a>ArrayBlockingQueue实现原理</h3><ul>\n<li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li>\n<li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li>\n<li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li>\n</ul>\n<p>线程间的等待和唤醒具体的实现：</p>\n<ul>\n<li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li>\n<li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li>\n<li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li>\n<li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li>\n</ul>\n<h3 id=\"ArrayBlockingQueue-LinkedBlockingQueue区别\"><a href=\"#ArrayBlockingQueue-LinkedBlockingQueue区别\" class=\"headerlink\" title=\"ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别\"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p>\n<ul>\n<li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li>\n<li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>\n<li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li>\n<li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li>\n</ul>\n<h3 id=\"DelayQueue底层\"><a href=\"#DelayQueue底层\" class=\"headerlink\" title=\"DelayQueue底层\"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p>\n<p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可重入锁，实现线程安全的关键</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">//指向准备执行优先级最高的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Thread</span> <span class=\"variable\">leader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//实现多线程之间等待唤醒的交互</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>\n<p><code>leader</code> ： 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code> ： 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p>\n</blockquote>\n<h3 id=\"DelayQueue是否线程安全？\"><a href=\"#DelayQueue是否线程安全？\" class=\"headerlink\" title=\"DelayQueue是否线程安全？\"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>\n<h3 id=\"DelayQueue使用场景\"><a href=\"#DelayQueue使用场景\" class=\"headerlink\" title=\"DelayQueue使用场景\"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p>\n<ul>\n<li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li>\n<li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li>\n</ul>\n<h3 id=\"DelayQueue中Delayed接口的作用是什么？\"><a href=\"#DelayQueue中Delayed接口的作用是什么？\" class=\"headerlink\" title=\"DelayQueue中Delayed接口的作用是什么？\"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口),否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>\n<h3 id=\"DelayQueue-Timer-TimerTask区别\"><a href=\"#DelayQueue-Timer-TimerTask区别\" class=\"headerlink\" title=\"DelayQueue&#x2F;Timer&#x2F;TimerTask区别\"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p>\n<ul>\n<li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li>\n<li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li>\n<li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li>\n</ul>\n<h2 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程&#x2F;线程&#x2F;协程\"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href=\"https://blog.csdn.net/m0_60505735/article/details/131047046\">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href=\"https://blog.csdn.net/weixin_49199646/article/details/109210547\">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p>\n<ul>\n<li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li>\n<li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>\n<li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li>\n</ul>\n<p><strong>进程与线程的区别</strong></p>\n<ul>\n<li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li>\n<li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li>\n<li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li>\n</ul>\n<p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p>\n<p><em>进程与线程的选择</em>*</p>\n<ul>\n<li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li>\n<li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li>\n<li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li>\n<li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li>\n</ul>\n<p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p>\n<h3 id=\"Java线程和操作系统线程有何区别\"><a href=\"#Java线程和操作系统线程有何区别\" class=\"headerlink\" title=\"Java线程和操作系统线程有何区别\"></a>Java线程和操作系统线程有何区别</h3><p>现在的 Java 线程的本质其实就是操作系统的线程。</p>\n<ul>\n<li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li>\n<li>JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li>\n</ul>\n<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p>\n<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p>\n<h3 id=\"程序计数器为啥是私有的\"><a href=\"#程序计数器为啥是私有的\" class=\"headerlink\" title=\"程序计数器为啥是私有的\"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n<li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li>\n</ul>\n<p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p>\n<h3 id=\"虚拟机栈和本地方法栈为啥是私有的\"><a href=\"#虚拟机栈和本地方法栈为啥是私有的\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈为啥是私有的\"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul>\n<li>虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>\n<li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>\n</ul>\n<p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3 id=\"一句话简单了解堆和方法区\"><a href=\"#一句话简单了解堆和方法区\" class=\"headerlink\" title=\"一句话简单了解堆和方法区\"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h3 id=\"如何创建线程\"><a href=\"#如何创建线程\" class=\"headerlink\" title=\"如何创建线程\"></a>如何创建线程</h3><ul>\n<li>继承<code>Thread</code>类并重写<code>run()</code>方法</li>\n<li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li>\n<li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li>\n<li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li>\n<li>等等……</li>\n</ul>\n<p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p>\n<h3 id=\"线程的生命周期和状态\"><a href=\"#线程的生命周期和状态\" class=\"headerlink\" title=\"线程的生命周期和状态\"></a>线程的生命周期和状态</h3><p>Java 线程 6 种状态：<br><code>NEW</code>： 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>： 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>\n<h3 id=\"线程上下文切换\"><a href=\"#线程上下文切换\" class=\"headerlink\" title=\"线程上下文切换\"></a>线程上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>\n<ul>\n<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>\n<li>时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n</ul>\n<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>\n<h3 id=\"Thread-sleep-方法和Object-wait-方法对比\"><a href=\"#Thread-sleep-方法和Object-wait-方法对比\" class=\"headerlink\" title=\"Thread.sleep()方法和Object.wait()方法对比\"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p>\n<ul>\n<li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁 。</li>\n<li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li>\n<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li>\n<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li>\n</ul>\n<h3 id=\"锁的基本概念\"><a href=\"#锁的基本概念\" class=\"headerlink\" title=\"锁的基本概念\"></a>锁的基本概念</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p>\n<h3 id=\"为什么wait-方法不定义在Thread中\"><a href=\"#为什么wait-方法不定义在Thread中\" class=\"headerlink\" title=\"为什么wait()方法不定义在Thread中\"></a>为什么wait()方法不定义在Thread中</h3><ul>\n<li>锁是对象级别的，每个对象都有一把锁。</li>\n<li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li>\n</ul>\n<h3 id=\"为什么sleep-方法定义在Thread中\"><a href=\"#为什么sleep-方法定义在Thread中\" class=\"headerlink\" title=\"为什么sleep()方法定义在Thread中\"></a>为什么sleep()方法定义在Thread中</h3><ul>\n<li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li>\n<li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li>\n</ul>\n<h3 id=\"sleep-如何控制当前线程沉睡\"><a href=\"#sleep-如何控制当前线程沉睡\" class=\"headerlink\" title=\"sleep()如何控制当前线程沉睡\"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p>\n<h3 id=\"可以直接调用Thread类的run方法吗\"><a href=\"#可以直接调用Thread类的run方法吗\" class=\"headerlink\" title=\"可以直接调用Thread类的run方法吗\"></a>可以直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p>\n<h3 id=\"并发-并行区别\"><a href=\"#并发-并行区别\" class=\"headerlink\" title=\"并发&#x2F;并行区别\"></a>并发&#x2F;并行区别</h3><ul>\n<li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<h3 id=\"同步-异步区别\"><a href=\"#同步-异步区别\" class=\"headerlink\" title=\"同步&#x2F;异步区别\"></a>同步&#x2F;异步区别</h3><ul>\n<li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>\n<li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li>\n</ul>\n<h3 id=\"为什么要使用多线程\"><a href=\"#为什么要使用多线程\" class=\"headerlink\" title=\"为什么要使用多线程\"></a>为什么要使用多线程</h3><ul>\n<li>线程切换和调度的成本远远小于进程。</li>\n<li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li>\n<li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li>\n<li>并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。</li>\n</ul>\n<h3 id=\"使用多线程风险\"><a href=\"#使用多线程风险\" class=\"headerlink\" title=\"使用多线程风险\"></a>使用多线程风险</h3><ul>\n<li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li>\n<li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li>\n<li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li>\n<li>上下文切换：线程频繁切换，会增加系统开销。</li>\n<li>…</li>\n</ul>\n<h3 id=\"如何理解线程安全和不安全\"><a href=\"#如何理解线程安全和不安全\" class=\"headerlink\" title=\"如何理解线程安全和不安全\"></a>如何理解线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p>\n<ul>\n<li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>\n<li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>\n</ul>\n<h3 id=\"单核CPU上运行多个线程效率一定会高吗\"><a href=\"#单核CPU上运行多个线程效率一定会高吗\" class=\"headerlink\" title=\"单核CPU上运行多个线程效率一定会高吗\"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<blockquote>\n<p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n</blockquote>\n<p>产生死锁的四个必要条件：</p>\n<ul>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"如何检测死锁\"><a href=\"#如何检测死锁\" class=\"headerlink\" title=\"如何检测死锁\"></a>如何检测死锁</h3><ul>\n<li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li>\n<li>jConsole： 可以检测死锁，查看线程的状态。</li>\n<li>jstack： 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li>\n</ul>\n<h3 id=\"如何预防和避免死锁\"><a href=\"#如何预防和避免死锁\" class=\"headerlink\" title=\"如何预防和避免死锁\"></a>如何预防和避免死锁</h3><p>破坏死锁的产生的必要条件：</p>\n<ul>\n<li>破坏请求与保持条件：一次性申请所有的资源。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ul>\n<p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong> )对资源分配进行计算评估，使其进入安全状态。</p>\n<blockquote>\n<p>安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</p>\n</blockquote>\n<h3 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>\n<h3 id=\"为什么需要Java内存模型\"><a href=\"#为什么需要Java内存模型\" class=\"headerlink\" title=\"为什么需要Java内存模型\"></a>为什么需要Java内存模型</h3><ul>\n<li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li>\n<li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li>\n<li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li>\n</ul>\n<h3 id=\"Java内存区域和Java内存模型有什么区别\"><a href=\"#Java内存区域和Java内存模型有什么区别\" class=\"headerlink\" title=\"Java内存区域和Java内存模型有什么区别\"></a>Java内存区域和Java内存模型有什么区别</h3><ul>\n<li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li>\n<li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li>\n</ul>\n<h3 id=\"JMM是如何抽象线程和主内存之间的关系\"><a href=\"#JMM是如何抽象线程和主内存之间的关系\" class=\"headerlink\" title=\"JMM是如何抽象线程和主内存之间的关系\"></a>JMM是如何抽象线程和主内存之间的关系</h3><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。</p>\n<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li>\n<li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li>\n</ul>\n<h3 id=\"并发编程三大特性\"><a href=\"#并发编程三大特性\" class=\"headerlink\" title=\"并发编程三大特性\"></a>并发编程三大特性</h3><p>可见性、原子性和有序性</p>\n<ul>\n<li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li>\n<li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li>\n<li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li>\n</ul>\n<p>JMM通过上面三种属性来确保线程之间的内存一致性。</p>\n<h3 id=\"如何保证变量的可见性-volatile\"><a href=\"#如何保证变量的可见性-volatile\" class=\"headerlink\" title=\"如何保证变量的可见性(volatile)\"></a>如何保证变量的可见性(volatile)</h3><p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3 id=\"如何禁止指令重排序\"><a href=\"#如何禁止指令重排序\" class=\"headerlink\" title=\"如何禁止指令重排序\"></a>如何禁止指令重排序</h3><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p>\n<h3 id=\"volatile可以保证原子性\"><a href=\"#volatile可以保证原子性\" class=\"headerlink\" title=\"volatile可以保证原子性\"></a>volatile可以保证原子性</h3><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>\n<h3 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁&#x2F;悲观锁\"></a>乐观锁&#x2F;悲观锁</h3><ul>\n<li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul>\n<li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li>\n<li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li>\n<li>悲观锁可能会存在死锁问题。</li>\n<li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>\n</ul>\n</li>\n<li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul>\n<li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li>\n<li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li>\n<li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul>\n<li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li>\n</ul>\n</li>\n<li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何实现乐观锁\"><a href=\"#如何实现乐观锁\" class=\"headerlink\" title=\"如何实现乐观锁\"></a>如何实现乐观锁</h3><ul>\n<li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li>\n<li>CAS算法：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul>\n<li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n</blockquote>\n<h3 id=\"CAS算法存在问题\"><a href=\"#CAS算法存在问题\" class=\"headerlink\" title=\"CAS算法存在问题\"></a>CAS算法存在问题</h3><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>\n<p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p>\n<p><strong>循环时间长开销大</strong><br>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p>\n<p><strong>只能保证一个共享变量的原子操作</strong><br>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p>\n<h3 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h3><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>\n<h3 id=\"JDK1-6之后synchronized的优化\"><a href=\"#JDK1-6之后synchronized的优化\" class=\"headerlink\" title=\"JDK1.6之后synchronized的优化\"></a>JDK1.6之后synchronized的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p>\n<h3 id=\"锁升级原理了解吗\"><a href=\"#锁升级原理了解吗\" class=\"headerlink\" title=\"锁升级原理了解吗\"></a>锁升级原理了解吗</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<h3 id=\"如何使用synchronized\"><a href=\"#如何使用synchronized\" class=\"headerlink\" title=\"如何使用synchronized\"></a>如何使用synchronized</h3><ul>\n<li>修饰实例方法：锁住当前实例对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰静态方法：锁住当前类的 Class 对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修饰代码块：锁住括号里面的对象。<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(对象) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">synchronized(类.class) &#123;</span><br><span class=\"line\">    //业务代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized底层原理\"><a href=\"#synchronized底层原理\" class=\"headerlink\" title=\"synchronized底层原理\"></a>synchronized底层原理</h3><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p>\n<ul>\n<li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li>\n<li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li>\n</ul>\n<p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>\n<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>\n<h3 id=\"AQS核心思想\"><a href=\"#AQS核心思想\" class=\"headerlink\" title=\"AQS核心思想\"></a>AQS核心思想</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p>\n<p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p>\n<blockquote>\n<p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p>\n</blockquote>\n<h3 id=\"AQS资源共享模式\"><a href=\"#AQS资源共享模式\" class=\"headerlink\" title=\"AQS资源共享模式\"></a>AQS资源共享模式</h3><p>AQS 支持两种资源共享方式：独占和共享。</p>\n<ul>\n<li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li>\n<li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li>\n</ul>\n<blockquote>\n<p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p>\n</blockquote>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p>\n<h3 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁&#x2F;非公平锁\"></a>公平锁&#x2F;非公平锁</h3><ul>\n<li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n<li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>\n</ul>\n<h3 id=\"synchronized和ReentrantLock有什么区别？\"><a href=\"#synchronized和ReentrantLock有什么区别？\" class=\"headerlink\" title=\"synchronized和ReentrantLock有什么区别？\"></a>synchronized和ReentrantLock有什么区别？</h3><p>两者都是可重入锁</p>\n<ul>\n<li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li>\n<li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li>\n<li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：<ul>\n<li>等待可中断 ： <code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li>\n<li>可实现公平锁： <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>\n<li>可实现选择性通知(锁可以绑定多个条件)： <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>\n</blockquote>\n<h3 id=\"可中断锁-不可中断锁\"><a href=\"#可中断锁-不可中断锁\" class=\"headerlink\" title=\"可中断锁&#x2F;不可中断锁\"></a>可中断锁&#x2F;不可中断锁</h3><ul>\n<li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li>\n<li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li>\n</ul>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>\n<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁) 。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>\n<blockquote>\n<p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p>\n</blockquote>\n<h3 id=\"共享锁-独占锁\"><a href=\"#共享锁-独占锁\" class=\"headerlink\" title=\"共享锁&#x2F;独占锁\"></a>共享锁&#x2F;独占锁</h3><ul>\n<li>共享锁：一把锁可以被多个线程同时获得。</li>\n<li>独占锁：一把锁只能被一个线程获得。</li>\n</ul>\n<h3 id=\"线程持有读锁还能获取写锁吗\"><a href=\"#线程持有读锁还能获取写锁吗\" class=\"headerlink\" title=\"线程持有读锁还能获取写锁吗\"></a>线程持有读锁还能获取写锁吗</h3><ul>\n<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>\n<li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li>\n</ul>\n<h3 id=\"读锁为什么不能升级为写锁\"><a href=\"#读锁为什么不能升级为写锁\" class=\"headerlink\" title=\"读锁为什么不能升级为写锁\"></a>读锁为什么不能升级为写锁</h3><ul>\n<li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li>\n<li>可能会有死锁问题发生。</li>\n</ul>\n<h3 id=\"StampedLock\"><a href=\"#StampedLock\" class=\"headerlink\" title=\"StampedLock\"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p>\n<p>提供三种访问模式：</p>\n<ul>\n<li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。</li>\n<li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。</li>\n<li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li>\n</ul>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>\n<h3 id=\"ThreadLocal原理\"><a href=\"#ThreadLocal原理\" class=\"headerlink\" title=\"ThreadLocal原理\"></a>ThreadLocal原理</h3><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p>\n<blockquote>\n<p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p>\n</blockquote>\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>\n<p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>\n<blockquote>\n<p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p>\n</blockquote>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>\n<h3 id=\"为什么用线程池\"><a href=\"#为什么用线程池\" class=\"headerlink\" title=\"为什么用线程池\"></a>为什么用线程池</h3><ul>\n<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<blockquote>\n<p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<h3 id=\"创建线程池的方式\"><a href=\"#创建线程池的方式\" class=\"headerlink\" title=\"创建线程池的方式\"></a>创建线程池的方式</h3><ul>\n<li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li>\n<li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul>\n<li><code>FixedThreadPool</code>：固定大小的线程池。</li>\n<li><code>SingleThreadPool</code>：只有一个线程的线程池。</li>\n<li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li>\n<li><code>ScheduledThreadPool</code>：定时任务的线程池。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么不推荐使用内置线程池\"><a href=\"#为什么不推荐使用内置线程池\" class=\"headerlink\" title=\"为什么不推荐使用内置线程池\"></a>为什么不推荐使用内置线程池</h3><ul>\n<li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li>\n<li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor参数\"><a href=\"#ThreadPoolExecutor参数\" class=\"headerlink\" title=\"ThreadPoolExecutor参数\"></a>ThreadPoolExecutor参数</h3><p>3 个最重要的参数：</p>\n<ul>\n<li><code>corePoolSize</code> ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>\n<li><code>maximumPoolSize</code> ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>\n<li><code>workQueue</code>： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>\n</ul>\n<p>其他常见参数 ：</p>\n<ul>\n<li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li>\n<li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li>\n<li><code>threadFactory</code> ：<code>executor</code> 创建新线程的时候会用到。</li>\n<li><code>handler</code> ：拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li>\n</ul>\n<h3 id=\"线程池的拒绝策略\"><a href=\"#线程池的拒绝策略\" class=\"headerlink\" title=\"线程池的拒绝策略\"></a>线程池的拒绝策略</h3><ul>\n<li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li>\n<li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li>\n<li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li>\n<li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>\n</ul>\n<h3 id=\"CallerRunsPolicy策略风险及解决方案\"><a href=\"#CallerRunsPolicy策略风险及解决方案\" class=\"headerlink\" title=\"CallerRunsPolicy策略风险及解决方案\"></a>CallerRunsPolicy策略风险及解决方案</h3><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li>\n<li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li>\n</ol>\n<h3 id=\"线程池常用阻塞队列\"><a href=\"#线程池常用阻塞队列\" class=\"headerlink\" title=\"线程池常用阻塞队列\"></a>线程池常用阻塞队列</h3><ul>\n<li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li>\n<li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>\n<li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>\n</ul>\n<h3 id=\"线程池处理任务流程\"><a href=\"#线程池处理任务流程\" class=\"headerlink\" title=\"线程池处理任务流程\"></a>线程池处理任务流程</h3><ol>\n<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li>\n<li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>\n<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li>\n</ol>\n<h3 id=\"线程池中线程异常后销毁还是复用？\"><a href=\"#线程池中线程异常后销毁还是复用？\" class=\"headerlink\" title=\"线程池中线程异常后销毁还是复用？\"></a>线程池中线程异常后销毁还是复用？</h3><p>两种情况：</p>\n<ul>\n<li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li>\n<li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li>\n</ul>\n<h3 id=\"如何设定线程池大小\"><a href=\"#如何设定线程池大小\" class=\"headerlink\" title=\"如何设定线程池大小\"></a>如何设定线程池大小</h3><ul>\n<li>CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li>\n<li>I&#x2F;O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I&#x2F;O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。</li>\n</ul>\n<h3 id=\"如何设计一个根据任务优先级执行的线程池\"><a href=\"#如何设计一个根据任务优先级执行的线程池\" class=\"headerlink\" title=\"如何设计一个根据任务优先级执行的线程池\"></a>如何设计一个根据任务优先级执行的线程池</h3><ul>\n<li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li>\n<li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li>\n</ul>\n<p>这样还存在一些问题：</p>\n<ul>\n<li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul>\n<li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 &#96;false 。</li>\n</ul>\n</li>\n<li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul>\n<li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异步调用Future类\"><a href=\"#异步调用Future类\" class=\"headerlink\" title=\"异步调用Future类\"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>\n<p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// V 代表了Future执行的任务返回值的类型</span><br><span class=\"line\">public interface Future&lt;V&gt; &#123;</span><br><span class=\"line\">    // 取消任务执行，成功取消返回 true，否则返回 false</span><br><span class=\"line\">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\">    // 判断任务是否被取消</span><br><span class=\"line\">    boolean isCancelled();</span><br><span class=\"line\">    // 判断任务是否已经执行完成</span><br><span class=\"line\">    boolean isDone();</span><br><span class=\"line\">    // 获取任务执行结果</span><br><span class=\"line\">    V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\">    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br><span class=\"line\">    V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">        throws InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Callable和Future关系\"><a href=\"#Callable和Future关系\" class=\"headerlink\" title=\"Callable和Future关系\"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p>\n<ul>\n<li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li>\n<li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li>\n</ul>\n<h3 id=\"CompletableFuture类有什么用？\"><a href=\"#CompletableFuture类有什么用？\" class=\"headerlink\" title=\"CompletableFuture类有什么用？\"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p>\n<h3 id=\"虚拟线程\"><a href=\"#虚拟线程\" class=\"headerlink\" title=\"虚拟线程\"></a>虚拟线程</h3><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>\n<p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>\n<p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p>\n<p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>\n<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li>\n<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>\n</ul>\n<p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p>\n<p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>\n<ul>\n<li><code>InputStream/Reader</code>： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>\n<li><code>OutputStream/Writer</code>： 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>\n</ul>\n<h3 id=\"Java为什么要分字节流和字符流\"><a href=\"#Java为什么要分字节流和字符流\" class=\"headerlink\" title=\"Java为什么要分字节流和字符流\"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p>\n<ul>\n<li>字符流自动处理字符编码问题，非常适合文本数据；</li>\n<li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li>\n</ul>\n<h3 id=\"字节流和字符流区别\"><a href=\"#字节流和字符流区别\" class=\"headerlink\" title=\"字节流和字符流区别\"></a>字节流和字符流区别</h3><ul>\n<li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li>\n<li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li>\n<li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li>\n</ul>\n<h3 id=\"IO设计模式总结\"><a href=\"#IO设计模式总结\" class=\"headerlink\" title=\"IO设计模式总结\"></a>IO设计模式总结</h3><ul>\n<li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li>\n<li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li>\n<li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li>\n<li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li>\n</ul>\n<h3 id=\"装饰器模式和适配器模式区别\"><a href=\"#装饰器模式和适配器模式区别\" class=\"headerlink\" title=\"装饰器模式和适配器模式区别\"></a>装饰器模式和适配器模式区别</h3><ul>\n<li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li>\n<li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li>\n</ul>\n<h3 id=\"3种常见的IO模型\"><a href=\"#3种常见的IO模型\" class=\"headerlink\" title=\"3种常见的IO模型\"></a>3种常见的IO模型</h3><ul>\n<li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul>\n<li>优点：编程简单，代码易于理解。</li>\n<li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li>\n</ul>\n</li>\n<li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul>\n<li>优点：单线程可以处理多个连接，提高并发性能。</li>\n<li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li>\n</ul>\n</li>\n<li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul>\n<li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li>\n<li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h3><p>Java内存区域通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p>\n<p>线程私有的内存区域包括：</p>\n<ul>\n<li><strong>程序计数器</strong>：<ul>\n<li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li>\n<li>如果正在执行的是本地方法，这个计数器是未指定值(undefined)。</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：<ul>\n<li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li>\n<li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li>\n</ul>\n</li>\n<li><strong>本地方法栈</strong>：<ul>\n<li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li>\n<li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li>\n</ul>\n</li>\n</ul>\n<p>线程共享的内存区域包括：</p>\n<ul>\n<li><strong>堆</strong>：<ul>\n<li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li>\n<li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li>\n<li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul>\n<li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>方法区</strong>：<ul>\n<li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n<li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li>\n</ul>\n</li>\n<li><strong>运行时常量池</strong>：<ul>\n<li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li>\n<li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li>\n</ul>\n</li>\n</ul>\n<p>本地内存：</p>\n<ul>\n<li>直接内存：<ul>\n<li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li>\n<li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li>\n<li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li>\n</ul>\n</li>\n</ul>\n<p><strong>内存模型与内存管理</strong></p>\n<ul>\n<li>**内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li>\n<li>**垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li>\n</ul>\n<p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p>\n<h3 id=\"对象的创建过程-5步\"><a href=\"#对象的创建过程-5步\" class=\"headerlink\" title=\"对象的创建过程(5步)\"></a>对象的创建过程(5步)</h3><ol>\n<li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>\n<li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>\n<li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>\n<li>执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域： </p>\n<ul>\n<li>对象头(<code>Header</code>)： <ul>\n<li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li>\n<li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n</li>\n<li>实例数据(<code>Instance Data</code>)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>\n<li>对齐填充(<code>Padding</code>)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li>\n</ul>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p>\n<ul>\n<li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li>\n<li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li>\n</ul>\n<p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<h3 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p>\n<p><strong>堆空间结构</strong><br>堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p>\n<p><strong>内存分配和回收原则</strong></p>\n<ul>\n<li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li>\n<li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li>\n<li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li>\n</ul>\n<p>垃圾回收的基本步骤分两步：</p>\n<ul>\n<li>查找内存中不再使用的对象(GC判断策略)</li>\n<li>释放这些对象占用的内存(GC收集算法)</li>\n</ul>\n<p><strong>死亡对象&#x2F;GC判断策略</strong></p>\n<ul>\n<li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul>\n<li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li>\n</ul>\n</li>\n<li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul>\n<li>这些对象可以用作 GC Roots： <ul>\n<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n<li>JNI(Java Native Interface)引用的对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p>\n</blockquote>\n<p><strong>垃圾回收算法</strong></p>\n<ul>\n<li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul>\n<li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li>\n</ul>\n</li>\n<li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul>\n<li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li>\n</ul>\n</li>\n<li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul>\n<li>问题：整理的过程效率也不高。</li>\n</ul>\n</li>\n<li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li>\n</ul>\n<p><strong>垃圾回收器</strong><br>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20： G1(Garbage-First)收集器</p>\n<ul>\n<li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。</li>\n<li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。</li>\n<li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。</li>\n<li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。</li>\n<li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。</li>\n<li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。</li>\n<li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。</li>\n<li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。</li>\n</ul>\n<blockquote>\n<p>HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<ul>\n<li>部分收集 (<code>Partial GC</code>)：<ul>\n<li>新生代收集(Minor GC &#x2F; Young GC)：只对新生代进行垃圾收集；</li>\n<li>老年代收集(Major GC &#x2F; Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>\n</ul>\n</blockquote>\n<h3 id=\"为什么要进行垃圾回收\"><a href=\"#为什么要进行垃圾回收\" class=\"headerlink\" title=\"为什么要进行垃圾回收\"></a>为什么要进行垃圾回收</h3><ul>\n<li><strong>防止内存泄漏</strong>：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li>\n<li><strong>提高开发效率</strong>：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li>\n<li><strong>系统性能和稳定性</strong>：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li>\n</ul>\n<h3 id=\"强引用-软引用-弱引用-虚引用\"><a href=\"#强引用-软引用-弱引用-虚引用\" class=\"headerlink\" title=\"强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用\"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用</h3><p><a href=\"https://blog.csdn.net/u013718071/article/details/134789666\">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p>\n<ul>\n<li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li>\n<li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li>\n<li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li>\n<li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li>\n</ul>\n<p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p>\n<h3 id=\"如何判断一个类是无用的\"><a href=\"#如何判断一个类是无用的\" class=\"headerlink\" title=\"如何判断一个类是无用的\"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p>\n<h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p>\n<p>其中验证、准备、解析 3 部分统称为连接。</p>\n<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p>\n<p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流。</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>\n</ol>\n<blockquote>\n<p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p>\n</blockquote>\n<p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p>\n<ol>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul>\n<li>如验证类是否有父类</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul>\n<li>如验证函数的参数是否正确</li>\n</ul>\n</li>\n<li>符号引用验证：确保解析动作能正确执行。<ul>\n<li>如验证该类要使用的其他类、方法是否存在。</li>\n</ul>\n</li>\n</ol>\n<p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p>\n<ul>\n<li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>\n<li>初始值是数据类型的默认值，如 0、null 等。</li>\n</ul>\n<p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p>\n<p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p>\n<h3 id=\"类卸载\"><a href=\"#类卸载\" class=\"headerlink\" title=\"类卸载\"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p>\n<p>卸载类需要满足 3 个要求：</p>\n<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n<p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p>\n<blockquote>\n<p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p>\n</blockquote>\n<p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p>\n<p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p>\n<p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p>\n<h2 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h2>"},{"title":"数据库","keywords":["面经"],"description":"数据库面经","abbrlink":17769,"date":"2024-06-12T14:47:36.000Z","updated":"2024-06-16T11:30:16.000Z","top_img":"https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png","comments":1,"cover":"https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"abcjs":null,"_content":"\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## SQL/NoSQL基础\n\n### 什么是SQL\nSQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。\n\n### DB/DBMS/DBS/DBA\n- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。\n- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。\n- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。\n\n\n### 数据库术语\n- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。\n- 数据表(`table`)：某种特定类型数据的结构化清单。\n- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。\n- 行(`row`)：表中的一个记录。\n- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。\n\n### 元组/码/候选码/主码/外码/主属性/非主属性概念\n- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。\n- 码：码就是能唯一标识实体的属性，对应表中的列。\n- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。\n- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n### ER图\nER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：\n- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。\n- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。\n- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。\n\n### 数据库三范式\n数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：\n- 1NF(第一范式)：属性不可再分。\n  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。\n- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。\n- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。\n  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。\n\n> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。\n>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；\n> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。\n>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；\n> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。\n> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**\n>   - 例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\n\n### 主键/外键区别\n主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n### 为什么不推荐使用外键和级联操作\n以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**\n\n- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；\n- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；\n- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。\n\n**外键好处**\n- 保证了数据库数据的一致性和完整性；\n- 级联操作方便，减轻了程序代码量；\n\n### 存储过程\n可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。\n\n存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n\n### DROP/TRUNCATE/DELETE区别\n1. 用法不同\n- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。\n- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\n- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。\n\n`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。\n\n2. 属于不同的数据库语言\n- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。\n\n3. 执行速度不同：`DROP > TRUNCATE > DELETE`。\n- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。\n- `DROP`命令会把表占用的空间全部释放掉。\n\n### 数据库设计分为哪几个步\n1. 需求分析：分析用户的需求，包括数据、功能和性能需求。\n2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。\n3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。\n5. 数据库实施：包括编程、测试和试运行\n6. 数据库的运行和维护：系统的运行与数据库的日常维护。\n\n### 什么是NoSQL\n`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\n一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。\n\n> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。\n\n### SQL/NoSQL区别\n\n|         | SQL 数据库                                      | NoSQL 数据库                                                                                |\n|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|\n| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |\n| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |\n| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |\n| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |\n| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |\n| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |\n| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |\n| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |\n\n### NoSQL优劣\n**优点**\n- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。\n- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。\n- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。\n\n**缺点**\n- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。\n- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。\n\n### NoSQL分类\n- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。\n- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。\n- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。\n- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。\n\n### 数据库分类\n`DDL/DML/DCL/TCL`\n- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。\n- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。\n- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### SQL三种注释方式\n- 单行注释：`-- 注释内容` 或 `# 注释内容`。\n- 多行注释：`/* 注释内容 */`。\n- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。\n\n### DML语句✅\n`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n\n### 增删改查CRUD\n增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n\n**插入数据**\n`INSERT INTO` 语句用于向表中插入新记录。\n\n```sql\n-- 插入完整的行\n-- 插入一行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com');\n-- 插入多行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');\n\n-- 插入行的一部分\nINSERT INTO user(username, password, email)\nVALUES ('admin', 'admin', 'xxxx@163.com');\n\n-- 插入查询出来的数据\nINSERT INTO user(username)\nSELECT name\nFROM account;\n```\n\n**更新数据**\n`UPDATE` 语句用于更新表中的记录。\n\n```sql\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n```\n\n**删除数据**\n- `DELETE` 语句用于删除表中的记录。\n- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。\n\n```sql\n-- 删除表中的指定数据\nDELETE FROM user\nWHERE username = 'robot';\n\n-- 清空表中的数据\nTRUNCATE TABLE user;\n```\n\n**查询数据**\n- `SELECT` 语句用于从数据库中查询数据。\n- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n- `ASC`：升序(默认)\n- `DESC`：降序\n\n```sql\n-- 查询单列\nSELECT prod_name\nFROM products;\n\n-- 查询多列\nSELECT prod_id, prod_name, prod_price\nFROM products;\n\n-- 查询所有列\nSELECT *\nFROM products;\n\n-- 查询不同的值\nSELECT DISTINCT\nvend_id FROM products;\n\n-- 限制查询结果\n-- 返回前 5 行\nSELECT * FROM mytable LIMIT 5;\nSELECT * FROM mytable LIMIT 0, 5;\n-- 返回第 3 ~ 5 行\nSELECT * FROM mytable LIMIT 2, 3;\n```\n\n### 排序\n- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。\n- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。\n\n```sql\nSELECT * FROM products\nORDER BY prod_price DESC, prod_name ASC;\n```\n\n### 分组\n**`GROUP BY`**：\n\n- `GROUP BY` 子句将记录分组到汇总行中。\n- `GROUP BY` 为每个组返回一个记录。\n- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。\n- `GROUP BY` 可以按一列或多列进行分组。\n- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。\n\n```sql\n-- 分组\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name;\n\n-- 分组后排序\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name\nORDER BY cust_name DESC;\n```\n\n### HAVING\n\n- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。\n- `HAVING` 一般都是和 `GROUP BY` 连用。\n- `WHERE` 和 `HAVING` 可以在相同的查询中。\n\n```sql\n-- 使用 WHERE 和 HAVING 过滤数据\nSELECT cust_name, COUNT(*) AS NumberOfOrders\nFROM Customers\nWHERE cust_email IS NOT NULL\nGROUP BY cust_name\nHAVING COUNT(*) > 1;\n```\n\n### WHERE/HAVING对比\n- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。\n- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。\n\n### 子查询\nMYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)\n\n子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。\n\n子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。\n\n子查询常用在 `WHERE` 子句和 `FROM` 子句后边：\n- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。\n```sql\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  column_name operator\n    (SELECT column_name [, column_name ]\n    FROM table1 [, table2 ]\n    [WHERE])\n```\n- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。\n```sql\nSELECT column_name [, column_name ]\nFROM (SELECT column_name [, column_name ]\n      FROM table1 [, table2 ]\n      [WHERE]) as temp_table_name\nWHERE  condition\n```\n\n**子查询的子查询**\n首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。\n```sql\nSELECT cust_name, cust_contact\nFROM customers\nWHERE cust_id IN (SELECT cust_id\n                  FROM orders\n                  WHERE order_num IN (SELECT order_num\n                                      FROM orderitems\n                                      WHERE prod_id = 'RGAN01'));\n```\n\n### WHERE\n- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。\n- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。\n- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。\n```sql\n-- SELECT语句中的WHERE\nSELECT * FROM Customers\nWHERE cust_name = 'Kids Place';\n\n-- UPDATE语句中的WHERE\nUPDATE Customers\nSET cust_name = 'Jack Jones'\nWHERE cust_name = 'Kids Place';\n\n-- DELETE语句中的WHERE\nDELETE FROM Customers\nWHERE cust_name = 'Kids Place';\n```\n- 可以在 `WHERE` 子句中使用的操作符。\n| 运算符       | 描述                                |\n|-----------|-----------------------------------|\n| `=`       | 等于                                |\n| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |\n| `>`       | 大于                                |\n| `<`       | 小于                                |\n| `>=`      | 大于等于                              |\n| `<=`      | 小于等于                              |\n| `BETWEEN` | 在某个范围内                            |\n| `LIKE`    | 搜索某种模式                            |\n| `IN`      | 指定针对某个列的多个可能值                     |\n\n### IN/BETWEEN\n- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。\n- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。\n\n```sql\n-- IN示例\nSELECT *\nFROM products\nWHERE vend_id IN ('DLL01', 'BRS01');\n\n-- BETWEEN示例\nSELECT *\nFROM products\nWHERE prod_price BETWEEN 3 AND 5;\n```\n\n### AND/OR/NOT\n- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。\n- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。\n- `AND` 操作符表示左右条件都要满足。\n- `OR` 操作符表示左右条件满足任意一个即可。\n- `NOT` 操作符用于否定一个条件。\n\n```sql\n-- AND示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' AND prod_price <= 4;\n\n-- OR示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' OR vend_id = 'BRS01';\n\n-- NOT示例\nSELECT *\nFROM products\nWHERE prod_price NOT BETWEEN 3 AND 5;\n```\n\n### LIKE\n- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。\n- 只有字段是文本值时才使用 `LIKE`。\n- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。\n- 不要滥用通配符，通配符位于开头处匹配会非常慢。\n- `%` 表示任何字符出现任意次数。\n- `_` 表示任何字符出现一次。\n\n```sql\n-- %示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '%bean bag%';\n\n-- _示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '__ inch teddy bear';\n```\n\n### 连接JOIN\n`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。\n\n语法：\n```sql\nSELECT table1.column1, table2.column2...\nFROM table1\nJOIN table2\nON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not\n```\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n\n如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。\n```sql\n# JOIN....ON\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nON c.cust_id = o.cust_id\n-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()\n-- using(cust_id) 代替 ON c.cust_id = o.cust_id\nORDER BY c.cust_name;\n```\n\n### 内连接/外连接\n- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。\n- `外连接`：\n  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。\n  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。\n  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。\n\n\n```sql\n/* \nstudent表\nstudent_id\tname\n1\t        Alice\n2\t        Bob\n3\t        Carol\n\ncourses表\ncourse_id\tstudent_id\tcourse_name\n101\t        1\t        Math\n102\t        2\t        Science\n103\t        4\t        History\n*/\n\n-- 内连接\nSELECT students.name, courses.course_name\nFROM students\nINNER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\n*/\n\n-- 左外连接\nSELECT students.name, courses.course_name\nFROM students\nLEFT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\n*/\n\n-- 右外连接\nSELECT students.name, courses.course_name\nFROM students\nRIGHT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nNULL\tHistory\n*/\n\n-- 全外连接\nSELECT students.name, courses.course_name\nFROM students\nFULL OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\nNULL\tHistory\n*/\n```\n\n### ON/WHERE区别\n- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。\n- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。\n\n### 组合UNION\n`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。\n\n`UNION` 基本规则：\n- 所有查询的列数和列顺序必须相同。\n- 每个查询中涉及表的列的数据类型必须相同或兼容。\n- 通常返回的列名取自第一个查询。\n- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。\n\n```sql\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n```\n\n### DDL语言✅\n`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n\n### 数据库DATABSE\n- 创建数据库：`CREATE DATABASE 数据库名;`\n- 删除数据库：`DROP DATABASE 数据库名;`\n- 选择数据库：`USE 数据库名;`\n- 查看数据库：`SHOW DATABASES;`\n\n### 数据表TABLE\n```sql\n-- 普通创建\nCREATE TABLE user (\nid int(10) unsigned NOT NULL COMMENT 'Id',\nusername varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',\npassword varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',\nemail varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'\n) COMMENT='用户表';\n\n-- 根据已有表创建\nCREATE TABLE vip_user AS\nSELECT * FROM user;\n\n-- 删除表\nDROP TABLE user;\n\n-- 查看表\nSHOW TABLES;\n\n-- 添加列\nALTER TABLE user -- ALTER用于修改表\nADD age int(3);\n\n-- 删除列\nALTER TABLE user\nDROP COLUMN age;\n\n-- 修改列\nALTER TABLE `user`\nMODIFY COLUMN age tinyint;\n\n-- 添加主键\nALTER TABLE user\nADD PRIMARY KEY (id);\n\n-- 删除主键\nALTER TABLE user\nDROP PRIMARY KEY;\n```\n\n### 视图VIEW\n在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。\n\n作用：\n- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。\n- 提高数据安全性：用来限制用户访问敏感数据。\n- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。\n- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。\n\n```sql\n-- 创建视图\nCREATE VIEW top_10_user_view AS\nSELECT id, username\nFROM user\nWHERE id < 10;\n\n-- 删除视图\nDROP VIEW top_10_user_view;\n```\n\n### 索引INDEX\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n**优点**\n- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n```sql\n-- 创建索引\nCREATE INDEX user_index\nON user (id);\n\n-- 添加索引\nALTER table user ADD INDEX user_index(id)\n\n-- 创建唯一索引\nCREATE UNIQUE INDEX user_index\nON user (id);\n\n-- 删除索引\nALTER TABLE user\nDROP INDEX user_index;\n```\n\n### 约束\nSQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。\n\n**约束类型**\n- `NOT NULL`：指示某列不能存储 `NULL` 值。\n- `UNIQUE`：保证某列的每行必须有唯一的值。\n- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。\n- `CHECK`：保证列中的值符合指定的条件。\n- `DEFAULT`：规定没有给列赋值时的默认值。\n\n```sql\nCREATE TABLE Users (\n  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',\n  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',\n  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',\n  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',\n  PRIMARY KEY (Id)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n```\n\n\n### TCL语句✅\n`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n\n### 事务TRANSACTION\n事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。\n\n**事务的四个特性(ACID)**\n- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- `一致性(Consistency)`：执行事务前后，数据保持一致。\n- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。\n\n> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。\n\n```sql\n-- 开始事务\nSTART TRANSACTION;\n\n-- 插入操作 A\nINSERT INTO `user`\nVALUES (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updateA\nSAVEPOINT updateA;\n\n-- 插入操作 B\nINSERT INTO `user`\nVALUES (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updateA\nROLLBACK TO updateA;\n\n-- 提交事务，只有操作 A 生效\nCOMMIT;\n```\n\n### DCL语句✅\n`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### 权限管理\n- 授予用户帐户权限，用`GRANT`命令。\n  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。\n  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。\n  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。\n  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。\n  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。\n- 撤销用户的权限，用`REVOKE`命令。\n  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。\n  - 指定在 `ON` 子句中撤销特权的特权级别。\n  - 指定要撤消 `FROM` 子句中的权限的用户帐户。\n\n`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：\n- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；\n- 整个数据库，使用 `ON database.*`；\n- 特定的表，使用 `ON database.table`；\n- 特定的列；\n- 特定的存储过程。\n\n```sql\n-- GRANT用法\nGRANT privilege,[privilege],.. ON privilege_level\nTO user [IDENTIFIED BY password]\n[REQUIRE tsl_option]\n[WITH [GRANT_OPTION | resource_option]];\n\n-- REVOKE用法\nREVOKE privilege_type [(column_list)]\n       [, priv_type [(column_list)]]...\nON [object_type] privilege_level\nFROM user [, user]...\n\n-- 创建账户\nCREATE USER myuser IDENTIFIED BY 'mypassword';\n-- 修改账户名\nUPDATE user SET user='newuser' WHERE user='myuser';\nFLUSH PRIVILEGES;\n-- 删除账户\nDROP USER myuser;\n-- 查看权限\nSHOW GRANTS FOR myuser;\n-- 授予权限\nGRANT SELECT, INSERT ON *.* TO myuser;\n-- 删除权限\nREVOKE SELECT, INSERT ON *.* FROM myuser;\n-- 更改密码\nSET PASSWORD FOR myuser = 'mypass';\n```\n\n### 游标CURSOR\n游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。\n\n### 触发器TRIGGER\n触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。\n\n**优点**\n- SQL 触发器提供了另一种检查数据完整性的方法。\n- SQL 触发器可以捕获数据库层中业务逻辑中的错误。\n- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。\n- SQL 触发器对于审计表中数据的更改非常有用。\n\n**缺点**\n- SQL 触发器可能会增加数据库服务器的开销。\n- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。\n\n在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。\n- `BEFORE INSERT`：在将数据插入表格之前激活。\n- `AFTER INSERT`：将数据插入表格后激活。\n- `BEFORE UPDATE`：在更新表中的数据之前激活。\n- `AFTER UPDATE`：更新表中的数据后激活。\n- `BEFORE DELETE`：在从表中删除数据之前激活。\n- `AFTER DELETE`：从表中删除数据后激活。\n\n`NEW` 和 `OLD`：\n- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；\n- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；\n- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；\n- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)\n\n### 触发器语法\n\n```sql\n-- 创建触发器\nCREATE TRIGGER trigger_name\ntrigger_time\ntrigger_event\nON table_name\nFOR EACH ROW\nBEGIN\ntrigger_statements\nEND;\n```\n\n说明：\n- `trigger_name`：触发器名\n- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。\n- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。\n- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。\n- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。\n- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。\n\n当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。\n\n```sql\n-- 创建触发器\nDELIMITER $\nCREATE TRIGGER `trigger_insert_user`\nAFTER INSERT ON `user`\nFOR EACH ROW\nBEGIN\n    INSERT INTO `user_history`(user_id, operate_type, operate_time)\n    VALUES (NEW.id, 'add a user',  now());\nEND $\nDELIMITER ;\n\n-- 查看触发器\nSHOW TRIGGERS;\n\n-- 删除触发器\nDROP TRIGGER trigger_insert_user;\n```\n\n## MySQL\nMySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是`3306`。\n\n### MySQL基础✅\n\n### MySQL优点\n- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。\n- 开箱即用，操作简单，维护成本低。\n- 兼容性好，支持常见的操作系统，支持多种开发语言。\n- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。\n- 支持分库分表、读写分离、高可用。\n\n### 什么是关系型数据库\n关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。\n\n大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……\n\n### MySQL字段类型\n简单分为三大类：数值类型、字符串类型、日期和时间类型。\n- 数值类型：\n  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。\n  - 浮点型：`FLOAT`、`DOUBLE`。\n  - 定点数：`DECIMAL`。\n- 字符串类型：\n  - 常用：`CHAR`、`VARCHAR`、`TEXT`。\n  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。\n- 日期和时间类型：\n  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。\n\n### 整数类型的UNSIGNED属性\n整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。\n\n> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。\n> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。\n\n对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。\n\n### CHAR/VARCHAR区别\n- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。\n- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。\n- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。\n- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。\n\n### VARCHAR(100)/VARCHAR(10)区别\n- 前者最大长度为 100，后者最大长度为 10。\n- 二者存储相同的字符串所占用的存储空间是一样的。\n- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。\n\n### DECIMAL和FLOAT/DOUBLE区别\n`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。\n\n### 为什么没不推荐使用TEXT/BLOB类型\n- `TEXT`用于存储长文本数据，如博客数据。\n- `BLOB`用于存储二进制大对象，例如图片、音视频等文件。\n\n这两种类型有如下缺陷：\n- 不能有默认值。\n- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。\n- 检索效率较低。\n- 不能直接创建索引，需要指定前缀长度。\n- 可能会消耗大量的网络和 IO 带宽。\n- 可能导致表上的 DML 操作变慢。\n\n### DATETIME/TIMESTAMP区别\n- `DATETIME`没有时区信息，`TIMESTAMP` 和时区有关。\n- `TIMESTAMP` 只需要使用 4 个字节的存储空间，但是 `DATETIME` 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，`TIMESTAMP` 表示的时间范围更小。\n  - `DATETIME`：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n  - `TIMESTAMP`：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC\n- `TIMESTAMP` 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。\n\n### NULL和''区别\n- `NULL` 表示未知的值，`''` 表示空字符串。\n  - `SELECT NULL=NULL`的结果为 `false`，但在使用`DISTINCT`,`GROUP BY`,`ORDER BY`时又认为`NULL`是相等的。\n- `''`长度为0，不占用空间，`NULL`占用空间。\n- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 `=`、`!=`、 `<`、`>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。\n- `NULL` 会影响聚合函数的结果。\n  - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。`COUNT` 的处理方式取决于参数的类型。如果参数是 `*(COUNT(*))`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名`(COUNT(列名))`，则会忽略 `NULL` 值，只统计非空值的个数。\n\n不推荐使用`NULL`作为列默认值。\n\n### Boolean类型如何在MySQL中存储\nMySQL 中没有布尔类型，可以使用 `TINYINT` 类型来存储布尔值。`TINYINT(1)` 可以存储 0 或 1，分别表示 `false` 和 `true`。\n\n### MySQL基础架构✅\n\nMySQL 基础架构主要分为 Server 层和存储引擎层：\n- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。\n- 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 `redolog` 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。\n\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\n- 连接器：身份认证和权限相关(登录 MySQL 的时候)。\n- 查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。\n- 分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\n- 优化器：按照 MySQL 认为最优的方案去执行。\n- 执行器：执行语句，然后从存储引擎返回数据。\n- 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。\n\n1. 连接器。\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。\n\n2. 查询缓存(MySQL 8.0 版本后移除)。\n主要用来缓存所执行的 `SELECT` 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 `Key-Value` 的形式缓存在内存中，`Key` 是查询语句，`Value` 是结果集。如果缓存 `Key` 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\n\n3. 分析器。\nMySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：\n   - 第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\n   - 第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\n\n4. 优化器。\n优化器以它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\n\n5. 执行器。\n当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\n\n### SQL语句在MySQL中的执行过程\n\n**查询语句**\n查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\n```sql\nselect * from tb_student  A where A.age='18' and A.name=' 张三 ';\n```\n1. 检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 `key` 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。\n2. 通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\n3. 优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：\n   - a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n   - b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。\n4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\n\n**更新语句(增加，修改，删除)**\n更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)\n```sql\nupdate tb_student A set A.age='19' where A.name=' 张三 ';\n```\nMySQL自带的日志模块是 `binlog`，以 `InnoDB` 作为存储引擎介绍，其自带了一个`redo log` 日志模块，用来保证数据的一致性的。\n1. 先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。\n2. 拿到查询的语句，把 `age` 改为 19，然后调用引擎 API 接口，写入这一行数据，`InnoDB` 引擎把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，执行完成了，随时可以提交。\n3. 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log` 为提交状态。\n4. 更新完成。\n\n### MySQL存储引擎✅\n\n### MySQL支持哪些存储引擎？\nMySQL 支持多种存储引擎，常见的存储引擎有 `InnoDB`、`MyISAM`、`Memory`、`CSV`、`Archive`、`Blackhole`、`NDB`、`Merge`、`Federated`、`Example` 等。\n\nMySQL 5.5.5 之前，`MyISAM` 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。\n\n### MyISAM/InnoDB存储引擎区别\n- `MyISAM`只支持表级锁，而 `InnoDB` 支持行级锁和表级锁，默认为行级锁。\n- `MyISAM` 不提供事务支持。`InnoDB` 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(`commit`)和回滚(`rollback`)事务的能力。并且，`InnoDB` 默认使用的 `REPEATABLE-READ`（可重读）隔离级别是可以解决幻读问题发生的（基于 `MVCC` 和 `Next-Key Lock`）。\n- `MyISAM` 不支持外键，而 `InnoDB` 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。\n- `MyISAM` 不支持数据库异常崩溃后的安全恢复，而 `InnoDB` 支持，恢复过程依赖于`redo log`。\n- `InnoDB`支持 `MVCC`，`MyISAM` 不支持。`MVCC` 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n- `InnoDB`和`MyISAM`都使用`B+Tree` 作为索引结构，但二者实现方式不一样。`InnoDB` 引擎中，其数据文件本身就是索引文件。相比 `MyISAM`，索引文件和数据文件是分离的，其表数据文件本身就是按 `B+Tree` 组织的一个索引结构，树的叶节点 `data` 域保存了完整的数据记录。\n- `InnoDB` 的性能比 `MyISAM` 更强大，随着 CPU 核数的增加，`InnoDB` 的读写能力呈线性增长。\n- 数据缓存策略和机制实现不同。`InnoDB` 使用缓冲池（`Buffer Pool`）缓存数据页和索引页，`MyISAM` 使用键缓存（`Key Cache`）仅缓存索引页而不缓存数据页。\n\n### MySQL索引✅\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 `Innodb` 还是 `MyIsam`，都使用了 **B+树**作为索引结构。\n\n**优点**\n- 大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n### 索引底层数据类型选型\n1. `Hash`索引\n`InnoDB` 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”（`Adaptive Hash Index`），结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 `B+Tree` 结构(不是传统的链表+红黑树)，这个 `B+Tree` 结构可以存储多个键值对，而不仅仅是一个键。`Hash` 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。\n\n2. 二叉查找树\n二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。\n当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 `O(N)`。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。\n\n3. AVL树\nAVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。\n\n4. 红黑树\n红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致**一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因**。红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 `O(logn)` 次数的旋转操作，其插入和删除操作效率大大提高。\n\n5. B树&B+树\nB 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。\n目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。\nB树&B+树区别\n- B 树的所有节点既存放键(`key`) 也存放数据(`data`)，而 B+树只有叶子节点存放 `key` 和 `data`，其他内节点只存放 `key`。\n- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。\n\n综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。\n\n### MyISAM/InnoDB索引区别\n`MyISAM` 引擎和 `InnoDB` 引擎都是使用 `B+Tree` 作为索引结构，但实现方式不太一样：\n- `MyISAM` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按照 `B+Tree` 搜索算法搜索索引，如果指定的 `Key` 存在，则取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。\n- `InnoDB` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 `InnoDB` 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。\n\n### 索引分类\n\n按照数据结构维度划分：\n- `BTree` 索引：MySQL 里默认和最常用的索引类型。\n- 哈希索引：类似键值对的形式，一次即可定位。\n\n按照底层存储方式角度划分：\n- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\n- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n按照应用维度划分：\n- 主键索引：加速查询 + 列值唯一（不可以有 `NULL`）+ 表中只有一个。\n- 普通索引：仅加速查询。\n- 唯一索引：加速查询 + 列值唯一（可以有 `NULL`）。\n- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 `ElasticSearch` 代替。\n\nMySQL 8.x 中实现的索引新特性：\n- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。\n- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 `GROUP BY` 语句进行隐式排序。\n- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。\n\n### 主键索引\n数据表的主键列使用的就是主键索引(主键索引的 `data` 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。\n\n在 MySQL 的 `InnoDB` 的表中，当没有显示的指定表的主键时，`InnoDB` 会自动先检查表中是否有唯一索引且不允许存在 `null` 值的字段，如果有，则选择该字段为默认的主键，否则 `InnoDB` 将会自动创建一个 6Byte 的自增主键。\n\n### 二级索引\n二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。\n\n唯一索引，普通索引，前缀索引等索引都属于二级索引。\n- 唯一索引(`Unique Key`):唯一索引的属性列不能出现重复的数据，但是允许数据为 `NULL`，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n- 普通索引(`Index`):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 `NULL`。\n- 前缀索引(`Prefix`):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。\n- 全文索引(`Full Text`):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 `MYISAM` 引擎支持全文索引，5.6 之后 `InnoDB` 也支持了全文索引。\n\n### 聚簇索引/非聚簇索引\n聚簇索引（聚集索引）：索引结构和数据一起存放的索引，`InnoDB` 中的主键索引就属于聚簇索引。\n\n**优点**：\n- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。\n- 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。\n\n**缺点**：\n- 依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串/UUID这类又长又难比较的数据，插入/查找的速度较慢。\n- 更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。\n\n非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 `MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n**优点**：\n更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。\n\n**缺点**：\n- 依赖于有序的数据\n- 可能会二次查询(回表):非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。\n\n### 回表\n在 `InnoDB` 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。\n\n### 覆盖索引/联合索引\n- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n\n### 联合索引最左前缀匹配原则\n在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n### 索引下推ICP\n索引下推（`Index Condition Pushdown,ICP`） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`语句中的判断条件，直接过滤掉不满足条件的记录，从而**减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量**。\n\n**原理**\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\nMySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。\n\n索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给下层（存储引擎层）去处理。\n\n```sql\nSELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;\n```\n- 没有索引下推，存储引擎层`zipcode` 字段利用索引可以快速定位到 `zipcode = '431200'`的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。\n- 有索引下推，存储引擎层根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。\n\n索引下推适用于 `InnoDB` 引擎和 `MyISAM` 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。\n\n### MySQL查询缓存✅\n执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用\n\n查询缓存不命中的情况：\n- 两个查询在任何字符上的不同都会导致缓存不命中。\n- 若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。\n- 缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。\n\n### MySQL三大日志✅\nMySQL比较重要的日志有二进制日志 `binlog`（归档日志）和事务日志 `redo log`（重做日志）和 `undo log`（回滚日志）。\n\nMySQL `InnoDB` 引擎使用 `redo log`(重做日志) 保证事务的持久性，使用 `undo log`(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### redo log\n`redo log`（重做日志）是 `InnoDB` 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，保证数据的持久性与完整性。\n\n查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 `Buffer Pool`中，后续查找先查找`Buffer Pool`，如果没有找到再去硬盘加载。更新数据的时候，若 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。\n\n### 刷盘时机\n`InnoDB` 在多种情况下将 `redo log` 刷到磁盘上，以保证数据的持久性和一致性。\n- 事务提交：当事务提交时，`redo log buffer` 里的 `redo log` 会被刷新到磁盘的 `redo log` 文件里。\n- `redo log buffer` 空间不足时：`redo log buffer` 中缓存的 `redo log` 已占了 `redo log buffer` 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。\n- `Checkpoint`（检查点）：`InnoDB` 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。\n- 正常关闭服务器：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去。\n- 后台线程：`InnoDB` 有一个后台线程，每隔1 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。\n\n### 刷盘策略\n`innodb_flush_log_at_trx_commit`参数设置三种刷盘策略：\n- 0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。\n- 1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。\n- 2，每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`（文件系统缓存）。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n默认策略为第二种。\n\n### binlog\n`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志，且是顺序写。\n\nMySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### 记录格式\n`binlog` 有三种记录格式：\n- `Statement`：记录的是 SQL 语句，如 `update t set c=c+1 where id=2`。\n  - 同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。\n- `Row`：记录的是行数据，如 `id=2 c=2`。\n  - 这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。\n- `Mixed`：记录的是上面两种的混合模式。\n  - MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。\n\n### 写入机制\n事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中。一个事务的 `binlog` 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。\n\n通过 `write` 将`binlog cache`中的 `binlog`写入文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。\n\n**`write` 和 `fsync` 时机** 由参数`sync_binlog`控制，默认是1。\n- 0，每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。\n  - 虽然性能最高，但是机器宕机，`page cache`里面的 `binlog` 会丢失。\n- 1，每次提交事务都会执行`write`+`fsync`，和 `redo log` 日志刷盘流程一样。\n- N(>1)，每次提交事务都会执行`write`，但是累计 `N`次事务后才执行 `fsync`。\n  - 在出现 IO 瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近`N`个事务的 `binlog` 日志。\n\n### 两阶段提交\n`redo log`（重做日志）让 `InnoDB` 存储引擎拥有了崩溃恢复能力。`binlog`（归档日志）保证了 MySQL 集群架构的数据一致性。\n\n`redo log` 与 `binlog` 的写入时机不一样，`redo log` 是事务执行过程中写入，`binlog` 是事务提交后写入。\n\n写入机制不一样会导致日志不一致：\n若某一事务(更新某一行的a值，从 0->1)执行过程中写完 `redo log` 日志后，`binlog` 日志写期间发生了异常，写入失败。此时使用`redo log`恢复的数据中，a值已经变为1，而`binlog`中记录的是a值为0，这样就导致了数据不一致。\n\n为了解决数据不一致问题，InnoDB 存储引擎使用两阶段提交：将 `redo log` 的写入拆成了两个步骤`prepare`和`commit`。\n- `prepare`：在事务执行过程中，先写入 `redo log`，但是不提交事务。\n- `commit`：在事务提交后，再写入 `binlog`，然后提交`redo log`。\n\n使用两阶段提交后，写入 `binlog` 时发生异常也不会有影响。此时 MySQL 根据 `redo log` 日志恢复数据时，发现 `redo log` 还处于`prepare`阶段，并且没有对应 `binlog` 日志，就会回滚该事务。\n\n如果`redo log` 在 `commit`阶段发生异常，虽然 `redo log` 处于`prepare`阶段，但是能通过事务id找到对应的 `binlog` 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n\n### undo log\n`undo log` 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 `DELETE` 语句，那 `undo log` 就会记录一条相对应的 `INSERT` 语句。每一个事务对数据的修改都会被记录到 `undo log` ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 `undo log` 将数据恢复到事务开始之前的状态。\n\n`undo log` 本身是会被删除清理的，例如 `INSERT` 操作，在事务提交之后就可以清除掉了；`UPDATE/DELETE` 操作在事务提交不会立即删除，会加入 `history list`，由后台线程 `purge` 进行清理。\n\n`undo log` 采用 `segment`（段）进行记录，事务开始时，需要为其分配一个 `rollback segment`。每个 `rollback segment` 有 1024 个 `undo log segment`(每个 `undo` 操作在记录的时候占用一个 `undo log segment`，多个有助于管理多个并发事务) 和 一个 `rollback segment header`(负责管理`rollback segment`)，`history list` 是`rollback segment header`的一部分，它的主要作用是记录所有已经提交但还没有被清理（`purge`）的事务的 `undo log`，`history list`列表使得 `purge` 线程能够找到并清理那些不再需要的 `undo log` 记录。\n\n### MySQL事务✅\n事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n### 事务的四大特性\n- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- 一致性(Consistency)：执行事务前后，数据保持一致。\n- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\n> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\n\n### 并发事务存在的问题\n\n### 脏读\n一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。\n\n一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。\n\n解决：\n- 设置事务隔离级别为 `Read Committed` 或更高。`Read Committed` 确保事务只能读取已经提交的数据，从而避免脏读。\n\n### 丢失修改\n两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。\n\n在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n\n解决：\n- 乐观锁（Optimistic Locking）： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。\n- 悲观锁（Pessimistic Locking）： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。\n\n### 不可重复读\n一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。\n\n一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。\n\n解决：\n- 执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。\n\n### 幻读\n一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。\n\n一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n解决：\n- 执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。\n- 事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。\n\n### 不可重复读和幻读有什么区别\n- 不可重复读：多次读取同一数据，发现数据不一致。\n- 幻读：多次执行同一条查询语句，发现查到的记录增加了。\n\n幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。\n- 解决不可重复读：执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 解决幻读：执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。\n\n### 并发事务的控制方式有哪些\nMySQL 中并发事务的控制方式无非就两种：锁 和 `MVCC`。锁可以看作是悲观控制的模式，多版本并发控制（`MVCC，Multiversion concurrency control`）可以看作是乐观控制的模式。\n\n- 锁：\n  - 共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n  - 排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。\n- `MVCC` 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\n\n读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(`table-level locking`) 和 行级锁(`row-level locking`) 。`InnoDB` 默认为行级锁，也支持表级锁，所以并发性能比较高。\n\n> 注意：不论是表级锁还是行级锁，都存在共享锁（`Share Lock`，S 锁）和排他锁（`Exclusive Lock`，X 锁）这两类。\n\nMVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段、`read view`、`undo log`。\n- `undo log` : `undo log` 用于记录某行数据的多个版本的数据。\n- `read view` 和 隐藏字段 : 用来判断当前版本数据的可见性。\n\n### 事务隔离级别\n`READ-UNCOMMITTED`(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n`READ-COMMITTED`(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n`REPEATABLE-READ`(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n`SERIALIZABLE`(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n|     隔离级别     | 脏读 | 不可重复读 | 幻读 | 实现方式 |\n| :--------------: | :--: | :--------: | :--: | :------: |\n| READ-UNCOMMITTED |  √   |     √      |  √   | /        |\n|  READ-COMMITTED  |  ×   |     √      |  √   | 基于 MVCC/锁 |\n| REPEATABLE-READ  |  ×   |     ×      |  √   | 基于 MVCC/锁(当前读情况下需要使用加锁读来保证不会出现幻读) |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   | 基于 锁 |\n\nMySQL默认隔离级别是 `REPEATABLE-READ`。\n\n\n\n\n\n### MySQL存储引擎\n存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。\n\n默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。\n\n### MySQL 锁机制\n锁是一种常见的并发事务的控制方式。\n\n### 表级锁/行级锁\nMyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。\n\nInnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。\n\n表级锁和行级锁对比：\n- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。\n- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n\n### MySQL字符集\nMySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`\n\n### MySQL字符集层次级别\n- MySQL 中的字符集分为四个层次：\n  - server(MySQL 实例级别)\n  - database(库级别)\n  - table(表级别)\n  - column(字段级别)\n\n其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。\n\nMySQL 字符编码集中有两套 UTF-8 编码实现：\n- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n\n\n## Redis\n\nRedisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。\n\n### 基本数据类型\nRedis 中比较常见的数据类型有下面这些：\n- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。\n- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。\n\n除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。\n\n### Redis持久化\n使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：\n- 快照(snapshotting，RDB)\n- 只追加文件(append-only file, AOF)\n- RDB 和 AOF 的混合持久化(Redis 4.0 新增)\n\n\n### 缓存穿透\n缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n### 缓存击穿\n缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n### 缓存雪崩\n缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\n\n\n\n\n","source":"_posts/数据库.md","raw":"---\ntitle: 数据库\ntags:\n  - 数据库\n  - SQL\n  - NoSQL\n  - MySQL\n  - mongodb\n  - Redis\n  - 面经\ncategories:\n  - 面经\nkeywords:\n  - 面经\ndescription: 数据库面经\nabbrlink: 17769\ndate: 2024-06-12 22:47:36\nupdated: 2024-06-16 19:30:16\ntop_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png\ncomments:\ncover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\nabcjs:\n---\n\n> 本文参考 [JavaGuide](https://javaguide.cn/)\n\n## SQL/NoSQL基础\n\n### 什么是SQL\nSQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。\n\n### DB/DBMS/DBS/DBA\n- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。\n- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。\n- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。\n\n\n### 数据库术语\n- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。\n- 数据表(`table`)：某种特定类型数据的结构化清单。\n- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。\n- 行(`row`)：表中的一个记录。\n- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。\n\n### 元组/码/候选码/主码/外码/主属性/非主属性概念\n- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。\n- 码：码就是能唯一标识实体的属性，对应表中的列。\n- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。\n- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n### ER图\nER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：\n- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。\n- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。\n- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。\n\n### 数据库三范式\n数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：\n- 1NF(第一范式)：属性不可再分。\n  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。\n- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。\n- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。\n  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。\n\n> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。\n>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；\n> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。\n>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；\n> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。\n> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**\n>   - 例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。\n\n### 主键/外键区别\n主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n### 为什么不推荐使用外键和级联操作\n以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**\n\n- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；\n- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；\n- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。\n\n**外键好处**\n- 保证了数据库数据的一致性和完整性；\n- 级联操作方便，减轻了程序代码量；\n\n### 存储过程\n可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。\n\n存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n\n### DROP/TRUNCATE/DELETE区别\n1. 用法不同\n- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。\n- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。\n- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。\n\n`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。\n\n2. 属于不同的数据库语言\n- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。\n\n3. 执行速度不同：`DROP > TRUNCATE > DELETE`。\n- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。\n- `DROP`命令会把表占用的空间全部释放掉。\n\n### 数据库设计分为哪几个步\n1. 需求分析：分析用户的需求，包括数据、功能和性能需求。\n2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。\n3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。\n5. 数据库实施：包括编程、测试和试运行\n6. 数据库的运行和维护：系统的运行与数据库的日常维护。\n\n### 什么是NoSQL\n`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\n一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。\n\n> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。\n\n### SQL/NoSQL区别\n\n|         | SQL 数据库                                      | NoSQL 数据库                                                                                |\n|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|\n| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |\n| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |\n| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |\n| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |\n| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |\n| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |\n| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |\n| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |\n\n### NoSQL优劣\n**优点**\n- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。\n- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。\n- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。\n\n**缺点**\n- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。\n- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。\n\n### NoSQL分类\n- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。\n- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。\n- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。\n- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。\n\n### 数据库分类\n`DDL/DML/DCL/TCL`\n- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。\n- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。\n- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### SQL三种注释方式\n- 单行注释：`-- 注释内容` 或 `# 注释内容`。\n- 多行注释：`/* 注释内容 */`。\n- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。\n\n### DML语句✅\n`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。\n\n### 增删改查CRUD\n增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n\n**插入数据**\n`INSERT INTO` 语句用于向表中插入新记录。\n\n```sql\n-- 插入完整的行\n-- 插入一行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com');\n-- 插入多行\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');\n\n-- 插入行的一部分\nINSERT INTO user(username, password, email)\nVALUES ('admin', 'admin', 'xxxx@163.com');\n\n-- 插入查询出来的数据\nINSERT INTO user(username)\nSELECT name\nFROM account;\n```\n\n**更新数据**\n`UPDATE` 语句用于更新表中的记录。\n\n```sql\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n```\n\n**删除数据**\n- `DELETE` 语句用于删除表中的记录。\n- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。\n\n```sql\n-- 删除表中的指定数据\nDELETE FROM user\nWHERE username = 'robot';\n\n-- 清空表中的数据\nTRUNCATE TABLE user;\n```\n\n**查询数据**\n- `SELECT` 语句用于从数据库中查询数据。\n- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n- `ASC`：升序(默认)\n- `DESC`：降序\n\n```sql\n-- 查询单列\nSELECT prod_name\nFROM products;\n\n-- 查询多列\nSELECT prod_id, prod_name, prod_price\nFROM products;\n\n-- 查询所有列\nSELECT *\nFROM products;\n\n-- 查询不同的值\nSELECT DISTINCT\nvend_id FROM products;\n\n-- 限制查询结果\n-- 返回前 5 行\nSELECT * FROM mytable LIMIT 5;\nSELECT * FROM mytable LIMIT 0, 5;\n-- 返回第 3 ~ 5 行\nSELECT * FROM mytable LIMIT 2, 3;\n```\n\n### 排序\n- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。\n- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。\n\n```sql\nSELECT * FROM products\nORDER BY prod_price DESC, prod_name ASC;\n```\n\n### 分组\n**`GROUP BY`**：\n\n- `GROUP BY` 子句将记录分组到汇总行中。\n- `GROUP BY` 为每个组返回一个记录。\n- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。\n- `GROUP BY` 可以按一列或多列进行分组。\n- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。\n\n```sql\n-- 分组\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name;\n\n-- 分组后排序\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name\nORDER BY cust_name DESC;\n```\n\n### HAVING\n\n- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。\n- `HAVING` 一般都是和 `GROUP BY` 连用。\n- `WHERE` 和 `HAVING` 可以在相同的查询中。\n\n```sql\n-- 使用 WHERE 和 HAVING 过滤数据\nSELECT cust_name, COUNT(*) AS NumberOfOrders\nFROM Customers\nWHERE cust_email IS NOT NULL\nGROUP BY cust_name\nHAVING COUNT(*) > 1;\n```\n\n### WHERE/HAVING对比\n- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。\n- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。\n\n### 子查询\nMYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)\n\n子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。\n\n子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。\n\n子查询常用在 `WHERE` 子句和 `FROM` 子句后边：\n- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。\n```sql\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  column_name operator\n    (SELECT column_name [, column_name ]\n    FROM table1 [, table2 ]\n    [WHERE])\n```\n- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。\n```sql\nSELECT column_name [, column_name ]\nFROM (SELECT column_name [, column_name ]\n      FROM table1 [, table2 ]\n      [WHERE]) as temp_table_name\nWHERE  condition\n```\n\n**子查询的子查询**\n首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。\n```sql\nSELECT cust_name, cust_contact\nFROM customers\nWHERE cust_id IN (SELECT cust_id\n                  FROM orders\n                  WHERE order_num IN (SELECT order_num\n                                      FROM orderitems\n                                      WHERE prod_id = 'RGAN01'));\n```\n\n### WHERE\n- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。\n- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。\n- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。\n```sql\n-- SELECT语句中的WHERE\nSELECT * FROM Customers\nWHERE cust_name = 'Kids Place';\n\n-- UPDATE语句中的WHERE\nUPDATE Customers\nSET cust_name = 'Jack Jones'\nWHERE cust_name = 'Kids Place';\n\n-- DELETE语句中的WHERE\nDELETE FROM Customers\nWHERE cust_name = 'Kids Place';\n```\n- 可以在 `WHERE` 子句中使用的操作符。\n| 运算符       | 描述                                |\n|-----------|-----------------------------------|\n| `=`       | 等于                                |\n| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |\n| `>`       | 大于                                |\n| `<`       | 小于                                |\n| `>=`      | 大于等于                              |\n| `<=`      | 小于等于                              |\n| `BETWEEN` | 在某个范围内                            |\n| `LIKE`    | 搜索某种模式                            |\n| `IN`      | 指定针对某个列的多个可能值                     |\n\n### IN/BETWEEN\n- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。\n- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。\n\n```sql\n-- IN示例\nSELECT *\nFROM products\nWHERE vend_id IN ('DLL01', 'BRS01');\n\n-- BETWEEN示例\nSELECT *\nFROM products\nWHERE prod_price BETWEEN 3 AND 5;\n```\n\n### AND/OR/NOT\n- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。\n- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。\n- `AND` 操作符表示左右条件都要满足。\n- `OR` 操作符表示左右条件满足任意一个即可。\n- `NOT` 操作符用于否定一个条件。\n\n```sql\n-- AND示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' AND prod_price <= 4;\n\n-- OR示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' OR vend_id = 'BRS01';\n\n-- NOT示例\nSELECT *\nFROM products\nWHERE prod_price NOT BETWEEN 3 AND 5;\n```\n\n### LIKE\n- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。\n- 只有字段是文本值时才使用 `LIKE`。\n- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。\n- 不要滥用通配符，通配符位于开头处匹配会非常慢。\n- `%` 表示任何字符出现任意次数。\n- `_` 表示任何字符出现一次。\n\n```sql\n-- %示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '%bean bag%';\n\n-- _示例\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '__ inch teddy bear';\n```\n\n### 连接JOIN\n`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。\n\n语法：\n```sql\nSELECT table1.column1, table2.column2...\nFROM table1\nJOIN table2\nON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not\n```\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n\n如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。\n```sql\n# JOIN....ON\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nON c.cust_id = o.cust_id\n-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()\n-- using(cust_id) 代替 ON c.cust_id = o.cust_id\nORDER BY c.cust_name;\n```\n\n### 内连接/外连接\n- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。\n- `外连接`：\n  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。\n  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。\n  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。\n\n\n```sql\n/* \nstudent表\nstudent_id\tname\n1\t        Alice\n2\t        Bob\n3\t        Carol\n\ncourses表\ncourse_id\tstudent_id\tcourse_name\n101\t        1\t        Math\n102\t        2\t        Science\n103\t        4\t        History\n*/\n\n-- 内连接\nSELECT students.name, courses.course_name\nFROM students\nINNER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\n*/\n\n-- 左外连接\nSELECT students.name, courses.course_name\nFROM students\nLEFT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\n*/\n\n-- 右外连接\nSELECT students.name, courses.course_name\nFROM students\nRIGHT OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nNULL\tHistory\n*/\n\n-- 全外连接\nSELECT students.name, courses.course_name\nFROM students\nFULL OUTER JOIN courses ON students.student_id = courses.student_id;\n/*\n结果\nname\tcourse_name\nAlice\tMath\nBob\tScience\nCarol\tNULL\nNULL\tHistory\n*/\n```\n\n### ON/WHERE区别\n- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。\n- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。\n\n### 组合UNION\n`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。\n\n`UNION` 基本规则：\n- 所有查询的列数和列顺序必须相同。\n- 每个查询中涉及表的列的数据类型必须相同或兼容。\n- 通常返回的列名取自第一个查询。\n- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。\n\n```sql\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n```\n\n### DDL语言✅\n`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。\n\n### 数据库DATABSE\n- 创建数据库：`CREATE DATABASE 数据库名;`\n- 删除数据库：`DROP DATABASE 数据库名;`\n- 选择数据库：`USE 数据库名;`\n- 查看数据库：`SHOW DATABASES;`\n\n### 数据表TABLE\n```sql\n-- 普通创建\nCREATE TABLE user (\nid int(10) unsigned NOT NULL COMMENT 'Id',\nusername varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',\npassword varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',\nemail varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'\n) COMMENT='用户表';\n\n-- 根据已有表创建\nCREATE TABLE vip_user AS\nSELECT * FROM user;\n\n-- 删除表\nDROP TABLE user;\n\n-- 查看表\nSHOW TABLES;\n\n-- 添加列\nALTER TABLE user -- ALTER用于修改表\nADD age int(3);\n\n-- 删除列\nALTER TABLE user\nDROP COLUMN age;\n\n-- 修改列\nALTER TABLE `user`\nMODIFY COLUMN age tinyint;\n\n-- 添加主键\nALTER TABLE user\nADD PRIMARY KEY (id);\n\n-- 删除主键\nALTER TABLE user\nDROP PRIMARY KEY;\n```\n\n### 视图VIEW\n在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。\n\n作用：\n- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。\n- 提高数据安全性：用来限制用户访问敏感数据。\n- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。\n- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。\n\n```sql\n-- 创建视图\nCREATE VIEW top_10_user_view AS\nSELECT id, username\nFROM user\nWHERE id < 10;\n\n-- 删除视图\nDROP VIEW top_10_user_view;\n```\n\n### 索引INDEX\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n**优点**\n- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n```sql\n-- 创建索引\nCREATE INDEX user_index\nON user (id);\n\n-- 添加索引\nALTER table user ADD INDEX user_index(id)\n\n-- 创建唯一索引\nCREATE UNIQUE INDEX user_index\nON user (id);\n\n-- 删除索引\nALTER TABLE user\nDROP INDEX user_index;\n```\n\n### 约束\nSQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。\n\n**约束类型**\n- `NOT NULL`：指示某列不能存储 `NULL` 值。\n- `UNIQUE`：保证某列的每行必须有唯一的值。\n- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。\n- `CHECK`：保证列中的值符合指定的条件。\n- `DEFAULT`：规定没有给列赋值时的默认值。\n\n```sql\nCREATE TABLE Users (\n  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',\n  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',\n  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',\n  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',\n  PRIMARY KEY (Id)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n```\n\n\n### TCL语句✅\n`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。\n\n### 事务TRANSACTION\n事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。\n\n**事务的四个特性(ACID)**\n- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- `一致性(Consistency)`：执行事务前后，数据保持一致。\n- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。\n\n> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。\n\n```sql\n-- 开始事务\nSTART TRANSACTION;\n\n-- 插入操作 A\nINSERT INTO `user`\nVALUES (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updateA\nSAVEPOINT updateA;\n\n-- 插入操作 B\nINSERT INTO `user`\nVALUES (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updateA\nROLLBACK TO updateA;\n\n-- 提交事务，只有操作 A 生效\nCOMMIT;\n```\n\n### DCL语句✅\n`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。\n\n### 权限管理\n- 授予用户帐户权限，用`GRANT`命令。\n  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。\n  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。\n  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。\n  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。\n  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。\n- 撤销用户的权限，用`REVOKE`命令。\n  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。\n  - 指定在 `ON` 子句中撤销特权的特权级别。\n  - 指定要撤消 `FROM` 子句中的权限的用户帐户。\n\n`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：\n- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；\n- 整个数据库，使用 `ON database.*`；\n- 特定的表，使用 `ON database.table`；\n- 特定的列；\n- 特定的存储过程。\n\n```sql\n-- GRANT用法\nGRANT privilege,[privilege],.. ON privilege_level\nTO user [IDENTIFIED BY password]\n[REQUIRE tsl_option]\n[WITH [GRANT_OPTION | resource_option]];\n\n-- REVOKE用法\nREVOKE privilege_type [(column_list)]\n       [, priv_type [(column_list)]]...\nON [object_type] privilege_level\nFROM user [, user]...\n\n-- 创建账户\nCREATE USER myuser IDENTIFIED BY 'mypassword';\n-- 修改账户名\nUPDATE user SET user='newuser' WHERE user='myuser';\nFLUSH PRIVILEGES;\n-- 删除账户\nDROP USER myuser;\n-- 查看权限\nSHOW GRANTS FOR myuser;\n-- 授予权限\nGRANT SELECT, INSERT ON *.* TO myuser;\n-- 删除权限\nREVOKE SELECT, INSERT ON *.* FROM myuser;\n-- 更改密码\nSET PASSWORD FOR myuser = 'mypass';\n```\n\n### 游标CURSOR\n游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。\n\n### 触发器TRIGGER\n触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。\n\n**优点**\n- SQL 触发器提供了另一种检查数据完整性的方法。\n- SQL 触发器可以捕获数据库层中业务逻辑中的错误。\n- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。\n- SQL 触发器对于审计表中数据的更改非常有用。\n\n**缺点**\n- SQL 触发器可能会增加数据库服务器的开销。\n- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。\n\n在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。\n- `BEFORE INSERT`：在将数据插入表格之前激活。\n- `AFTER INSERT`：将数据插入表格后激活。\n- `BEFORE UPDATE`：在更新表中的数据之前激活。\n- `AFTER UPDATE`：更新表中的数据后激活。\n- `BEFORE DELETE`：在从表中删除数据之前激活。\n- `AFTER DELETE`：从表中删除数据后激活。\n\n`NEW` 和 `OLD`：\n- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；\n- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；\n- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；\n- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)\n\n### 触发器语法\n\n```sql\n-- 创建触发器\nCREATE TRIGGER trigger_name\ntrigger_time\ntrigger_event\nON table_name\nFOR EACH ROW\nBEGIN\ntrigger_statements\nEND;\n```\n\n说明：\n- `trigger_name`：触发器名\n- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。\n- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。\n- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。\n- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。\n- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。\n\n当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。\n\n```sql\n-- 创建触发器\nDELIMITER $\nCREATE TRIGGER `trigger_insert_user`\nAFTER INSERT ON `user`\nFOR EACH ROW\nBEGIN\n    INSERT INTO `user_history`(user_id, operate_type, operate_time)\n    VALUES (NEW.id, 'add a user',  now());\nEND $\nDELIMITER ;\n\n-- 查看触发器\nSHOW TRIGGERS;\n\n-- 删除触发器\nDROP TRIGGER trigger_insert_user;\n```\n\n## MySQL\nMySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是`3306`。\n\n### MySQL基础✅\n\n### MySQL优点\n- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。\n- 开箱即用，操作简单，维护成本低。\n- 兼容性好，支持常见的操作系统，支持多种开发语言。\n- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。\n- 支持分库分表、读写分离、高可用。\n\n### 什么是关系型数据库\n关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。\n\n大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……\n\n### MySQL字段类型\n简单分为三大类：数值类型、字符串类型、日期和时间类型。\n- 数值类型：\n  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。\n  - 浮点型：`FLOAT`、`DOUBLE`。\n  - 定点数：`DECIMAL`。\n- 字符串类型：\n  - 常用：`CHAR`、`VARCHAR`、`TEXT`。\n  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。\n- 日期和时间类型：\n  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。\n\n### 整数类型的UNSIGNED属性\n整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。\n\n> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。\n> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。\n\n对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。\n\n### CHAR/VARCHAR区别\n- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。\n- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。\n- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。\n- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。\n\n### VARCHAR(100)/VARCHAR(10)区别\n- 前者最大长度为 100，后者最大长度为 10。\n- 二者存储相同的字符串所占用的存储空间是一样的。\n- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。\n\n### DECIMAL和FLOAT/DOUBLE区别\n`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。\n\n### 为什么没不推荐使用TEXT/BLOB类型\n- `TEXT`用于存储长文本数据，如博客数据。\n- `BLOB`用于存储二进制大对象，例如图片、音视频等文件。\n\n这两种类型有如下缺陷：\n- 不能有默认值。\n- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。\n- 检索效率较低。\n- 不能直接创建索引，需要指定前缀长度。\n- 可能会消耗大量的网络和 IO 带宽。\n- 可能导致表上的 DML 操作变慢。\n\n### DATETIME/TIMESTAMP区别\n- `DATETIME`没有时区信息，`TIMESTAMP` 和时区有关。\n- `TIMESTAMP` 只需要使用 4 个字节的存储空间，但是 `DATETIME` 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，`TIMESTAMP` 表示的时间范围更小。\n  - `DATETIME`：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n  - `TIMESTAMP`：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC\n- `TIMESTAMP` 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。\n\n### NULL和''区别\n- `NULL` 表示未知的值，`''` 表示空字符串。\n  - `SELECT NULL=NULL`的结果为 `false`，但在使用`DISTINCT`,`GROUP BY`,`ORDER BY`时又认为`NULL`是相等的。\n- `''`长度为0，不占用空间，`NULL`占用空间。\n- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 `=`、`!=`、 `<`、`>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。\n- `NULL` 会影响聚合函数的结果。\n  - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。`COUNT` 的处理方式取决于参数的类型。如果参数是 `*(COUNT(*))`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名`(COUNT(列名))`，则会忽略 `NULL` 值，只统计非空值的个数。\n\n不推荐使用`NULL`作为列默认值。\n\n### Boolean类型如何在MySQL中存储\nMySQL 中没有布尔类型，可以使用 `TINYINT` 类型来存储布尔值。`TINYINT(1)` 可以存储 0 或 1，分别表示 `false` 和 `true`。\n\n### MySQL基础架构✅\n\nMySQL 基础架构主要分为 Server 层和存储引擎层：\n- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。\n- 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 `redolog` 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。\n\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\n- 连接器：身份认证和权限相关(登录 MySQL 的时候)。\n- 查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。\n- 分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\n- 优化器：按照 MySQL 认为最优的方案去执行。\n- 执行器：执行语句，然后从存储引擎返回数据。\n- 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。\n\n1. 连接器。\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。\n\n2. 查询缓存(MySQL 8.0 版本后移除)。\n主要用来缓存所执行的 `SELECT` 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 `Key-Value` 的形式缓存在内存中，`Key` 是查询语句，`Value` 是结果集。如果缓存 `Key` 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\n\n3. 分析器。\nMySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：\n   - 第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\n   - 第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\n\n4. 优化器。\n优化器以它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\n\n5. 执行器。\n当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\n\n### SQL语句在MySQL中的执行过程\n\n**查询语句**\n查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\n```sql\nselect * from tb_student  A where A.age='18' and A.name=' 张三 ';\n```\n1. 检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 `key` 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。\n2. 通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\n3. 优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：\n   - a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\n   - b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。\n4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\n\n**更新语句(增加，修改，删除)**\n更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)\n```sql\nupdate tb_student A set A.age='19' where A.name=' 张三 ';\n```\nMySQL自带的日志模块是 `binlog`，以 `InnoDB` 作为存储引擎介绍，其自带了一个`redo log` 日志模块，用来保证数据的一致性的。\n1. 先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。\n2. 拿到查询的语句，把 `age` 改为 19，然后调用引擎 API 接口，写入这一行数据，`InnoDB` 引擎把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，执行完成了，随时可以提交。\n3. 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log` 为提交状态。\n4. 更新完成。\n\n### MySQL存储引擎✅\n\n### MySQL支持哪些存储引擎？\nMySQL 支持多种存储引擎，常见的存储引擎有 `InnoDB`、`MyISAM`、`Memory`、`CSV`、`Archive`、`Blackhole`、`NDB`、`Merge`、`Federated`、`Example` 等。\n\nMySQL 5.5.5 之前，`MyISAM` 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。\n\n### MyISAM/InnoDB存储引擎区别\n- `MyISAM`只支持表级锁，而 `InnoDB` 支持行级锁和表级锁，默认为行级锁。\n- `MyISAM` 不提供事务支持。`InnoDB` 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(`commit`)和回滚(`rollback`)事务的能力。并且，`InnoDB` 默认使用的 `REPEATABLE-READ`（可重读）隔离级别是可以解决幻读问题发生的（基于 `MVCC` 和 `Next-Key Lock`）。\n- `MyISAM` 不支持外键，而 `InnoDB` 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。\n- `MyISAM` 不支持数据库异常崩溃后的安全恢复，而 `InnoDB` 支持，恢复过程依赖于`redo log`。\n- `InnoDB`支持 `MVCC`，`MyISAM` 不支持。`MVCC` 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n- `InnoDB`和`MyISAM`都使用`B+Tree` 作为索引结构，但二者实现方式不一样。`InnoDB` 引擎中，其数据文件本身就是索引文件。相比 `MyISAM`，索引文件和数据文件是分离的，其表数据文件本身就是按 `B+Tree` 组织的一个索引结构，树的叶节点 `data` 域保存了完整的数据记录。\n- `InnoDB` 的性能比 `MyISAM` 更强大，随着 CPU 核数的增加，`InnoDB` 的读写能力呈线性增长。\n- 数据缓存策略和机制实现不同。`InnoDB` 使用缓冲池（`Buffer Pool`）缓存数据页和索引页，`MyISAM` 使用键缓存（`Key Cache`）仅缓存索引页而不缓存数据页。\n\n### MySQL索引✅\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 `Innodb` 还是 `MyIsam`，都使用了 **B+树**作为索引结构。\n\n**优点**\n- 大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。\n- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n**缺点**\n- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n- 索引需要使用物理文件存储，也会耗费一定空间。\n\n### 索引底层数据类型选型\n1. `Hash`索引\n`InnoDB` 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”（`Adaptive Hash Index`），结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 `B+Tree` 结构(不是传统的链表+红黑树)，这个 `B+Tree` 结构可以存储多个键值对，而不仅仅是一个键。`Hash` 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。\n\n2. 二叉查找树\n二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。\n当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 `O(N)`。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。\n\n3. AVL树\nAVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。\n\n4. 红黑树\n红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致**一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因**。红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 `O(logn)` 次数的旋转操作，其插入和删除操作效率大大提高。\n\n5. B树&B+树\nB 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。\n目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。\nB树&B+树区别\n- B 树的所有节点既存放键(`key`) 也存放数据(`data`)，而 B+树只有叶子节点存放 `key` 和 `data`，其他内节点只存放 `key`。\n- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。\n\n综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。\n\n### MyISAM/InnoDB索引区别\n`MyISAM` 引擎和 `InnoDB` 引擎都是使用 `B+Tree` 作为索引结构，但实现方式不太一样：\n- `MyISAM` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按照 `B+Tree` 搜索算法搜索索引，如果指定的 `Key` 存在，则取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。\n- `InnoDB` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 `InnoDB` 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。\n\n### 索引分类\n\n按照数据结构维度划分：\n- `BTree` 索引：MySQL 里默认和最常用的索引类型。\n- 哈希索引：类似键值对的形式，一次即可定位。\n\n按照底层存储方式角度划分：\n- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\n- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n按照应用维度划分：\n- 主键索引：加速查询 + 列值唯一（不可以有 `NULL`）+ 表中只有一个。\n- 普通索引：仅加速查询。\n- 唯一索引：加速查询 + 列值唯一（可以有 `NULL`）。\n- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 `ElasticSearch` 代替。\n\nMySQL 8.x 中实现的索引新特性：\n- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。\n- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 `GROUP BY` 语句进行隐式排序。\n- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。\n\n### 主键索引\n数据表的主键列使用的就是主键索引(主键索引的 `data` 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。\n\n在 MySQL 的 `InnoDB` 的表中，当没有显示的指定表的主键时，`InnoDB` 会自动先检查表中是否有唯一索引且不允许存在 `null` 值的字段，如果有，则选择该字段为默认的主键，否则 `InnoDB` 将会自动创建一个 6Byte 的自增主键。\n\n### 二级索引\n二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。\n\n唯一索引，普通索引，前缀索引等索引都属于二级索引。\n- 唯一索引(`Unique Key`):唯一索引的属性列不能出现重复的数据，但是允许数据为 `NULL`，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n- 普通索引(`Index`):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 `NULL`。\n- 前缀索引(`Prefix`):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。\n- 全文索引(`Full Text`):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 `MYISAM` 引擎支持全文索引，5.6 之后 `InnoDB` 也支持了全文索引。\n\n### 聚簇索引/非聚簇索引\n聚簇索引（聚集索引）：索引结构和数据一起存放的索引，`InnoDB` 中的主键索引就属于聚簇索引。\n\n**优点**：\n- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。\n- 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。\n\n**缺点**：\n- 依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串/UUID这类又长又难比较的数据，插入/查找的速度较慢。\n- 更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。\n\n非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 `MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n**优点**：\n更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。\n\n**缺点**：\n- 依赖于有序的数据\n- 可能会二次查询(回表):非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。\n\n### 回表\n在 `InnoDB` 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。\n\n### 覆盖索引/联合索引\n- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。\n- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n\n### 联合索引最左前缀匹配原则\n在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n### 索引下推ICP\n索引下推（`Index Condition Pushdown,ICP`） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`语句中的判断条件，直接过滤掉不满足条件的记录，从而**减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量**。\n\n**原理**\n![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)\n\nMySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。\n\n索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给下层（存储引擎层）去处理。\n\n```sql\nSELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;\n```\n- 没有索引下推，存储引擎层`zipcode` 字段利用索引可以快速定位到 `zipcode = '431200'`的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。\n- 有索引下推，存储引擎层根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。\n\n索引下推适用于 `InnoDB` 引擎和 `MyISAM` 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。\n\n### MySQL查询缓存✅\n执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用\n\n查询缓存不命中的情况：\n- 两个查询在任何字符上的不同都会导致缓存不命中。\n- 若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。\n- 缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。\n\n### MySQL三大日志✅\nMySQL比较重要的日志有二进制日志 `binlog`（归档日志）和事务日志 `redo log`（重做日志）和 `undo log`（回滚日志）。\n\nMySQL `InnoDB` 引擎使用 `redo log`(重做日志) 保证事务的持久性，使用 `undo log`(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### redo log\n`redo log`（重做日志）是 `InnoDB` 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，保证数据的持久性与完整性。\n\n查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 `Buffer Pool`中，后续查找先查找`Buffer Pool`，如果没有找到再去硬盘加载。更新数据的时候，若 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。\n\n### 刷盘时机\n`InnoDB` 在多种情况下将 `redo log` 刷到磁盘上，以保证数据的持久性和一致性。\n- 事务提交：当事务提交时，`redo log buffer` 里的 `redo log` 会被刷新到磁盘的 `redo log` 文件里。\n- `redo log buffer` 空间不足时：`redo log buffer` 中缓存的 `redo log` 已占了 `redo log buffer` 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。\n- `Checkpoint`（检查点）：`InnoDB` 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。\n- 正常关闭服务器：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去。\n- 后台线程：`InnoDB` 有一个后台线程，每隔1 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。\n\n### 刷盘策略\n`innodb_flush_log_at_trx_commit`参数设置三种刷盘策略：\n- 0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。\n- 1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。\n- 2，每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`（文件系统缓存）。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n默认策略为第二种。\n\n### binlog\n`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志，且是顺序写。\n\nMySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。\n\n### 记录格式\n`binlog` 有三种记录格式：\n- `Statement`：记录的是 SQL 语句，如 `update t set c=c+1 where id=2`。\n  - 同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。\n- `Row`：记录的是行数据，如 `id=2 c=2`。\n  - 这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。\n- `Mixed`：记录的是上面两种的混合模式。\n  - MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。\n\n### 写入机制\n事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中。一个事务的 `binlog` 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。\n\n通过 `write` 将`binlog cache`中的 `binlog`写入文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。\n\n**`write` 和 `fsync` 时机** 由参数`sync_binlog`控制，默认是1。\n- 0，每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。\n  - 虽然性能最高，但是机器宕机，`page cache`里面的 `binlog` 会丢失。\n- 1，每次提交事务都会执行`write`+`fsync`，和 `redo log` 日志刷盘流程一样。\n- N(>1)，每次提交事务都会执行`write`，但是累计 `N`次事务后才执行 `fsync`。\n  - 在出现 IO 瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近`N`个事务的 `binlog` 日志。\n\n### 两阶段提交\n`redo log`（重做日志）让 `InnoDB` 存储引擎拥有了崩溃恢复能力。`binlog`（归档日志）保证了 MySQL 集群架构的数据一致性。\n\n`redo log` 与 `binlog` 的写入时机不一样，`redo log` 是事务执行过程中写入，`binlog` 是事务提交后写入。\n\n写入机制不一样会导致日志不一致：\n若某一事务(更新某一行的a值，从 0->1)执行过程中写完 `redo log` 日志后，`binlog` 日志写期间发生了异常，写入失败。此时使用`redo log`恢复的数据中，a值已经变为1，而`binlog`中记录的是a值为0，这样就导致了数据不一致。\n\n为了解决数据不一致问题，InnoDB 存储引擎使用两阶段提交：将 `redo log` 的写入拆成了两个步骤`prepare`和`commit`。\n- `prepare`：在事务执行过程中，先写入 `redo log`，但是不提交事务。\n- `commit`：在事务提交后，再写入 `binlog`，然后提交`redo log`。\n\n使用两阶段提交后，写入 `binlog` 时发生异常也不会有影响。此时 MySQL 根据 `redo log` 日志恢复数据时，发现 `redo log` 还处于`prepare`阶段，并且没有对应 `binlog` 日志，就会回滚该事务。\n\n如果`redo log` 在 `commit`阶段发生异常，虽然 `redo log` 处于`prepare`阶段，但是能通过事务id找到对应的 `binlog` 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。\n\n### undo log\n`undo log` 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 `DELETE` 语句，那 `undo log` 就会记录一条相对应的 `INSERT` 语句。每一个事务对数据的修改都会被记录到 `undo log` ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 `undo log` 将数据恢复到事务开始之前的状态。\n\n`undo log` 本身是会被删除清理的，例如 `INSERT` 操作，在事务提交之后就可以清除掉了；`UPDATE/DELETE` 操作在事务提交不会立即删除，会加入 `history list`，由后台线程 `purge` 进行清理。\n\n`undo log` 采用 `segment`（段）进行记录，事务开始时，需要为其分配一个 `rollback segment`。每个 `rollback segment` 有 1024 个 `undo log segment`(每个 `undo` 操作在记录的时候占用一个 `undo log segment`，多个有助于管理多个并发事务) 和 一个 `rollback segment header`(负责管理`rollback segment`)，`history list` 是`rollback segment header`的一部分，它的主要作用是记录所有已经提交但还没有被清理（`purge`）的事务的 `undo log`，`history list`列表使得 `purge` 线程能够找到并清理那些不再需要的 `undo log` 记录。\n\n### MySQL事务✅\n事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n### 事务的四大特性\n- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\n- 一致性(Consistency)：执行事务前后，数据保持一致。\n- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。\n\n> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！\n\n### 并发事务存在的问题\n\n### 脏读\n一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。\n\n一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。\n\n解决：\n- 设置事务隔离级别为 `Read Committed` 或更高。`Read Committed` 确保事务只能读取已经提交的数据，从而避免脏读。\n\n### 丢失修改\n两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。\n\n在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n\n解决：\n- 乐观锁（Optimistic Locking）： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。\n- 悲观锁（Pessimistic Locking）： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。\n\n### 不可重复读\n一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。\n\n一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。\n\n解决：\n- 执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。\n\n### 幻读\n一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。\n\n一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n解决：\n- 执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。\n- 事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。\n\n### 不可重复读和幻读有什么区别\n- 不可重复读：多次读取同一数据，发现数据不一致。\n- 幻读：多次执行同一条查询语句，发现查到的记录增加了。\n\n幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。\n- 解决不可重复读：执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。\n- 解决幻读：执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。\n\n### 并发事务的控制方式有哪些\nMySQL 中并发事务的控制方式无非就两种：锁 和 `MVCC`。锁可以看作是悲观控制的模式，多版本并发控制（`MVCC，Multiversion concurrency control`）可以看作是乐观控制的模式。\n\n- 锁：\n  - 共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n  - 排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。\n- `MVCC` 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\n\n读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(`table-level locking`) 和 行级锁(`row-level locking`) 。`InnoDB` 默认为行级锁，也支持表级锁，所以并发性能比较高。\n\n> 注意：不论是表级锁还是行级锁，都存在共享锁（`Share Lock`，S 锁）和排他锁（`Exclusive Lock`，X 锁）这两类。\n\nMVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段、`read view`、`undo log`。\n- `undo log` : `undo log` 用于记录某行数据的多个版本的数据。\n- `read view` 和 隐藏字段 : 用来判断当前版本数据的可见性。\n\n### 事务隔离级别\n`READ-UNCOMMITTED`(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n`READ-COMMITTED`(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n`REPEATABLE-READ`(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n`SERIALIZABLE`(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n|     隔离级别     | 脏读 | 不可重复读 | 幻读 | 实现方式 |\n| :--------------: | :--: | :--------: | :--: | :------: |\n| READ-UNCOMMITTED |  √   |     √      |  √   | /        |\n|  READ-COMMITTED  |  ×   |     √      |  √   | 基于 MVCC/锁 |\n| REPEATABLE-READ  |  ×   |     ×      |  √   | 基于 MVCC/锁(当前读情况下需要使用加锁读来保证不会出现幻读) |\n|   SERIALIZABLE   |  ×   |     ×      |  ×   | 基于 锁 |\n\nMySQL默认隔离级别是 `REPEATABLE-READ`。\n\n\n\n\n\n### MySQL存储引擎\n存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。\n\n默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。\n\n### MySQL存储引擎架构\nMySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。\n\n### MySQL 锁机制\n锁是一种常见的并发事务的控制方式。\n\n### 表级锁/行级锁\nMyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。\n\nInnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。\n\n表级锁和行级锁对比：\n- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。\n- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n\n### MySQL字符集\nMySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`\n\n### MySQL字符集层次级别\n- MySQL 中的字符集分为四个层次：\n  - server(MySQL 实例级别)\n  - database(库级别)\n  - table(表级别)\n  - column(字段级别)\n\n其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。\n\nMySQL 字符编码集中有两套 UTF-8 编码实现：\n- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n\n\n## Redis\n\nRedisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。\n\n### 基本数据类型\nRedis 中比较常见的数据类型有下面这些：\n- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。\n- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。\n\n除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。\n\n### Redis持久化\n使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：\n- 快照(snapshotting，RDB)\n- 只追加文件(append-only file, AOF)\n- RDB 和 AOF 的混合持久化(Redis 4.0 新增)\n\n\n### 缓存穿透\n缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n### 缓存击穿\n缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n### 缓存雪崩\n缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\n\n\n\n\n","slug":"数据库","published":1,"layout":"post","photos":[],"link":"","_id":"clxkia0ve002duugnfeppbqpm","content":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"SQL-NoSQL基础\"><a href=\"#SQL-NoSQL基础\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL基础\"></a>SQL&#x2F;NoSQL基础</h2><h3 id=\"什么是SQL\"><a href=\"#什么是SQL\" class=\"headerlink\" title=\"什么是SQL\"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p>\n<h3 id=\"DB-DBMS-DBS-DBA\"><a href=\"#DB-DBMS-DBS-DBA\" class=\"headerlink\" title=\"DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA\"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul>\n<li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li>\n<li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"数据库术语\"><a href=\"#数据库术语\" class=\"headerlink\" title=\"数据库术语\"></a>数据库术语</h3><ul>\n<li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li>\n<li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li>\n<li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li>行(<code>row</code>)：表中的一个记录。</li>\n<li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性概念\"><a href=\"#元组-码-候选码-主码-外码-主属性-非主属性概念\" class=\"headerlink\" title=\"元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念\"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul>\n<li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p>\n<ul>\n<li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li>\n<li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<h3 id=\"数据库三范式\"><a href=\"#数据库三范式\" class=\"headerlink\" title=\"数据库三范式\"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。<ul>\n<li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li>\n</ul>\n</li>\n<li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li>\n<li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul>\n<li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul>\n<li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li>\n</ul>\n</li>\n<li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul>\n<li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li>\n</ul>\n</li>\n<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li>\n<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul>\n<li>例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主键-外键区别\"><a href=\"#主键-外键区别\" class=\"headerlink\" title=\"主键&#x2F;外键区别\"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>\n<h3 id=\"为什么不推荐使用外键和级联操作\"><a href=\"#为什么不推荐使用外键和级联操作\" class=\"headerlink\" title=\"为什么不推荐使用外键和级联操作\"></a>为什么不推荐使用外键和级联操作</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p>\n<ul>\n<li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；</li>\n<li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li>\n<li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li>\n</ul>\n<p><strong>外键好处</strong></p>\n<ul>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n</ul>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p>\n<p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<h3 id=\"DROP-TRUNCATE-DELETE区别\"><a href=\"#DROP-TRUNCATE-DELETE区别\" class=\"headerlink\" title=\"DROP&#x2F;TRUNCATE&#x2F;DELETE区别\"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol>\n<li>用法不同</li>\n</ol>\n<ul>\n<li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li>\n</ul>\n<p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p>\n<ol start=\"2\">\n<li>属于不同的数据库语言</li>\n</ol>\n<ul>\n<li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li>\n</ul>\n<ol start=\"3\">\n<li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li>\n</ol>\n<ul>\n<li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>DROP</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<h3 id=\"数据库设计分为哪几个步\"><a href=\"#数据库设计分为哪几个步\" class=\"headerlink\" title=\"数据库设计分为哪几个步\"></a>数据库设计分为哪几个步</h3><ol>\n<li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li>\n<li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li>数据库实施：包括编程、测试和试运行</li>\n<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>\n</ol>\n<h3 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p>\n<blockquote>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n</blockquote>\n<h3 id=\"SQL-NoSQL区别\"><a href=\"#SQL-NoSQL区别\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL区别\"></a>SQL&#x2F;NoSQL区别</h3><p>|         | SQL 数据库                                      | NoSQL 数据库                                                                                |<br>|：——–|———————————————-|——————————————————————————————|<br>| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |<br>| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |<br>| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |<br>| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |<br>| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |<br>| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |<br>| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |<br>| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |</p>\n<h3 id=\"NoSQL优劣\"><a href=\"#NoSQL优劣\" class=\"headerlink\" title=\"NoSQL优劣\"></a>NoSQL优劣</h3><p><strong>优点</strong></p>\n<ul>\n<li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li>\n<li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li>\n<li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li>\n<li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li>\n</ul>\n<h3 id=\"NoSQL分类\"><a href=\"#NoSQL分类\" class=\"headerlink\" title=\"NoSQL分类\"></a>NoSQL分类</h3><ul>\n<li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<h3 id=\"数据库分类\"><a href=\"#数据库分类\" class=\"headerlink\" title=\"数据库分类\"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p>\n<ul>\n<li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul>\n<li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li>\n</ul>\n</li>\n<li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul>\n<li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li>\n</ul>\n</li>\n<li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li>\n<li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li>\n</ul>\n<h3 id=\"SQL三种注释方式\"><a href=\"#SQL三种注释方式\" class=\"headerlink\" title=\"SQL三种注释方式\"></a>SQL三种注释方式</h3><ul>\n<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li>\n<li>多行注释：<code>/* 注释内容 */</code>。</li>\n<li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li>\n</ul>\n<h3 id=\"DML语句✅\"><a href=\"#DML语句✅\" class=\"headerlink\" title=\"DML语句✅\"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p>\n<h3 id=\"增删改查CRUD\"><a href=\"#增删改查CRUD\" class=\"headerlink\" title=\"增删改查CRUD\"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入完整的行</span></span><br><span class=\"line\"><span class=\"comment\">-- 插入一行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 插入多行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">12</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">18</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入行的一部分</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username, password, email)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入查询出来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> account;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> username<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span>, password<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 删除表中的指定数据</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;robot&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表中的数据</span></span><br><span class=\"line\"><span class=\"keyword\">TRUNCATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询数据</strong></p>\n<ul>\n<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>\n<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>\n<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>\n<li><code>ASC</code>：升序(默认)</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询单列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询多列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询所有列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询不同的值</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">vend_id <span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 限制查询结果</span></span><br><span class=\"line\"><span class=\"comment\">-- 返回前 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">0</span>, <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 返回第 3 ~ 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">2</span>, <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li>\n<li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> prod_price <span class=\"keyword\">DESC</span>, prod_name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>**<code>GROUP BY</code>**：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分组</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 分组后排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cust_name <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> NumberOfOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_email <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE-HAVING对比\"><a href=\"#WHERE-HAVING对比\" class=\"headerlink\" title=\"WHERE&#x2F;HAVING对比\"></a>WHERE&#x2F;HAVING对比</h3><ul>\n<li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li>\n<li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li>\n</ul>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>MYSQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   table1 [, table2 ]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  column_name operator</span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">    [<span class=\"keyword\">WHERE</span>])</span><br></pre></td></tr></table></figure></li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">      <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">      [<span class=\"keyword\">WHERE</span>]) <span class=\"keyword\">as</span> temp_table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  <span class=\"keyword\">condition</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, cust_contact</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> cust_id</span><br><span class=\"line\">                  <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\">                  <span class=\"keyword\">WHERE</span> order_num <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> order_num</span><br><span class=\"line\">                                      <span class=\"keyword\">FROM</span> orderitems</span><br><span class=\"line\">                                      <span class=\"keyword\">WHERE</span> prod_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SELECT语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">SET</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jack Jones&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- DELETE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>&lt;&gt;</code></td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>BETWEEN</code></td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td><code>LIKE</code></td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td><code>IN</code></td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"IN-BETWEEN\"><a href=\"#IN-BETWEEN\" class=\"headerlink\" title=\"IN&#x2F;BETWEEN\"></a>IN&#x2F;BETWEEN</h3><ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- IN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"keyword\">IN</span> (<span class=\"string\">&#x27;DLL01&#x27;</span>, <span class=\"string\">&#x27;BRS01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- BETWEEN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AND-OR-NOT\"><a href=\"#AND-OR-NOT\" class=\"headerlink\" title=\"AND&#x2F;OR&#x2F;NOT\"></a>AND&#x2F;OR&#x2F;NOT</h3><ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- AND示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">AND</span> prod_price <span class=\"operator\">&lt;=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- OR示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">OR</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;BRS01&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- NOT示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">NOT</span> <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- %示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%bean bag%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- _示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接JOIN\"><a href=\"#连接JOIN\" class=\"headerlink\" title=\"连接JOIN\"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> table1.column1, table2.column2...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> table2</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table1.common_column1 <span class=\"operator\">=</span> table2.common_column2; <span class=\"comment\">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JOIN....ON</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> c.cust_name, o.order_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers c</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Orders o</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.cust_id <span class=\"operator\">=</span> o.cust_id</span><br><span class=\"line\"><span class=\"comment\">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class=\"line\"><span class=\"comment\">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内连接-外连接\"><a href=\"#内连接-外连接\" class=\"headerlink\" title=\"内连接&#x2F;外连接\"></a>内连接&#x2F;外连接</h3><ul>\n<li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li>\n<li><code>外连接</code>：<ul>\n<li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li>\n<li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li>\n<li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">student表</span></span><br><span class=\"line\"><span class=\"comment\">student_id\tname</span></span><br><span class=\"line\"><span class=\"comment\">1\t        Alice</span></span><br><span class=\"line\"><span class=\"comment\">2\t        Bob</span></span><br><span class=\"line\"><span class=\"comment\">3\t        Carol</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">courses表</span></span><br><span class=\"line\"><span class=\"comment\">course_id\tstudent_id\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">101\t        1\t        Math</span></span><br><span class=\"line\"><span class=\"comment\">102\t        2\t        Science</span></span><br><span class=\"line\"><span class=\"comment\">103\t        4\t        History</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 内连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 左外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 右外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 全外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">FULL</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ON-WHERE区别\"><a href=\"#ON-WHERE区别\" class=\"headerlink\" title=\"ON&#x2F;WHERE区别\"></a>ON&#x2F;WHERE区别</h3><ul>\n<li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li>\n<li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li>\n</ul>\n<h3 id=\"组合UNION\"><a href=\"#组合UNION\" class=\"headerlink\" title=\"组合UNION\"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n<li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DDL语言✅\"><a href=\"#DDL语言✅\" class=\"headerlink\" title=\"DDL语言✅\"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p>\n<h3 id=\"数据库DATABSE\"><a href=\"#数据库DATABSE\" class=\"headerlink\" title=\"数据库DATABSE\"></a>数据库DATABSE</h3><ul>\n<li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li>\n<li>删除数据库：<code>DROP DATABASE 数据库名;</code></li>\n<li>选择数据库：<code>USE 数据库名;</code></li>\n<li>查看数据库：<code>SHOW DATABASES;</code></li>\n</ul>\n<h3 id=\"数据表TABLE\"><a href=\"#数据表TABLE\" class=\"headerlink\" title=\"数据表TABLE\"></a>数据表TABLE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 普通创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> (</span><br><span class=\"line\">id <span class=\"type\">int</span>(<span class=\"number\">10</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;Id&#x27;</span>,</span><br><span class=\"line\">username <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">password <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">email <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱&#x27;</span></span><br><span class=\"line\">) COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 根据已有表创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> vip_user <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"comment\">-- ALTER用于修改表</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> age <span class=\"type\">int</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\">MODIFY <span class=\"keyword\">COLUMN</span> age tinyint;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"视图VIEW\"><a href=\"#视图VIEW\" class=\"headerlink\" title=\"视图VIEW\"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p>\n<p>作用：</p>\n<ul>\n<li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li>\n<li>提高数据安全性：用来限制用户访问敏感数据。</li>\n<li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li>\n<li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> top_10_user_view <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, username</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">&lt;</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除视图</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引INDEX\"><a href=\"#索引INDEX\" class=\"headerlink\" title=\"索引INDEX\"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">table</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX user_index(id)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p>\n<p><strong>约束类型</strong></p>\n<ul>\n<li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li>\n<li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>：保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Users (</span><br><span class=\"line\">  Id <span class=\"type\">INT</span>(<span class=\"number\">10</span>) UNSIGNED <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增Id&#x27;</span>,</span><br><span class=\"line\">  Username <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">  Password <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">  Email <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱地址&#x27;</span>,</span><br><span class=\"line\">  Enabled TINYINT(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;是否有效&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (Id)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"TCL语句✅\"><a href=\"#TCL语句✅\" class=\"headerlink\" title=\"TCL语句✅\"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h3 id=\"事务TRANSACTION\"><a href=\"#事务TRANSACTION\" class=\"headerlink\" title=\"事务TRANSACTION\"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p>\n<p><strong>事务的四个特性(ACID)</strong></p>\n<ul>\n<li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li>\n<li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<blockquote>\n<p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开始事务</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 A</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">SAVEPOINT</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 B</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 回滚到保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> <span class=\"keyword\">TO</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务，只有操作 A 生效</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DCL语句✅\"><a href=\"#DCL语句✅\" class=\"headerlink\" title=\"DCL语句✅\"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p>\n<h3 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h3><ul>\n<li>授予用户帐户权限，用<code>GRANT</code>命令。<ul>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ul>\n</li>\n<li>撤销用户的权限，用<code>REVOKE</code>命令。<ul>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ul>\n</li>\n</ul>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- GRANT用法</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> privilege,[privilege],.. <span class=\"keyword\">ON</span> privilege_level</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span> [IDENTIFIED <span class=\"keyword\">BY</span> password]</span><br><span class=\"line\">[REQUIRE tsl_option]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> [GRANT_OPTION <span class=\"operator\">|</span> resource_option]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- REVOKE用法</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> privilege_type [(column_list)]</span><br><span class=\"line\">       [, priv_type [(column_list)]]...</span><br><span class=\"line\"><span class=\"keyword\">ON</span> [object_type] privilege_level</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> [, <span class=\"keyword\">user</span>]...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建账户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> myuser IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;mypassword&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 修改账户名</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;newuser&#x27;</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;myuser&#x27;</span>;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"><span class=\"comment\">-- 删除账户</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 查看权限</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> GRANTS <span class=\"keyword\">FOR</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 授予权限</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 更改密码</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> PASSWORD <span class=\"keyword\">FOR</span> myuser <span class=\"operator\">=</span> <span class=\"string\">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"游标CURSOR\"><a href=\"#游标CURSOR\" class=\"headerlink\" title=\"游标CURSOR\"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<h3 id=\"触发器TRIGGER\"><a href=\"#触发器TRIGGER\" class=\"headerlink\" title=\"触发器TRIGGER\"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n</ul>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>：将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>：从表中删除数据后激活。</li>\n</ul>\n<p><code>NEW</code> 和 <code>OLD</code>：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li>\n</ul>\n<h3 id=\"触发器语法\"><a href=\"#触发器语法\" class=\"headerlink\" title=\"触发器语法\"></a>触发器语法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name</span><br><span class=\"line\">trigger_time</span><br><span class=\"line\">trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">trigger_statements</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li><code>trigger_name</code>：触发器名</li>\n<li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\">DELIMITER $</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> `trigger_insert_user`</span><br><span class=\"line\">AFTER <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (NEW.id, <span class=\"string\">&#x27;add a user&#x27;</span>,  now());</span><br><span class=\"line\"><span class=\"keyword\">END</span> $</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看触发器</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TRIGGERS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p>\n<h3 id=\"MySQL基础✅\"><a href=\"#MySQL基础✅\" class=\"headerlink\" title=\"MySQL基础✅\"></a>MySQL基础✅</h3><h3 id=\"MySQL优点\"><a href=\"#MySQL优点\" class=\"headerlink\" title=\"MySQL优点\"></a>MySQL优点</h3><ul>\n<li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ul>\n<h3 id=\"什么是关系型数据库\"><a href=\"#什么是关系型数据库\" class=\"headerlink\" title=\"什么是关系型数据库\"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p>\n<h3 id=\"MySQL字段类型\"><a href=\"#MySQL字段类型\" class=\"headerlink\" title=\"MySQL字段类型\"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p>\n<ul>\n<li>数值类型：<ul>\n<li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li>\n<li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li>\n<li>定点数：<code>DECIMAL</code>。</li>\n</ul>\n</li>\n<li>字符串类型：<ul>\n<li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li>\n<li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li>\n</ul>\n</li>\n<li>日期和时间类型：<ul>\n<li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"整数类型的UNSIGNED属性\"><a href=\"#整数类型的UNSIGNED属性\" class=\"headerlink\" title=\"整数类型的UNSIGNED属性\"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>\n<blockquote>\n<p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p>\n</blockquote>\n<p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h3 id=\"CHAR-VARCHAR区别\"><a href=\"#CHAR-VARCHAR区别\" class=\"headerlink\" title=\"CHAR&#x2F;VARCHAR区别\"></a>CHAR&#x2F;VARCHAR区别</h3><ul>\n<li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li>\n<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li>\n<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>\n<li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li>\n</ul>\n<h3 id=\"VARCHAR-100-VARCHAR-10-区别\"><a href=\"#VARCHAR-100-VARCHAR-10-区别\" class=\"headerlink\" title=\"VARCHAR(100)&#x2F;VARCHAR(10)区别\"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul>\n<li>前者最大长度为 100，后者最大长度为 10。</li>\n<li>二者存储相同的字符串所占用的存储空间是一样的。</li>\n<li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li>\n</ul>\n<h3 id=\"DECIMAL和FLOAT-DOUBLE区别\"><a href=\"#DECIMAL和FLOAT-DOUBLE区别\" class=\"headerlink\" title=\"DECIMAL和FLOAT&#x2F;DOUBLE区别\"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p>\n<h3 id=\"为什么没不推荐使用TEXT-BLOB类型\"><a href=\"#为什么没不推荐使用TEXT-BLOB类型\" class=\"headerlink\" title=\"为什么没不推荐使用TEXT&#x2F;BLOB类型\"></a>为什么没不推荐使用TEXT&#x2F;BLOB类型</h3><ul>\n<li><code>TEXT</code>用于存储长文本数据，如博客数据。</li>\n<li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li>\n</ul>\n<p>这两种类型有如下缺陷：</p>\n<ul>\n<li>不能有默认值。</li>\n<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li>\n<li>检索效率较低。</li>\n<li>不能直接创建索引，需要指定前缀长度。</li>\n<li>可能会消耗大量的网络和 IO 带宽。</li>\n<li>可能导致表上的 DML 操作变慢。</li>\n</ul>\n<h3 id=\"DATETIME-TIMESTAMP区别\"><a href=\"#DATETIME-TIMESTAMP区别\" class=\"headerlink\" title=\"DATETIME&#x2F;TIMESTAMP区别\"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul>\n<li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li>\n<li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul>\n<li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li>\n</ul>\n</li>\n<li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li>\n</ul>\n<h3 id=\"NULL和’’区别\"><a href=\"#NULL和’’区别\" class=\"headerlink\" title=\"NULL和’’区别\"></a>NULL和’’区别</h3><ul>\n<li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul>\n<li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li>\n</ul>\n</li>\n<li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li>\n<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>\n<li><code>NULL</code> 会影响聚合函数的结果。<ul>\n<li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>\n</ul>\n</li>\n</ul>\n<p>不推荐使用<code>NULL</code>作为列默认值。</p>\n<h3 id=\"Boolean类型如何在MySQL中存储\"><a href=\"#Boolean类型如何在MySQL中存储\" class=\"headerlink\" title=\"Boolean类型如何在MySQL中存储\"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p>\n<h3 id=\"MySQL基础架构✅\"><a href=\"#MySQL基础架构✅\" class=\"headerlink\" title=\"MySQL基础架构✅\"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li>\n<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li>\n</ul>\n<p><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<ul>\n<li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li>查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li>优化器：按照 MySQL 认为最优的方案去执行。</li>\n<li>执行器：执行语句，然后从存储引擎返回数据。</li>\n<li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<ol>\n<li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>\n</li>\n<li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n</li>\n<li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p>\n<ul>\n<li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>\n<li>第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</li>\n</ul>\n</li>\n<li><p>优化器。<br>优化器以它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n</li>\n<li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n</li>\n</ol>\n<h3 id=\"SQL语句在MySQL中的执行过程\"><a href=\"#SQL语句在MySQL中的执行过程\" class=\"headerlink\" title=\"SQL语句在MySQL中的执行过程\"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> tb_student  A <span class=\"keyword\">where</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;18&#x27;</span> <span class=\"keyword\">and</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>\n<li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n<li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul>\n<li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li>\n<li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li>\n</ul>\n</li>\n<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>\n</ol>\n<p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> tb_student A <span class=\"keyword\">set</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;19&#x27;</span> <span class=\"keyword\">where</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p>\n<ol>\n<li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li>\n<li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li>\n<li>更新完成。</li>\n</ol>\n<h3 id=\"MySQL存储引擎✅\"><a href=\"#MySQL存储引擎✅\" class=\"headerlink\" title=\"MySQL存储引擎✅\"></a>MySQL存储引擎✅</h3><h3 id=\"MySQL支持哪些存储引擎？\"><a href=\"#MySQL支持哪些存储引擎？\" class=\"headerlink\" title=\"MySQL支持哪些存储引擎？\"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p>\n<p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p>\n<h3 id=\"MySQL存储引擎架构\"><a href=\"#MySQL存储引擎架构\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。</p>\n<h3 id=\"MyISAM-InnoDB存储引擎区别\"><a href=\"#MyISAM-InnoDB存储引擎区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB存储引擎区别\"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul>\n<li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>\n<li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>（可重读）隔离级别是可以解决幻读问题发生的（基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>）。</li>\n<li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li>\n<li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li>\n<li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li>\n<li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li>\n<li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li>\n<li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池（<code>Buffer Pool</code>）缓存数据页和索引页，<code>MyISAM</code> 使用键缓存（<code>Key Cache</code>）仅缓存索引页而不缓存数据页。</li>\n</ul>\n<h3 id=\"MySQL索引✅\"><a href=\"#MySQL索引✅\" class=\"headerlink\" title=\"MySQL索引✅\"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyIsam</code>，都使用了 <strong>B+树</strong>作为索引结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h3 id=\"索引底层数据类型选型\"><a href=\"#索引底层数据类型选型\" class=\"headerlink\" title=\"索引底层数据类型选型\"></a>索引底层数据类型选型</h3><ol>\n<li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”（<code>Adaptive Hash Index</code>），结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p>\n</li>\n<li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p>\n</li>\n<li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p>\n</li>\n<li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p>\n</li>\n<li><p>B树&amp;B+树<br>B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br>B树&amp;B+树区别</p>\n</li>\n</ol>\n<ul>\n<li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li>\n<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>\n</ul>\n<p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>\n<h3 id=\"MyISAM-InnoDB索引区别\"><a href=\"#MyISAM-InnoDB索引区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB索引区别\"></a>MyISAM&#x2F;InnoDB索引区别</h3><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p>\n<ul>\n<li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。</li>\n<li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>按照数据结构维度划分：</p>\n<ul>\n<li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li>\n<li>哈希索引：类似键值对的形式，一次即可定位。</li>\n</ul>\n<p>按照底层存储方式角度划分：</p>\n<ul>\n<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>\n<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>\n</ul>\n<p>按照应用维度划分：</p>\n<ul>\n<li>主键索引：加速查询 + 列值唯一（不可以有 <code>NULL</code>）+ 表中只有一个。</li>\n<li>普通索引：仅加速查询。</li>\n<li>唯一索引：加速查询 + 列值唯一（可以有 <code>NULL</code>）。</li>\n<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的索引新特性：</p>\n<ul>\n<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>\n<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 <code>GROUP BY</code> 语句进行隐式排序。</li>\n<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p>\n<p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p>\n<h3 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h3><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p>\n<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>\n<ul>\n<li>唯一索引(<code>Unique Key</code>):唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li>普通索引(<code>Index</code>):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li>\n<li>前缀索引(<code>Prefix</code>):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>\n<li>全文索引(<code>Full Text</code>):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li>\n</ul>\n<h3 id=\"聚簇索引-非聚簇索引\"><a href=\"#聚簇索引-非聚簇索引\" class=\"headerlink\" title=\"聚簇索引&#x2F;非聚簇索引\"></a>聚簇索引&#x2F;非聚簇索引</h3><p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>\n<li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li>\n<li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<p>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>\n<p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据</li>\n<li>可能会二次查询(回表):非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ul>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p>\n<h3 id=\"覆盖索引-联合索引\"><a href=\"#覆盖索引-联合索引\" class=\"headerlink\" title=\"覆盖索引&#x2F;联合索引\"></a>覆盖索引&#x2F;联合索引</h3><ul>\n<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n</ul>\n<h3 id=\"联合索引最左前缀匹配原则\"><a href=\"#联合索引最左前缀匹配原则\" class=\"headerlink\" title=\"联合索引最左前缀匹配原则\"></a>联合索引最左前缀匹配原则</h3><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>\n<h3 id=\"索引下推ICP\"><a href=\"#索引下推ICP\" class=\"headerlink\" title=\"索引下推ICP\"></a>索引下推ICP</h3><p>索引下推（<code>Index Condition Pushdown,ICP</code>） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p>\n<p><strong>原理</strong><br><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p>\n<p>索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给下层（存储引擎层）去处理。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> zipcode <span class=\"operator\">=</span> <span class=\"string\">&#x27;431200&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span>(birthdate) <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li>\n<li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li>\n</ul>\n<p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p>\n<h3 id=\"MySQL查询缓存✅\"><a href=\"#MySQL查询缓存✅\" class=\"headerlink\" title=\"MySQL查询缓存✅\"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p>查询缓存不命中的情况：</p>\n<ul>\n<li>两个查询在任何字符上的不同都会导致缓存不命中。</li>\n<li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n</ul>\n<p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p>\n<h3 id=\"MySQL三大日志✅\"><a href=\"#MySQL三大日志✅\" class=\"headerlink\" title=\"MySQL三大日志✅\"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>\n<p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h3><p><code>redo log</code>（重做日志）是 <code>InnoDB</code> 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p>\n<p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<h3 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h3><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p>\n<ul>\n<li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li>\n<li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>\n<li><code>Checkpoint</code>（检查点）：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>\n<li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li>\n<li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</li>\n</ul>\n<h3 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h3><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p>\n<ul>\n<li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li>\n<li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li>\n<li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>（文件系统缓存）。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>默认策略为第二种。</p>\n<h3 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p>\n<p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h3><p><code>binlog</code> 有三种记录格式：</p>\n<ul>\n<li><code>Statement</code>：记录的是 SQL 语句，如 <code>update t set c=c+1 where id=2</code>。<ul>\n<li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li>\n</ul>\n</li>\n<li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul>\n<li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li>\n</ul>\n</li>\n<li><code>Mixed</code>：记录的是上面两种的混合模式。<ul>\n<li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>\n<p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p>\n<ul>\n<li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul>\n<li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li>\n</ul>\n</li>\n<li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li>\n<li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul>\n<li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p><code>redo log</code>（重做日志）让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>（归档日志）保证了 MySQL 集群架构的数据一致性。</p>\n<p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p>\n<p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p>\n<p>为了解决数据不一致问题，InnoDB 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p>\n<ul>\n<li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li>\n<li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li>\n</ul>\n<p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p>\n<p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p><code>undo log</code> 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p>\n<p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p>\n<p><code>undo log</code> 采用 <code>segment</code>（段）进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理（<code>purge</code>）的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p>\n<h3 id=\"MySQL事务✅\"><a href=\"#MySQL事务✅\" class=\"headerlink\" title=\"MySQL事务✅\"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<h3 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h3><ul>\n<li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性(Consistency)：执行事务前后，数据保持一致。</li>\n<li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<blockquote>\n<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>\n</blockquote>\n<h3 id=\"并发事务存在的问题\"><a href=\"#并发事务存在的问题\" class=\"headerlink\" title=\"并发事务存在的问题\"></a>并发事务存在的问题</h3><h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p>\n<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>解决：</p>\n<ul>\n<li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li>\n</ul>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>解决：</p>\n<ul>\n<li>乐观锁（Optimistic Locking）： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li>\n<li>悲观锁（Pessimistic Locking）： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li>\n</ul>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p>\n<p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li>\n</ul>\n<h3 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h3><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p>\n<p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>insert</code> 操作的时候，由于记录锁（<code>Record Lock</code>）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（<code>Gap Lock</code>）。也就是说执行 <code>insert</code> 操作的时候需要依赖 <code>Next-Key Lock（Record Lock+Gap Lock）</code> 进行加锁来保证不出现幻读。</li>\n<li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li>\n</ul>\n<h3 id=\"不可重复读和幻读有什么区别\"><a href=\"#不可重复读和幻读有什么区别\" class=\"headerlink\" title=\"不可重复读和幻读有什么区别\"></a>不可重复读和幻读有什么区别</h3><ul>\n<li>不可重复读：多次读取同一数据，发现数据不一致。</li>\n<li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p>\n<ul>\n<li>解决不可重复读：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>解决幻读：执行 <code>insert</code> 操作的时候，由于记录锁（<code>Record Lock</code>）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（<code>Gap Lock</code>）。也就是说执行 <code>insert</code> 操作的时候需要依赖 <code>Next-Key Lock（Record Lock+Gap Lock）</code> 进行加锁来保证不出现幻读。</li>\n</ul>\n<h3 id=\"并发事务的控制方式有哪些\"><a href=\"#并发事务的控制方式有哪些\" class=\"headerlink\" title=\"并发事务的控制方式有哪些\"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制（<code>MVCC，Multiversion concurrency control</code>）可以看作是乐观控制的模式。</p>\n<ul>\n<li>锁：<ul>\n<li>共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li>排他锁（X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n</li>\n<li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p>\n<blockquote>\n<p>注意：不论是表级锁还是行级锁，都存在共享锁（<code>Share Lock</code>，S 锁）和排他锁（<code>Exclusive Lock</code>，X 锁）这两类。</p>\n</blockquote>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段、<code>read view</code>、<code>undo log</code>。</p>\n<ul>\n<li><code>undo log</code> : <code>undo log</code> 用于记录某行数据的多个版本的数据。</li>\n<li><code>read view</code> 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n<th align=\"center\">实现方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">READ-UNCOMMITTED</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">READ-COMMITTED</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁</td>\n</tr>\n<tr>\n<td align=\"center\">REPEATABLE-READ</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td>\n</tr>\n<tr>\n<td align=\"center\">SERIALIZABLE</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">基于 锁</td>\n</tr>\n</tbody></table>\n<p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><p>存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。</p>\n<p>默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。</p>\n<h3 id=\"MySQL存储引擎架构-1\"><a href=\"#MySQL存储引擎架构-1\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。</p>\n<h3 id=\"MySQL-锁机制\"><a href=\"#MySQL-锁机制\" class=\"headerlink\" title=\"MySQL 锁机制\"></a>MySQL 锁机制</h3><p>锁是一种常见的并发事务的控制方式。</p>\n<h3 id=\"表级锁-行级锁\"><a href=\"#表级锁-行级锁\" class=\"headerlink\" title=\"表级锁&#x2F;行级锁\"></a>表级锁&#x2F;行级锁</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p>\n<p>InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。</p>\n<p>表级锁和行级锁对比：</p>\n<ul>\n<li>表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>\n<li>行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>\n</ul>\n<h3 id=\"MySQL字符集\"><a href=\"#MySQL字符集\" class=\"headerlink\" title=\"MySQL字符集\"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p>\n<h3 id=\"MySQL字符集层次级别\"><a href=\"#MySQL字符集层次级别\" class=\"headerlink\" title=\"MySQL字符集层次级别\"></a>MySQL字符集层次级别</h3><ul>\n<li>MySQL 中的字符集分为四个层次：<ul>\n<li>server(MySQL 实例级别)</li>\n<li>database(库级别)</li>\n<li>table(表级别)</li>\n<li>column(字段级别)</li>\n</ul>\n</li>\n</ul>\n<p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Redis 中比较常见的数据类型有下面这些：</p>\n<ul>\n<li>5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。</li>\n<li>3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。</li>\n</ul>\n<p>除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。</p>\n<h3 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：</p>\n<ul>\n<li>快照(snapshotting，RDB)</li>\n<li>只追加文件(append-only file, AOF)</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网志框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p>本文参考 <a href=\"https://javaguide.cn/\">JavaGuide</a></p>\n</blockquote>\n<h2 id=\"SQL-NoSQL基础\"><a href=\"#SQL-NoSQL基础\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL基础\"></a>SQL&#x2F;NoSQL基础</h2><h3 id=\"什么是SQL\"><a href=\"#什么是SQL\" class=\"headerlink\" title=\"什么是SQL\"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p>\n<h3 id=\"DB-DBMS-DBS-DBA\"><a href=\"#DB-DBMS-DBS-DBA\" class=\"headerlink\" title=\"DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA\"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul>\n<li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li>\n<li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>\n<li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>\n<li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li>\n</ul>\n<h3 id=\"数据库术语\"><a href=\"#数据库术语\" class=\"headerlink\" title=\"数据库术语\"></a>数据库术语</h3><ul>\n<li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li>\n<li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li>\n<li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>\n<li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li>\n<li>行(<code>row</code>)：表中的一个记录。</li>\n<li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li>\n</ul>\n<h3 id=\"元组-码-候选码-主码-外码-主属性-非主属性概念\"><a href=\"#元组-码-候选码-主码-外码-主属性-非主属性概念\" class=\"headerlink\" title=\"元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念\"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul>\n<li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>\n<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>\n<li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>\n<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>\n<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>\n<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>\n<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>\n</ul>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p>\n<ul>\n<li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li>\n<li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<h3 id=\"数据库三范式\"><a href=\"#数据库三范式\" class=\"headerlink\" title=\"数据库三范式\"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。<ul>\n<li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li>\n</ul>\n</li>\n<li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li>\n<li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul>\n<li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul>\n<li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li>\n</ul>\n</li>\n<li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul>\n<li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li>\n</ul>\n</li>\n<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li>\n<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul>\n<li>例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主键-外键区别\"><a href=\"#主键-外键区别\" class=\"headerlink\" title=\"主键&#x2F;外键区别\"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>\n<h3 id=\"为什么不推荐使用外键和级联操作\"><a href=\"#为什么不推荐使用外键和级联操作\" class=\"headerlink\" title=\"为什么不推荐使用外键和级联操作\"></a>为什么不推荐使用外键和级联操作</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p>\n<ul>\n<li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；</li>\n<li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li>\n<li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li>\n</ul>\n<p><strong>外键好处</strong></p>\n<ul>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n</ul>\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p>\n<p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<h3 id=\"DROP-TRUNCATE-DELETE区别\"><a href=\"#DROP-TRUNCATE-DELETE区别\" class=\"headerlink\" title=\"DROP&#x2F;TRUNCATE&#x2F;DELETE区别\"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol>\n<li>用法不同</li>\n</ol>\n<ul>\n<li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li>\n</ul>\n<p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p>\n<ol start=\"2\">\n<li>属于不同的数据库语言</li>\n</ol>\n<ul>\n<li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li>\n</ul>\n<ol start=\"3\">\n<li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li>\n</ol>\n<ul>\n<li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>DROP</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<h3 id=\"数据库设计分为哪几个步\"><a href=\"#数据库设计分为哪几个步\" class=\"headerlink\" title=\"数据库设计分为哪几个步\"></a>数据库设计分为哪几个步</h3><ol>\n<li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li>\n<li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li>数据库实施：包括编程、测试和试运行</li>\n<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>\n</ol>\n<h3 id=\"什么是NoSQL\"><a href=\"#什么是NoSQL\" class=\"headerlink\" title=\"什么是NoSQL\"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p>\n<blockquote>\n<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>\n</blockquote>\n<h3 id=\"SQL-NoSQL区别\"><a href=\"#SQL-NoSQL区别\" class=\"headerlink\" title=\"SQL&#x2F;NoSQL区别\"></a>SQL&#x2F;NoSQL区别</h3><p>|         | SQL 数据库                                      | NoSQL 数据库                                                                                |<br>|：——–|———————————————-|——————————————————————————————|<br>| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |<br>| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |<br>| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |<br>| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |<br>| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |<br>| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |<br>| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |<br>| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |</p>\n<h3 id=\"NoSQL优劣\"><a href=\"#NoSQL优劣\" class=\"headerlink\" title=\"NoSQL优劣\"></a>NoSQL优劣</h3><p><strong>优点</strong></p>\n<ul>\n<li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li>\n<li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li>\n<li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li>\n<li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li>\n</ul>\n<h3 id=\"NoSQL分类\"><a href=\"#NoSQL分类\" class=\"headerlink\" title=\"NoSQL分类\"></a>NoSQL分类</h3><ul>\n<li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>\n<li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>\n<li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>\n<li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>\n</ul>\n<h3 id=\"数据库分类\"><a href=\"#数据库分类\" class=\"headerlink\" title=\"数据库分类\"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p>\n<ul>\n<li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul>\n<li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li>\n</ul>\n</li>\n<li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul>\n<li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li>\n</ul>\n</li>\n<li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li>\n<li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li>\n</ul>\n<h3 id=\"SQL三种注释方式\"><a href=\"#SQL三种注释方式\" class=\"headerlink\" title=\"SQL三种注释方式\"></a>SQL三种注释方式</h3><ul>\n<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li>\n<li>多行注释：<code>/* 注释内容 */</code>。</li>\n<li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li>\n</ul>\n<h3 id=\"DML语句✅\"><a href=\"#DML语句✅\" class=\"headerlink\" title=\"DML语句✅\"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p>\n<h3 id=\"增删改查CRUD\"><a href=\"#增删改查CRUD\" class=\"headerlink\" title=\"增删改查CRUD\"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>\n<p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入完整的行</span></span><br><span class=\"line\"><span class=\"comment\">-- 插入一行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 插入多行</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">10</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;root&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">12</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;user1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>), (<span class=\"number\">18</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;user2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入行的一部分</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username, password, email)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入查询出来的数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">user</span>(username)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> account;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> username<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span>, password<span class=\"operator\">=</span><span class=\"string\">&#x27;robot&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<ul>\n<li><code>DELETE</code> 语句用于删除表中的记录。</li>\n<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 删除表中的指定数据</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> <span class=\"string\">&#x27;robot&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表中的数据</span></span><br><span class=\"line\"><span class=\"keyword\">TRUNCATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询数据</strong></p>\n<ul>\n<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>\n<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>\n<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>\n<li><code>ASC</code>：升序(默认)</li>\n<li><code>DESC</code>：降序</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询单列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询多列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询所有列</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询不同的值</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span></span><br><span class=\"line\">vend_id <span class=\"keyword\">FROM</span> products;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 限制查询结果</span></span><br><span class=\"line\"><span class=\"comment\">-- 返回前 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">0</span>, <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 返回第 3 ~ 5 行</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> mytable LIMIT <span class=\"number\">2</span>, <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><ul>\n<li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li>\n<li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> prod_price <span class=\"keyword\">DESC</span>, prod_name <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>**<code>GROUP BY</code>**：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分组</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 分组后排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(cust_address) <span class=\"keyword\">AS</span> addr_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> cust_name <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HAVING\"><a href=\"#HAVING\" class=\"headerlink\" title=\"HAVING\"></a>HAVING</h3><ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">AS</span> NumberOfOrders</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_email <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> cust_name</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE-HAVING对比\"><a href=\"#WHERE-HAVING对比\" class=\"headerlink\" title=\"WHERE&#x2F;HAVING对比\"></a>WHERE&#x2F;HAVING对比</h3><ul>\n<li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li>\n<li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li>\n</ul>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>MYSQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p>\n<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>   table1 [, table2 ]</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  column_name operator</span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">    [<span class=\"keyword\">WHERE</span>])</span><br></pre></td></tr></table></figure></li>\n<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> column_name [, column_name ]</span><br><span class=\"line\">      <span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">      [<span class=\"keyword\">WHERE</span>]) <span class=\"keyword\">as</span> temp_table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span>  <span class=\"keyword\">condition</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> cust_name, cust_contact</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> cust_id</span><br><span class=\"line\">                  <span class=\"keyword\">FROM</span> orders</span><br><span class=\"line\">                  <span class=\"keyword\">WHERE</span> order_num <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> order_num</span><br><span class=\"line\">                                      <span class=\"keyword\">FROM</span> orderitems</span><br><span class=\"line\">                                      <span class=\"keyword\">WHERE</span> prod_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WHERE\"><a href=\"#WHERE\" class=\"headerlink\" title=\"WHERE\"></a>WHERE</h3><ul>\n<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>\n<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>\n<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- SELECT语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- UPDATE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">SET</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Jack Jones&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- DELETE语句中的WHERE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> cust_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li>可以在 <code>WHERE</code> 子句中使用的操作符。<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>=</code></td>\n<td>等于</td>\n</tr>\n<tr>\n<td><code>&lt;&gt;</code></td>\n<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td><code>BETWEEN</code></td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td><code>LIKE</code></td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td><code>IN</code></td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"IN-BETWEEN\"><a href=\"#IN-BETWEEN\" class=\"headerlink\" title=\"IN&#x2F;BETWEEN\"></a>IN&#x2F;BETWEEN</h3><ul>\n<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>\n<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- IN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"keyword\">IN</span> (<span class=\"string\">&#x27;DLL01&#x27;</span>, <span class=\"string\">&#x27;BRS01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- BETWEEN示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AND-OR-NOT\"><a href=\"#AND-OR-NOT\" class=\"headerlink\" title=\"AND&#x2F;OR&#x2F;NOT\"></a>AND&#x2F;OR&#x2F;NOT</h3><ul>\n<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>\n<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>\n<li><code>AND</code> 操作符表示左右条件都要满足。</li>\n<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>\n<li><code>NOT</code> 操作符用于否定一个条件。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- AND示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">AND</span> prod_price <span class=\"operator\">&lt;=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- OR示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;DLL01&#x27;</span> <span class=\"keyword\">OR</span> vend_id <span class=\"operator\">=</span> <span class=\"string\">&#x27;BRS01&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- NOT示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_price <span class=\"keyword\">NOT</span> <span class=\"keyword\">BETWEEN</span> <span class=\"number\">3</span> <span class=\"keyword\">AND</span> <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><ul>\n<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>\n<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>\n<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>\n<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>\n<li><code>%</code> 表示任何字符出现任意次数。</li>\n<li><code>_</code> 表示任何字符出现一次。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- %示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%bean bag%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- _示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> prod_id, prod_name, prod_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> prod_name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接JOIN\"><a href=\"#连接JOIN\" class=\"headerlink\" title=\"连接JOIN\"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> table1.column1, table2.column2...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> table2</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table1.common_column1 <span class=\"operator\">=</span> table2.common_column2; <span class=\"comment\">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JOIN....ON</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> c.cust_name, o.order_num</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> Customers c</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> Orders o</span><br><span class=\"line\"><span class=\"keyword\">ON</span> c.cust_id <span class=\"operator\">=</span> o.cust_id</span><br><span class=\"line\"><span class=\"comment\">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class=\"line\"><span class=\"comment\">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内连接-外连接\"><a href=\"#内连接-外连接\" class=\"headerlink\" title=\"内连接&#x2F;外连接\"></a>内连接&#x2F;外连接</h3><ul>\n<li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li>\n<li><code>外连接</code>：<ul>\n<li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li>\n<li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li>\n<li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">student表</span></span><br><span class=\"line\"><span class=\"comment\">student_id\tname</span></span><br><span class=\"line\"><span class=\"comment\">1\t        Alice</span></span><br><span class=\"line\"><span class=\"comment\">2\t        Bob</span></span><br><span class=\"line\"><span class=\"comment\">3\t        Carol</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">courses表</span></span><br><span class=\"line\"><span class=\"comment\">course_id\tstudent_id\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">101\t        1\t        Math</span></span><br><span class=\"line\"><span class=\"comment\">102\t        2\t        Science</span></span><br><span class=\"line\"><span class=\"comment\">103\t        4\t        History</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 内连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 左外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 右外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 全外连接</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> students.name, courses.course_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> students</span><br><span class=\"line\"><span class=\"keyword\">FULL</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> courses <span class=\"keyword\">ON</span> students.student_id <span class=\"operator\">=</span> courses.student_id;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">结果</span></span><br><span class=\"line\"><span class=\"comment\">name\tcourse_name</span></span><br><span class=\"line\"><span class=\"comment\">Alice\tMath</span></span><br><span class=\"line\"><span class=\"comment\">Bob\tScience</span></span><br><span class=\"line\"><span class=\"comment\">Carol\tNULL</span></span><br><span class=\"line\"><span class=\"comment\">NULL\tHistory</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ON-WHERE区别\"><a href=\"#ON-WHERE区别\" class=\"headerlink\" title=\"ON&#x2F;WHERE区别\"></a>ON&#x2F;WHERE区别</h3><ul>\n<li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li>\n<li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li>\n</ul>\n<h3 id=\"组合UNION\"><a href=\"#组合UNION\" class=\"headerlink\" title=\"组合UNION\"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n<li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1, column2, ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DDL语言✅\"><a href=\"#DDL语言✅\" class=\"headerlink\" title=\"DDL语言✅\"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p>\n<h3 id=\"数据库DATABSE\"><a href=\"#数据库DATABSE\" class=\"headerlink\" title=\"数据库DATABSE\"></a>数据库DATABSE</h3><ul>\n<li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li>\n<li>删除数据库：<code>DROP DATABASE 数据库名;</code></li>\n<li>选择数据库：<code>USE 数据库名;</code></li>\n<li>查看数据库：<code>SHOW DATABASES;</code></li>\n</ul>\n<h3 id=\"数据表TABLE\"><a href=\"#数据表TABLE\" class=\"headerlink\" title=\"数据表TABLE\"></a>数据表TABLE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 普通创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> (</span><br><span class=\"line\">id <span class=\"type\">int</span>(<span class=\"number\">10</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;Id&#x27;</span>,</span><br><span class=\"line\">username <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">password <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">email <span class=\"type\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱&#x27;</span></span><br><span class=\"line\">) COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 根据已有表创建</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> vip_user <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"comment\">-- ALTER用于修改表</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> age <span class=\"type\">int</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\">MODIFY <span class=\"keyword\">COLUMN</span> age tinyint;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"视图VIEW\"><a href=\"#视图VIEW\" class=\"headerlink\" title=\"视图VIEW\"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p>\n<p>作用：</p>\n<ul>\n<li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li>\n<li>提高数据安全性：用来限制用户访问敏感数据。</li>\n<li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li>\n<li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> top_10_user_view <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, username</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">&lt;</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除视图</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引INDEX\"><a href=\"#索引INDEX\" class=\"headerlink\" title=\"索引INDEX\"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">table</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX user_index(id)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX user_index</span><br><span class=\"line\"><span class=\"keyword\">ON</span> <span class=\"keyword\">user</span> (id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p>\n<p><strong>约束类型</strong></p>\n<ul>\n<li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li>\n<li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li>\n<li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>\n<li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li>\n<li><code>CHECK</code>：保证列中的值符合指定的条件。</li>\n<li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Users (</span><br><span class=\"line\">  Id <span class=\"type\">INT</span>(<span class=\"number\">10</span>) UNSIGNED <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增Id&#x27;</span>,</span><br><span class=\"line\">  Username <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;用户名&#x27;</span>,</span><br><span class=\"line\">  Password <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;密码&#x27;</span>,</span><br><span class=\"line\">  Email <span class=\"type\">VARCHAR</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;default&#x27;</span> COMMENT <span class=\"string\">&#x27;邮箱地址&#x27;</span>,</span><br><span class=\"line\">  Enabled TINYINT(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;是否有效&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (Id)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 COMMENT<span class=\"operator\">=</span><span class=\"string\">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"TCL语句✅\"><a href=\"#TCL语句✅\" class=\"headerlink\" title=\"TCL语句✅\"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p>\n<h3 id=\"事务TRANSACTION\"><a href=\"#事务TRANSACTION\" class=\"headerlink\" title=\"事务TRANSACTION\"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p>\n<p><strong>事务的四个特性(ACID)</strong></p>\n<ul>\n<li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li>\n<li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<blockquote>\n<p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开始事务</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 A</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">1</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;root1&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">SAVEPOINT</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入操作 B</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (<span class=\"number\">2</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;root2&#x27;</span>, <span class=\"string\">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 回滚到保留点 updateA</span></span><br><span class=\"line\"><span class=\"keyword\">ROLLBACK</span> <span class=\"keyword\">TO</span> updateA;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务，只有操作 A 生效</span></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DCL语句✅\"><a href=\"#DCL语句✅\" class=\"headerlink\" title=\"DCL语句✅\"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p>\n<h3 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h3><ul>\n<li>授予用户帐户权限，用<code>GRANT</code>命令。<ul>\n<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>\n<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li>\n<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>\n<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>\n<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>\n</ul>\n</li>\n<li>撤销用户的权限，用<code>REVOKE</code>命令。<ul>\n<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>\n<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>\n<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>\n</ul>\n</li>\n</ul>\n<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>\n<li>整个数据库，使用 <code>ON database.*</code>；</li>\n<li>特定的表，使用 <code>ON database.table</code>；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- GRANT用法</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> privilege,[privilege],.. <span class=\"keyword\">ON</span> privilege_level</span><br><span class=\"line\"><span class=\"keyword\">TO</span> <span class=\"keyword\">user</span> [IDENTIFIED <span class=\"keyword\">BY</span> password]</span><br><span class=\"line\">[REQUIRE tsl_option]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> [GRANT_OPTION <span class=\"operator\">|</span> resource_option]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- REVOKE用法</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> privilege_type [(column_list)]</span><br><span class=\"line\">       [, priv_type [(column_list)]]...</span><br><span class=\"line\"><span class=\"keyword\">ON</span> [object_type] privilege_level</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> [, <span class=\"keyword\">user</span>]...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建账户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> myuser IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;mypassword&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 修改账户名</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">SET</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;newuser&#x27;</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;myuser&#x27;</span>;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"><span class=\"comment\">-- 删除账户</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">USER</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 查看权限</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> GRANTS <span class=\"keyword\">FOR</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 授予权限</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">TO</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">REVOKE</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> myuser;</span><br><span class=\"line\"><span class=\"comment\">-- 更改密码</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> PASSWORD <span class=\"keyword\">FOR</span> myuser <span class=\"operator\">=</span> <span class=\"string\">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"游标CURSOR\"><a href=\"#游标CURSOR\" class=\"headerlink\" title=\"游标CURSOR\"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>\n<h3 id=\"触发器TRIGGER\"><a href=\"#触发器TRIGGER\" class=\"headerlink\" title=\"触发器TRIGGER\"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>\n<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>\n<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>\n<li>SQL 触发器对于审计表中数据的更改非常有用。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>SQL 触发器可能会增加数据库服务器的开销。</li>\n<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>\n</ul>\n<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p>\n<ul>\n<li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li>\n<li><code>AFTER INSERT</code>：将数据插入表格后激活。</li>\n<li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li>\n<li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li>\n<li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li>\n<li><code>AFTER DELETE</code>：从表中删除数据后激活。</li>\n</ul>\n<p><code>NEW</code> 和 <code>OLD</code>：</p>\n<ul>\n<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>\n<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li>\n<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>\n<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>\n<li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li>\n</ul>\n<h3 id=\"触发器语法\"><a href=\"#触发器语法\" class=\"headerlink\" title=\"触发器语法\"></a>触发器语法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> trigger_name</span><br><span class=\"line\">trigger_time</span><br><span class=\"line\">trigger_event</span><br><span class=\"line\"><span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">trigger_statements</span><br><span class=\"line\"><span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li><code>trigger_name</code>：触发器名</li>\n<li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>\n<li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>\n<li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li>\n<li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li>\n<li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>\n</ul>\n<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建触发器</span></span><br><span class=\"line\">DELIMITER $</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> `trigger_insert_user`</span><br><span class=\"line\">AFTER <span class=\"keyword\">INSERT</span> <span class=\"keyword\">ON</span> `<span class=\"keyword\">user</span>`</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"type\">ROW</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class=\"line\">    <span class=\"keyword\">VALUES</span> (NEW.id, <span class=\"string\">&#x27;add a user&#x27;</span>,  now());</span><br><span class=\"line\"><span class=\"keyword\">END</span> $</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看触发器</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TRIGGERS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p>\n<h3 id=\"MySQL基础✅\"><a href=\"#MySQL基础✅\" class=\"headerlink\" title=\"MySQL基础✅\"></a>MySQL基础✅</h3><h3 id=\"MySQL优点\"><a href=\"#MySQL优点\" class=\"headerlink\" title=\"MySQL优点\"></a>MySQL优点</h3><ul>\n<li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ul>\n<h3 id=\"什么是关系型数据库\"><a href=\"#什么是关系型数据库\" class=\"headerlink\" title=\"什么是关系型数据库\"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p>\n<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p>\n<h3 id=\"MySQL字段类型\"><a href=\"#MySQL字段类型\" class=\"headerlink\" title=\"MySQL字段类型\"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p>\n<ul>\n<li>数值类型：<ul>\n<li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li>\n<li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li>\n<li>定点数：<code>DECIMAL</code>。</li>\n</ul>\n</li>\n<li>字符串类型：<ul>\n<li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li>\n<li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li>\n</ul>\n</li>\n<li>日期和时间类型：<ul>\n<li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"整数类型的UNSIGNED属性\"><a href=\"#整数类型的UNSIGNED属性\" class=\"headerlink\" title=\"整数类型的UNSIGNED属性\"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>\n<blockquote>\n<p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p>\n</blockquote>\n<p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>\n<h3 id=\"CHAR-VARCHAR区别\"><a href=\"#CHAR-VARCHAR区别\" class=\"headerlink\" title=\"CHAR&#x2F;VARCHAR区别\"></a>CHAR&#x2F;VARCHAR区别</h3><ul>\n<li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li>\n<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li>\n<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>\n<li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li>\n</ul>\n<h3 id=\"VARCHAR-100-VARCHAR-10-区别\"><a href=\"#VARCHAR-100-VARCHAR-10-区别\" class=\"headerlink\" title=\"VARCHAR(100)&#x2F;VARCHAR(10)区别\"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul>\n<li>前者最大长度为 100，后者最大长度为 10。</li>\n<li>二者存储相同的字符串所占用的存储空间是一样的。</li>\n<li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li>\n</ul>\n<h3 id=\"DECIMAL和FLOAT-DOUBLE区别\"><a href=\"#DECIMAL和FLOAT-DOUBLE区别\" class=\"headerlink\" title=\"DECIMAL和FLOAT&#x2F;DOUBLE区别\"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p>\n<h3 id=\"为什么没不推荐使用TEXT-BLOB类型\"><a href=\"#为什么没不推荐使用TEXT-BLOB类型\" class=\"headerlink\" title=\"为什么没不推荐使用TEXT&#x2F;BLOB类型\"></a>为什么没不推荐使用TEXT&#x2F;BLOB类型</h3><ul>\n<li><code>TEXT</code>用于存储长文本数据，如博客数据。</li>\n<li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li>\n</ul>\n<p>这两种类型有如下缺陷：</p>\n<ul>\n<li>不能有默认值。</li>\n<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li>\n<li>检索效率较低。</li>\n<li>不能直接创建索引，需要指定前缀长度。</li>\n<li>可能会消耗大量的网络和 IO 带宽。</li>\n<li>可能导致表上的 DML 操作变慢。</li>\n</ul>\n<h3 id=\"DATETIME-TIMESTAMP区别\"><a href=\"#DATETIME-TIMESTAMP区别\" class=\"headerlink\" title=\"DATETIME&#x2F;TIMESTAMP区别\"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul>\n<li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li>\n<li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul>\n<li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>\n<li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li>\n</ul>\n</li>\n<li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li>\n</ul>\n<h3 id=\"NULL和’’区别\"><a href=\"#NULL和’’区别\" class=\"headerlink\" title=\"NULL和’’区别\"></a>NULL和’’区别</h3><ul>\n<li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul>\n<li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li>\n</ul>\n</li>\n<li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li>\n<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>\n<li><code>NULL</code> 会影响聚合函数的结果。<ul>\n<li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>\n</ul>\n</li>\n</ul>\n<p>不推荐使用<code>NULL</code>作为列默认值。</p>\n<h3 id=\"Boolean类型如何在MySQL中存储\"><a href=\"#Boolean类型如何在MySQL中存储\" class=\"headerlink\" title=\"Boolean类型如何在MySQL中存储\"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p>\n<h3 id=\"MySQL基础架构✅\"><a href=\"#MySQL基础架构✅\" class=\"headerlink\" title=\"MySQL基础架构✅\"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p>\n<ul>\n<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li>\n<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li>\n</ul>\n<p><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<ul>\n<li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li>查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li>优化器：按照 MySQL 认为最优的方案去执行。</li>\n<li>执行器：执行语句，然后从存储引擎返回数据。</li>\n<li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<ol>\n<li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>\n</li>\n<li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>\n</li>\n<li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p>\n<ul>\n<li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>\n<li>第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</li>\n</ul>\n</li>\n<li><p>优化器。<br>优化器以它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>\n</li>\n<li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>\n</li>\n</ol>\n<h3 id=\"SQL语句在MySQL中的执行过程\"><a href=\"#SQL语句在MySQL中的执行过程\" class=\"headerlink\" title=\"SQL语句在MySQL中的执行过程\"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> tb_student  A <span class=\"keyword\">where</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;18&#x27;</span> <span class=\"keyword\">and</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>\n<li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>\n<li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul>\n<li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li>\n<li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</li>\n</ul>\n</li>\n<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>\n</ol>\n<p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> tb_student A <span class=\"keyword\">set</span> A.age<span class=\"operator\">=</span><span class=\"string\">&#x27;19&#x27;</span> <span class=\"keyword\">where</span> A.name<span class=\"operator\">=</span><span class=\"string\">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p>\n<ol>\n<li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li>\n<li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li>\n<li>更新完成。</li>\n</ol>\n<h3 id=\"MySQL存储引擎✅\"><a href=\"#MySQL存储引擎✅\" class=\"headerlink\" title=\"MySQL存储引擎✅\"></a>MySQL存储引擎✅</h3><h3 id=\"MySQL支持哪些存储引擎？\"><a href=\"#MySQL支持哪些存储引擎？\" class=\"headerlink\" title=\"MySQL支持哪些存储引擎？\"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p>\n<p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p>\n<h3 id=\"MySQL存储引擎架构\"><a href=\"#MySQL存储引擎架构\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。</p>\n<h3 id=\"MyISAM-InnoDB存储引擎区别\"><a href=\"#MyISAM-InnoDB存储引擎区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB存储引擎区别\"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul>\n<li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>\n<li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>（可重读）隔离级别是可以解决幻读问题发生的（基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>）。</li>\n<li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li>\n<li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li>\n<li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li>\n<li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li>\n<li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li>\n<li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池（<code>Buffer Pool</code>）缓存数据页和索引页，<code>MyISAM</code> 使用键缓存（<code>Key Cache</code>）仅缓存索引页而不缓存数据页。</li>\n</ul>\n<h3 id=\"MySQL索引✅\"><a href=\"#MySQL索引✅\" class=\"headerlink\" title=\"MySQL索引✅\"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyIsam</code>，都使用了 <strong>B+树</strong>作为索引结构。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>\n<li>索引需要使用物理文件存储，也会耗费一定空间。</li>\n</ul>\n<h3 id=\"索引底层数据类型选型\"><a href=\"#索引底层数据类型选型\" class=\"headerlink\" title=\"索引底层数据类型选型\"></a>索引底层数据类型选型</h3><ol>\n<li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”（<code>Adaptive Hash Index</code>），结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p>\n</li>\n<li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p>\n</li>\n<li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p>\n</li>\n<li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p>\n</li>\n<li><p>B树&amp;B+树<br>B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br>B树&amp;B+树区别</p>\n</li>\n</ol>\n<ul>\n<li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li>\n<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>\n<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>\n<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>\n</ul>\n<p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>\n<h3 id=\"MyISAM-InnoDB索引区别\"><a href=\"#MyISAM-InnoDB索引区别\" class=\"headerlink\" title=\"MyISAM&#x2F;InnoDB索引区别\"></a>MyISAM&#x2F;InnoDB索引区别</h3><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p>\n<ul>\n<li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。</li>\n<li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。</li>\n</ul>\n<h3 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h3><p>按照数据结构维度划分：</p>\n<ul>\n<li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li>\n<li>哈希索引：类似键值对的形式，一次即可定位。</li>\n</ul>\n<p>按照底层存储方式角度划分：</p>\n<ul>\n<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>\n<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>\n</ul>\n<p>按照应用维度划分：</p>\n<ul>\n<li>主键索引：加速查询 + 列值唯一（不可以有 <code>NULL</code>）+ 表中只有一个。</li>\n<li>普通索引：仅加速查询。</li>\n<li>唯一索引：加速查询 + 列值唯一（可以有 <code>NULL</code>）。</li>\n<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li>\n</ul>\n<p>MySQL 8.x 中实现的索引新特性：</p>\n<ul>\n<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>\n<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 <code>GROUP BY</code> 语句进行隐式排序。</li>\n<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>\n</ul>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p>\n<p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p>\n<h3 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h3><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p>\n<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>\n<ul>\n<li>唯一索引(<code>Unique Key</code>):唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>\n<li>普通索引(<code>Index</code>):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li>\n<li>前缀索引(<code>Prefix</code>):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>\n<li>全文索引(<code>Full Text</code>):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li>\n</ul>\n<h3 id=\"聚簇索引-非聚簇索引\"><a href=\"#聚簇索引-非聚簇索引\" class=\"headerlink\" title=\"聚簇索引&#x2F;非聚簇索引\"></a>聚簇索引&#x2F;非聚簇索引</h3><p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>\n<li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li>\n<li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ul>\n<p>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>\n<p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>依赖于有序的数据</li>\n<li>可能会二次查询(回表):非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>\n</ul>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p>\n<h3 id=\"覆盖索引-联合索引\"><a href=\"#覆盖索引-联合索引\" class=\"headerlink\" title=\"覆盖索引&#x2F;联合索引\"></a>覆盖索引&#x2F;联合索引</h3><ul>\n<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li>\n<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n</ul>\n<h3 id=\"联合索引最左前缀匹配原则\"><a href=\"#联合索引最左前缀匹配原则\" class=\"headerlink\" title=\"联合索引最左前缀匹配原则\"></a>联合索引最左前缀匹配原则</h3><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>\n<h3 id=\"索引下推ICP\"><a href=\"#索引下推ICP\" class=\"headerlink\" title=\"索引下推ICP\"></a>索引下推ICP</h3><p>索引下推（<code>Index Condition Pushdown,ICP</code>） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p>\n<p><strong>原理</strong><br><img src=\"/../image/Database-Interview/13526879-3037b144ed09eb88.png\" alt=\"MySQL基础架构图\"></p>\n<p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p>\n<p>索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给下层（存储引擎层）去处理。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> zipcode <span class=\"operator\">=</span> <span class=\"string\">&#x27;431200&#x27;</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span>(birthdate) <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li>\n<li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li>\n</ul>\n<p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p>\n<h3 id=\"MySQL查询缓存✅\"><a href=\"#MySQL查询缓存✅\" class=\"headerlink\" title=\"MySQL查询缓存✅\"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p>查询缓存不命中的情况：</p>\n<ul>\n<li>两个查询在任何字符上的不同都会导致缓存不命中。</li>\n<li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n</ul>\n<p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p>\n<h3 id=\"MySQL三大日志✅\"><a href=\"#MySQL三大日志✅\" class=\"headerlink\" title=\"MySQL三大日志✅\"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>\n<p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h3><p><code>redo log</code>（重做日志）是 <code>InnoDB</code> 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p>\n<p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>\n<h3 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h3><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p>\n<ul>\n<li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li>\n<li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>\n<li><code>Checkpoint</code>（检查点）：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>\n<li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li>\n<li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</li>\n</ul>\n<h3 id=\"刷盘策略\"><a href=\"#刷盘策略\" class=\"headerlink\" title=\"刷盘策略\"></a>刷盘策略</h3><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p>\n<ul>\n<li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li>\n<li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li>\n<li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>（文件系统缓存）。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>\n</ul>\n<p>默认策略为第二种。</p>\n<h3 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p>\n<p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>\n<h3 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h3><p><code>binlog</code> 有三种记录格式：</p>\n<ul>\n<li><code>Statement</code>：记录的是 SQL 语句，如 <code>update t set c=c+1 where id=2</code>。<ul>\n<li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li>\n</ul>\n</li>\n<li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul>\n<li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li>\n</ul>\n</li>\n<li><code>Mixed</code>：记录的是上面两种的混合模式。<ul>\n<li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>\n<p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>\n<p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p>\n<ul>\n<li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul>\n<li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li>\n</ul>\n</li>\n<li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li>\n<li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul>\n<li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p><code>redo log</code>（重做日志）让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>（归档日志）保证了 MySQL 集群架构的数据一致性。</p>\n<p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p>\n<p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p>\n<p>为了解决数据不一致问题，InnoDB 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p>\n<ul>\n<li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li>\n<li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li>\n</ul>\n<p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p>\n<p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>\n<h3 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h3><p><code>undo log</code> 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p>\n<p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p>\n<p><code>undo log</code> 采用 <code>segment</code>（段）进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理（<code>purge</code>）的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p>\n<h3 id=\"MySQL事务✅\"><a href=\"#MySQL事务✅\" class=\"headerlink\" title=\"MySQL事务✅\"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<h3 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h3><ul>\n<li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性(Consistency)：执行事务前后，数据保持一致。</li>\n<li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>\n</ul>\n<blockquote>\n<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>\n</blockquote>\n<h3 id=\"并发事务存在的问题\"><a href=\"#并发事务存在的问题\" class=\"headerlink\" title=\"并发事务存在的问题\"></a>并发事务存在的问题</h3><h3 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h3><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p>\n<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>解决：</p>\n<ul>\n<li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li>\n</ul>\n<h3 id=\"丢失修改\"><a href=\"#丢失修改\" class=\"headerlink\" title=\"丢失修改\"></a>丢失修改</h3><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>解决：</p>\n<ul>\n<li>乐观锁（Optimistic Locking）： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li>\n<li>悲观锁（Pessimistic Locking）： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li>\n</ul>\n<h3 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h3><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p>\n<p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li>\n</ul>\n<h3 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h3><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p>\n<p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>解决：</p>\n<ul>\n<li>执行 <code>insert</code> 操作的时候，由于记录锁（<code>Record Lock</code>）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（<code>Gap Lock</code>）。也就是说执行 <code>insert</code> 操作的时候需要依赖 <code>Next-Key Lock（Record Lock+Gap Lock）</code> 进行加锁来保证不出现幻读。</li>\n<li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li>\n</ul>\n<h3 id=\"不可重复读和幻读有什么区别\"><a href=\"#不可重复读和幻读有什么区别\" class=\"headerlink\" title=\"不可重复读和幻读有什么区别\"></a>不可重复读和幻读有什么区别</h3><ul>\n<li>不可重复读：多次读取同一数据，发现数据不一致。</li>\n<li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p>\n<ul>\n<li>解决不可重复读：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>\n<li>解决幻读：执行 <code>insert</code> 操作的时候，由于记录锁（<code>Record Lock</code>）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（<code>Gap Lock</code>）。也就是说执行 <code>insert</code> 操作的时候需要依赖 <code>Next-Key Lock（Record Lock+Gap Lock）</code> 进行加锁来保证不出现幻读。</li>\n</ul>\n<h3 id=\"并发事务的控制方式有哪些\"><a href=\"#并发事务的控制方式有哪些\" class=\"headerlink\" title=\"并发事务的控制方式有哪些\"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制（<code>MVCC，Multiversion concurrency control</code>）可以看作是乐观控制的模式。</p>\n<ul>\n<li>锁：<ul>\n<li>共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li>排他锁（X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n</li>\n<li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p>\n<blockquote>\n<p>注意：不论是表级锁还是行级锁，都存在共享锁（<code>Share Lock</code>，S 锁）和排他锁（<code>Exclusive Lock</code>，X 锁）这两类。</p>\n</blockquote>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段、<code>read view</code>、<code>undo log</code>。</p>\n<ul>\n<li><code>undo log</code> : <code>undo log</code> 用于记录某行数据的多个版本的数据。</li>\n<li><code>read view</code> 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">隔离级别</th>\n<th align=\"center\">脏读</th>\n<th align=\"center\">不可重复读</th>\n<th align=\"center\">幻读</th>\n<th align=\"center\">实现方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">READ-UNCOMMITTED</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">READ-COMMITTED</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁</td>\n</tr>\n<tr>\n<td align=\"center\">REPEATABLE-READ</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">√</td>\n<td align=\"center\">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td>\n</tr>\n<tr>\n<td align=\"center\">SERIALIZABLE</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">基于 锁</td>\n</tr>\n</tbody></table>\n<p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><p>存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。</p>\n<p>默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。</p>\n<h3 id=\"MySQL存储引擎架构-1\"><a href=\"#MySQL存储引擎架构-1\" class=\"headerlink\" title=\"MySQL存储引擎架构\"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。</p>\n<h3 id=\"MySQL-锁机制\"><a href=\"#MySQL-锁机制\" class=\"headerlink\" title=\"MySQL 锁机制\"></a>MySQL 锁机制</h3><p>锁是一种常见的并发事务的控制方式。</p>\n<h3 id=\"表级锁-行级锁\"><a href=\"#表级锁-行级锁\" class=\"headerlink\" title=\"表级锁&#x2F;行级锁\"></a>表级锁&#x2F;行级锁</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p>\n<p>InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。</p>\n<p>表级锁和行级锁对比：</p>\n<ul>\n<li>表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>\n<li>行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>\n</ul>\n<h3 id=\"MySQL字符集\"><a href=\"#MySQL字符集\" class=\"headerlink\" title=\"MySQL字符集\"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p>\n<h3 id=\"MySQL字符集层次级别\"><a href=\"#MySQL字符集层次级别\" class=\"headerlink\" title=\"MySQL字符集层次级别\"></a>MySQL字符集层次级别</h3><ul>\n<li>MySQL 中的字符集分为四个层次：<ul>\n<li>server(MySQL 实例级别)</li>\n<li>database(库级别)</li>\n<li>table(表级别)</li>\n<li>column(字段级别)</li>\n</ul>\n</li>\n</ul>\n<p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p>\n<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>\n<ul>\n<li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>\n<li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Redis 中比较常见的数据类型有下面这些：</p>\n<ul>\n<li>5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。</li>\n<li>3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。</li>\n</ul>\n<p>除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。</p>\n<h3 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：</p>\n<ul>\n<li>快照(snapshotting，RDB)</li>\n<li>只追加文件(append-only file, AOF)</li>\n<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clxkia0ux0001uugn08mx6pkv","category_id":"clxkia0v10004uugn9efl15nk","_id":"clxkia0v6000juugn66517o5q"},{"post_id":"clxkia0v30007uugn5t0e1ey5","category_id":"clxkia0v6000kuugn2oyfeyc8","_id":"clxkia0v7000ruugn9u1e3e88"},{"post_id":"clxkia0v40009uugndinqgq81","category_id":"clxkia0v6000ouugn1tiu8jlf","_id":"clxkia0v8000wuugn4y7808bn"},{"post_id":"clxkia0v4000buugn5zny9zgj","category_id":"clxkia0v7000tuugn0uzmas55","_id":"clxkia0v80010uugn3r6p4td9"},{"post_id":"clxkia0v5000guugnfo500ze1","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0v80015uugn00rxhtrh"},{"post_id":"clxkia0v00003uugn57hecdiw","category_id":"clxkia0v5000cuugnaw607gzo","_id":"clxkia0v80018uugna4m40f80"},{"post_id":"clxkia0v00003uugn57hecdiw","category_id":"clxkia0v80012uugncx8qgov9","_id":"clxkia0v8001auugn19np4pmy"},{"post_id":"clxkia0v6000iuugnfift2gu4","category_id":"clxkia0v6000ouugn1tiu8jlf","_id":"clxkia0v9001buugn93rt3dof"},{"post_id":"clxkia0vb001zuugn5b5t6ms3","category_id":"clxkia0v5000cuugnaw607gzo","_id":"clxkia0vd0026uugn9os6dgv7"},{"post_id":"clxkia0vc0020uugnhyvug30s","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0vd0028uugnewbe4d5x"},{"post_id":"clxkia0vc0022uugn752y8adl","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0ve002buugnhvlb4obf"},{"post_id":"clxkia0vd0025uugnfhwt9vh3","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0ve002euugnaw0g9m9c"},{"post_id":"clxkia0vd0027uugn2ji3hgg3","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0ve002guugn2v7td24q"},{"post_id":"clxkia0vd0029uugn4ungbfjb","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0ve002juugn9mty92su"},{"post_id":"clxkia0ve002duugnfeppbqpm","category_id":"clxkia0v8000yuugn406t6e8b","_id":"clxkia0ve002luugnh2pc04pp"}],"PostTag":[{"post_id":"clxkia0ux0001uugn08mx6pkv","tag_id":"clxkia0v30005uugn460masl2","_id":"clxkia0v5000euugn52i77zj4"},{"post_id":"clxkia0v00003uugn57hecdiw","tag_id":"clxkia0v5000duugnebt4032g","_id":"clxkia0v7000uuugn4l7jd1ix"},{"post_id":"clxkia0v00003uugn57hecdiw","tag_id":"clxkia0v6000luugn5f082h28","_id":"clxkia0v7000vuugnd8qo7zzp"},{"post_id":"clxkia0v00003uugn57hecdiw","tag_id":"clxkia0v30005uugn460masl2","_id":"clxkia0v8000zuugn83ji16ra"},{"post_id":"clxkia0v30007uugn5t0e1ey5","tag_id":"clxkia0v7000suugncuwbepgj","_id":"clxkia0v80013uugnc2lwbpv2"},{"post_id":"clxkia0v30007uugn5t0e1ey5","tag_id":"clxkia0v8000xuugn5c14ezgu","_id":"clxkia0v80014uugncpxf8afp"},{"post_id":"clxkia0v40009uugndinqgq81","tag_id":"clxkia0v80011uugn3g000fq0","_id":"clxkia0v9001duugnep041l6h"},{"post_id":"clxkia0v40009uugndinqgq81","tag_id":"clxkia0v80016uugnb7lu7qcq","_id":"clxkia0v9001euugn98lqgriz"},{"post_id":"clxkia0v40009uugndinqgq81","tag_id":"clxkia0v8000xuugn5c14ezgu","_id":"clxkia0v9001guugnb9fldj4x"},{"post_id":"clxkia0v4000buugn5zny9zgj","tag_id":"clxkia0v9001cuugn690ub4pj","_id":"clxkia0v9001kuugnfx5qfl1y"},{"post_id":"clxkia0v4000buugn5zny9zgj","tag_id":"clxkia0v9001fuugn1ss9dddu","_id":"clxkia0v9001luugne3i33gyb"},{"post_id":"clxkia0v4000buugn5zny9zgj","tag_id":"clxkia0v9001huugn9pu1cgco","_id":"clxkia0v9001nuugnhf67d2a8"},{"post_id":"clxkia0v4000buugn5zny9zgj","tag_id":"clxkia0v9001iuugn7d8s9ar0","_id":"clxkia0v9001ouugn46wj43bb"},{"post_id":"clxkia0v5000guugnfo500ze1","tag_id":"clxkia0v9001fuugn1ss9dddu","_id":"clxkia0v9001ruugn23afgmjt"},{"post_id":"clxkia0v5000guugnfo500ze1","tag_id":"clxkia0v9001cuugn690ub4pj","_id":"clxkia0v9001suugnhism0grg"},{"post_id":"clxkia0v5000guugnfo500ze1","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0v9001uuugnb6it1muz"},{"post_id":"clxkia0v6000iuugnfift2gu4","tag_id":"clxkia0v80011uugn3g000fq0","_id":"clxkia0va001wuugne8yc6zr6"},{"post_id":"clxkia0v6000iuugnfift2gu4","tag_id":"clxkia0v80016uugnb7lu7qcq","_id":"clxkia0va001xuugn2e7pelxu"},{"post_id":"clxkia0v6000iuugnfift2gu4","tag_id":"clxkia0v8000xuugn5c14ezgu","_id":"clxkia0va001yuugngdp0an3o"},{"post_id":"clxkia0vb001zuugn5b5t6ms3","tag_id":"clxkia0v5000duugnebt4032g","_id":"clxkia0vc0021uugnd316b78m"},{"post_id":"clxkia0vb001zuugn5b5t6ms3","tag_id":"clxkia0v30005uugn460masl2","_id":"clxkia0vd0024uugn5bmb90d1"},{"post_id":"clxkia0vc0020uugnhyvug30s","tag_id":"clxkia0vd0023uugnfpgvfsei","_id":"clxkia0ve002cuugn0278h9dj"},{"post_id":"clxkia0vc0020uugnhyvug30s","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0ve002fuugng5gr5c1g"},{"post_id":"clxkia0vc0022uugn752y8adl","tag_id":"clxkia0ve002auugnhbt8gzhq","_id":"clxkia0ve002iuugngxu180j5"},{"post_id":"clxkia0vc0022uugn752y8adl","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0ve002kuugnbe1u1hbg"},{"post_id":"clxkia0vd0025uugnfhwt9vh3","tag_id":"clxkia0ve002huugn43lb1lg5","_id":"clxkia0vf002ouugn4wybbe1d"},{"post_id":"clxkia0vd0025uugnfhwt9vh3","tag_id":"clxkia0ve002muugn5nxa4db6","_id":"clxkia0vf002puugncdjafrcg"},{"post_id":"clxkia0vd0025uugnfhwt9vh3","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0vf002ruugn6bdjfuqo"},{"post_id":"clxkia0vd0027uugn2ji3hgg3","tag_id":"clxkia0vf002nuugnhg4zbt62","_id":"clxkia0vf002suugn8a0q80k3"},{"post_id":"clxkia0vd0027uugn2ji3hgg3","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0vf002uuugnbws98puu"},{"post_id":"clxkia0vd0029uugn4ungbfjb","tag_id":"clxkia0vf002quugnak8ff80k","_id":"clxkia0vf002vuugngk948o1o"},{"post_id":"clxkia0vd0029uugn4ungbfjb","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0vf002xuugneb9aazf0"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf002tuugndo204w5c","_id":"clxkia0vf0032uugnb50z6e57"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf002wuugn7izl1hbm","_id":"clxkia0vf0033uugng66ifcvx"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf002yuugn7sdy1txt","_id":"clxkia0vf0034uugn4bns4kpl"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf002zuugn8369hs17","_id":"clxkia0vf0035uugn3p1t0t7g"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf0030uugn3jhodtkm","_id":"clxkia0vf0036uugng5jtcb3f"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0vf0031uugn4zfibdyu","_id":"clxkia0vf0037uugn6w3j8hiz"},{"post_id":"clxkia0ve002duugnfeppbqpm","tag_id":"clxkia0v9001puugn56mi1pvx","_id":"clxkia0vf0038uugn2asuhd60"}],"Tag":[{"name":"算法","_id":"clxkia0v30005uugn460masl2"},{"name":"强化学习","_id":"clxkia0v5000duugnebt4032g"},{"name":"多智能体强化学习","_id":"clxkia0v6000luugn5f082h28"},{"name":"hexo","_id":"clxkia0v7000suugncuwbepgj"},{"name":"教程","_id":"clxkia0v8000xuugn5c14ezgu"},{"name":"k8s","_id":"clxkia0v80011uugn3g000fq0"},{"name":"Kubernetes","_id":"clxkia0v80016uugnb7lu7qcq"},{"name":"移动端","_id":"clxkia0v9001cuugn690ub4pj"},{"name":"前端","_id":"clxkia0v9001fuugn1ss9dddu"},{"name":"react","_id":"clxkia0v9001huugn9pu1cgco"},{"name":"react-native","_id":"clxkia0v9001iuugn7d8s9ar0"},{"name":"面经","_id":"clxkia0v9001puugn56mi1pvx"},{"name":"框架","_id":"clxkia0vd0023uugnfpgvfsei"},{"name":"手撕技巧","_id":"clxkia0ve002auugnhbt8gzhq"},{"name":"计算机网络","_id":"clxkia0ve002huugn43lb1lg5"},{"name":"操作系统","_id":"clxkia0ve002muugn5nxa4db6"},{"name":"测试开发","_id":"clxkia0vf002nuugnhg4zbt62"},{"name":"Java","_id":"clxkia0vf002quugnak8ff80k"},{"name":"数据库","_id":"clxkia0vf002tuugndo204w5c"},{"name":"SQL","_id":"clxkia0vf002wuugn7izl1hbm"},{"name":"NoSQL","_id":"clxkia0vf002yuugn7sdy1txt"},{"name":"MySQL","_id":"clxkia0vf002zuugn8369hs17"},{"name":"mongodb","_id":"clxkia0vf0030uugn3jhodtkm"},{"name":"Redis","_id":"clxkia0vf0031uugn4zfibdyu"}]}}