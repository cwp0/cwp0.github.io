---
title: 数据库
tags:
  - 数据库
  - MySQL
  - mongodb
  - Redis
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 数据库面经
abbrlink: 17769
date: 2024-06-12 22:47:41
updated: 2024-06-13 16:16:41
top_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png
comments:
cover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

## 基础


## MySQL
MySQL 是一种关系型数据库
### 事务

我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：数据库中途突然因为某些原因挂掉了。客户端突然因为网络原因连接不上数据库了。并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。……上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性
- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- 一致性(Consistency)：事务执行前后，数据库的完整性约束没有被破坏。
- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

### 索引
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

优点：使用索引可以大大加快数据的检索速度(大大减少检索的数据量), 减少 IO 次数，这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。

### MySQL存储引擎
存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。

默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。

### MySQL存储引擎架构
MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

### MySQL 锁机制
锁是一种常见的并发事务的控制方式。

### 表级锁/行级锁
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比：
- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。


## Redis

Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

### 基本数据类型
Redis 中比较常见的数据类型有下面这些：
- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。
- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。

### Redis持久化
使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:
- 快照(snapshotting，RDB)
- 只追加文件(append-only file, AOF)
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)


### 缓存穿透
缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存击穿
缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存雪崩
缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。




