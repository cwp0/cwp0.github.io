---
title: 数据库
tags:
  - 数据库
  - SQL
  - NoSQL
  - MySQL
  - mongodb
  - Redis
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 数据库面经
abbrlink: 17769
date: 2024-06-12 22:47:41
updated: 2024-06-13 21:50:41
top_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png
comments:
cover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

## SQL/NoSQL基础

### DB/DBMS/DBS/DBA
- 数据库 : 数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。
- 数据库管理系统 : 数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。
- 数据库系统 : 数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。
- 数据库管理员 : 数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。


### 数据库术语
- 数据库（`database`）：保存有组织的数据的容器（通常是一个文件或一组文件）。
- 数据表（`table`）：某种特定类型数据的结构化清单。
- 模式（`schema`）：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。
- 列（`column`）：表中的一个字段。所有表都是由一个或多个列组成的。
- 行（`row`）：表中的一个记录。
- 主键（`primary key`）：一列（或一组列），其值能够唯一标识表中每一行。

### 元组/码/候选码/主码/外码/主属性/非主属性概念
- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- 码：码就是能唯一标识实体的属性，对应表中的列。
- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

### ER图
ER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：
- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。
- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。
- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。

### 数据库三范式
数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：
- 1NF(第一范式)：属性不可再分。
  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。
- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。
- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。
  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
>   - 例子：学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖于（学号，身份证号）；
> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。
>   - 例子：学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。
> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**
>   - 例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

### 主键/外键区别
主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

### 为什么不推荐使用外键和级联操作
以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**

- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；
- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；
- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。

**外键好处**
- 保证了数据库数据的一致性和完整性；
- 级联操作方便，减轻了程序代码量；

### 存储过程
可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。

存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。

### DROP/TRUNCATE/DELETE区别
1. 用法不同
- `DROP`(丢弃数据): `DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。
- `TRUNCATE`(清空数据) : `TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- `DELETE`（删除数据） : `DELETE from 表名 where 列名=值`，删除某一行的数据，如果不加 `where` 子句和`TRUNCATE table 表名`作用类似。

`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。

2. 属于不同的数据库语言
- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。

3. 执行速度不同：`DROP > TRUNCATE > DELETE`。
- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。
- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。
- `DROP`命令会把表占用的空间全部释放掉。

### 数据库设计分为哪几个步
1. 需求分析 : 分析用户的需求，包括数据、功能和性能需求。
2. 概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。
3. 逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. 数据库实施 : 包括编程、测试和试运行
6. 数据库的运行和维护 : 系统的运行与数据库的日常维护。

### 什么是NoSQL
`NoSQL（Not Only SQL）`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。

一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。

> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。

### SQL/NoSQL区别

|         | SQL 数据库                                      | NoSQL 数据库                                                                                |
|:--------|----------------------------------------------|------------------------------------------------------------------------------------------|
| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |
| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |
| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |
| 扩展      | 垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表                | 横向（增加服务器的方式横向扩展，通常是基于分片机制）                                                               |
| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |
| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |
| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |
| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |

### NoSQL优劣
**优点**
- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。
- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。
- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。
- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。

**缺点**
- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。
- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。

### NoSQL分类
- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。
- 文档：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。
- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。
- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。

### 数据库分类
`DDL/DML/DQL/DCL/TCL`
- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。
  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。
- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。
  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。
- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。
- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。

### DDL语句用法✅
### 增删改查CRUD









## MySQL
MySQL 是一种关系型数据库
### 事务

我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：数据库中途突然因为某些原因挂掉了。客户端突然因为网络原因连接不上数据库了。并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。……上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性
- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- 一致性(Consistency)：事务执行前后，数据库的完整性约束没有被破坏。
- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

### 索引
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

优点：使用索引可以大大加快数据的检索速度(大大减少检索的数据量), 减少 IO 次数，这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。

### MySQL存储引擎
存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。

默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。

### MySQL存储引擎架构
MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

### MySQL 锁机制
锁是一种常见的并发事务的控制方式。

### 表级锁/行级锁
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比：
- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。


### MySQL字符集
MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集（UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等）。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`

### MySQL字符集层次级别
- MySQL 中的字符集分为四个层次：
  - server（MySQL 实例级别）
  - database（库级别）
  - table（表级别）
  - column（字段级别）

其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。

MySQL 字符编码集中有两套 UTF-8 编码实现：
- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。
- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。




## Redis

Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

### 基本数据类型
Redis 中比较常见的数据类型有下面这些：
- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。
- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。

### Redis持久化
使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：
- 快照(snapshotting，RDB)
- 只追加文件(append-only file, AOF)
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)


### 缓存穿透
缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存击穿
缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存雪崩
缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。




