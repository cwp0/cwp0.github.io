---
title: 数据库
tags:
  - 数据库
  - SQL
  - NoSQL
  - MySQL
  - mongodb
  - Redis
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 数据库面经
abbrlink: 17769
date: 2024-06-12 22:47:36
updated: 2024-06-16 19:30:16
top_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png
comments:
cover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

## SQL/NoSQL基础

### 什么是SQL
SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。

### DB/DBMS/DBS/DBA
- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。
- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。
- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。
- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。


### 数据库术语
- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。
- 数据表(`table`)：某种特定类型数据的结构化清单。
- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。
- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。
- 行(`row`)：表中的一个记录。
- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。

### 元组/码/候选码/主码/外码/主属性/非主属性概念
- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- 码：码就是能唯一标识实体的属性，对应表中的列。
- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

### ER图
ER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：
- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。
- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。
- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。

### 数据库三范式
数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：
- 1NF(第一范式)：属性不可再分。
  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。
- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。
- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。
  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；
> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。
>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；
> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。
> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**
>   - 例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

### 主键/外键区别
主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

### 为什么不推荐使用外键和级联操作
以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**

- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；
- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；
- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。

**外键好处**
- 保证了数据库数据的一致性和完整性；
- 级联操作方便，减轻了程序代码量；

### 存储过程
可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。

存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。

### DROP/TRUNCATE/DELETE区别
1. 用法不同
- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。
- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。

`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。

2. 属于不同的数据库语言
- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。

3. 执行速度不同：`DROP > TRUNCATE > DELETE`。
- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。
- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。
- `DROP`命令会把表占用的空间全部释放掉。

### 数据库设计分为哪几个步
1. 需求分析：分析用户的需求，包括数据、功能和性能需求。
2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。
3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。
5. 数据库实施：包括编程、测试和试运行
6. 数据库的运行和维护：系统的运行与数据库的日常维护。

### 什么是NoSQL
`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。

一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。

> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。

### SQL/NoSQL区别

|         | SQL 数据库                                      | NoSQL 数据库                                                                                |
|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|
| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |
| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |
| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |
| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |
| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |
| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |
| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |
| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |

### NoSQL优劣
**优点**
- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。
- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。
- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。
- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。

**缺点**
- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。
- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。

### NoSQL分类
- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。
- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。
- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。
- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。

### 数据库分类
`DDL/DML/DCL/TCL`
- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。
  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。
- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。
  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。
- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。
- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。

### SQL三种注释方式
- 单行注释：`-- 注释内容` 或 `# 注释内容`。
- 多行注释：`/* 注释内容 */`。
- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。

### DML语句✅
`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。

### 增删改查CRUD
增删改查，又称为 CRUD，数据库基本操作中的基本操作。

**插入数据**
`INSERT INTO` 语句用于向表中插入新记录。

```sql
-- 插入完整的行
-- 插入一行
INSERT INTO user
VALUES (10, 'root', 'root', 'xxxx@163.com');
-- 插入多行
INSERT INTO user
VALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');

-- 插入行的一部分
INSERT INTO user(username, password, email)
VALUES ('admin', 'admin', 'xxxx@163.com');

-- 插入查询出来的数据
INSERT INTO user(username)
SELECT name
FROM account;
```

**更新数据**
`UPDATE` 语句用于更新表中的记录。

```sql
UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
```

**删除数据**
- `DELETE` 语句用于删除表中的记录。
- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。

```sql
-- 删除表中的指定数据
DELETE FROM user
WHERE username = 'robot';

-- 清空表中的数据
TRUNCATE TABLE user;
```

**查询数据**
- `SELECT` 语句用于从数据库中查询数据。
- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。
- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。
- `ASC`：升序(默认)
- `DESC`：降序

```sql
-- 查询单列
SELECT prod_name
FROM products;

-- 查询多列
SELECT prod_id, prod_name, prod_price
FROM products;

-- 查询所有列
SELECT *
FROM products;

-- 查询不同的值
SELECT DISTINCT
vend_id FROM products;

-- 限制查询结果
-- 返回前 5 行
SELECT * FROM mytable LIMIT 5;
SELECT * FROM mytable LIMIT 0, 5;
-- 返回第 3 ~ 5 行
SELECT * FROM mytable LIMIT 2, 3;
```

### 排序
- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。
- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。

```sql
SELECT * FROM products
ORDER BY prod_price DESC, prod_name ASC;
```

### 分组
**`GROUP BY`**：

- `GROUP BY` 子句将记录分组到汇总行中。
- `GROUP BY` 为每个组返回一个记录。
- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。
- `GROUP BY` 可以按一列或多列进行分组。
- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。

```sql
-- 分组
SELECT cust_name, COUNT(cust_address) AS addr_num
FROM Customers GROUP BY cust_name;

-- 分组后排序
SELECT cust_name, COUNT(cust_address) AS addr_num
FROM Customers GROUP BY cust_name
ORDER BY cust_name DESC;
```

### HAVING

- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。
- `HAVING` 一般都是和 `GROUP BY` 连用。
- `WHERE` 和 `HAVING` 可以在相同的查询中。

```sql
-- 使用 WHERE 和 HAVING 过滤数据
SELECT cust_name, COUNT(*) AS NumberOfOrders
FROM Customers
WHERE cust_email IS NOT NULL
GROUP BY cust_name
HAVING COUNT(*) > 1;
```

### WHERE/HAVING对比
- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。
- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。

### 子查询
MYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)

子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。

子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。

子查询常用在 `WHERE` 子句和 `FROM` 子句后边：
- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。
```sql
SELECT column_name [, column_name ]
FROM   table1 [, table2 ]
WHERE  column_name operator
    (SELECT column_name [, column_name ]
    FROM table1 [, table2 ]
    [WHERE])
```
- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。
```sql
SELECT column_name [, column_name ]
FROM (SELECT column_name [, column_name ]
      FROM table1 [, table2 ]
      [WHERE]) as temp_table_name
WHERE  condition
```

**子查询的子查询**
首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。
```sql
SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
                  FROM orders
                  WHERE order_num IN (SELECT order_num
                                      FROM orderitems
                                      WHERE prod_id = 'RGAN01'));
```

### WHERE
- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。
- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。
- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。
```sql
-- SELECT语句中的WHERE
SELECT * FROM Customers
WHERE cust_name = 'Kids Place';

-- UPDATE语句中的WHERE
UPDATE Customers
SET cust_name = 'Jack Jones'
WHERE cust_name = 'Kids Place';

-- DELETE语句中的WHERE
DELETE FROM Customers
WHERE cust_name = 'Kids Place';
```
- 可以在 `WHERE` 子句中使用的操作符。
| 运算符       | 描述                                |
|-----------|-----------------------------------|
| `=`       | 等于                                |
| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |
| `>`       | 大于                                |
| `<`       | 小于                                |
| `>=`      | 大于等于                              |
| `<=`      | 小于等于                              |
| `BETWEEN` | 在某个范围内                            |
| `LIKE`    | 搜索某种模式                            |
| `IN`      | 指定针对某个列的多个可能值                     |

### IN/BETWEEN
- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。
- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。

```sql
-- IN示例
SELECT *
FROM products
WHERE vend_id IN ('DLL01', 'BRS01');

-- BETWEEN示例
SELECT *
FROM products
WHERE prod_price BETWEEN 3 AND 5;
```

### AND/OR/NOT
- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。
- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。
- `AND` 操作符表示左右条件都要满足。
- `OR` 操作符表示左右条件满足任意一个即可。
- `NOT` 操作符用于否定一个条件。

```sql
-- AND示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE vend_id = 'DLL01' AND prod_price <= 4;

-- OR示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';

-- NOT示例
SELECT *
FROM products
WHERE prod_price NOT BETWEEN 3 AND 5;
```

### LIKE
- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。
- 只有字段是文本值时才使用 `LIKE`。
- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。
- 不要滥用通配符，通配符位于开头处匹配会非常慢。
- `%` 表示任何字符出现任意次数。
- `_` 表示任何字符出现一次。

```sql
-- %示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE prod_name LIKE '%bean bag%';

-- _示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE prod_name LIKE '__ inch teddy bear';
```

### 连接JOIN
`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。

语法：
```sql
SELECT table1.column1, table2.column2...
FROM table1
JOIN table2
ON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not
```
当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。

如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。
```sql
# JOIN....ON
SELECT c.cust_name, o.order_num
FROM Customers c
INNER JOIN Orders o
ON c.cust_id = o.cust_id
-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()
-- using(cust_id) 代替 ON c.cust_id = o.cust_id
ORDER BY c.cust_name;
```

### 内连接/外连接
- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。
- `外连接`：
  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。
  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。
  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。


```sql
/* 
student表
student_id	name
1	        Alice
2	        Bob
3	        Carol

courses表
course_id	student_id	course_name
101	        1	        Math
102	        2	        Science
103	        4	        History
*/

-- 内连接
SELECT students.name, courses.course_name
FROM students
INNER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
*/

-- 左外连接
SELECT students.name, courses.course_name
FROM students
LEFT OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
Carol	NULL
*/

-- 右外连接
SELECT students.name, courses.course_name
FROM students
RIGHT OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
NULL	History
*/

-- 全外连接
SELECT students.name, courses.course_name
FROM students
FULL OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
Carol	NULL
NULL	History
*/
```

### ON/WHERE区别
- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。
- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。

### 组合UNION
`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。

`UNION` 基本规则：
- 所有查询的列数和列顺序必须相同。
- 每个查询中涉及表的列的数据类型必须相同或兼容。
- 通常返回的列名取自第一个查询。
- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。

```sql
SELECT column1, column2, ...
FROM table1
UNION
SELECT column1, column2, ...
FROM table2;
```

### DDL语言✅
`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。

### 数据库DATABSE
- 创建数据库：`CREATE DATABASE 数据库名;`
- 删除数据库：`DROP DATABASE 数据库名;`
- 选择数据库：`USE 数据库名;`
- 查看数据库：`SHOW DATABASES;`

### 数据表TABLE
```sql
-- 普通创建
CREATE TABLE user (
id int(10) unsigned NOT NULL COMMENT 'Id',
username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';

-- 根据已有表创建
CREATE TABLE vip_user AS
SELECT * FROM user;

-- 删除表
DROP TABLE user;

-- 查看表
SHOW TABLES;

-- 添加列
ALTER TABLE user -- ALTER用于修改表
ADD age int(3);

-- 删除列
ALTER TABLE user
DROP COLUMN age;

-- 修改列
ALTER TABLE `user`
MODIFY COLUMN age tinyint;

-- 添加主键
ALTER TABLE user
ADD PRIMARY KEY (id);

-- 删除主键
ALTER TABLE user
DROP PRIMARY KEY;
```

### 视图VIEW
在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。

作用：
- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。
- 提高数据安全性：用来限制用户访问敏感数据。
- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。
- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。

```sql
-- 创建视图
CREATE VIEW top_10_user_view AS
SELECT id, username
FROM user
WHERE id < 10;

-- 删除视图
DROP VIEW top_10_user_view;
```

### 索引INDEX
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

**优点**
- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点**
- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

```sql
-- 创建索引
CREATE INDEX user_index
ON user (id);

-- 添加索引
ALTER table user ADD INDEX user_index(id)

-- 创建唯一索引
CREATE UNIQUE INDEX user_index
ON user (id);

-- 删除索引
ALTER TABLE user
DROP INDEX user_index;
```

### 约束
SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。

**约束类型**
- `NOT NULL`：指示某列不能存储 `NULL` 值。
- `UNIQUE`：保证某列的每行必须有唯一的值。
- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。
- `CHECK`：保证列中的值符合指定的条件。
- `DEFAULT`：规定没有给列赋值时的默认值。

```sql
CREATE TABLE Users (
  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',
  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',
  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',
  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',
  PRIMARY KEY (Id)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```


### TCL语句✅
`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。

### 事务TRANSACTION
事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。

**事务的四个特性(ACID)**
- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- `一致性(Consistency)`：事务执行前后，数据库的完整性约束没有被破坏。
- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。

```sql
-- 开始事务
START TRANSACTION;

-- 插入操作 A
INSERT INTO `user`
VALUES (1, 'root1', 'root1', 'xxxx@163.com');

-- 创建保留点 updateA
SAVEPOINT updateA;

-- 插入操作 B
INSERT INTO `user`
VALUES (2, 'root2', 'root2', 'xxxx@163.com');

-- 回滚到保留点 updateA
ROLLBACK TO updateA;

-- 提交事务，只有操作 A 生效
COMMIT;
```

### DCL语句✅
`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。

### 权限管理
- 授予用户帐户权限，用`GRANT`命令。
  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。
  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。
  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。
  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。
  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。
- 撤销用户的权限，用`REVOKE`命令。
  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。
  - 指定在 `ON` 子句中撤销特权的特权级别。
  - 指定要撤消 `FROM` 子句中的权限的用户帐户。

`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：
- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；
- 整个数据库，使用 `ON database.*`；
- 特定的表，使用 `ON database.table`；
- 特定的列；
- 特定的存储过程。

```sql
-- GRANT用法
GRANT privilege,[privilege],.. ON privilege_level
TO user [IDENTIFIED BY password]
[REQUIRE tsl_option]
[WITH [GRANT_OPTION | resource_option]];

-- REVOKE用法
REVOKE privilege_type [(column_list)]
       [, priv_type [(column_list)]]...
ON [object_type] privilege_level
FROM user [, user]...

-- 创建账户
CREATE USER myuser IDENTIFIED BY 'mypassword';
-- 修改账户名
UPDATE user SET user='newuser' WHERE user='myuser';
FLUSH PRIVILEGES;
-- 删除账户
DROP USER myuser;
-- 查看权限
SHOW GRANTS FOR myuser;
-- 授予权限
GRANT SELECT, INSERT ON *.* TO myuser;
-- 删除权限
REVOKE SELECT, INSERT ON *.* FROM myuser;
-- 更改密码
SET PASSWORD FOR myuser = 'mypass';
```

### 游标CURSOR
游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

### 触发器TRIGGER
触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。

**优点**
- SQL 触发器提供了另一种检查数据完整性的方法。
- SQL 触发器可以捕获数据库层中业务逻辑中的错误。
- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。
- SQL 触发器对于审计表中数据的更改非常有用。

**缺点**
- SQL 触发器可能会增加数据库服务器的开销。
- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。

在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。
- `BEFORE INSERT`：在将数据插入表格之前激活。
- `AFTER INSERT`：将数据插入表格后激活。
- `BEFORE UPDATE`：在更新表中的数据之前激活。
- `AFTER UPDATE`：更新表中的数据后激活。
- `BEFORE DELETE`：在从表中删除数据之前激活。
- `AFTER DELETE`：从表中删除数据后激活。

`NEW` 和 `OLD`：
- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。
- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；
- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；
- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；
- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)

### 触发器语法

```sql
-- 创建触发器
CREATE TRIGGER trigger_name
trigger_time
trigger_event
ON table_name
FOR EACH ROW
BEGIN
trigger_statements
END;
```

说明：
- `trigger_name`：触发器名
- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。
- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。
- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。
- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。
- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。

当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。

```sql
-- 创建触发器
DELIMITER $
CREATE TRIGGER `trigger_insert_user`
AFTER INSERT ON `user`
FOR EACH ROW
BEGIN
    INSERT INTO `user_history`(user_id, operate_type, operate_time)
    VALUES (NEW.id, 'add a user',  now());
END $
DELIMITER ;

-- 查看触发器
SHOW TRIGGERS;

-- 删除触发器
DROP TRIGGER trigger_insert_user;
```

## MySQL
MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是3306。

### MySQL优点
- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。
- 开箱即用，操作简单，维护成本低。
- 兼容性好，支持常见的操作系统，支持多种开发语言。
- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。
- 支持分库分表、读写分离、高可用。

### 什么是关系型数据库
关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。

大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……

### MySQL字段类型
简单分为三大类：数值类型、字符串类型、日期和时间类型。
- 数值类型：
  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。
  - 浮点型：`FLOAT`、`DOUBLE`。
  - 定点数：`DECIMAL`。
- 字符串类型：
  - 常用：`CHAR`、`VARCHAR`、`TEXT`。
  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。
- 日期和时间类型：
  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。

### 整数类型的UNSIGNED属性
整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。

> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。
> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。

对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。

### CHAR/VARCHAR区别
- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。
- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。
- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。
- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。

### VARCHAR(100)/VARCHAR(10)区别
- 前者最大长度为 100，后者最大长度为 10。
- 二者存储相同的字符串所占用的存储空间是一样的。
- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。

### DECIMAL和FLOAT/DOUBLE区别
`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。

### 为什么没不推荐使用TEXT/BLOB类型








### 事务

我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：数据库中途突然因为某些原因挂掉了。客户端突然因为网络原因连接不上数据库了。并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。……上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性
- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- 一致性(Consistency)：事务执行前后，数据库的完整性约束没有被破坏。
- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

### 索引
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

优点：使用索引可以大大加快数据的检索速度(大大减少检索的数据量), 减少 IO 次数，这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。

### MySQL存储引擎
存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。

默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。

### MySQL存储引擎架构
MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

### MySQL 锁机制
锁是一种常见的并发事务的控制方式。

### 表级锁/行级锁
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比：
- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。


### MySQL字符集
MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`

### MySQL字符集层次级别
- MySQL 中的字符集分为四个层次：
  - server(MySQL 实例级别)
  - database(库级别)
  - table(表级别)
  - column(字段级别)

其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。

MySQL 字符编码集中有两套 UTF-8 编码实现：
- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。
- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。




## Redis

Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

### 基本数据类型
Redis 中比较常见的数据类型有下面这些：
- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。
- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。

### Redis持久化
使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：
- 快照(snapshotting，RDB)
- 只追加文件(append-only file, AOF)
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)


### 缓存穿透
缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存击穿
缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存雪崩
缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。




