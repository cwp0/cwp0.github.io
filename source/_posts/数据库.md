---
title: 数据库
tags:
  - 数据库
  - SQL
  - NoSQL
  - MySQL
  - mongodb
  - Redis
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 数据库面经
abbrlink: 17769
date: 2024-06-12 22:47:36
updated: 2024-06-16 19:30:16
top_img: https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png
comments:
cover: https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

> 本文参考 [JavaGuide](https://javaguide.cn/)

## SQL/NoSQL基础

### 什么是SQL
SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。

### DB/DBMS/DBS/DBA
- 数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。
- 数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。
- 数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。
- 数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。


### 数据库术语
- 数据库(`database`)：保存有组织的数据的容器(通常是一个文件或一组文件)。
- 数据表(`table`)：某种特定类型数据的结构化清单。
- 模式(`schema`)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。
- 列(`column`)：表中的一个字段。所有表都是由一个或多个列组成的。
- 行(`row`)：表中的一个记录。
- 主键(`primary key`)：一列(或一组列)，其值能够唯一标识表中每一行。

### 元组/码/候选码/主码/外码/主属性/非主属性概念
- 元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- 码：码就是能唯一标识实体的属性，对应表中的列。
- 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- 主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

### ER图
ER 图(`Entity Relationship Diagram`，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：
- 实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。
- 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。
- 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。

### 数据库三范式
数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：
- 1NF(第一范式)：属性不可再分。
  - 1NF 是所有**关系型数据库**的最基本要求 ，关系型数据库中创建的表一定满足第一范式。
- 2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的**部分函数依赖**。
- 3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的**传递函数依赖**。
  - 符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

> - 函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
>   - 例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)->(姓名)，(学号)->(姓名)，(身份证号)->(姓名)；所以姓名部分函数依赖于(学号，身份证号)；
> - 部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。
>   - 例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)->(姓名)，但是(学号)->(姓名)不成立，(班级)->(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；
> - 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。
> - 传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。**
>   - 例子：在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。

### 主键/外键区别
主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

### 为什么不推荐使用外键和级联操作
以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。**外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。**

- 增加了复杂型：每次做 `DELETE` 或者 `UPDATE` 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便；
- 增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；
- 对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。

**外键好处**
- 保证了数据库数据的一致性和完整性；
- 级联操作方便，减轻了程序代码量；

### 存储过程
可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。

存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。

### DROP/TRUNCATE/DELETE区别
1. 用法不同
- `DROP`(丢弃数据)：`DROP table 表名` ，直接将表都删除掉，在删除表的时候使用。
- `TRUNCATE`(清空数据)：`TRUNCATE table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- `DELETE`(删除数据)：`DELETE FROM 表名 WHERE 列名=值`，删除某一行的数据，如果不加 `WHERE` 子句和`TRUNCATE table 表名`作用类似。

`TRUNCATE` 和 `DELETE` 只删除数据不删除表的结构(定义)，`DROP`会删除表的结构。

2. 属于不同的数据库语言
- `DROP` 和 `TRUNCATE` 是 `DDL(Data Definition Language)` 数据定义语言，`DELETE` 是 `DML(Data Manipulation Language)` 数据操纵语言。

3. 执行速度不同：`DROP > TRUNCATE > DELETE`。
- `DELETE`命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。
- `TRUNCATE`命令执行的时候不会产生数据库日志，因此比`DELETE`要快。但其需要把表的自增值重置和索引恢复到初始大小等。
- `DROP`命令会把表占用的空间全部释放掉。

### 数据库设计分为哪几个步
1. 需求分析：分析用户的需求，包括数据、功能和性能需求。
2. 概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。
3. 逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. 物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。
5. 数据库实施：包括编程、测试和试运行
6. 数据库的运行和维护：系统的运行与数据库的日常维护。

### 什么是NoSQL
`NoSQL(Not Only SQL)`泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。

一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。

> NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。

### SQL/NoSQL区别

|         | SQL 数据库                                      | NoSQL 数据库                                                                                |
|：--------|----------------------------------------------|------------------------------------------------------------------------------------------|
| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |
| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |
| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |
| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |
| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |
| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |
| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |
| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |

### NoSQL优劣
**优点**
- 灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。
- 可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。
- 高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。
- 功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。

**缺点**
- 一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。
- 缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。

### NoSQL分类
- 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 `value` 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。
- 文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。
- 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。
- 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。

### 数据库分类
`DDL/DML/DCL/TCL`
- `DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。
  - DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。
- `DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。
  - DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。
- `TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。
- `DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。

### SQL三种注释方式
- 单行注释：`-- 注释内容` 或 `# 注释内容`。
- 多行注释：`/* 注释内容 */`。
- 行尾注释：`SELECT * FROM table_name; -- 注释内容`。

### DML语句✅
`DML(Data Manipulation Language)` 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：`INSERT`、`UPDATE`、`DELETE`、`SELECT`，这四个指令合称`CRUD(Create, Read, Update, Delete)`，即增删改查。

### 增删改查CRUD
增删改查，又称为 CRUD，数据库基本操作中的基本操作。

**插入数据**
`INSERT INTO` 语句用于向表中插入新记录。

```sql
-- 插入完整的行
-- 插入一行
INSERT INTO user
VALUES (10, 'root', 'root', 'xxxx@163.com');
-- 插入多行
INSERT INTO user
VALUES (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com'), (18, 'user2', 'user2', 'xxxx@163.com');

-- 插入行的一部分
INSERT INTO user(username, password, email)
VALUES ('admin', 'admin', 'xxxx@163.com');

-- 插入查询出来的数据
INSERT INTO user(username)
SELECT name
FROM account;
```

**更新数据**
`UPDATE` 语句用于更新表中的记录。

```sql
UPDATE user
SET username='robot', password='robot'
WHERE username = 'root';
```

**删除数据**
- `DELETE` 语句用于删除表中的记录。
- `TRUNCATE TABLE` 可以清空表，也就是删除所有行。

```sql
-- 删除表中的指定数据
DELETE FROM user
WHERE username = 'robot';

-- 清空表中的数据
TRUNCATE TABLE user;
```

**查询数据**
- `SELECT` 语句用于从数据库中查询数据。
- `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。
- `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。
- `ASC`：升序(默认)
- `DESC`：降序

```sql
-- 查询单列
SELECT prod_name
FROM products;

-- 查询多列
SELECT prod_id, prod_name, prod_price
FROM products;

-- 查询所有列
SELECT *
FROM products;

-- 查询不同的值
SELECT DISTINCT
vend_id FROM products;

-- 限制查询结果
-- 返回前 5 行
SELECT * FROM mytable LIMIT 5;
SELECT * FROM mytable LIMIT 0, 5;
-- 返回第 3 ~ 5 行
SELECT * FROM mytable LIMIT 2, 3;
```

### 排序
- `ORDER BY` 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 `DESC` 关键字。
- `ORDER BY` 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。

```sql
SELECT * FROM products
ORDER BY prod_price DESC, prod_name ASC;
```

### 分组
**`GROUP BY`**：

- `GROUP BY` 子句将记录分组到汇总行中。
- `GROUP BY` 为每个组返回一个记录。
- `GROUP BY` 通常还涉及聚合`COUNT`，`MAX`，`SUM`，`AVG` 等。
- `GROUP BY` 可以按一列或多列进行分组。
- `GROUP BY` 按分组字段进行排序后，`ORDER BY` 可以以汇总字段来进行排序。

```sql
-- 分组
SELECT cust_name, COUNT(cust_address) AS addr_num
FROM Customers GROUP BY cust_name;

-- 分组后排序
SELECT cust_name, COUNT(cust_address) AS addr_num
FROM Customers GROUP BY cust_name
ORDER BY cust_name DESC;
```

### HAVING

- `HAVING` 用于对汇总的 `GROUP BY` 结果进行过滤。
- `HAVING` 一般都是和 `GROUP BY` 连用。
- `WHERE` 和 `HAVING` 可以在相同的查询中。

```sql
-- 使用 WHERE 和 HAVING 过滤数据
SELECT cust_name, COUNT(*) AS NumberOfOrders
FROM Customers
WHERE cust_email IS NOT NULL
GROUP BY cust_name
HAVING COUNT(*) > 1;
```

### WHERE/HAVING对比
- `WHERE`：过滤过滤指定的行，后面不能加聚合函数(分组函数)。`WHERE` 在`GROUP BY` 前。
- `HAVING`：过滤分组，一般都是和 `GROUP BY` 连用，不能单独使用。`HAVING` 在 `GROUP BY` 之后。

### 子查询
MYSQL4.1才开始支持子查询(子查询需要放入括号`()`内)

子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 `SELECT` 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。

子查询可以嵌入 `SELECT`、`INSERT`、`UPDATE` 和 `DELETE` 语句中，也可以和 `=`、`<`、`>`、`IN`、`BETWEEN`、`EXISTS` 等运算符一起使用。

子查询常用在 `WHERE` 子句和 `FROM` 子句后边：
- 当用于 `WHERE` 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 `WHERE` 子句查询条件的值。
```sql
SELECT column_name [, column_name ]
FROM   table1 [, table2 ]
WHERE  column_name operator
    (SELECT column_name [, column_name ]
    FROM table1 [, table2 ]
    [WHERE])
```
- 当用于 `FROM` 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 `FROM` 后面是表的规则。这种做法能够实现多表联合查询。
```sql
SELECT column_name [, column_name ]
FROM (SELECT column_name [, column_name ]
      FROM table1 [, table2 ]
      [WHERE]) as temp_table_name
WHERE  condition
```

**子查询的子查询**
首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。
```sql
SELECT cust_name, cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
                  FROM orders
                  WHERE order_num IN (SELECT order_num
                                      FROM orderitems
                                      WHERE prod_id = 'RGAN01'));
```

### WHERE
- `WHERE` 子句用于过滤记录，即缩小访问数据的范围。
- `WHERE` 后跟一个返回 `true` 或 `false` 的条件。
- `WHERE` 可以与 `SELECT`，`UPDATE` 和 `DELETE` 一起使用。
```sql
-- SELECT语句中的WHERE
SELECT * FROM Customers
WHERE cust_name = 'Kids Place';

-- UPDATE语句中的WHERE
UPDATE Customers
SET cust_name = 'Jack Jones'
WHERE cust_name = 'Kids Place';

-- DELETE语句中的WHERE
DELETE FROM Customers
WHERE cust_name = 'Kids Place';
```
- 可以在 `WHERE` 子句中使用的操作符。
| 运算符       | 描述                                |
|-----------|-----------------------------------|
| `=`       | 等于                                |
| `<>`      | 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 `!=` |
| `>`       | 大于                                |
| `<`       | 小于                                |
| `>=`      | 大于等于                              |
| `<=`      | 小于等于                              |
| `BETWEEN` | 在某个范围内                            |
| `LIKE`    | 搜索某种模式                            |
| `IN`      | 指定针对某个列的多个可能值                     |

### IN/BETWEEN
- `IN` 操作符在 `WHERE` 子句中使用，作用是在指定的几个特定值中任选一个值。
- `BETWEEN` 操作符在 `WHERE` 子句中使用，作用是选取介于某个范围内的值。

```sql
-- IN示例
SELECT *
FROM products
WHERE vend_id IN ('DLL01', 'BRS01');

-- BETWEEN示例
SELECT *
FROM products
WHERE prod_price BETWEEN 3 AND 5;
```

### AND/OR/NOT
- `AND`、`OR`、`NOT` 是用于对过滤条件的逻辑处理指令。
- `AND` 优先级高于 `OR`，为了明确处理顺序，可以使用 `()`。
- `AND` 操作符表示左右条件都要满足。
- `OR` 操作符表示左右条件满足任意一个即可。
- `NOT` 操作符用于否定一个条件。

```sql
-- AND示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE vend_id = 'DLL01' AND prod_price <= 4;

-- OR示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';

-- NOT示例
SELECT *
FROM products
WHERE prod_price NOT BETWEEN 3 AND 5;
```

### LIKE
- `LIKE` 操作符在 `WHERE` 子句中使用，作用是确定字符串是否匹配模式。
- 只有字段是文本值时才使用 `LIKE`。
- `LIKE` 支持两个通配符匹配选项：`%` 和 `_`。
- 不要滥用通配符，通配符位于开头处匹配会非常慢。
- `%` 表示任何字符出现任意次数。
- `_` 表示任何字符出现一次。

```sql
-- %示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE prod_name LIKE '%bean bag%';

-- _示例
SELECT prod_id, prod_name, prod_price
FROM products
WHERE prod_name LIKE '__ inch teddy bear';
```

### 连接JOIN
`JOIN` 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。

语法：
```sql
SELECT table1.column1, table2.column2...
FROM table1
JOIN table2
ON table1.common_column1 = table2.common_column2; -- 连接条件，可以使用多个运算符， =、>、<、<>、<=、>=、!=、between、like 或者 not
```
当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。

如果两张表的关联字段名相同，也可以使用 `USING`子句来代替 `ON`。
```sql
# JOIN....ON
SELECT c.cust_name, o.order_num
FROM Customers c
INNER JOIN Orders o
ON c.cust_id = o.cust_id
-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()
-- using(cust_id) 代替 ON c.cust_id = o.cust_id
ORDER BY c.cust_name;
```

### 内连接/外连接
- `内连接`：`INNER JOIN` 或者 `JOIN`，只返回两个表中满足连接条件的行，是连接表的默认方式。
- `外连接`：
  - `左外连接`：`LEFT JOIN`/`LEFT OUTER JOIN`，返回左表中所有记录和右表中满足连接条件的记录。
  - `右外连接`：`RIGHT JOIN`/`RIGHT OUTER JOIN`，返回右表中所有记录和左表中满足连接条件的记录。
  - `全外连接`：`FULL JOIN`/`FULL OUTER JOIN`，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 `NULL` 值。


```sql
/* 
student表
student_id	name
1	        Alice
2	        Bob
3	        Carol

courses表
course_id	student_id	course_name
101	        1	        Math
102	        2	        Science
103	        4	        History
*/

-- 内连接
SELECT students.name, courses.course_name
FROM students
INNER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
*/

-- 左外连接
SELECT students.name, courses.course_name
FROM students
LEFT OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
Carol	NULL
*/

-- 右外连接
SELECT students.name, courses.course_name
FROM students
RIGHT OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
NULL	History
*/

-- 全外连接
SELECT students.name, courses.course_name
FROM students
FULL OUTER JOIN courses ON students.student_id = courses.student_id;
/*
结果
name	course_name
Alice	Math
Bob	Science
Carol	NULL
NULL	History
*/
```

### ON/WHERE区别
- `ON` 子句是在执行 `JOIN` 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。
- `WHERE` 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。

### 组合UNION
`UNION` 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 `UNION` 中参与查询的提取行。

`UNION` 基本规则：
- 所有查询的列数和列顺序必须相同。
- 每个查询中涉及表的列的数据类型必须相同或兼容。
- 通常返回的列名取自第一个查询。
- `UNION` 默认选取不同的值。如果允许重复的值，用 `UNION ALL`。

```sql
SELECT column1, column2, ...
FROM table1
UNION
SELECT column1, column2, ...
FROM table2;
```

### DDL语言✅
`DDL(Data Definition Language)` 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：`CREATE`、`ALTER`、`DROP`、`TRUNCATE`。

### 数据库DATABSE
- 创建数据库：`CREATE DATABASE 数据库名;`
- 删除数据库：`DROP DATABASE 数据库名;`
- 选择数据库：`USE 数据库名;`
- 查看数据库：`SHOW DATABASES;`

### 数据表TABLE
```sql
-- 普通创建
CREATE TABLE user (
id int(10) unsigned NOT NULL COMMENT 'Id',
username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
) COMMENT='用户表';

-- 根据已有表创建
CREATE TABLE vip_user AS
SELECT * FROM user;

-- 删除表
DROP TABLE user;

-- 查看表
SHOW TABLES;

-- 添加列
ALTER TABLE user -- ALTER用于修改表
ADD age int(3);

-- 删除列
ALTER TABLE user
DROP COLUMN age;

-- 修改列
ALTER TABLE `user`
MODIFY COLUMN age tinyint;

-- 添加主键
ALTER TABLE user
ADD PRIMARY KEY (id);

-- 删除主键
ALTER TABLE user
DROP PRIMARY KEY;
```

### 视图VIEW
在SQL中，视图`VIEW`是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。

作用：
- 简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。
- 提高数据安全性：用来限制用户访问敏感数据。
- 数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。
- 重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。

```sql
-- 创建视图
CREATE VIEW top_10_user_view AS
SELECT id, username
FROM user
WHERE id < 10;

-- 删除视图
DROP VIEW top_10_user_view;
```

### 索引INDEX
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

**优点**
- 使用索引可以大大加快 数据的检索速度(大大减少检索的数据量), 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点**
- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

```sql
-- 创建索引
CREATE INDEX user_index
ON user (id);

-- 添加索引
ALTER table user ADD INDEX user_index(id)

-- 创建唯一索引
CREATE UNIQUE INDEX user_index
ON user (id);

-- 删除索引
ALTER TABLE user
DROP INDEX user_index;
```

### 约束
SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 `CREATE TABLE 语句`)，或者在表创建之后规定(`通过 ALTER TABLE 语句`)。

**约束类型**
- `NOT NULL`：指示某列不能存储 `NULL` 值。
- `UNIQUE`：保证某列的每行必须有唯一的值。
- `PRIMARY KEY`：`NOT NULL` 和 `UNIQUE` 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
- `FOREIGN KEY`：保证一个表中的数据匹配另一个表中的值的参照完整性。
- `CHECK`：保证列中的值符合指定的条件。
- `DEFAULT`：规定没有给列赋值时的默认值。

```sql
CREATE TABLE Users (
  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',
  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',
  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',
  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',
  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',
  PRIMARY KEY (Id)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```


### TCL语句✅
`TCL(Transaction Control Language)` 事务控制语言：用于管理数据库中的事务。关键字：`COMMIT`、`ROLLBACK`。

### 事务TRANSACTION
事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。

**事务的四个特性(ACID)**
- `原子性(Atomicity)`：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- `一致性(Consistency)`：执行事务前后，数据保持一致。
- `隔离性(Isolation)`：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- `持久性(Durability)`：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

> 注意：不能回退 `CREATE` 或 `DROP` 等 DDL 语句。也不能回退 `SELECT`语句，回退也没意义。针对每个连接，通过设置`set autocommit=0`取消自动提交，`set autocommit=1` 才会自动提交。

```sql
-- 开始事务
START TRANSACTION;

-- 插入操作 A
INSERT INTO `user`
VALUES (1, 'root1', 'root1', 'xxxx@163.com');

-- 创建保留点 updateA
SAVEPOINT updateA;

-- 插入操作 B
INSERT INTO `user`
VALUES (2, 'root2', 'root2', 'xxxx@163.com');

-- 回滚到保留点 updateA
ROLLBACK TO updateA;

-- 提交事务，只有操作 A 生效
COMMIT;
```

### DCL语句✅
`DCL(Data Control Language)` 数据控制语言：用来控制数据库用户的访问权限。关键字：`GRANT`、`REVOKE`。

### 权限管理
- 授予用户帐户权限，用`GRANT`命令。
  - 在`GRANT`关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。
  - `ON privilege_level` 确定权限应用级别。MySQL 支持 global(`*.*`)，database(`database.*`)，table(`database.table`)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。
  - `user` 是要授予权限的用户。如果用户已存在，则`GRANT`语句将修改其权限。否则，`GRANT`语句将创建一个新用户。可选子句`IDENTIFIED BY`允许您为用户设置新的密码。
  - `REQUIRE tsl_option`指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。
  - 可选 `WITH GRANT OPTION` 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用`WITH`子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。
- 撤销用户的权限，用`REVOKE`命令。
  - 在 `REVOKE` 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。
  - 指定在 `ON` 子句中撤销特权的特权级别。
  - 指定要撤消 `FROM` 子句中的权限的用户帐户。

`GRANT` 和 `REVOKE` 可在几个层次上控制访问权限：
- 整个服务器，使用 `GRANT ALL` 和 `REVOKE ALL`；
- 整个数据库，使用 `ON database.*`；
- 特定的表，使用 `ON database.table`；
- 特定的列；
- 特定的存储过程。

```sql
-- GRANT用法
GRANT privilege,[privilege],.. ON privilege_level
TO user [IDENTIFIED BY password]
[REQUIRE tsl_option]
[WITH [GRANT_OPTION | resource_option]];

-- REVOKE用法
REVOKE privilege_type [(column_list)]
       [, priv_type [(column_list)]]...
ON [object_type] privilege_level
FROM user [, user]...

-- 创建账户
CREATE USER myuser IDENTIFIED BY 'mypassword';
-- 修改账户名
UPDATE user SET user='newuser' WHERE user='myuser';
FLUSH PRIVILEGES;
-- 删除账户
DROP USER myuser;
-- 查看权限
SHOW GRANTS FOR myuser;
-- 授予权限
GRANT SELECT, INSERT ON *.* TO myuser;
-- 删除权限
REVOKE SELECT, INSERT ON *.* FROM myuser;
-- 更改密码
SET PASSWORD FOR myuser = 'mypass';
```

### 游标CURSOR
游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 `SELECT` 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

### 触发器TRIGGER
触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 `INSERT`、`UPDATE` 或 `DELETE` 语句。

**优点**
- SQL 触发器提供了另一种检查数据完整性的方法。
- SQL 触发器可以捕获数据库层中业务逻辑中的错误。
- SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。
- SQL 触发器对于审计表中数据的更改非常有用。

**缺点**
- SQL 触发器可能会增加数据库服务器的开销。
- 从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。

在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。
- `BEFORE INSERT`：在将数据插入表格之前激活。
- `AFTER INSERT`：将数据插入表格后激活。
- `BEFORE UPDATE`：在更新表中的数据之前激活。
- `AFTER UPDATE`：更新表中的数据后激活。
- `BEFORE DELETE`：在从表中删除数据之前激活。
- `AFTER DELETE`：从表中删除数据后激活。

`NEW` 和 `OLD`：
- MySQL 中定义了 `NEW` 和 `OLD` 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。
- 在 `INSERT` 型触发器中，`NEW` 用来表示将要(`BEFORE`)或已经(`AFTER`)插入的新数据；
- 在 `UPDATE` 型触发器中，`OLD` 用来表示将要或已经被修改的原数据，`NEW` 用来表示将要或已经修改为的新数据；
- 在 `DELETE` 型触发器中，`OLD` 用来表示将要或已经被删除的原数据；
- 使用方法：`NEW.columnName` (`columnName` 为相应数据表某一列名)

### 触发器语法

```sql
-- 创建触发器
CREATE TRIGGER trigger_name
trigger_time
trigger_event
ON table_name
FOR EACH ROW
BEGIN
trigger_statements
END;
```

说明：
- `trigger_name`：触发器名
- `trigger_time`：触发器的触发时机。取值为 `BEFORE` 或 `AFTER`。
- `trigger_event`：触发器的监听事件。取值为 `INSERT`、`UPDATE` 或 `DELETE`。
- `table_name`：触发器的监听目标。指定在哪张表上建立触发器。
- `FOR EACH ROW`：行级监视，Mysql 固定写法，其他 DBMS 不同。
- `trigger_statements`：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 `;` 来结尾。

当触发器的触发条件满足时，将会执行 `BEGIN` 和 `END` 之间的触发器执行动作。

```sql
-- 创建触发器
DELIMITER $
CREATE TRIGGER `trigger_insert_user`
AFTER INSERT ON `user`
FOR EACH ROW
BEGIN
    INSERT INTO `user_history`(user_id, operate_type, operate_time)
    VALUES (NEW.id, 'add a user',  now());
END $
DELIMITER ;

-- 查看触发器
SHOW TRIGGERS;

-- 删除触发器
DROP TRIGGER trigger_insert_user;
```

## MySQL
MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是`3306`。

### MySQL基础✅

### MySQL优点
- 成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。
- 开箱即用，操作简单，维护成本低。
- 兼容性好，支持常见的操作系统，支持多种开发语言。
- 社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。
- 支持分库分表、读写分离、高可用。

### 什么是关系型数据库
关系型数据库(`RDB，Relational Database`)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。

大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(`ACID`)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……

### MySQL字段类型
简单分为三大类：数值类型、字符串类型、日期和时间类型。
- 数值类型：
  - 整形：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`。
  - 浮点型：`FLOAT`、`DOUBLE`。
  - 定点数：`DECIMAL`。
- 字符串类型：
  - 常用：`CHAR`、`VARCHAR`、`TEXT`。
  - 不常用：`TINYTEXT`、`MEDIUMTEXT`、`LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等。
- 日期和时间类型：
  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`等。

### 整数类型的UNSIGNED属性
整数类型可以使用可选的 `UNSIGNED` 属性来表示不允许负值的无符号整数。使用 `UNSIGNED` 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。

> `TINYINT UNSIGNED` 取值范围是 0 ~ 255，`TINYINT` 是 -128 ~ 127。
> `INT UNSIGNED` 取值范围是 0 ~ 4,294,967,295，`INT` 是 -2,147,483,648 ~ 2,147,483,647。

对于从 0 开始递增的 ID 列，使用 `UNSIGNED` 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。

### CHAR/VARCHAR区别
- `CHAR` 是一种固定长度的类型，`VARCHAR` 是一种可变长度的类型。
- `CHAR` 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；`VARCHAR` 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。
- `CHAR(M)` 和 `VARCHAR(M)` 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。
- `CHAR` 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。`VARCHAR`适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。

### VARCHAR(100)/VARCHAR(10)区别
- 前者最大长度为 100，后者最大长度为 10。
- 二者存储相同的字符串所占用的存储空间是一样的。
- `VARCHAR` 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。`VARCHAR(100)`在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。

### DECIMAL和FLOAT/DOUBLE区别
`DECIMAL` 是定点数，`FLOAT/DOUBLE` 是浮点数。`DECIMAL` 可以存储精确的小数值，`FLOAT/DOUBLE` 只能存储近似的小数值。

### 为什么没不推荐使用TEXT/BLOB类型
- `TEXT`用于存储长文本数据，如博客数据。
- `BLOB`用于存储二进制大对象，例如图片、音视频等文件。

这两种类型有如下缺陷：
- 不能有默认值。
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
- 检索效率较低。
- 不能直接创建索引，需要指定前缀长度。
- 可能会消耗大量的网络和 IO 带宽。
- 可能导致表上的 DML 操作变慢。

### DATETIME/TIMESTAMP区别
- `DATETIME`没有时区信息，`TIMESTAMP` 和时区有关。
- `TIMESTAMP` 只需要使用 4 个字节的存储空间，但是 `DATETIME` 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，`TIMESTAMP` 表示的时间范围更小。
  - `DATETIME`：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
  - `TIMESTAMP`：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC
- `TIMESTAMP` 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。

### NULL和''区别
- `NULL` 表示未知的值，`''` 表示空字符串。
  - `SELECT NULL=NULL`的结果为 `false`，但在使用`DISTINCT`,`GROUP BY`,`ORDER BY`时又认为`NULL`是相等的。
- `''`长度为0，不占用空间，`NULL`占用空间。
- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 `=`、`!=`、 `<`、`>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。
- `NULL` 会影响聚合函数的结果。
  - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。`COUNT` 的处理方式取决于参数的类型。如果参数是 `*(COUNT(*))`，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名`(COUNT(列名))`，则会忽略 `NULL` 值，只统计非空值的个数。

不推荐使用`NULL`作为列默认值。

### Boolean类型如何在MySQL中存储
MySQL 中没有布尔类型，可以使用 `TINYINT` 类型来存储布尔值。`TINYINT(1)` 可以存储 0 或 1，分别表示 `false` 和 `true`。

### MySQL基础架构✅

MySQL 基础架构主要分为 Server 层和存储引擎层：
- Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 `binlog` 日志模块。
- 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 `redolog` 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。

![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)

- 连接器：身份认证和权限相关(登录 MySQL 的时候)。
- 查询缓存：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
- 分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- 优化器：按照 MySQL 认为最优的方案去执行。
- 执行器：执行语句，然后从存储引擎返回数据。
- 插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。

1. 连接器。
主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。

2. 查询缓存(MySQL 8.0 版本后移除)。
主要用来缓存所执行的 `SELECT` 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 `Key-Value` 的形式缓存在内存中，`Key` 是查询语句，`Value` 是结果集。如果缓存 `Key` 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。
MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。

3. 分析器。
MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：
   - 第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。
   - 第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。

4. 优化器。
优化器以它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。

5. 执行器。
当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

### SQL语句在MySQL中的执行过程

**查询语句**
查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```
1. 检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 `key` 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
2. 通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
3. 优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：
   - a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
   - b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。
4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

**更新语句(增加，修改，删除)**
更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)
```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```
MySQL自带的日志模块是 `binlog`，以 `InnoDB` 作为存储引擎介绍，其自带了一个`redo log` 日志模块，用来保证数据的一致性的。
1. 先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。
2. 拿到查询的语句，把 `age` 改为 19，然后调用引擎 API 接口，写入这一行数据，`InnoDB` 引擎把数据保存在内存中，同时记录 `redo log`，此时 `redo log` 进入 `prepare` 状态，然后告诉执行器，执行完成了，随时可以提交。
3. 执行器收到通知后记录 `binlog`，然后调用引擎接口，提交 `redo log` 为提交状态。
4. 更新完成。

### MySQL存储引擎✅

### MySQL支持哪些存储引擎？
MySQL 支持多种存储引擎，常见的存储引擎有 `InnoDB`、`MyISAM`、`Memory`、`CSV`、`Archive`、`Blackhole`、`NDB`、`Merge`、`Federated`、`Example` 等。

MySQL 5.5.5 之前，`MyISAM` 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。

### MySQL存储引擎架构
MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。

### MyISAM/InnoDB存储引擎区别
- `MyISAM`只支持表级锁，而 `InnoDB` 支持行级锁和表级锁，默认为行级锁。
- `MyISAM` 不提供事务支持。`InnoDB` 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(`commit`)和回滚(`rollback`)事务的能力。并且，`InnoDB` 默认使用的 `REPEATABLE-READ`（可重读）隔离级别是可以解决幻读问题发生的（基于 `MVCC` 和 `Next-Key Lock`）。
- `MyISAM` 不支持外键，而 `InnoDB` 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。
- `MyISAM` 不支持数据库异常崩溃后的安全恢复，而 `InnoDB` 支持，恢复过程依赖于`redo log`。
- `InnoDB`支持 `MVCC`，`MyISAM` 不支持。`MVCC` 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。
- `InnoDB`和`MyISAM`都使用`B+Tree` 作为索引结构，但二者实现方式不一样。`InnoDB` 引擎中，其数据文件本身就是索引文件。相比 `MyISAM`，索引文件和数据文件是分离的，其表数据文件本身就是按 `B+Tree` 组织的一个索引结构，树的叶节点 `data` 域保存了完整的数据记录。
- `InnoDB` 的性能比 `MyISAM` 更强大，随着 CPU 核数的增加，`InnoDB` 的读写能力呈线性增长。
- 数据缓存策略和机制实现不同。`InnoDB` 使用缓冲池（`Buffer Pool`）缓存数据页和索引页，`MyISAM` 使用键缓存（`Key Cache`）仅缓存索引页而不缓存数据页。

### MySQL索引✅
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 `Innodb` 还是 `MyIsam`，都使用了 **B+树**作为索引结构。

**优点**
- 大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

**缺点**
- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

### 索引底层数据类型选型
1. `Hash`索引
`InnoDB` 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”（`Adaptive Hash Index`），结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 `B+Tree` 结构(不是传统的链表+红黑树)，这个 `B+Tree` 结构可以存储多个键值对，而不仅仅是一个键。`Hash` 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。

2. 二叉查找树
二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。
当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 `O(N)`。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。

3. AVL树
AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。

4. 红黑树
红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致**一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因**。红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 `O(logn)` 次数的旋转操作，其插入和删除操作效率大大提高。

5. B树&B+树
B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。
目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。
B树&B+树区别
- B 树的所有节点既存放键(`key`) 也存放数据(`data`)，而 B+树只有叶子节点存放 `key` 和 `data`，其他内节点只存放 `key`。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

### MyISAM/InnoDB索引区别
`MyISAM` 引擎和 `InnoDB` 引擎都是使用 `B+Tree` 作为索引结构，但实现方式不太一样：
- `MyISAM` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是数据记录的地址。在索引检索的时候，首先按照 `B+Tree` 搜索算法搜索索引，如果指定的 `Key` 存在，则取出其 `data` 域的值，然后以 `data` 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。
- `InnoDB` 引擎中，`B+Tree` 叶节点的 `data` 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 `InnoDB` 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。

### 索引分类

按照数据结构维度划分：
- `BTree` 索引：MySQL 里默认和最常用的索引类型。
- 哈希索引：类似键值对的形式，一次即可定位。

按照底层存储方式角度划分：
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：
- 主键索引：加速查询 + 列值唯一（不可以有 `NULL`）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 `NULL`）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 `ElasticSearch` 代替。

MySQL 8.x 中实现的索引新特性：
- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 `GROUP BY` 语句进行隐式排序。
- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。

### 主键索引
数据表的主键列使用的就是主键索引(主键索引的 `data` 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 `null`，不能重复。

在 MySQL 的 `InnoDB` 的表中，当没有显示的指定表的主键时，`InnoDB` 会自动先检查表中是否有唯一索引且不允许存在 `null` 值的字段，如果有，则选择该字段为默认的主键，否则 `InnoDB` 将会自动创建一个 6Byte 的自增主键。

### 二级索引
二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引/非主键索引。

唯一索引，普通索引，前缀索引等索引都属于二级索引。
- 唯一索引(`Unique Key`):唯一索引的属性列不能出现重复的数据，但是允许数据为 `NULL`，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
- 普通索引(`Index`):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 `NULL`。
- 前缀索引(`Prefix`):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。
- 全文索引(`Full Text`):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 `MYISAM` 引擎支持全文索引，5.6 之后 `InnoDB` 也支持了全文索引。

### 聚簇索引/非聚簇索引
聚簇索引（聚集索引）：索引结构和数据一起存放的索引，`InnoDB` 中的主键索引就属于聚簇索引。

**优点**：
- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。
- 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。

**缺点**：
- 依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串/UUID这类又长又难比较的数据，插入/查找的速度较慢。
- 更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。

非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 `MyISAM` 引擎，不管主键还是非主键，使用的都是非聚簇索引。

**优点**：
更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。

**缺点**：
- 依赖于有序的数据
- 可能会二次查询(回表):非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

### 回表
在 `InnoDB` 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。

### 覆盖索引/联合索引
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。

### 联合索引最左前缀匹配原则
在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

### 索引下推ICP
索引下推（`Index Condition Pushdown,ICP`） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 `WHERE`语句中的判断条件，直接过滤掉不满足条件的记录，从而**减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量**。

**原理**
![MySQL基础架构图](..%2Fimage%2FDatabase-Interview%2F13526879-3037b144ed09eb88.png)

MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。

索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给下层（存储引擎层）去处理。

```sql
SELECT * FROM user WHERE zipcode = '431200' AND MONTH(birthdate) = 3;
```
- 没有索引下推，存储引擎层`zipcode` 字段利用索引可以快速定位到 `zipcode = '431200'`的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据`MONTH(birthdate) = 3`这一条件再进一步做筛选。
- 有索引下推，存储引擎层根据 `zipcode` 索引字段找到所有 `zipcode = '431200'` 的用户，然后直接判断 `MONTH(birthdate) = 3`，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。

索引下推适用于 `InnoDB` 引擎和 `MyISAM` 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。

### MySQL查询缓存✅
执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用

查询缓存不命中的情况：
- 两个查询在任何字符上的不同都会导致缓存不命中。
- 若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。
- 缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。

### MySQL三大日志✅
MySQL比较重要的日志有二进制日志 `binlog`（归档日志）和事务日志 `redo log`（重做日志）和 `undo log`（回滚日志）。

MySQL `InnoDB` 引擎使用 `redo log`(重做日志) 保证事务的持久性，使用 `undo log`(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。

### redo log
`redo log`（重做日志）是 `InnoDB` 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，`InnoDB` 存储引擎会使用 `redo log` 恢复数据，保证数据的持久性与完整性。

查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 `Buffer Pool`中，后续查找先查找`Buffer Pool`，如果没有找到再去硬盘加载。更新数据的时候，若 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。

### 刷盘时机
`InnoDB` 在多种情况下将 `redo log` 刷到磁盘上，以保证数据的持久性和一致性。
- 事务提交：当事务提交时，`redo log buffer` 里的 `redo log` 会被刷新到磁盘的 `redo log` 文件里。
- `redo log buffer` 空间不足时：`redo log buffer` 中缓存的 `redo log` 已占了 `redo log buffer` 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。
- `Checkpoint`（检查点）：`InnoDB` 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。
- 正常关闭服务器：MySQL 关闭的时候，`redo log` 都会刷入到磁盘里去。
- 后台线程：`InnoDB` 有一个后台线程，每隔1 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。

### 刷盘策略
`innodb_flush_log_at_trx_commit`参数设置三种刷盘策略：
- 0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。
- 1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，`redo log` 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。
- 2，每次事务提交时都只把 `log buffer` 里的 `redo log` 内容写入 `page cache`（文件系统缓存）。`page cache` 是专门用来缓存文件的，这里被缓存的文件就是 `redo log` 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。

默认策略为第二种。

### binlog
`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志，且是顺序写。

MySQL 数据库的数据备份、主备、主主、主从都离不开 `binlog`，需要依靠 `binlog` 来同步数据，保证数据一致性。

### 记录格式
`binlog` 有三种记录格式：
- `Statement`：记录的是 SQL 语句，如 `update t set c=c+1 where id=2`。
  - 同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。
- `Row`：记录的是行数据，如 `id=2 c=2`。
  - 这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。
- `Mixed`：记录的是上面两种的混合模式。
  - MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。

### 写入机制
事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到 `binlog` 文件中。一个事务的 `binlog` 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。

通过 `write` 将`binlog cache`中的 `binlog`写入文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。

**`write` 和 `fsync` 时机** 由参数`sync_binlog`控制，默认是1。
- 0，每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。
  - 虽然性能最高，但是机器宕机，`page cache`里面的 `binlog` 会丢失。
- 1，每次提交事务都会执行`write`+`fsync`，和 `redo log` 日志刷盘流程一样。
- N(>1)，每次提交事务都会执行`write`，但是累计 `N`次事务后才执行 `fsync`。
  - 在出现 IO 瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近`N`个事务的 `binlog` 日志。

### 两阶段提交
`redo log`（重做日志）让 `InnoDB` 存储引擎拥有了崩溃恢复能力。`binlog`（归档日志）保证了 MySQL 集群架构的数据一致性。

`redo log` 与 `binlog` 的写入时机不一样，`redo log` 是事务执行过程中写入，`binlog` 是事务提交后写入。

写入机制不一样会导致日志不一致：
若某一事务(更新某一行的a值，从 0->1)执行过程中写完 `redo log` 日志后，`binlog` 日志写期间发生了异常，写入失败。此时使用`redo log`恢复的数据中，a值已经变为1，而`binlog`中记录的是a值为0，这样就导致了数据不一致。

为了解决数据不一致问题，InnoDB 存储引擎使用两阶段提交：将 `redo log` 的写入拆成了两个步骤`prepare`和`commit`。
- `prepare`：在事务执行过程中，先写入 `redo log`，但是不提交事务。
- `commit`：在事务提交后，再写入 `binlog`，然后提交`redo log`。

使用两阶段提交后，写入 `binlog` 时发生异常也不会有影响。此时 MySQL 根据 `redo log` 日志恢复数据时，发现 `redo log` 还处于`prepare`阶段，并且没有对应 `binlog` 日志，就会回滚该事务。

如果`redo log` 在 `commit`阶段发生异常，虽然 `redo log` 处于`prepare`阶段，但是能通过事务id找到对应的 `binlog` 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。

### undo log
`undo log` 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 `DELETE` 语句，那 `undo log` 就会记录一条相对应的 `INSERT` 语句。每一个事务对数据的修改都会被记录到 `undo log` ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 `undo log` 将数据恢复到事务开始之前的状态。

`undo log` 本身是会被删除清理的，例如 `INSERT` 操作，在事务提交之后就可以清除掉了；`UPDATE/DELETE` 操作在事务提交不会立即删除，会加入 `history list`，由后台线程 `purge` 进行清理。

`undo log` 采用 `segment`（段）进行记录，事务开始时，需要为其分配一个 `rollback segment`。每个 `rollback segment` 有 1024 个 `undo log segment`(每个 `undo` 操作在记录的时候占用一个 `undo log segment`，多个有助于管理多个并发事务) 和 一个 `rollback segment header`(负责管理`rollback segment`)，`history list` 是`rollback segment header`的一部分，它的主要作用是记录所有已经提交但还没有被清理（`purge`）的事务的 `undo log`，`history list`列表使得 `purge` 线程能够找到并清理那些不再需要的 `undo log` 记录。

### MySQL事务✅
事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性
- 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。
- 一致性(Consistency)：执行事务前后，数据保持一致。
- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。

> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！

### 并发事务存在的问题

### 脏读
一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。

一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。

解决：
- 设置事务隔离级别为 `Read Committed` 或更高。`Read Committed` 确保事务只能读取已经提交的数据，从而避免脏读。

### 丢失修改
两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。

在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

解决：
- 乐观锁（Optimistic Locking）： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。
- 悲观锁（Pessimistic Locking）： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。

### 不可重复读
一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。

一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。

解决：
- 执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。
- 设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。

### 幻读
一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。

一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

解决：
- 执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。
- 事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。

### 不可重复读和幻读有什么区别
- 不可重复读：多次读取同一数据，发现数据不一致。
- 幻读：多次执行同一条查询语句，发现查到的记录增加了。

幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。
- 解决不可重复读：执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。
- 解决幻读：执行 `insert` 操作的时候，由于记录锁（`Record Lock`）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（`Gap Lock`）。也就是说执行 `insert` 操作的时候需要依赖 `Next-Key Lock（Record Lock+Gap Lock）` 进行加锁来保证不出现幻读。

### 并发事务的控制方式有哪些
MySQL 中并发事务的控制方式无非就两种：锁 和 `MVCC`。锁可以看作是悲观控制的模式，多版本并发控制（`MVCC，Multiversion concurrency control`）可以看作是乐观控制的模式。

- 锁：
  - 共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
  - 排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。
- `MVCC` 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(`table-level locking`) 和 行级锁(`row-level locking`) 。`InnoDB` 默认为行级锁，也支持表级锁，所以并发性能比较高。

> 注意：不论是表级锁还是行级锁，都存在共享锁（`Share Lock`，S 锁）和排他锁（`Exclusive Lock`，X 锁）这两类。

MVCC 在 MySQL 中实现所依赖的手段主要是:隐藏字段、`read view`、`undo log`。
- `undo log` : `undo log` 用于记录某行数据的多个版本的数据。
- `read view` 和 隐藏字段 : 用来判断当前版本数据的可见性。

### 事务隔离级别
`READ-UNCOMMITTED`(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
`READ-COMMITTED`(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
`REPEATABLE-READ`(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
`SERIALIZABLE`(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

|     隔离级别     | 脏读 | 不可重复读 | 幻读 | 实现方式 |
| :--------------: | :--: | :--------: | :--: | :------: |
| READ-UNCOMMITTED |  √   |     √      |  √   | /        |
|  READ-COMMITTED  |  ×   |     √      |  √   | 基于 MVCC/锁 |
| REPEATABLE-READ  |  ×   |     ×      |  √   | 基于 MVCC/锁(当前读情况下需要使用加锁读来保证不会出现幻读) |
|   SERIALIZABLE   |  ×   |     ×      |  ×   | 基于 锁 |

MySQL默认隔离级别是 `REPEATABLE-READ`。





### MySQL存储引擎
存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。

默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。

### MySQL存储引擎架构
MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

### MySQL 锁机制
锁是一种常见的并发事务的控制方式。

### 表级锁/行级锁
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比：
- 表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
- 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。


### MySQL字符集
MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 `latin1` ；在 MySQL8.0 中，默认字符集是 `utf8mb4`

### MySQL字符集层次级别
- MySQL 中的字符集分为四个层次：
  - server(MySQL 实例级别)
  - database(库级别)
  - table(表级别)
  - column(字段级别)

其优先级可以简单的认为是从上往下依次增大，也即 `column` 的优先级会大于 `table` 等其余层次的。如指定 MySQL 实例级别字符集是`utf8mb4`，指定某个表字符集是`latin1`，那么这个表的所有字段如果不指定的话，编码就是`latin1`。

MySQL 字符编码集中有两套 UTF-8 编码实现：
- `utf8`：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。
- `utf8mb4`：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。




## Redis

Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

### 基本数据类型
Redis 中比较常见的数据类型有下面这些：
- 5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。
- 3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。

除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。

### Redis持久化
使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式：
- 快照(snapshotting，RDB)
- 只追加文件(append-only file, AOF)
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)


### 缓存穿透
缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存击穿
缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。

### 缓存雪崩
缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。




