---
title: 框架
tags:
  - 框架
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 框架方面的面经
abbrlink: 17771
date: 2024-06-12 22:49:36
updated: 2024-06-28 00:15:41
top_img: https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png
comments:
cover: https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

> 本文参考 [JavaGuide](https://javaguide.cn/)

## Spring
### 什么是Spring
Spring 是一款基于 Java 的轻量级开源开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

Spring 框架(Spring Framework)是很多模块的集合，使用这些模块可以很方便地协助进行开发。Spring 支持控制反转(Inversion of Control, IOC) 和 面向切面编程(Aspect-Oriented Programming, AOP)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件(电子邮件，任务，调度，缓存等等)、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。

Spring的核心功能主要是 `IoC` 和 `AOP`，核心思想是不重新造轮子，开箱即用，提高开发效率。

### Spring模块
![Spring 4.x](./image/Framework/Spring-4-x.png)

Spring5.x 版本中 Web 模块的 `Portlet` 组件已经被废弃掉，同时增加了用于异步响应式处理的 `WebFlux` 组件。

- `Core Container`：Spring 框架的核心模块、基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块。
  - `spring-core`：Spring 框架基本的核心工具类。
  - `spring-beans`：提供对 `bean` 的创建、配置和管理等功能的支持。
  - `spring-context`：提供对国际化、事件传播、资源加载等功能的支持。
  - `spring-expression`：提供对表达式语言(Spring Expression Language, SpEL)的支持，只依赖于 `core` 模块，不依赖于其他模块，可以单独使用。
- `AOP`：面向切面编程，提供对切面编程的支持。
  - `spring-aop`：提供了面向切面的编程实现。
  - `spring-aspects`：该模块为与 `AspectJ` 的集成提供支持。
  - `spring-instrument`：提供了为 JVM 添加代理(agent)的功能。其为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。
- `Data Access/Integration`：数据访问/集成层，提供对数据库访问、事务管理、ORM、OXM、JMS 等功能的支持。
  - `spring-jdbc`：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。
  - `spring-tx`：提供事务管理的支持。
  - `spring-orm`：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。
  - `spring-oxm`：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。
  - `spring-jms`：消息服务。自 Spring Framework 4.1 以后，它还提供了对 `spring-messaging` 模块的继承。
- `Spring Web`：Web 模块，提供对 Web 应用开发的支持。
  - `spring-web`：提供了基本的 Web 功能，如多文件上传、使用 `Servlet` 监听器初始化 Spring IoC 容器等。
  - `spring-webmvc`：提供了 Spring MVC 的实现。
  - `spring-websocket`：提供了对 WebSocket 的支持，可以让客户端和服务端进行双向通信。
  - `spring-webflux`：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。
- `Messaging`：`spring-messaging` 是Spring4.0新加入的模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。
- `Spring Test`：Spring有控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。Spring 的测试模块对 JUnit(单元测试框架)、TestNG(类似 JUnit)、Mockito(主要用来 Mock 对象)、PowerMock(解决 Mockito 的问题比如无法模拟 `final`，`static`，`private` 方法)等等常用的测试框架支持的都比较好。

![Spring各模块依赖关系](./image/Framework/Spring各模块依赖关系.png)

### Spring/Spring Boot/Spring MVC之间的关系
- Spring是基于 Java 的轻量级开源框架，包含众多模块，其中最重要的是`Spring-Core`(主要提供 `IoC` 依赖注入功能的支持)模块， Spring中的其他模块(如 `Spring MVC`)的功能实现基本都需要依赖于该模块。
- `Spring MVC` 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。
- 使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。过于麻烦，所以 `Spring Boot` 诞生了，其只是简化了配置，如果需要构建 MVC 架构的 Web 程序，还是需要使用 `Spring MVC` 作为 MVC 框架，只是说 `Spring Boot` 简化了 `Spring MVC` 的很多配置，真正做到开箱即用！
  - Spring 旨在简化 J2EE 企业应用程序开发。`Spring Boot` 旨在简化 Spring 开发(减少配置文件，开箱即用！)。

### Spring IoC✅
### 什么是Spring IoC
控制反转(Inversion of Control, IoC)是一种设计思想，而不是一个具体的技术实现，并非Spring特有。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。

现有类 A 依赖于类 B
- 传统的开发方式 ：往往是在类 A 中手动通过 `new` 关键字来 new 一个 B 的对象出来
- 使用 IoC 思想的开发方式 ：不通过 `new` 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。

IoC使开发者丧失了创建、管理对象的权利，但是也使得开发者不用再考虑对象的创建、管理等一系列的事情，只需要专注于业务逻辑的实现。

### IoC解决了什么问题
1. **依赖管理和解耦**：在传统的Java应用中，类与类之间的依赖是通过硬编码实现的，这导致了代码的高度耦合和难以维护。Spring IoC通过依赖注入（Dependency Injection，DI）模式，将对象的创建和依赖关系的管理交给Spring容器处理，从而实现了组件之间的解耦，提升了代码的可维护性和可测试性。
2. **对象生命周期管理**：Spring容器负责管理Bean的生命周期，从创建、初始化到销毁，开发者可以通过配置和注解来控制这些生命周期方法，从而避免了手动管理对象生命周期的复杂性。
3. **配置集中管理**：通过Spring IoC，可以将应用程序的配置信息集中在一个或多个配置文件中（如XML文件、Java配置类或注解），从而使得配置更加集中和统一，便于管理和维护。
4. **代码的可测试性**：通过依赖注入，可以轻松地替换实际的依赖对象为模拟对象（mock objects），从而提高了单元测试的可行性和便捷性。
5. **模块化和可插拔性**：Spring IoC支持通过不同的配置方式（XML、注解、Java配置类等）来实现模块化配置，便于扩展和维护。同时，Spring IoC容器支持不同类型的Bean作用域（如单例、原型等），增强了系统的灵活性和可扩展性。

通过Spring IoC的依赖注入和面向接口编程的方式，开发者可以更加专注于业务逻辑的实现，而不必过多关心对象的创建和管理，从而提升了开发效率和代码质量。

### Spring IoC原理
控制反转指将对象的创建和依赖关系的管理从应用程序代码中抽离出来，交给Spring容器进行管理。

**控制反转**
- 控制：指的是对象创建(实例化、管理)的权力
- 反转：控制权交给外部环境(Spring 框架、`IoC` 容器)

实现控制反转有多种方式：
- 依赖注入：通过注入方式实现依赖管理，易于测试和维护，广泛应用于现代开发框架(如Spring)。
- 服务定位器模式：通过中央注册器获取服务，使用方便，但可能引入全局状态和隐藏依赖。
- 事件驱动架构：通过事件进行解耦，适用于异步处理和复杂业务流程。
- 依赖查找：通过标准API查找依赖，适用于某些特定场景，但查找过程可能较为复杂。

**Spring IoC容器**
Spring IoC容器是负责管理对象及其依赖关系的核心组件。IoC 容器实际上就是个 Map(key，value)，Map 中存放的是各种对象。主要的IoC容器有：
- `BeanFactory`：最基础的IoC容器，提供基本的依赖注入功能。
- `ApplicationContext`：继承自`BeanFactory`，提供更多高级功能，如事件发布、国际化、AOP等。

### 什么是Spring Bean
在Spring中，bean是由IoC容器管理的对象。bean的定义和配置可以通过以下几种方式：
- XML配置文件：在XML文件中定义`bean`及其依赖关系。
- 注解配置：通过Java注解(如`@Component`、`@Autowired`等)定义和注入`bean`。
- Java配置类：使用`@Configuration`和`@Bean`注解，通过Java类定义`bean`。

### 将一个类声明为Bean的注解有哪些
- `@Component`：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository`： 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service`： 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller`： 对应 `Spring MVC` 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。

### @Component/@Bean区别

**主要区别**
1. 定义方式：
  - `@Component` 是在类上使用，Spring 自动扫描并注册 Bean。
  - `@Bean` 是在方法上使用，返回值被注册为 Bean。
2. 适用场景：
  - `@Component` 适用于开发人员自己编写的类。
  - `@Bean` 适用于第三方库的类或需要复杂配置的 Bean。
3. 扫描和配置：
  - `@Component` 需要启用组件扫描。
  - `@Bean` 通常与配置类一起使用，不需要组件扫描。

总结来说，`@Component` 更适合于直接在类上进行标注，简化了配置过程；而 `@Bean` 则提供了更多的灵活性，可以在配置类中以编程的方式定义 Bean。

**@Component**
- 用途：`@Component` 用于标记一个类为 Spring 容器的组件(Bean)。
- 使用方式：直接在类上使用。Spring 会自动扫描带有 `@Component` 注解的类，并将其注册为 Spring 容器中的 Bean。
- 扫描：需要在配置类上使用 `@ComponentScan` 注解来启用自动扫描。
- 适用范围：通常用于标记服务层、数据访问层、控制层等组件类。
- 例子：
  ```java
  @Component
  public class MyService {
      // 服务实现
  }
  ```
**@Bean**
- 用途：`@Bean` 用于在配置类中定义一个方法，该方法的返回值会被注册为 Spring 容器中的 Bean。
- 使用方式：在配置类的方法上使用，方法的返回值会作为 Bean 注册到 Spring 容器中。
- 配置类：通常与 `@Configuration` 注解一起使用，表明这是一个配置类。
- 适用范围：通常用于定义第三方库的 Bean，或者需要复杂初始化的 Bean。
- 例子：
  ```java
  @Configuration
  public class AppConfig {
      @Bean
      public MyService myService() {
          return new MyServiceImpl();
      }
  }
  ```

### 用于注入Bean的注解有哪些？

#### @Autowired
- **用途**：`@Autowired` 用于自动注入 Bean，Spring 会自动满足标记了该注解的依赖。
- **使用位置**：可以用在字段、构造方法、Setter 方法以及普通方法上。
- **特点**：默认按类型注入，可以结合 `@Qualifier` 按名称注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Autowired
      private MyRepository myRepository;

      // 或者使用构造方法注入
      @Autowired
      public MyService(MyRepository myRepository) {
          this.myRepository = myRepository;
      }
  }
  ```
#### @Resource
- **用途**：`@Resource` 是 JSR-250 标准的注解，可以按名称或类型注入。
- **使用位置**：字段、Setter 方法。
- **特点**：默认按名称注入，如果找不到匹配的 Bean，则按类型注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Resource(name = "myRepository")
      private MyRepository myRepository;
  }
  ```

#### @Qualifier
- **用途**：与 `@Autowired` 一起使用，按名称注入 Bean。
- **使用位置**：字段、构造方法参数、Setter 方法参数。
- **特点**：解决同类型 Bean 多个实例的冲突问题。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Autowired
      @Qualifier("specificRepository")
      private MyRepository myRepository;
  }
  ```

#### @Inject
- **用途**：`@Inject` 是 JSR-330 标准的注解，功能与 `@Autowired` 类似。
- **使用位置**：字段、构造方法、Setter 方法。
- **特点**：仅支持按类型注入，可以结合 `@Named` 注解按名称注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Inject
      private MyRepository myRepository;

      // 或者使用构造方法注入
      @Inject
      public MyService(MyRepository myRepository) {
          this.myRepository = myRepository;
      }
  }
  ```

#### @Value
- **用途**：`@Value` 用于注入简单值，比如基本类型、字符串、Spring EL 表达式等。
- **使用位置**：字段、构造方法参数、Setter 方法参数。
- **特点**：可以注入配置文件中的属性值。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Value("${app.name}")
      private String appName;
  }
  ```

`@Autowired` 和`@Resource`用的多一些。

### @Autowired/@Resource区别
- 默认注入方式：
  - `@Autowired` 默认根据接口类型(`byType`)去匹配并注入Bean(接口的实现类)。当一个接口存在多个实现类的话，`Autowired` 可以通过 `@Qualifier` 注解来显式指定类名称。
  - `@Resource` 当一个接口存在多个实现类的话，默认按类名称(`byName`)注入。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为`byType`。
- 注解来源：
  - `@Autowired`：Spring 框架提供的注解。
  - `@Resource`：JSR-250(JDK) 标准提供的注解。
- 使用位置：
  - `@Autowired` 可以用在构造函数、方法、字段以及参数上。
  - `@Resource` 通常用在字段和 Setter 方法上的注入。
- 配置属性：
  - `@Autowired`：可以结合 `@Qualifier` 按名称注入。
  - `@Resource`：可以通过 `name` 属性指定 `Bean` 名称，通过 `type` 属性指定 Bean 类型。
- 处理机制：
  - `@Autowired`：使用 Spring 的依赖注入机制。
  - `@Resource`：使用 JNDI 进行资源查找，适合在 Java EE 容器环境中使用。
  
总的来说，`@Autowired` 更加灵活和强大，适合在 Spring 应用中广泛使用；而 `@Resource` 则提供了一种更标准化的方式进行依赖注入，特别是在需要与 Java EE 容器进行集成时。

> `@Resource` 有两个比较重要且日常开发常用的属性：`name`(名称)、`type`(类型)。
> ```java
> public @interface Resource {
>     String name() default "";
>     Class<?> type() default Object.class;
> }
> ```
> 如果仅指定 `name` 属性则注入方式为`byName`，如果仅指定`type`属性则注入方式为`byType`，如果同时指定`name`和`type`属性(不建议这么做)则注入方式为`byType`+`byName`。

### Bean的作用域有哪些？
在 Spring 框架中，Bean 的作用域(scope)定义了 Bean 的生命周期和可见性。Spring 提供了以下几种常见的 Bean 作用域：

- `Singleton`
  - **描述**：默认作用域。在整个 Spring 容器中只有一个 Bean 实例，每次请求该 Bean 时都会返回同一个实例。
  - **使用场景**：大多数情况下使用，适用于无状态的 Bean。
- `Prototype`
  - **描述**：每次请求该 Bean 时，都会创建一个新的实例。
  - **使用场景**：适用于有状态的 Bean 或需要每次使用时创建新实例的 Bean。
- `Request`
  - **描述**：在一个 HTTP 请求中，每次请求该 Bean 时，都会创建一个新的实例。该作用域仅在 Web 应用程序中有效。
  - **使用场景**：适用于每个 HTTP 请求需要一个独立 Bean 实例的情况，例如处理用户请求的控制器。
- `Session`
  - **描述**：在一个 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域仅在 Web 应用程序中有效。
  - **使用场景**：适用于需要在整个用户会话期间保持状态的 Bean。
- `Global Session`
  - **描述**：在一个全局 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域主要用于 Portlet 应用程序。
  - **使用场景**：适用于需要在全局 Portlet 会话期间保持状态的 Bean。
- `Application`
  - **描述**：在整个应用程序生命周期内，每次请求该 Bean 时，都会返回同一个实例。通常在 Web 应用程序中使用。
  - **使用场景**：适用于需要在整个应用程序生命周期内共享的 Bean。

```java
// Scope中可以指定Bean的作用域，取值：singleton、prototype、request、session、globalSession、application
@Component
@Scope("singleton")
public class MySingletonBean {
    // 实现代码
}
 ```

### Bean是线程安全的吗
在 Spring 框架中，Bean 的线程安全性取决于其作用域和状态。以下是一些常见情况：

### Singleton Bean
- **默认作用域**：`@Scope("singleton")`
- **描述**：单例 Bean 在 Spring 容器中只有一个实例，并且该实例会被多个线程共享。
- **线程安全性**：单例 Bean 本身并不是线程安全的。如果单例 Bean 中包含可变的共享状态，则需要确保其线程安全。这可以通过以下方式实现：
  - 不在单例 Bean 中使用可变状态。
  - 使用线程安全的数据结构(如 `ConcurrentHashMap`)。
  - 在访问可变状态时使用同步(如 `synchronized`)。
  - 采用无状态的设计模式。

### Prototype Bean
- **作用域**：`@Scope("prototype")`
- **描述**：原型 Bean 每次请求时都会创建一个新的实例，因此每个线程都会获得一个新的实例。
- **线程安全性**：由于每个线程都有自己的实例，原型 Bean 通常是线程安全的。但是，原型 Bean 的生命周期由使用它的对象管理，可能需要注意其创建和销毁的时机。

### Request 和 Session Scoped Beans
- **作用域**：`@Scope("request")` 和 `@Scope("session")`
- **描述**：请求作用域的 Bean 在一个 HTTP 请求中创建和销毁。会话作用域的 Bean 在一个 HTTP 会话中创建和销毁。
- **线程安全性**：请求作用域的 Bean 通常是线程安全的，因为每个请求都是独立的。会话作用域的 Bean 可能会被多个线程共享，需要考虑线程安全性。

### Application Scoped Beans
- **作用域**：`@Scope("application")`
- **描述**：应用程序作用域的 Bean 在整个应用程序生命周期内共享。
- **线程安全性**：与单例 Bean 类似，应用程序作用域的 Bean 需要注意线程安全性问题。

### Global Session Scoped Beans
- **作用域**：`@Scope("globalSession")`
- **描述**：全局会话作用域的 Bean 在 Portlet 应用程序的全局会话中共享。
- **线程安全性**：类似于会话作用域的 Bean，需要考虑线程安全性。

总之，除非 Bean 的设计明确考虑了线程安全性，否则默认情况下 Spring 容器不会保证 Bean 的线程安全。确保线程安全的最佳实践包括无状态设计、使用线程安全的数据结构以及适当的同步机制。

### Bean的生命周期
1. 创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。
2. Bean 属性填充(依赖注入)：为 Bean 设置相关属性和依赖，如`@Autowired` 等注解注入的对象、`@Value` 注入的值、`setter`方法或构造函数注入依赖和值、`@Resource`注入的各种资源。
3. Bean的初始化
   1. 调用`Aware`接口的方法：
      - 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入 Bean 的名字。
      - 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。
      - 如果 Bean 实现了 `BeanFactoryAware` 接口，调用 `setBeanFactory()`方法，传入 `BeanFactory`对象的实例。
      - 如果实现了其他 *.Aware接口，就调用相应的方法。
   2. 前置处理：如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessBeforeInitialization()` 方法
   3. 初始化方法：如果 Bean 实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。如果 Bean 在配置文件中的定义包含 `init-method` 属性，执行指定的方法。
   4. 后置处理：如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessAfterInitialization()` 方法。
4. 使用 Bean：Bean 可以被容器使用了，可以调用 Bean 的方法处理业务逻辑。
5. 销毁 Bean：销毁并不是立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。
   - 如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。
   - 如果 Bean 在配置文件中的定义包含 `destroy-method` 属性，执行指定的 Bean 销毁方法。
   - 也可以直接通过`@PreDestroy` 注解标记 Bean 销毁之前执行的方法。

![Bean的生命周期](./image/Framework/spring-bean-lifestyle.png)

> Spring 中提供的 Aware 接口主要有：
> `BeanNameAware`：注入当前 `bean` 对应 `beanName`；
> `BeanClassLoaderAware`：注入加载当前 `bean` 的 `ClassLoader`；
> `BeanFactoryAware`：注入当前 `BeanFactory` 容器的引用。

### Spring AOP✅

### 对Spring AOP的理解
面向切面编程(Aspect-Oriented Programming, AOP)是面向对象编程(OOP)的延续，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：

![Spring AOP代理方式](./image/Framework/230ae587a322d6e4d09510161987d346.jpeg)

Spring AOP也集成了 AspectJ，可以使用 AspectJ 的注解来实现 AOP。

### AOP解决了什么问题
1. **横切关注点分离**：在传统的面向对象编程中，某些功能（如日志记录、事务管理、安全性验证等）往往分散在多个类和方法中，导致代码的重复和耦合。AOP通过将这些横切关注点独立出来，以切面的形式进行集中管理，从而简化了核心业务逻辑。
2. **提高代码可读性和可维护性**：通过将横切关注点分离出来，核心业务代码变得更加简洁、清晰。这样，开发者可以更加专注于业务逻辑的实现，提高代码的可读性和可维护性。
3. **动态代理和拦截功能**：AOP提供了动态代理机制，可以在不修改原有代码的情况下，对方法进行拦截和增强。这种机制在处理权限验证、性能监控、缓存管理等场景时非常有用。
4. **代码重用**：由于横切关注点可以以独立的切面形式存在，可以在不同的应用和模块之间共享和重用，提高了代码的复用性。
5. **减少代码耦合**：通过AOP，将横切关注点从业务逻辑中分离出来，使得各个模块之间的耦合度降低，从而提高了系统的灵活性和可扩展性。

### AOP应用场景
1. **日志记录**：可以在方法执行前后自动记录日志，而不需要在每个方法中手动添加日志代码。
2. **事务管理**：可以在方法开始时开启事务，方法结束时提交或回滚事务，确保数据一致性。
3. **安全性验证**：可以在方法执行前进行权限验证，确保用户有权限执行该操作。
4. **性能监控**：可以统计方法的执行时间，进行性能分析和优化。
5. **异常处理**：可以统一处理方法中的异常，避免重复的异常处理代码。

### Spring AOP原理
Spring AOP(面向切面编程)是Spring框架中的一个重要模块，用于在不修改现有代码的情况下向程序中添加新的行为。基本原理和关键概念如下：

1. 核心概念
   - Target(目标)：被通知的对象
   - Proxy(代理)：向目标对象应用通知之后创建的代理对象
   - Join Point(连接点)：目标对象的所属类中，定义的所有方法均为连接点
   - Pointcut(切点)：切点是用于匹配连接点的表达式。被切面拦截 / 增强的连接点(切入点一定是连接点，连接点不一定是切入点)
   - Advice(通知)：增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情。Spring AOP支持五种类型的通知：前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。
   - Aspect(切面)：切面是AOP的核心概念。切入点(Pointcut)+通知(Advice)。
   - Weaving(织入)：将通知应用到目标对象，进而生成代理对象的过程动作。Spring AOP在运行时通过动态代理实现织入。
2. 实现机制
   Spring AOP主要通过两种方式来实现AOP功能：
   - JDK动态代理：适用于基于接口的代理。Spring AOP使用JDK动态代理来创建实现了一个或多个接口的代理对象。 
   - CGLIB代理：适用于没有实现接口的类。Spring AOP使用CGLIB库生成目标类的子类来实现代理。
3. 工作流程
   - 定义切面和通知：使用`@Aspect`注解定义切面，并在切面类中使用`@Before`、`@After`等注解定义通知。 
   - 配置AOP：在Spring配置文件中启用AOP支持，或使用`@EnableAspectJAutoProxy`注解来启用AOP自动代理。 
   - 应用切面：Spring容器根据配置和切点表达式在运行时生成代理对象，并将通知织入到目标方法的执行中。

Spring AOP的核心在于通过动态代理和切点表达式，实现了对横切关注点的模块化管理，使得代码更易于维护和扩展。

```java
// 定义切面
@Aspect
public class LoggingAspect {
    // 定义切点表达式
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    // 定义前置通知
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Executing method: " + joinPoint.getSignature().getName());
    }
    // 定义后置通知
    @After("serviceMethods()")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("Method executed: " + joinPoint.getSignature().getName());
    }
}
// 启用AOP支持
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
}
```
在示例中，定义了一个`LoggingAspect`切面，其中包含前置通知和后置通知。然后，在Spring配置中启用了AOP支持，并将切面类注册为Bean。Spring容器将在运行时生成代理对象，并在目标方法执行前后执行通知。

### Spring AOP/AspectJ AOP区别
1. 实现方式
   - Spring AOP：基于代理机制(Proxy-based)，主要使用JDK动态代理和CGLIB动态代理。属于运行时增强 
   - AspectJ AOP：基于字节码操作(Bytecode Manipulation)，通过编译时、加载时和运行时织入(Weaving)实现。属于编译时增强
2. 功能
   - Spring AOP：只支持方法级别的AOP。 
   - AspectJ AOP：提供更强大的功能和更高的性能，适用于类级别和方法级别的AOP。
3. 性能
   - Spring AOP：由于基于代理机制，性能相对较低，适用于大多数应用场景，但在高性能要求的场景中可能不够高效。 
   - AspectJ AOP：由于直接操作字节码，性能较高，适用于对性能要求较高的应用场景。
4. 配置和使用
   - Spring AOP：配置相对简单，使用Spring的注解和配置文件即可实现。适用于已经使用Spring框架的应用，容易集成和使用。 
   - AspectJ AOP：配置较为复杂，需要AspectJ编译器或AspectJ加载时编织器。需要对AspectJ的语法和配置有一定了解，适用于需要更强大AOP功能的应用。
5. 使用场景 
   - Spring AOP：适用于大多数Spring应用，特别是那些只需要方法级别AOP的场景。 
   - AspectJ AOP：适用于需要更强大AOP功能、更高性能和更细粒度控制的场景。

如果项目已经在使用Spring框架并且AOP需求较为简单，Spring AOP是一个不错的选择；如果需要更强大和高性能的AOP功能，AspectJ AOP是更好的选择。

### AspectJ的五种通知类型
- Before(前置通知)：目标对象的方法调用之前触发
- After (后置通知)：目标对象的方法调用之后触发
- AfterReturning(返回通知)：目标对象的方法调用完成，在返回结果值之后触发
- AfterThrowing(异常通知)：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。
- Around (环绕通知)：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

### 多个切面的执行顺序如何控制
1. 通常使用`@Order` 注解直接定义切面顺序
```java
// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
```

2. 实现`Ordered` 接口重写 `getOrder` 方法。
```java
@Component
@Aspect
public class LoggingAspect implements Ordered {
    // ....
    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
```

### SpringMVC✅
MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。

### MVC核心组件
- **`DispatcherServlet`**：**核心的中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`Handler`**：**请求处理器**，处理实际请求的处理器。
- **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

### SpringMVC工作原理
![SpringMVC工作原理](./image/Framework/de6d2b213f112297298f3e223bf08f28.png)

**流程**
1. 客户端（浏览器）发送请求， `DispatcherServlet`拦截请求。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping` 。`HandlerMapping` 根据 URL 去匹配查找能处理的 `Handler`（也就是 `Controller` 控制器） ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
3. `DispatcherServlet` 调用 `HandlerAdapter`适配器执行 `Handler` 。
4. `Handler` 完成对用户请求的处理后，会返回一个 `ModelAndView` 对象给`DispatcherServlet`，`ModelAndView` 顾名思义，包含了数据模型以及相应的视图的信息。`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
5. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
6. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
7. 把 `View` 返回给请求者（浏览器）

### Spring框架中用到了哪些设计模式
1. **工厂模式 (Factory Pattern)**：
    - Spring 使用工厂模式来创建对象实例。`BeanFactory` 和 `ApplicationContext` 是 Spring 中的两种主要的工厂类，用于管理和创建 bean 对象。
      - `BeanFactory`：延迟注入(使用到某个 bean 的时候才会注入),相比于`ApplicationContext` 来说会占用更少的内存，程序启动速度更快。
      - `ApplicationContext`：容器启动的时候，不管用没用到，一次性创建所有 bean 。`BeanFactory` 仅提供了最基本的依赖注入支持，`ApplicationContext` 扩展了 `BeanFactory` ,除了有`BeanFactory`的功能还有额外更多功能，所以一般开发人员使用`ApplicationContext`会更多。
2. **单例模式 (Singleton Pattern)**：
    - 默认情况下，Spring 容器中的 bean 是单例的，这意味着在整个 Spring 容器中只有一个 bean 实例存在。这通过 Spring 的 IoC 容器来管理。
3. **代理模式 (Proxy Pattern)**：
    - Spring AOP (Aspect-Oriented Programming) 使用代理模式来实现横切关注点（如事务管理、日志记录等）的分离。Spring 提供了 JDK 动态代理和 CGLIB 代理两种方式。
4. **模板模式 (Template Method Pattern)**：
    - Spring 中的模板类（如 `JdbcTemplate`, `RestTemplate`）通过封装一系列的操作步骤，简化了数据库操作和 REST 调用等重复性的编程任务。
5. **依赖注入模式 (Dependency Injection Pattern)**：
    - 依赖注入是 Spring 的核心设计模式，通过构造器注入、setter 注入和接口注入等方式，实现了对象之间的松耦合。
6. **观察者模式 (Observer Pattern)**：
    - Spring 事件机制使用了观察者模式。可以通过 `ApplicationEvent` 和 `ApplicationListener` 在应用程序中发布和监听事件。
7. **适配器模式 (Adapter Pattern)**：
   - Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是`AdvisorAdapter`。
   - Spring MVC 中的 `HandlerAdapter` 用于适配不同类型的处理器方法，使得这些方法可以作为统一的处理器进行调用。
8. **策略模式 (Strategy Pattern)**：
    - Spring 中的某些功能（如事务管理）使用了策略模式，允许在运行时选择具体的实现策略。
9. **装饰者模式 (Decorator Pattern)**：
    - Spring 的 `BeanPostProcessor` 和 `BeanFactoryPostProcessor` 用于在 bean 初始化前后进行一些自定义的处理，这实际上是对原有 bean 的功能进行扩展和增强。

这些设计模式的使用，使得 Spring 框架具备高度的灵活性、可扩展性和可维护性。

### BeanFactory/ApplicationContext区别
- 功能：
  - `BeanFactory`是Spring的核心接口，提供了基本的IOC（Inversion of Control）容器功能，负责实例化、配置和管理bean。
  - `ApplicationContext`是`BeanFactory`的子接口，扩展了更多的企业级功能，如事件机制、国际化支持、AOP（面向切面编程）集成、Web应用上下文等。
- 初始化：
  - `BeanFactory`采用懒加载机制，只有在第一次访问某个bean时，才会实例化该bean。这对启动性能有好处，但可能会导致首次访问时的延迟。
  - `ApplicationContext`预初始化：其在启动时会预先实例化所有单例bean，确保在应用启动时所有必要的bean已经准备好。这有助于捕获配置问题并提升应用的响应速度。
- 使用场景：
  - `BeanFactory`适用于资源受限的环境，如移动设备或嵌入式系统，适用于对性能要求高且对Spring的高级功能需求较少的应用。
  - `ApplicationContext`适用于标准的企业级应用中，特别是Web应用，适用于需要Spring框架提供的所有功能和高级特性的应用。
- 依赖查找：
  - `BeanFactory`依赖于显式的查找，开发者需要通过`getBean`方法手动获取bean。
  - `ApplicationContext`除了显式查找外，还支持自动注入和其他更加灵活的依赖管理方式。

- 如果应用需要完整的Spring功能，包括事件发布、国际化、AOP支持以及其他企业级特性，使用`ApplicationContext`。
- 如果应用在一个资源受限的环境中运行并且只需要基本的IOC容器功能，`BeanFactory`可能更合适。

通常在实际的Spring应用开发中，大多数开发者会选择使用`ApplicationContext`，因为它提供了更丰富的功能和更好的开发体验。

### Spring循环依赖





## SpringBoot

## SpringClod



## 其他
