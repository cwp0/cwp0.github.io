---
title: 框架
tags:
  - 框架
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: 框架方面的面经
abbrlink: 17771
date: 2024-06-12 22:49:36
updated: 2024-06-28 00:15:41
top_img: https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png
comments:
cover: https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

> 本文参考 [JavaGuide](https://javaguide.cn/)

## Spring
### 什么是Spring
Spring 是一款基于 Java 的轻量级开源开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

Spring 框架(Spring Framework)是很多模块的集合，使用这些模块可以很方便地协助进行开发。Spring 支持控制反转(Inversion of Control, IOC) 和 面向切面编程(Aspect-Oriented Programming, AOP)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件(电子邮件，任务，调度，缓存等等)、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。

Spring的核心功能主要是 `IoC` 和 `AOP`，核心思想是不重新造轮子，开箱即用，提高开发效率。

### Spring模块
![Spring 4.x](./image/Framework/Spring-4-x.png)

Spring5.x 版本中 Web 模块的 `Portlet` 组件已经被废弃掉，同时增加了用于异步响应式处理的 `WebFlux` 组件。

- `Core Container`：Spring 框架的核心模块、基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块。
  - `spring-core`：Spring 框架基本的核心工具类。
  - `spring-beans`：提供对 `bean` 的创建、配置和管理等功能的支持。
  - `spring-context`：提供对国际化、事件传播、资源加载等功能的支持。
  - `spring-expression`：提供对表达式语言(Spring Expression Language, SpEL)的支持，只依赖于 `core` 模块，不依赖于其他模块，可以单独使用。
- `AOP`：面向切面编程，提供对切面编程的支持。
  - `spring-aop`：提供了面向切面的编程实现。
  - `spring-aspects`：该模块为与 `AspectJ` 的集成提供支持。
  - `spring-instrument`：提供了为 JVM 添加代理(agent)的功能。其为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。
- `Data Access/Integration`：数据访问/集成层，提供对数据库访问、事务管理、ORM、OXM、JMS 等功能的支持。
  - `spring-jdbc`：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。
  - `spring-tx`：提供事务管理的支持。
  - `spring-orm`：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。
  - `spring-oxm`：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。
  - `spring-jms`：消息服务。自 Spring Framework 4.1 以后，它还提供了对 `spring-messaging` 模块的继承。
- `Spring Web`：Web 模块，提供对 Web 应用开发的支持。
  - `spring-web`：提供了基本的 Web 功能，如多文件上传、使用 `Servlet` 监听器初始化 Spring IoC 容器等。
  - `spring-webmvc`：提供了 Spring MVC 的实现。
  - `spring-websocket`：提供了对 WebSocket 的支持，可以让客户端和服务端进行双向通信。
  - `spring-webflux`：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。
- `Messaging`：`spring-messaging` 是Spring4.0新加入的模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。
- `Spring Test`：Spring有控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。Spring 的测试模块对 JUnit(单元测试框架)、TestNG(类似 JUnit)、Mockito(主要用来 Mock 对象)、PowerMock(解决 Mockito 的问题比如无法模拟 `final`，`static`，`private` 方法)等等常用的测试框架支持的都比较好。

![Spring各模块依赖关系](./image/Framework/Spring各模块依赖关系.png)

### Spring/Spring Boot/Spring MVC之间的关系
- Spring是基于 Java 的轻量级开源框架，包含众多模块，其中最重要的是`Spring-Core`(主要提供 `IoC` 依赖注入功能的支持)模块， Spring中的其他模块(如 `Spring MVC`)的功能实现基本都需要依赖于该模块。
- `Spring MVC` 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。
- 使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。过于麻烦，所以 `Spring Boot` 诞生了，其只是简化了配置，如果需要构建 MVC 架构的 Web 程序，还是需要使用 `Spring MVC` 作为 MVC 框架，只是说 `Spring Boot` 简化了 `Spring MVC` 的很多配置，真正做到开箱即用！
  - Spring 旨在简化 J2EE 企业应用程序开发。`Spring Boot` 旨在简化 Spring 开发(减少配置文件，开箱即用！)。

### Spring IoC✅
### 对Spring IoC的理解
控制反转(Inversion of Control, IoC)是一种设计思想，而不是一个具体的技术实现，并非Spring特有。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。

### Spring IoC原理
控制反转指将对象的创建和依赖关系的管理从应用程序代码中抽离出来，交给Spring容器进行管理。

**控制反转**
- 控制：指的是对象创建(实例化、管理)的权力
- 反转：控制权交给外部环境(Spring 框架、`IoC` 容器)

实现控制反转有多种方式：
- 依赖注入：通过注入方式实现依赖管理，易于测试和维护，广泛应用于现代开发框架(如Spring)。
- 服务定位器模式：通过中央注册器获取服务，使用方便，但可能引入全局状态和隐藏依赖。
- 事件驱动架构：通过事件进行解耦，适用于异步处理和复杂业务流程。
- 依赖查找：通过标准API查找依赖，适用于某些特定场景，但查找过程可能较为复杂。

**Spring IoC容器**
Spring IoC容器是负责管理对象及其依赖关系的核心组件。IoC 容器实际上就是个 Map(key，value)，Map 中存放的是各种对象。主要的IoC容器有：
- `BeanFactory`：最基础的IoC容器，提供基本的依赖注入功能。
- `ApplicationContext`：继承自`BeanFactory`，提供更多高级功能，如事件发布、国际化、AOP等。

### 什么是Spring Bean
在Spring中，bean是由IoC容器管理的对象。bean的定义和配置可以通过以下几种方式：
- XML配置文件：在XML文件中定义`bean`及其依赖关系。
- 注解配置：通过Java注解(如`@Component`、`@Autowired`等)定义和注入`bean`。
- Java配置类：使用`@Configuration`和`@Bean`注解，通过Java类定义`bean`。

### 将一个类声明为Bean的注解有哪些
- `@Component`：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository`： 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service`： 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller`： 对应 `Spring MVC` 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。

### @Component/@Bean区别

**主要区别**
1. 定义方式：
  - `@Component` 是在类上使用，Spring 自动扫描并注册 Bean。
  - `@Bean` 是在方法上使用，返回值被注册为 Bean。
2. 适用场景：
  - `@Component` 适用于开发人员自己编写的类。
  - `@Bean` 适用于第三方库的类或需要复杂配置的 Bean。
3. 扫描和配置：
  - `@Component` 需要启用组件扫描。
  - `@Bean` 通常与配置类一起使用，不需要组件扫描。

总结来说，`@Component` 更适合于直接在类上进行标注，简化了配置过程；而 `@Bean` 则提供了更多的灵活性，可以在配置类中以编程的方式定义 Bean。

**@Component**
- 用途：`@Component` 用于标记一个类为 Spring 容器的组件(Bean)。
- 使用方式：直接在类上使用。Spring 会自动扫描带有 `@Component` 注解的类，并将其注册为 Spring 容器中的 Bean。
- 扫描：需要在配置类上使用 `@ComponentScan` 注解来启用自动扫描。
- 适用范围：通常用于标记服务层、数据访问层、控制层等组件类。
- 例子：
  ```java
  @Component
  public class MyService {
      // 服务实现
  }
  ```
**@Bean**
- 用途：`@Bean` 用于在配置类中定义一个方法，该方法的返回值会被注册为 Spring 容器中的 Bean。
- 使用方式：在配置类的方法上使用，方法的返回值会作为 Bean 注册到 Spring 容器中。
- 配置类：通常与 `@Configuration` 注解一起使用，表明这是一个配置类。
- 适用范围：通常用于定义第三方库的 Bean，或者需要复杂初始化的 Bean。
- 例子：
  ```java
  @Configuration
  public class AppConfig {
      @Bean
      public MyService myService() {
          return new MyServiceImpl();
      }
  }
  ```

### 用于注入Bean的注解有哪些？

#### @Autowired
- **用途**：`@Autowired` 用于自动注入 Bean，Spring 会自动满足标记了该注解的依赖。
- **使用位置**：可以用在字段、构造方法、Setter 方法以及普通方法上。
- **特点**：默认按类型注入，可以结合 `@Qualifier` 按名称注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Autowired
      private MyRepository myRepository;

      // 或者使用构造方法注入
      @Autowired
      public MyService(MyRepository myRepository) {
          this.myRepository = myRepository;
      }
  }
  ```
#### @Resource
- **用途**：`@Resource` 是 JSR-250 标准的注解，可以按名称或类型注入。
- **使用位置**：字段、Setter 方法。
- **特点**：默认按名称注入，如果找不到匹配的 Bean，则按类型注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Resource(name = "myRepository")
      private MyRepository myRepository;
  }
  ```

#### @Qualifier
- **用途**：与 `@Autowired` 一起使用，按名称注入 Bean。
- **使用位置**：字段、构造方法参数、Setter 方法参数。
- **特点**：解决同类型 Bean 多个实例的冲突问题。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Autowired
      @Qualifier("specificRepository")
      private MyRepository myRepository;
  }
  ```

#### @Inject
- **用途**：`@Inject` 是 JSR-330 标准的注解，功能与 `@Autowired` 类似。
- **使用位置**：字段、构造方法、Setter 方法。
- **特点**：仅支持按类型注入，可以结合 `@Named` 注解按名称注入。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Inject
      private MyRepository myRepository;

      // 或者使用构造方法注入
      @Inject
      public MyService(MyRepository myRepository) {
          this.myRepository = myRepository;
      }
  }
  ```

#### @Value
- **用途**：`@Value` 用于注入简单值，比如基本类型、字符串、Spring EL 表达式等。
- **使用位置**：字段、构造方法参数、Setter 方法参数。
- **特点**：可以注入配置文件中的属性值。
- **例子**：
  ```java
  @Service
  public class MyService {
      
      @Value("${app.name}")
      private String appName;
  }
  ```

`@Autowired` 和`@Resource`用的多一些。

### @Autowired/@Resource区别
- 默认注入方式：
  - `@Autowired` 默认根据接口类型(`byType`)去匹配并注入Bean(接口的实现类)。当一个接口存在多个实现类的话，`Autowired` 可以通过 `@Qualifier` 注解来显式指定类名称。
  - `@Resource` 当一个接口存在多个实现类的话，默认按类名称(`byName`)注入。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为`byType`。
- 注解来源：
  - `@Autowired`：Spring 框架提供的注解。
  - `@Resource`：JSR-250(JDK) 标准提供的注解。
- 使用位置：
  - `@Autowired` 可以用在构造函数、方法、字段以及参数上。
  - `@Resource` 通常用在字段和 Setter 方法上的注入。
- 配置属性：
  - `@Autowired`：可以结合 `@Qualifier` 按名称注入。
  - `@Resource`：可以通过 `name` 属性指定 `Bean` 名称，通过 `type` 属性指定 Bean 类型。
- 处理机制：
  - `@Autowired`：使用 Spring 的依赖注入机制。
  - `@Resource`：使用 JNDI 进行资源查找，适合在 Java EE 容器环境中使用。
  
总的来说，`@Autowired` 更加灵活和强大，适合在 Spring 应用中广泛使用；而 `@Resource` 则提供了一种更标准化的方式进行依赖注入，特别是在需要与 Java EE 容器进行集成时。

> `@Resource` 有两个比较重要且日常开发常用的属性：`name`(名称)、`type`(类型)。
> ```java
> public @interface Resource {
>     String name() default "";
>     Class<?> type() default Object.class;
> }
> ```
> 如果仅指定 `name` 属性则注入方式为`byName`，如果仅指定`type`属性则注入方式为`byType`，如果同时指定`name`和`type`属性(不建议这么做)则注入方式为`byType`+`byName`。

### Bean的作用域有哪些？
在 Spring 框架中，Bean 的作用域(scope)定义了 Bean 的生命周期和可见性。Spring 提供了以下几种常见的 Bean 作用域：

- `Singleton`
  - **描述**：默认作用域。在整个 Spring 容器中只有一个 Bean 实例，每次请求该 Bean 时都会返回同一个实例。
  - **使用场景**：大多数情况下使用，适用于无状态的 Bean。
- `Prototype`
  - **描述**：每次请求该 Bean 时，都会创建一个新的实例。
  - **使用场景**：适用于有状态的 Bean 或需要每次使用时创建新实例的 Bean。
- `Request`
  - **描述**：在一个 HTTP 请求中，每次请求该 Bean 时，都会创建一个新的实例。该作用域仅在 Web 应用程序中有效。
  - **使用场景**：适用于每个 HTTP 请求需要一个独立 Bean 实例的情况，例如处理用户请求的控制器。
- `Session`
  - **描述**：在一个 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域仅在 Web 应用程序中有效。
  - **使用场景**：适用于需要在整个用户会话期间保持状态的 Bean。
- `Global Session`
  - **描述**：在一个全局 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域主要用于 Portlet 应用程序。
  - **使用场景**：适用于需要在全局 Portlet 会话期间保持状态的 Bean。
- `Application`
  - **描述**：在整个应用程序生命周期内，每次请求该 Bean 时，都会返回同一个实例。通常在 Web 应用程序中使用。
  - **使用场景**：适用于需要在整个应用程序生命周期内共享的 Bean。

```java
// Scope中可以指定Bean的作用域，取值：singleton、prototype、request、session、globalSession、application
@Component
@Scope("singleton")
public class MySingletonBean {
    // 实现代码
}
 ```

### Bean是线程安全的吗
在 Spring 框架中，Bean 的线程安全性取决于其作用域和状态。以下是一些常见情况：

### Singleton Bean
- **默认作用域**：`@Scope("singleton")`
- **描述**：单例 Bean 在 Spring 容器中只有一个实例，并且该实例会被多个线程共享。
- **线程安全性**：单例 Bean 本身并不是线程安全的。如果单例 Bean 中包含可变的共享状态，则需要确保其线程安全。这可以通过以下方式实现：
  - 不在单例 Bean 中使用可变状态。
  - 使用线程安全的数据结构(如 `ConcurrentHashMap`)。
  - 在访问可变状态时使用同步(如 `synchronized`)。
  - 采用无状态的设计模式。

### Prototype Bean
- **作用域**：`@Scope("prototype")`
- **描述**：原型 Bean 每次请求时都会创建一个新的实例，因此每个线程都会获得一个新的实例。
- **线程安全性**：由于每个线程都有自己的实例，原型 Bean 通常是线程安全的。但是，原型 Bean 的生命周期由使用它的对象管理，可能需要注意其创建和销毁的时机。

### Request 和 Session Scoped Beans
- **作用域**：`@Scope("request")` 和 `@Scope("session")`
- **描述**：请求作用域的 Bean 在一个 HTTP 请求中创建和销毁。会话作用域的 Bean 在一个 HTTP 会话中创建和销毁。
- **线程安全性**：请求作用域的 Bean 通常是线程安全的，因为每个请求都是独立的。会话作用域的 Bean 可能会被多个线程共享，需要考虑线程安全性。

### Application Scoped Beans
- **作用域**：`@Scope("application")`
- **描述**：应用程序作用域的 Bean 在整个应用程序生命周期内共享。
- **线程安全性**：与单例 Bean 类似，应用程序作用域的 Bean 需要注意线程安全性问题。

### Global Session Scoped Beans
- **作用域**：`@Scope("globalSession")`
- **描述**：全局会话作用域的 Bean 在 Portlet 应用程序的全局会话中共享。
- **线程安全性**：类似于会话作用域的 Bean，需要考虑线程安全性。

总之，除非 Bean 的设计明确考虑了线程安全性，否则默认情况下 Spring 容器不会保证 Bean 的线程安全。确保线程安全的最佳实践包括无状态设计、使用线程安全的数据结构以及适当的同步机制。

### Bean的生命周期
1. 创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。
2. Bean 属性填充(依赖注入)：为 Bean 设置相关属性和依赖，如`@Autowired` 等注解注入的对象、`@Value` 注入的值、`setter`方法或构造函数注入依赖和值、`@Resource`注入的各种资源。
3. Bean的初始化
   1. 调用`Aware`接口的方法：
      - 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入 Bean 的名字。
      - 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。
      - 如果 Bean 实现了 `BeanFactoryAware` 接口，调用 `setBeanFactory()`方法，传入 `BeanFactory`对象的实例。
      - 如果实现了其他 *.Aware接口，就调用相应的方法。
   2. 前置处理：如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessBeforeInitialization()` 方法
   3. 初始化方法：如果 Bean 实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。如果 Bean 在配置文件中的定义包含 `init-method` 属性，执行指定的方法。
   4. 后置处理：如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessAfterInitialization()` 方法。
4. 使用 Bean：Bean 可以被容器使用了，可以调用 Bean 的方法处理业务逻辑。
5. 销毁 Bean：销毁并不是立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。
   - 如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。
   - 如果 Bean 在配置文件中的定义包含 `destroy-method` 属性，执行指定的 Bean 销毁方法。
   - 也可以直接通过`@PreDestroy` 注解标记 Bean 销毁之前执行的方法。

![Bean的生命周期](./image/Framework/spring-bean-lifestyle.png)

> Spring 中提供的 Aware 接口主要有：
> `BeanNameAware`：注入当前 `bean` 对应 `beanName`；
> `BeanClassLoaderAware`：注入加载当前 `bean` 的 `ClassLoader`；
> `BeanFactoryAware`：注入当前 `BeanFactory` 容器的引用。

### Spring AOP✅

### 对Spring AOP的理解
面向切面编程(Aspect-Oriented Programming, AOP)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：

![Spring AOP代理方式](./image/Framework/230ae587a322d6e4d09510161987d346.jpeg)

Spring AOP也集成了 AspectJ，可以使用 AspectJ 的注解来实现 AOP。

### Spring AOP原理
Spring AOP(面向切面编程)是Spring框架中的一个重要模块，用于在不修改现有代码的情况下向程序中添加新的行为。基本原理和关键概念如下：

1. 核心概念
   - Target(目标)：被通知的对象
   - Proxy(代理)：向目标对象应用通知之后创建的代理对象
   - Join Point(连接点)：目标对象的所属类中，定义的所有方法均为连接点
   - Pointcut(切点)：切点是用于匹配连接点的表达式。被切面拦截 / 增强的连接点(切入点一定是连接点，连接点不一定是切入点)
   - Advice(通知)：增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情。Spring AOP支持五种类型的通知：前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。
   - Aspect(切面)：切面是AOP的核心概念。切入点(Pointcut)+通知(Advice)。
   - Weaving(织入)：将通知应用到目标对象，进而生成代理对象的过程动作。Spring AOP在运行时通过动态代理实现织入。
2. 实现机制
   Spring AOP主要通过两种方式来实现AOP功能：
   - JDK动态代理：适用于基于接口的代理。Spring AOP使用JDK动态代理来创建实现了一个或多个接口的代理对象。 
   - CGLIB代理：适用于没有实现接口的类。Spring AOP使用CGLIB库生成目标类的子类来实现代理。
3. 工作流程
   - 定义切面和通知：使用`@Aspect`注解定义切面，并在切面类中使用`@Before`、`@After`等注解定义通知。 
   - 配置AOP：在Spring配置文件中启用AOP支持，或使用`@EnableAspectJAutoProxy`注解来启用AOP自动代理。 
   - 应用切面：Spring容器根据配置和切点表达式在运行时生成代理对象，并将通知织入到目标方法的执行中。

Spring AOP的核心在于通过动态代理和切点表达式，实现了对横切关注点的模块化管理，使得代码更易于维护和扩展。

```java
// 定义切面
@Aspect
public class LoggingAspect {
    // 定义切点表达式
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    // 定义前置通知
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Executing method: " + joinPoint.getSignature().getName());
    }
    // 定义后置通知
    @After("serviceMethods()")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("Method executed: " + joinPoint.getSignature().getName());
    }
}
// 启用AOP支持
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
}
```
在示例中，定义了一个`LoggingAspect`切面，其中包含前置通知和后置通知。然后，在Spring配置中启用了AOP支持，并将切面类注册为Bean。Spring容器将在运行时生成代理对象，并在目标方法执行前后执行通知。

### Spring AOP/AspectJ AOP区别
1. 实现方式
   - Spring AOP：基于代理机制(Proxy-based)，主要使用JDK动态代理和CGLIB动态代理。属于运行时增强 
   - AspectJ AOP：基于字节码操作(Bytecode Manipulation)，通过编译时、加载时和运行时织入(Weaving)实现。属于编译时增强
2. 功能
   - Spring AOP：只支持方法级别的AOP。 
   - AspectJ AOP：提供更强大的功能和更高的性能，适用于类级别和方法级别的AOP。
3. 性能
   - Spring AOP：由于基于代理机制，性能相对较低，适用于大多数应用场景，但在高性能要求的场景中可能不够高效。 
   - AspectJ AOP：由于直接操作字节码，性能较高，适用于对性能要求较高的应用场景。
4. 配置和使用
   - Spring AOP：配置相对简单，使用Spring的注解和配置文件即可实现。适用于已经使用Spring框架的应用，容易集成和使用。 
   - AspectJ AOP：配置较为复杂，需要AspectJ编译器或AspectJ加载时编织器。需要对AspectJ的语法和配置有一定了解，适用于需要更强大AOP功能的应用。
5. 使用场景 
   - Spring AOP：适用于大多数Spring应用，特别是那些只需要方法级别AOP的场景。 
   - AspectJ AOP：适用于需要更强大AOP功能、更高性能和更细粒度控制的场景。

如果项目已经在使用Spring框架并且AOP需求较为简单，Spring AOP是一个不错的选择；如果需要更强大和高性能的AOP功能，AspectJ AOP是更好的选择。

### AspectJ的五种通知类型
- Before(前置通知)：目标对象的方法调用之前触发
- After (后置通知)：目标对象的方法调用之后触发
- AfterReturning(返回通知)：目标对象的方法调用完成，在返回结果值之后触发
- AfterThrowing(异常通知)：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。
- Around (环绕通知)：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

### 多个切面的执行顺序如何控制
1. 通常使用`@Order` 注解直接定义切面顺序
```java
// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
```

2. 实现`Ordered` 接口重写 `getOrder` 方法。
```java
@Component
@Aspect
public class LoggingAspect implements Ordered {
    // ....
    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
```

### SpringMVC✅









## SpringBoot

## SpringClod



## 其他
