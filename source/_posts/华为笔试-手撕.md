---
title: 华为笔试/手撕
tags:
  - 手撕
categories:
  - 手撕
keywords:
  - 手撕
description: 华为的手撕相关面试准备
abbrlink: 17781
date: 2024-11-15 11:51:23
updated: 2024-11-15 11:51:23
top_img: https://s2.loli.net/2025/03/19/AWbLRs73mHovfQt.png
comments:
cover: https://s2.loli.net/2025/03/19/kAcZ5yKPDwizuMN.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

### 对华为文化的了解

华为的企业文化可以用几个关键词来概括：奋斗、客户至上、团队合作和自我批判。以下是一些具体的特点：

1. **奋斗者文化**：华为一直强调“奋斗者为本”，这不仅仅是对员工的期望，也体现在公司对个人的奖励制度上。公司认为，只有通过努力和奋斗，才能在竞争中脱颖而出，创造更大的价值。因此，华为推崇拼搏精神，鼓励员工不断进步。
2. **客户至上**：华为在文化中一直强调“以客户为中心”。这意味着华为关注客户的需求和期望，致力于提供最优质的产品和服务。公司倡导通过创新和精益求精来满足客户的需求。
3. **自我批判和持续改进**：华为的领导层，尤其是创始人任正非，推崇自我批判的精神。公司鼓励员工、管理层定期反思并查找自己的不足，不断改进，不满足于现状。任正非曾多次提到，华为的成功不仅仅是外部环境使然，更重要的是公司能够在内部自我调整、避免固守错误的做法。
4. **全球化与本地化**：华为从创立伊始就立足于全球化发展，强调跨文化的交流与融合。公司在全球范围内设有研发中心，注重本地化的产品设计与服务。
5. **高度的责任感**：华为还推崇高度的社会责任感。任正非曾提到，华为不仅仅要在商业上成功，还要在社会和文化层面贡献自己的力量。华为也积极参与公益活动，特别是在教育和环保领域。
6. **自由与责任并重**：华为推崇自由的工作氛围，鼓励员工在公司内部开展创新和自由探索，同时也强调员工要对自己的工作结果负责。

这些文化元素帮助华为成为了全球领先的通信技术和设备供应商，也为其在激烈的市场竞争中积累了强大的竞争力。当然，华为的文化也因为其高强度的工作压力和某些管理方式而在外界有所争议。

### 华为企业文化

终端理念：万物互联，互联互通。

华为的企业文化是其发展壮大的核心动力之一，被总结为一种以奋斗者为本、客户为中心的管理哲学和实践导向。其企业文化主要体现在以下几个方面：

1. 以客户为中心：华为始终强调“以客户为中心”的理念，坚持为客户创造价值。企业所有的决策和行动都围绕客户需求展开，从而帮助客户取得成功，实现合作共赢。
2. 以奋斗者为本：华为重视员工的努力和贡献，倡导艰苦奋斗、主动作为的精神。公司鼓励员工通过努力工作提升自身价值，同时将奋斗精神与员工的利益挂钩，采用“多劳多得”的激励机制。
3. 开放与创新：作为一家技术驱动型企业，华为注重开放合作与技术创新。公司每年将大量收入投入研发，追求技术领先，并通过开放的心态与全球合作伙伴共同构建产业生态。
4. 坚持长期投入：华为强调“厚积薄发”和“长期主义”，愿意在技术研发和市场布局上进行长时间的投入，不急于求成。正是这种坚持，使其在通信和科技领域逐步建立了全球领先的地位。
5. 追求灰度管理：华为崇尚“灰度文化”，在决策中不追求绝对的对与错，而是注重在复杂的环境中寻求平衡与妥协。这种文化强调灵活性和包容性，使得公司能在不确定性中更好地应对挑战。
6. 集体奋斗与共同成长：华为提倡集体奋斗的价值观，强调公司和员工的命运共同体关系。通过利润分享、股权激励等方式，让员工与企业共担风险、共享收益。
7. 以责任为导向：华为秉承“责任文化”，注重对社会、客户、员工、合作伙伴和环境的责任。例如，在全球范围内推动绿色可持续发展，致力于降低碳排放。
8. 全球化视野：华为从成立之初就抱有国际化视野，强调多元文化和全球协作。在全球范围内吸引人才，尊重不同文化，推动全球业务布局。

**总结**
华为的企业文化是其成功的重要基石，这种文化帮助华为在快速变化的市场中保持竞争力，并在全球范围内持续扩展影响力。通过“客户为中心”“奋斗者为本”等核心价值观，华为不仅赢得了客户的信任，也凝聚了员工的向心力。

### 最大的挫折

### 长期职业规划
我的长期职业规划是成为一名技术领域的专家。我希望通过系统的学习和以及在工作中的项目实践，逐步掌握更深层次的专业技能，同时培养管理和协调同事能力。这不仅能帮助我个人成长，也能为团队和公司创造更多的价值。

### 对华为的了解
1. 对华为的整体认识：华为是一家全球领先的ICT（信息与通信技术）解决方案提供商，以创新驱动发展，致力于为客户提供高质量的技术和服务。华为的业务覆盖了通信网络、云计算、人工智能和消费电子等多个领域。尤其在5G、AI、云计算等前沿技术上，华为一直是行业的标杆企业。
2. 对华为核心理念的理解：华为一直秉承着“以客户为中心”的理念，通过技术创新和长期投入，不断为客户创造价值。同时，华为重视员工的成长与发展，这种以奋斗者为本的文化也让我非常认同。华为的“狼性文化”和全球化视野，体现了对市场的敏锐洞察和执行力。
3. 对华为具体业务的关注：我了解到，华为目前主要有三大核心业务：
   - **运营商业务**：在通信基础设施建设上，特别是在5G领域，华为是全球领先的企业。
   - **企业业务**：为企业提供全面的ICT解决方案，比如云服务、数据中心和物联网。
   - **消费者业务**：华为的智能手机、智能穿戴设备和智能家居产品都在全球市场上有很强的竞争力。

    此外，华为近年来还在人工智能、自动驾驶、数字能源等领域进行了大量投入，显示了未来发展的广阔前景。

4. 结合自己的兴趣或技能：结合我的背景，我对华为的某某业务（例如5G、云计算或消费者业务）尤其感兴趣。因为我认为这些领域不仅有巨大的发展潜力，而且能够推动社会进步和产业升级。
5. 对华为未来的期待：我相信，面对全球化和科技创新的挑战，华为在技术研发、市场拓展和企业社会责任方面将继续保持领先地位。我也希望能有机会在华为这样一个充满活力的团队中学习和成长，为公司的发展贡献自己的力量。


### 项目中遇到问题是如何解决的






### Q1
Java ACM模式解题
有一个定时器系统：
1. 该系统精度为1刻度、可容纳n个超时任务；
2. 每个人屋里包含该任务超时时刻t(当系统时钟到达t时，该任务开始执行)，t为正整数；
3. 同一时刻超时的任务按照加入系统的先后顺序依次执行超时任务;
4. 当定时器中任务不足n个时候，可以直接添加新任务；
5. 当定时器中任务数达到n个时候，假定待添加任务的超时时刻为ti，系统中最后执行的任务的超时时刻为tj，如果ti>tj，则丢弃待添加的任务，否则丢弃系统中最晚执行的超时任务，并将待添加任务加入系统中。

现在给定定时器容量n，短时间内(不到1刻度)依次向该系统添加m个定时任务tasks，假定当前时钟为0时刻，即添加的任务都是未超时任务，且都是一次性定时任务。

输出该定时器系统中最后超时的任务索引号，即：当前task在tasks中的下标(下标从0开始)，如果多个任务同时超时，则输出最大的索引号。

输入描述
第一行 容量n， 1<=n<=1000
第二行 任务个数m， 1<=m<=1000000
第三行 m个正整数，表示任务超时时刻，1<=ti<=100000

输出描述
输出最后超时的任务索引号

样例输入
2
12
1 2 3 4 6 19 20 21 22 23 24 1
样例输出
11
说明：
容量为2，最终定时器只会有两个任务，分别为1(索引为0), 1(索引为11)，这两个任务同时超时，返回更大的任务索引号为11

```java
import java.util.*;

public class Q1 {
    // 内部类，用于表示任务和其超时时刻的索引
    static class Task {
        int time;
        int index;

        Task(int time, int index) {
            this.time = time;
            this.index = index;
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 输入
        int n = sc.nextInt();  // 定时器容量
        int m = sc.nextInt();  // 任务数量
        int[] tasks = new int[m];  // 超时时刻

        for (int i = 0; i < m; i++) {
            tasks[i] = sc.nextInt();
        }

        // 定时器任务管理：队列保存超时时刻和任务的索引
        Deque<Task> timer = new LinkedList<>();

        // 记录队列中的任务
        for (int i = 0; i < m; i++) {
            int time = tasks[i];

            // 如果定时器未满，直接添加任务
            if (timer.size() < n) {
                timer.offer(new Task(time, i));
            } else {
                // 如果定时器已满，查看任务超时刻是否符合条件
                Task lastTask = timer.peekLast(); // 获取队列中最晚的超时任务
                if (time <= lastTask.time) {
                    timer.pollLast(); // 移除最晚超时任务
                    timer.offer(new Task(time, i)); // 添加新任务
                }
            }
        }

        // 输出队列中最后一个超时任务的索引
//        int lastTaskIndex = -1;
//        while (!timer.isEmpty()) {
//            lastTaskIndex = timer.poll().index;
//        }

        System.out.println(timer.peekLast().index);
    }
}
```

### Q2
Java ACM模式解题
数据中心摆放M排N列机柜，现需要在每排选择一个机柜安装监控器来监视本排机柜的用电量，由于监控器安装位置太近的话会相互干扰，安装时候需要满足条件：
安装监控器的机柜不能在同一排或者同一列，并且不能在同一斜线上(45°或者135°的正斜线)。请问一共有多少种安装监控器的方案？

输入描述
机柜的行数M和列数N(1<=M,N<15)

输出描述
输出一行一个整数表示方案数，如果没有方案则输出0

样例输入
2 3
样例输出
2
说明
有两种安装方案
1 0 0
0 0 1

0 0 1
1 0 0

其中，1表示安装监控器的机柜，0表示未安装监控器的机柜
```java
public class Q2 {
    static int M, N;
    static int count = 0;

    // 使用数组记录哪些列、主对角线、副对角线已经被占用
    static boolean[] Cols;
    static boolean[] Line1; // 左上到右下
    static boolean[] Line2; // 右上到左下

    public static void main(String[] args) {
        // 读取输入
        java.util.Scanner sc = new java.util.Scanner(System.in);
        M = sc.nextInt();
        N = sc.nextInt();

        // 初始化数组
        Cols = new boolean[N]; // 标记每一列是否已使用
        Line1 = new boolean[M + N - 1]; // 标记每条主对角线是否已使用
        Line2 = new boolean[M + N - 1]; // 标记每条副对角线是否已使用

        // 开始回溯
        backtrack(0);

        // 输出结果
        System.out.println(count);
    }

    // 回溯函数，尝试在第 row 行安装监控器
    static void backtrack(int row) {
        if (row == M) {
            // 已经处理了所有的行，说明找到了一种合法的方案
            count++;
            return;
        }

        // 遍历当前行的所有列
        for (int col = 0; col < N; col++) {
            // 检查当前列和对角线是否已被占用
            if (Cols[col] || Line1[row - col + N - 1] || Line2[row + col]) {
                continue; // 如果当前选择不合法，跳过
            }

            // 标记当前列和对角线为已使用
            Cols[col] = true;
            Line1[row - col + N - 1] = true;
            Line2[row + col] = true;

            // 递归尝试放置下一个行的监控器
            backtrack(row + 1);

            // 回溯，撤销选择
            Cols[col] = false;
            Line1[row - col + N - 1] = false;
            Line2[row + col] = false;
        }
    }
}
```

### Q3
Java ACM模式解题
小明在一个足球场上踢球，他需要绕过障碍物把球踢到球门里。

足球场用M*M的正方形网格表示，其中每个元素可以是下面的值之一：
X:表示小明，只要他在空地里面，就可以上下左右四个方向移动。
0:表示空地，小明可以自由移动。
1:表示障碍物，意味着不能通行，可能有多个。
B:表示球，小明需要把球踢到球门，只能有一个。
G:表示球门，小明需要把球踢到这里，只能有一个。

初始时候小明和球可能不相邻，他需要走到球的位置才能开始踢球；当移动到球边(相邻格子)后，继续向着球的方向移动，球会被踢到同方向相邻格的位置，即：球移动方向与小明移动方向相同，一次移动一格。
注：如果球移动前方会碰到障碍物或者边界，那么此次踢球无效，小明和球的位置均不变。

小明需要持续移动，直到球被踢进球门，返回小明踢球的最小次数，如果无法踢进，返回-1。
注：足球的每一次移动算作一次踢球，小明自己移动不算踢球。

输入描述：
第一行一个整数M，表示网格的大小。5<=M<=20
接下来M行，每行M个字符，表示网格的元素。仅包含X,0,1,B,G这五种字符，且保证有且仅有一个X，一个B，一个G。

输出描述：
输出一个整数，表示小明踢球的最小次数，如果无法踢进，返回-1。

样例输入
5
0 0 0 0 0
0 0 0 0 G
0 0 B 0 0
X 1 0 0 0
0 0 0 0 0
样例输出
3
```java
import java.util.*;

public class Q3 {
    // 定义四个方向的移动（上下左右）
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int M = scanner.nextInt();
        scanner.nextLine();  // 读取换行符

        char[][] grid = new char[M][M];
        int XX = -1, XY = -1, BX = -1, BY = -1, GX = -1, GY = -1;

        for (int i = 0; i < M; i++) {
            String[] line = scanner.nextLine().split(" ");
            for (int j = 0; j < M; j++) {
                grid[i][j] = line[j].charAt(0);
                if (grid[i][j] == 'X') {
                    XX = i;
                    XY = j;
                } else if (grid[i][j] == 'B') {
                    BX = i;
                    BY = j;
                } else if (grid[i][j] == 'G') {
                    GX = i;
                    GY = j;
                }
            }
        }

        // 使用BFS搜索
        int result = bfs(grid, M, XX, XY, BX, BY, GX, GY);
        System.out.println(result);
    }

    static int bfs(char[][] grid, int M, int XX, int XY, int BX, int BY, int GX, int GY) {
        // 队列保存的是 (小明x, 小明y, 球x, 球y, 踢球次数)
        Queue<int[]> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();

        // 初始状态加入队列
        queue.offer(new int[] {XX, XY, BX, BY, 0});
        visited.add(XX + "," + XY + "," + BX + "," + BY);

        while (!queue.isEmpty()) {
            int[] state = queue.poll();
            int xx = state[0], xy = state[1], bx = state[2], by = state[3], kicks = state[4];

            // 如果球已经到达球门
            if (bx == GX && by == GY) {
                return kicks;
            }

            // 小明可以向四个方向移动
            for (int i = 0; i < 4; i++) {
                int newX = xx + dx[i], newY = xy + dy[i];

                // 判断小明的移动是否有效
                if (newX >= 0 && newX < M && newY >= 0 && newY < M && grid[newX][newY] != '1') {
                    // 判断是否与球相邻
                    if (Math.abs(newX - bx) + Math.abs(newY - by) == 1) {
                        // 小明与球相邻，开始踢球
                        int newBX = bx + dx[i], newBY = by + dy[i];

                        // 判断球是否能被踢动
                        if (newBX >= 0 && newBX < M && newBY >= 0 && newBY < M && grid[newBX][newBY] != '1') {
                            // 球能被踢动
                            if (!visited.contains(newX + "," + newY + "," + newBX + "," + newBY)) {
                                visited.add(newX + "," + newY + "," + newBX + "," + newBY);
                                queue.offer(new int[] {newX, newY, newBX, newBY, kicks + 1});
                            }
                        }
                    } else {
                        // 小明移动，不是踢球
                        if (!visited.contains(newX + "," + newY + "," + bx + "," + by)) {
                            visited.add(newX + "," + newY + "," + bx + "," + by);
                            queue.offer(new int[] {newX, newY, bx, by, kicks});
                        }
                    }
                }
            }
        }

        // 如果无法到达球门
        return -1;
    }
}
```






