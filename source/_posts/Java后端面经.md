---
title: Java后端面经
tags:
  - Java
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: Java后端面经
abbrlink: 17766
date: 2024-05-27 19:58:53
updated: 2024-05-27 20:58:53
top_img: https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png
comments:
cover: https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础、网络、操作系统、数据库等内容的精简答案，最后再回顾一下每次面试的面经。
> 本文参考 JavaGuide 

## 简历相关

### 自我介绍

面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。

我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。

然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xx 给我这次面试机会，我也十分希望能进入 xx ，与公司共同成长进步！

### 专业技能




### Casbin明日之星实习

1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。

2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录（SSO）和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。

3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。

### 中科院开源之夏项目

**简介**
Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。

**项目诉求**
1. 对微信第三方登录的移动端支持
    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。

2. 对flutter、react-native、unity等sdk的开发及功能的增强
    - 对flutter-sdk的增强如第一点

3. 临时加上的开发casdoor-app诉求，对标Google Authenticator

**技术细节**
1. 在flutter-sdk中通过截取session中的url和callbackURLscheme判断其中是否有"weixin"字段，如果有，则进行微信第三方原生授权登录；

    - 使用WKWebView替换原本的ASWebAuthenticationSession，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；
    - 使用rb脚本文件自动化配置微信SDK导入后xcode中xcodeproj文件的相关配置；

    - 接入xcframework的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；

接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置universal Link，需付费几百美元，所以最终代码并未实际测试。

2. 分为两部分
    1. casdoor-unity-example
        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；
        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；
        - 在casdoor服务端配置好应用的ClientCode和ClientSecret后，在Unity3D中向服务端发送认证请求(CilentCode等)，解析返回的token，就可以得到用户信息，也可以使用session保存token等信息。
        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。
    2. casdoor-react-native-sdk、example
        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；
        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。
        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 code_challenge 和 code_verifier 。
3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。
    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。
    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。

> SHA（Secure Hash Algorithm，安全哈希算法）是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。

**总结**
参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。

### Casbin Casdoor 介绍
> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略（Policy-Based）的访问控制模型，支持各种访问控制模型（如 ACL、RBAC、ABAC 等），并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 
> Casbin 的主要特点包括：
> 1. **多种访问控制模型支持**：包括基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）、访问控制列表（ACL）等，满足不同场景的权限管理需求。
> 2. **灵活的策略管理**：通过策略文件进行权限管理，支持多种格式（如 CSV、JSON、数据库等），方便管理和配置访问策略。
> 3. **细粒度的权限控制**：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。
> 4. **跨语言支持**：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。

> Casdoor 是基于 Casbin 的单点登录（SSO）和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。
> 1. **单点登录（SSO）**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。
> 2. **用户管理**：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。
> 3. **权限控制**：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。
> 4. **开源社区**：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。

### RESTful API
> RESTful API（Representational State Transfer API）是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。
> REST架构原则：
> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。
> - 统一接口： 资源：通过URL定位资源（通常是名词，如 /users 表示用户资源）。 操作：使用标准HTTP方法对资源进行操作： GET：获取资源 POST：创建资源 PUT：更新资源 DELETE：删除资源
> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。
> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器（如代理、负载均衡器等）来提升系统的可扩展性和安全性。
> - 按需代码：在某些情况下，服务器可以返回可执行代码（如JavaScript），使客户端能够执行。
>
> 特点：
> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 
> - 标准化操作：利用HTTP动词来描述对资源的操作。 
> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 
> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 
> - 无状态交互：每个请求独立，不依赖于之前的请求。
> 
> 优点 
> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 
> - 性能高：无状态和可缓存性提高了性能。 
> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 
> - 灵活性：支持多种数据格式（如JSON、XML），适应不同客户端需求。
> 
> 缺点 
> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。
> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 
> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议（如GraphQL）高效。
> 
> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。

### 国家电网项目

**简介**

自己导师接的项目，江苏省国家电网智能诊断数据分析平台

**项目诉求**

- 对相应指标进行增删改查
- 可以导入、导出一些excel表格
- 对数据进行智能诊断分析

**技术细节**

react、Antd、Flask、mongodb


### 江南布衣实习
在公司实习期间，我担任网络工程师实习生，主要负责以下工作：

1. **新入职员工设备管理**：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。

2. **离职员工设备回收和资料销毁**：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>

3. **订货会期间设备组装和网络连接**：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。

4. **员工设备报修响应与问题解决**：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。

通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。

> **公司内网**：指的是一个局域网（LAN），用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。
> 要使一台电脑接入公司内网，经过以下步骤：
> 
> 1. **网络配置**：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。
> 2. **身份验证**：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。
> 3. **访问内部资源**：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。

## Java

### Java和C++的区别
Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：
- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；
- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；
- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；
- C++ 支持方法重载和操作符重载，Java 只支持方法重载（操作符重载增加了复杂性，与Java最初的设计思想不符）。

> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。

### 移位运算符
`<<`: 左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。
`>>`: 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。
`>>>`: 无符号右移，忽略符号位，空位都以 0 补齐。

使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。

如果移位的位数超过数值所占有的位数会怎样？
当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余（%）** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。

### 基本数据类型/包装类型 及区别
**8种基本数据类型**
- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`

> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 
> `char a = 'h'`，`char`: 单引号，`String a = "hello"`，`String`: 双引号。

**8种包装类型** 
`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

**区别**
- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。
- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。
- 占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

### 包装类的缓存机制
Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

### 什么是自动拆装箱
```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

- 装箱：将基本类型用它们对应的引用类型包装起来；
- 拆箱：将包装类型转换为基本数据类型；

从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。

### 如何解决浮点数运算的精度丢失问题

无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

### 局部变量/成员变量/静态变量

- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。

### 重载和重写
- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
  - 构造方法无法被重写

### 面向对象和面向过程区别
两者的主要区别在于解决问题的方式不同：
- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

另外，面向对象开发的程序一般更易维护、易复用、易扩展。

### 接口和抽象类
共同点: 都不能被实例化
https://learn.skyofit.com/archives/351
**区别**
- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。
- 抽象类可以有构造方法，接口不能有构造方法。
- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。
- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。
- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。
- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。

### 深拷贝/浅拷贝/引用拷贝
- 深拷贝: 完全复制整个对象，包括这个对象所包含的内部对象。
- 浅拷贝: 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- 引用拷贝: 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？

### Object 类
Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：
```java
//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
public final native Class<?> getClass()

//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
public native int hashCode()

//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
public boolean equals(Object obj)

//native 方法，用于创建并返回当前对象的一份拷贝。
protected native Object clone() throws CloneNotSupportedException

//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
public String toString()

//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()

//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()

//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
public final native void wait(long timeout) throws InterruptedException

//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
public final void wait(long timeout, int nanos) throws InterruptedException

//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException

// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

### 形参&实参
- 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
- 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。

### 值传递&引用传递
- 值传递：方法接收的是实参值的拷贝，会创建副本。
- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

Java 中只有值传递，C++ 中有值传递和引用传递。

### ==和equals()区别
- `==` 可以用来比较基本数据类型和引用数据类型
  - 基本数据类型：比较的是值是否相等
  - 引用数据类型：比较的是引用地址是否相等
  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。
- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。
  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。
  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。

### hashCode()和equal()
`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。

`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。
- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（**哈希碰撞**）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。

**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**
因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

### String/StringBuffer/StringBuilder
- `String` : 字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。
- `StringBuffer` : 字符串变量（线程安全），适用于多线程下大量字符串操作的情况。
- `StringBuilder` : 字符串变量（非线程安全），适用于单线程下大量字符串操作的情况。

- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。
- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

** `String` 为什么不可变？**
- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。
- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

### 字符串拼接使用+还是StringBuilder？
Java中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。

### String.equals()/Object.equals()
`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

### 字符串常量池
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### 异常
异常的共同祖先是 `Throwable` 类，其有两个重要的子类：
`Error`: 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。
`Exception`: 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。

### Checked/Unchecked Exception
- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。
  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。
- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。
  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。

### try-catch-finally
`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
`catch`：用于处理 `try` 捕获到的异常。
`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。

### 泛型
- 使用泛型参数，可以增强代码的可读性以及稳定性。
- 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。

### 反射
反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。

- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

### 注解
注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解只有被解析之后才会生效，常见的解析方法有两种：
- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

### 序列化/反序列化
如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
- 序列化：将数据结构或对象转换成二进制字节流的过程
- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

序列化和反序列化常见应用场景：
- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

### 语法糖
语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。

Java 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。

### List/Set/Queue/Map区别
- List: 存储的元素是有序的、可重复的。
- Set: 存储的元素不可重复的。
- Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- Map: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### 如何选用集合?
主要根据集合的特点来选择合适的集合。如：
- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。
- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。

### 为什么要使用集合？
在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。

### ArrayList和Array区别
`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 更加灵活：
- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。
- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。
- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。
- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。

> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。

### ArrayList和LinkedList区别
- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。
  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。
  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。
- 二者都是线程不安全的。
- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。
- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。

> 项目中一般不会使用 `LinkedList`。

### ArrayList和LinkedList插入/删除效率
`ArrayList`
- 头部插入/删除：O(n), 需要移动元素。
- 指定位置插入/删除：O(n), 需要移动元素。
- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。
`LinkedList`
- 头部插入/删除：O(1), 只需改变指针指向。
- 尾部插入/删除：O(1), 只需改变指针指向。
- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。

### HashSet/LinkedHashSet/TreeSet
- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。
- 主要区别在于底层数据结构不同。
  - `HashSet` 底层是哈希表(`HashMap`)。
  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。
  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

### Queue/Deque区别
- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。
- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。

### ArrayDeque/LinkedList区别
- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。
- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。

### PriorityQueue
PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。
- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据
- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。

### BlockingQueue及其实现类
`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。

**实现类**
- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。
- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。
- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。
- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

### ArrayBlockingQueue/LinkedBlockingQueue区别
二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：
- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

### Map(重要)
### HashMap/HashTable区别
- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。
- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。
- `HashTable`中有锁，所以效率比 `HashMap` 低。
- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。
- 初始容量大小和每次扩充容量大小的不同： 
  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。
  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。
  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。

> `HashTable` 已经被淘汰，不建议使用。
> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`

### HashMap长度为什么是2的幂次方
key经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。

“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作（也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。

### HashMap/TreeMap区别
- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。
- `HashMap` 是无序的，`TreeMap` 是有序的。
- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。
- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。

相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。

### HashSet如何检查重复
把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。

### HashMap底层实现
**JDK1.8 之前**
底层是数组和链表。哈希冲突使用“拉链法”解决。

`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。

- 扰动函数 `hash()` 可以减少碰撞。
- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。

**JDK1.8 之后**
底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。

- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。
- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。

### HashMap多线程扩容死循环问题
JDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。

为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。

> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。

### HashMap为什么线程不安全
- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。
- JDK1.7 和 JDK 1.8 都存在数据丢失问题。

**数据丢失**
在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。
> 例子：
> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。

### 遍历HashMap
七种
```java
HashMap<Integer, String> map = new HashMap<>();
// ForEach EntrySet
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
// ForEach KeySet
for (Integer key : map.keySet()) {
    System.out.println(key + ":" + map.get(key));
}
// 迭代器EntrySet
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
// 迭代器KeySet
Iterator<Integer> iterator = map.keySet().iterator();
while (iterator.hasNext()) {
    Integer key = iterator.next();
    System.out.println(key + ":" + map.get(key));
}
// Lambda
map.forEach((key, value) -> {
    System.out.println(key);
    System.out.println(value);
});
// Streams API 单线程
map.entrySet().stream().forEach(entry -> {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
});
// Streams API 多线程
map.entrySet().parallelStream().forEach(entry -> {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
});
```

### ConcurrentHashMap/Hashtable区别
- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。
- 实现线程安全的方式：
  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。
  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
  - `Hashtable`(同一把锁) :使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。

### ConcurrentHashMap底层

JDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。

`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。

JDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。


### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？
- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。
- Hash 碰撞解决方法 : JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。

### ConcurrentHashMap能保证复合操作的原子性吗？
- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。
- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。

### 什么是LinkedHashMap
继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性:
- 支持遍历时会按照插入顺序有序进行迭代
- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。
- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。

> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。

### LinkedHashMap如何按照访问顺序迭代元素？
`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。

### 如何实现LRU缓存
- `accessOrder` = `true` 
- 继承`LinkedHashMap`
- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。
```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    public LRUCache(int capacity) {
        super(capacity, 1f, true);
        this.capacity = capacity;
    }
    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}
```
### LinkedHashMap和HashMap的区别
- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。
- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。

### CopyOnWriteArrayList





### 堆和栈的区别
https://blog.csdn.net/qq_44944221/article/details/126692973
- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；
- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；

区别:
- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；
- 共享性不同：栈是线程私有，而堆是线程共享；
- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；
- 空间大小不同：堆空间大小远远大于栈的内存空间。

### 进程/线程/协程
https://blog.csdn.net/m0_60505735/article/details/131047046
https://blog.csdn.net/weixin_49199646/article/details/109210547
进程： 进程是程序的一次执行过程，是系统资源分配和独立运行的最小单位；
线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；
协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
**进程与线程的区别**
- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。
- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。
- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。

**进程与线程的联系**
一个进程由共享空间（包括堆、代码区、数据区、进程空间和打开的文件描述符）和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。

*进程与线程的选择**
- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；
- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；
- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程
- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。

综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。

### 强引用/软引用/弱引用/虚引用
https://blog.csdn.net/u013718071/article/details/134789666
Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。
- 强引用（Strong Reference）：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。
- 软引用（Soft Reference）：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。
- 弱引用（Weak Reference）：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。
- 虚引用（Phantom Reference）：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。

以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。强引用对对象的生命周期没有影响，而软引用、弱引用和虚引用可以让对象在系统内存不足时被垃圾回收器回收。软引用和弱引用可以通过Java提供的相应类来创建，而虚引用需要借助 `PhantomReference` 类来实现。这些不同类型的引用给提供了更灵活的内存控制机制，用于满足不同的需求。

### 垃圾回收机制



## 网络



## 操作系统


## MySQL




## Redis



## spring boot/cloud ???


## Linux



## 其他



## 面经



