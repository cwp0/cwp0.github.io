---
title: Java后端面经
tags:
  - Java
  - 面经
categories:
  - 面经
keywords:
  - 面经
description: Java后端面经
abbrlink: 17766
date: 2024-05-27 19:58:53
updated: 2024-06-11 22:06:23
top_img: https://s2.loli.net/2024/05/27/Rq3jowUDsv9nT71.png
comments:
cover: https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

> 准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础、网络、操作系统、数据库等内容的精简答案，最后再回顾一下每次面试的面经。
> 本文参考 JavaGuide 

## 简历相关

### 自我介绍

面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 **Java后端开发岗位**。

我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。

然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xx 给我这次面试机会，我也十分希望能进入 xx ，与公司共同成长进步！

### 专业技能




### Casbin明日之星实习

1. 在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。

2. 有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录（SSO）和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。

3. 另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。

### 中科院开源之夏项目

**简介**
Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。

**项目诉求**
1. 对微信第三方登录的移动端支持
    - 在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。

2. 对flutter、react-native、unity等sdk的开发及功能的增强
    - 对flutter-sdk的增强如第一点

3. 临时加上的开发casdoor-app诉求，对标Google Authenticator

**技术细节**
1. 在flutter-sdk中通过截取session中的url和callbackURLscheme判断其中是否有"weixin"字段，如果有，则进行微信第三方原生授权登录；

    - 使用WKWebView替换原本的ASWebAuthenticationSession，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；
    - 使用rb脚本文件自动化配置微信SDK导入后xcode中xcodeproj文件的相关配置；

    - 接入xcframework的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；

接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置universal Link，需付费几百美元，所以最终代码并未实际测试。

2. 分为两部分
    1. casdoor-unity-example
        - 在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；
        - 以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；
        - 在casdoor服务端配置好应用的ClientCode和ClientSecret后，在Unity3D中向服务端发送认证请求(CilentCode等)，解析返回的token，就可以得到用户信息，也可以使用session保存token等信息。
        - 认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。
    2. casdoor-react-native-sdk、example
        - 以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；
        - react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。
        - sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 code_challenge 和 code_verifier 。
3. casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。
    - casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。
    - casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。

> SHA（Secure Hash Algorithm，安全哈希算法）是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。

**总结**
参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。

### Casbin Casdoor 介绍
> Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略（Policy-Based）的访问控制模型，支持各种访问控制模型（如 ACL、RBAC、ABAC 等），并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。 
> Casbin 的主要特点包括：
> 1. **多种访问控制模型支持**：包括基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）、访问控制列表（ACL）等，满足不同场景的权限管理需求。
> 2. **灵活的策略管理**：通过策略文件进行权限管理，支持多种格式（如 CSV、JSON、数据库等），方便管理和配置访问策略。
> 3. **细粒度的权限控制**：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。
> 4. **跨语言支持**：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。

> Casdoor 是基于 Casbin 的单点登录（SSO）和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。
> 1. **单点登录（SSO）**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。
> 2. **用户管理**：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。
> 3. **权限控制**：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。
> 4. **开源社区**：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。

### RESTful API
> RESTful API（Representational State Transfer API）是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。
> REST架构原则：
> - 无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。
> - 统一接口： 资源：通过URL定位资源（通常是名词，如 /users 表示用户资源）。 操作：使用标准HTTP方法对资源进行操作： GET：获取资源 POST：创建资源 PUT：更新资源 DELETE：删除资源
> - 可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。
> - 分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器（如代理、负载均衡器等）来提升系统的可扩展性和安全性。
> - 按需代码：在某些情况下，服务器可以返回可执行代码（如JavaScript），使客户端能够执行。
>
> 特点：
> - 资源导向：一切皆资源，每个资源使用唯一的URL表示。 
> - 标准化操作：利用HTTP动词来描述对资源的操作。 
> - 状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 
> - 客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 
> - 无状态交互：每个请求独立，不依赖于之前的请求。
> 
> 优点 
> - 简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 
> - 性能高：无状态和可缓存性提高了性能。 
> - 可扩展性：分层系统和明确的资源导向使得系统易于扩展。 
> - 灵活性：支持多种数据格式（如JSON、XML），适应不同客户端需求。
> 
> 缺点 
> - 无状态：每个请求都需要携带所有信息，可能会导致开销增加。
> - 缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 
> - 适用于简单操作：对于复杂事务处理，REST可能不如其他协议（如GraphQL）高效。
> 
> RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。

### 国家电网项目

**简介**

自己导师接的项目，江苏省国家电网智能诊断数据分析平台

**项目诉求**

- 对相应指标进行增删改查
- 可以导入、导出一些excel表格
- 对数据进行智能诊断分析

**技术细节**

react、Antd、Flask、mongodb


### 江南布衣实习
在公司实习期间，我担任网络工程师实习生，主要负责以下工作：

1. **新入职员工设备管理**：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。

2. **离职员工设备回收和资料销毁**：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u>

3. **订货会期间设备组装和网络连接**：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。

4. **员工设备报修响应与问题解决**：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。

通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。

> **公司内网**：指的是一个局域网（LAN），用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。
> 要使一台电脑接入公司内网，经过以下步骤：
> 
> 1. **网络配置**：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。
> 2. **身份验证**：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。
> 3. **访问内部资源**：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。

## Java

-----------------
### ✅基础

### Java和C++的区别
Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：
- Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；
- Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；
- Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；
- C++ 支持方法重载和操作符重载，Java 只支持方法重载（操作符重载增加了复杂性，与Java最初的设计思想不符）。

> C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。

### 移位运算符
`<<`: 左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。
`>>`: 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。
`>>>`: 无符号右移，忽略符号位，空位都以 0 补齐。

使用 `<<`、 `>>` 和`>>>`转换成的指令码运行起来会更高效些。由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 `int` 和 `long`，编译器在对 `short`、`byte`、`char` 类型进行移位前，都会将其转换为`int`类型再操作。

如果移位的位数超过数值所占有的位数会怎样？
当 `int` 类型左移/右移位数大于等于 32 位操作时，会先 **求余（%）** 后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 `long` 类型进行左移/右移操作时，由于 `long` 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x>>>42`等同于`x>>>10`。

### 基本数据类型/包装类型 及区别
**8种基本数据类型**
- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`

> 注意：Java 里使用 `long` 类型的数据一定要在数值后面加上 `L` ，否则将作为整型解析。 
> `char a = 'h'`，`char`: 单引号，`String a = "hello"`，`String`: 双引号。

**8种包装类型** 
`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

**区别**
- 用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。
- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。
- 占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- 默认值：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- 比较方式：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

### 包装类的缓存机制
Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，`Character` 创建了数值在 [0,127] 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

### 什么是自动拆装箱
```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

- 装箱：将基本类型用它们对应的引用类型包装起来；
- 拆箱：将包装类型转换为基本数据类型；

从字节码来看，装箱调用包装类的 `valueOf()` 方法，拆箱调用 `xxxValue()` 方法。

### 如何解决浮点数运算的精度丢失问题

无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

### 局部变量/成员变量/静态变量

- 语法形式：成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
- 存储方式：如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
- 生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
- 默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

静态变量是被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。

### 重载和重写
- 重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
  - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
  - 构造方法无法被重写

### 面向对象和面向过程区别
两者的主要区别在于解决问题的方式不同：
- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

另外，面向对象开发的程序一般更易维护、易复用、易扩展。

### 接口和抽象类
共同点: 都不能被实例化
https://learn.skyofit.com/archives/351
**区别**
- 子类使用`extends`关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字`implements`来实现接口，可以实现多个接口。
- 抽象类可以有构造方法，接口不能有构造方法。
- 抽象类允许有普通方法，接口中的方法默认是`public abstract`类型(JDK8后允许使用`default`、`static`定义非抽象方法)。
- 抽象类允许有成员变量，接口中只允许有常量(默认是`public static final`类型)。
- 抽象类中的抽象方法可以有访问修饰符(可以是`public`、`protected`、`private`)，接口中的抽象方法默认是`public`类型。
- 抽象类可以有 `main` 方法，接口中不能有 `main` 方法。

### 深拷贝/浅拷贝/引用拷贝
- 深拷贝: 完全复制整个对象，包括这个对象所包含的内部对象。
- 浅拷贝: 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- 引用拷贝: 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？

### Object 类
Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：
```java
//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
public final native Class<?> getClass()

//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
public native int hashCode()

//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
public boolean equals(Object obj)

//native 方法，用于创建并返回当前对象的一份拷贝。
protected native Object clone() throws CloneNotSupportedException

//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
public String toString()

//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()

//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()

//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
public final native void wait(long timeout) throws InterruptedException

//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
public final void wait(long timeout, int nanos) throws InterruptedException

//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException

// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

### 形参&实参
- 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
- 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。

### 值传递&引用传递
- 值传递：方法接收的是实参值的拷贝，会创建副本。
- 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

Java 中只有值传递，C++ 中有值传递和引用传递。

### ==和equals()区别
- `==` 可以用来比较基本数据类型和引用数据类型
  - 基本数据类型：比较的是值是否相等
  - 引用数据类型：比较的是引用地址是否相等
  - Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。
- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。
  - 如果没有重写`equals()`方法， 子类调用`Object` 类中的`equals()`方法，等价于通过“==”比较这两个对象，即比较的是两个对象的引用地址。
  - 一般重写`equals()`方法来比较两个对象中的属性是否相等；若属性相等，则返回 `true`(即认为这两个对象相等)。

### hashCode()和equal()
`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 `Object` 类中，意味着 Java 中的任何类都有 `hashCode()`。注意：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的。

`hashCode()` 和 `equals()`都是用于比较两个对象是否相等。JDK 同时提供这两个方法，`hashCode()`方法可以大大减少`equals()`方法的调用次数，从而提高程序的性能。
- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（**哈希碰撞**）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，可以直接认为这两个对象不相等。

**为什么重写 `equals()` 时必须重写 `hashCode()` 方法？**
因为两个相等对象的 `hashCode` 值必须相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

### String/StringBuffer/StringBuilder
- `String` : 字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。
- `StringBuffer` : 字符串变量（线程安全），适用于多线程下大量字符串操作的情况。
- `StringBuilder` : 字符串变量（非线程安全），适用于单线程下大量字符串操作的情况。

- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
- `StringBuffer` 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。
- `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

** `String` 为什么不可变？**
- `String`类内保存字符串的`char`数组被 `final` 修饰且为私有的，并且 `String` 类没有提供/暴露修改这个字符串的方法。
- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

### 字符串拼接使用+还是StringBuilder？
Java中“+”和“+=” 实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象。

### String.equals()/Object.equals()
`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

### 字符串常量池
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### 异常
异常的共同祖先是 `Throwable` 类，其有两个重要的子类：
`Error`: 程序无法处理的错误，不建议通过 `catch` 捕获。一般由 JVM 抛出，线程终止执行。
`Exception`: 程序本身可以处理的异常，可以通过 `catch` 来进行捕获。

### Checked/Unchecked Exception
- `Checked Exception`即受检查异常 ，在编译过程中，若受检查异常没有被 `catch` 或者 `throws` 关键字处理的话，就没办法通过编译。
  - 除了 `RuntimeException` 及其子类以外，其他的 `Exception` 类及其子类都属于受检查异常 。常见的受检查异常有：`ClassNotFoundException`、`FileNotFoundException`、`SQLException` 等。
- `Unchecked Exception` 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。
  - `RuntimeException` 及其子类属于不受检查异常。常见的不受检查异常有：`NullPointerException`、`ArrayIndexOutOfBoundsException`、`IllegalArgumentException` 等。

### try-catch-finally
`try`：用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
`catch`：用于处理 `try` 捕获到的异常。
`finally`：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

> 注意：不要在 `finally` 语句块中使用 `return` ! 当 `try` 语句和 `finally` 语句中都有 `return` 语句时，`try` 语句块中的 `return` 语句会被忽略。

### 泛型
- 使用泛型参数，可以增强代码的可读性以及稳定性。
- 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。

### 反射
反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。

- 优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。
- 缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

### 注解
注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解只有被解析之后才会生效，常见的解析方法有两种：
- 编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 `@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- 运行期通过反射处理：像框架中自带的注解(比如 `Spring` 框架的 `@Value`、`@Component`)都是通过反射来进行处理的。

### 序列化/反序列化
如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
- 序列化：将数据结构或对象转换成二进制字节流的过程
- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

序列化和反序列化常见应用场景：
- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

### 语法糖
语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。

Java 中最常用的语法糖主要有**switch语句**、**自动拆装箱**、**for-each循环**、**try-with-resources** 语法、**lambda 表达式**等。

-----------------
### ✅集合

### List/Set/Queue/Map区别
- List: 存储的元素是有序的、可重复的。
- Set: 存储的元素不可重复的。
- Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- Map: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### 如何选用集合?
主要根据集合的特点来选择合适的集合。如：
- 需要根据键值获取到元素值时就选用 `Map` 接口下的集合，需要排序时选择 `TreeMap` ,不需要排序时就选择 `HashMap` ,需要保证线程安全就选用 `ConcurrentHashMap` 。
- 只需要存放元素值时，就选择实现 `Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet` ，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList` ，然后再根据实现这些接口的集合的特点来选用。

### 为什么要使用集合？
在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。

### ArrayList和Array区别
`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 更加灵活：
- `ArrayList`可动态扩容/缩容，`Array` 创建后不能改变长度。
- `ArrayList` 可使用泛型确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存对象，存基本类型数据时要用对应包装类(如`Integer`)。`Array` 可直接存储基本类型数据，也可存储对象。
- `ArrayList` 提供增删改查等 API 操作方法，如 `add()`、`remove()`等。`Array` 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。
- `ArrayList`创建时不需指定大小，而`Array`创建时必须指定大小。

> 以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。

### ArrayList和LinkedList区别
- `ArrayList` 底层基于`Object`数组实现的，`LinkedList` 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。
  - `ArrayList`插入和删除元素的时间复杂度受元素位置的影响。`add()`方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。
  - `LinkedList`插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。
- 二者都是线程不安全的。
- `ArrayList` 随机访问效率高(实现了`RandomAccess()`接口)，`LinkedList` 插入删除效率高。
- 占用空间：`ArrayList` 主要体现在在列表的结尾会留一定的容量空间，`LinkedList` 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。

> 项目中一般不会使用 `LinkedList`。

### ArrayList和LinkedList插入/删除效率
`ArrayList`
- 头部插入/删除：O(n), 需要移动元素。
- 指定位置插入/删除：O(n), 需要移动元素。
- 尾部插入/删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。
`LinkedList`
- 头部插入/删除：O(1), 只需改变指针指向。
- 尾部插入/删除：O(1), 只需改变指针指向。
- 指定位置插入/删除：O(n), 需要先移动到指定位置再插入和删除。

### CopyOnWriteArrayList
`CopyOnWriteArrayList` 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 `Copy-On-Write（COW）`的策略，即每次写操作（如添加、删除、更新元素）都会创建一个新的数组副本。这种策略在以下场景中非常有用：
- **读多写少**：大部分操作都是读取数据，写操作相对较少。
- **不要求实时性**：因为写操作需要创建数组副本，可能会有短暂的延迟。

`ReentrantReadWriteLock` 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。`CopyOnWriteArrayList` 更进一步地实现了这一思想。为了将读操作性能发挥到极致，`CopyOnWriteArrayList` 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。

**优点**
- **线程安全**：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。
- **简化并发控制**：不需要显式的同步块或锁定机制。
- **迭代器安全**：迭代器不会抛出 `ConcurrentModificationException`，因为迭代时是基于快照的。

**缺点**
- **内存开销大**：每次写操作都会创建数组副本，可能会占用较多的内存。
- **写操作开销大**：由于需要复制整个数组，写操作的时间复杂度为 O(n)。
- **读取旧数据**：在高并发场景下，可能会读取到旧的数据。

**适用场景**
- 配置类数据：如系统配置参数、常量集合等。
- 事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。

**不适用场景**
- 高并发写操作：如果有大量的写操作，那么 `CopyOnWriteArrayList` 的性能会变差。
- 实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。

**结论**
`CopyOnWriteArrayList` 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 `ConcurrentHashMap` 或 `ConcurrentLinkedQueue`。

### HashSet/LinkedHashSet/TreeSet
- 都是 `Set` 接口的实现类，都保证元素唯一，且都不是线程安全的。
- 主要区别在于底层数据结构不同。
  - `HashSet` 底层是哈希表(`HashMap`)。
  - `LinkedHashSet` 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。
  - `TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同导致三者应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

### Map(重要)
### HashMap/HashTable区别
- `HashMap` 是非线程安全的，`HashTable` 是线程安全的(内部方法经过`synchronized`修饰)。
- JDK1.8以后 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。`Hashtable` 没有这样的机制。
- `HashTable`中有锁，所以效率比 `HashMap` 低。
- `HashMap` 可以有一个 `null` key和多个`null` value，而 `HashTable` 不允许有`null` key和value，否则会报错`NullPointerException`。
- 初始容量大小和每次扩充容量大小的不同： 
  - `Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。
  - `HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。
  - 创建时如果给定了容量初始值，`Hashtable` 会直接使用给定的大小，而 `HashMap` 总是使用 2 的初始容量的幂作为哈希表的大小。

> `HashTable` 已经被淘汰，不建议使用。
> `HashMap` `loadFactor` 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。`threshold = capacity * loadFactor`

### HashMap长度为什么是2的幂次方
key经过扰动函数`hash()`后得到 `hash` 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。

“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&)操作（也就是说 `hash % n == hash & (n - 1)` 的前提是 n 是 2 的幂次）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 `HashMap` 的长度为什么是 2 的幂次方。

### HashMap/TreeMap区别
- `HashMap` 是基于哈希表实现的，`TreeMap` 是基于红黑树实现的。
- `HashMap` 是无序的，`TreeMap` 是有序的。
- `HashMap` 的键值对允许有一个 `null` 键和多个 `null` 值，`TreeMap` 不允许有 `null` 键，但允许有 `null` 值。
- `HashMap` 的查询、插入、删除操作的时间复杂度是 O(1)，而 `TreeMap` 的时间复杂度是 O(logn)。

相比于`HashMap`，`TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。

### HashSet如何检查重复
把对象加入`HashSet`时，先计算对象的`hashcode`值来判断对象加入的位置，同时会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，认为对象没有重复出现。但如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

在 JDK1.8 中，实际上无论`HashSet`中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。

### HashMap底层实现
**JDK1.8 之前**
底层是数组和链表。哈希冲突使用“拉链法”解决。

`HashMap` 通过 key 的 `hashcode` 经过扰动函数`hash()`处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 `hash` 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。

- 扰动函数 `hash()` 可以减少碰撞。
- “拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
- “拉链法”中，数组的 index 就是通过扰动函数`hash()`计算出来的 `hash` 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。

**JDK1.8 之后**
底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 `treeifyBin()`方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 `resize()` 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。

- 数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。
- 扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过`hash()`计算出来的`hash`值不变，但数组长度 n 变化，将原数组中的元素通过 `(n - 1) & hash`重新计算 index 放入新数组中。

### HashMap多线程扩容死循环问题
JDK1.7及之前版本的`HashMap`在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。

为了解决这个问题，JDK1.8 版本的` HashMap` 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。

> 注意：不建议在多线程下使用 `HashMap`，会存在数据覆盖的问题，并发环境下，推荐使用`ConcurrentHashMap`。

### HashMap为什么线程不安全
- JDK1.7及之前版本，存在多线程扩容死循环问题，如上。
- JDK1.7 和 JDK 1.8 都存在数据丢失问题。

**数据丢失**
在 `HashMap` 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有数据覆盖的风险。
> 例子：
> 线程 1,2 同时进行 `put` 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
> 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
> 随后，线程 1 获得时间片，由于之前已经进行过 `hash` 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。

### 遍历HashMap
七种
```java
HashMap<Integer, String> map = new HashMap<>();
// ForEach EntrySet
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
// ForEach KeySet
for (Integer key : map.keySet()) {
    System.out.println(key + ":" + map.get(key));
}
// 迭代器EntrySet
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
// 迭代器KeySet
Iterator<Integer> iterator = map.keySet().iterator();
while (iterator.hasNext()) {
    Integer key = iterator.next();
    System.out.println(key + ":" + map.get(key));
}
// Lambda
map.forEach((key, value) -> {
    System.out.println(key);
    System.out.println(value);
});
// Streams API 单线程
map.entrySet().stream().forEach(entry -> {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
});
// Streams API 多线程
map.entrySet().parallelStream().forEach(entry -> {
    System.out.println(entry.getKey());
    System.out.println(entry.getValue());
});
```

### ConcurrentHashMap/Hashtable区别
- 底层：JDK1.7的`ConcurrentHashMap`采用**分段的数组+链表** 实现，JDK1.8跟 `HashMap` 1.8结构一样，**数组+链表/红黑二叉树** 。`Hashtable` 是**数组+链表** 实现。
- 实现线程安全的方式：
  - JDK1.7`ConcurrentHashMap` 对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组中每个元素都有一个锁，且每个元素包含一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment`中守护一个`HashEntry`，多个 `Segment` 组成一个 `ConcurrentHashMap`。当一个线程占用`Segment`锁访问其中的元素时，其他线程可以访问其他 `Segment`。
  - JDK1.8`ConcurrentHashMap` 摒弃 `Segment` 的概念，而是直接用 **`Node`数组+链表+红黑树** 实现，并发控制使用 `synchronized` 和 CAS 来操作。(JDK1.6 以后 `synchronized` 锁做了很多优化) 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
  - `Hashtable`(同一把锁) :使用 `synchronized` 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 `put` 添加元素，另一个线程不能使用 `put` 添加元素，也不能使用 `get`，竞争会越来越激烈效率越低。

### ConcurrentHashMap底层

JDK1.7`ConcurrentHashMap` 数据结构为**`Segment`数组+`HashEntry`数组+链表** 。`ConcurrentHashMap`对整个桶数组进行分割分段(`Segment`，分段锁)，`Segment`数组每个元素存放一个`HashEntry`数组，其中每个`HashEntry`元素是一个链表，即一个`Segment` 守护一个 `HashEntry` 数组里的元素(`HashEntry`结构类似于`HashMap`)，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的。

`Segment` 继承了 `ReentrantLock` ，是可重入锁，`Segment` 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。

JDK1.8`ConcurrentHashMap`取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap`1.8 的结构类似，**`Node`数组+链表/红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 `hash` 不冲突，就不会产生并发，就不会影响其他 `Node` 的读写，效率大幅提升。


### JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？
- 线程安全实现方式：JDK 1.7采用 `Segment` 分段锁来保证安全，`Segment`继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。
- Hash 碰撞解决方法 : JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
- 并发度：JDK 1.7最大并发度是 `Segment` 的个数，默认是 16。JDK 1.8 最大并发度是 `Node` 数组的大小，并发度更大。

### ConcurrentHashMap能保证复合操作的原子性吗？
- `ConcurrentHashMap`是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。
- `ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 `key` 和 `value` 来计算一个新的 `value`，并且将其更新到 `map` 中。

### 什么是LinkedHashMap
继承了 `HashMap` 的所有属性和方法，在 `HashMap` 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 `bucket` 上的节点、链表、红黑树有序关联起来。具备如下特性:
- 支持遍历时会按照插入顺序有序进行迭代
- 支持按照元素访问顺序排序,_**适用于封装 LRU 缓存工具**_ 。
- 因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 `HashMap` 来说，迭代效率会高很多。

> 在 `HashMap` 的基础重写了 `afterNodeRemoval`、`afterNodeInsertion`、`afterNodeAccess` 方法。使之拥有顺序插入和访问有序的特性。

### LinkedHashMap如何按照访问顺序迭代元素？
`LinkedHashMap`通过构造函数中的 `accessOrder` 参数指定按照访问顺序迭代元素。当 `accessOrder` 为 `true` 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。

### 如何实现LRU缓存
- `accessOrder` = `true` 
- 继承`LinkedHashMap`
- 重写 `removeEldestEntry` 方法。当链表大小超过容量时返回 `true`，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 `removeEldestEntry` 返回 `true` 时，视为缓存已满，`LinkedHashMap` 就会将链表首元素移除，由此实现 LRU 缓存。
```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    public LRUCache(int capacity) {
        super(capacity, 1f, true);
        this.capacity = capacity;
    }
    // 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}
```
### LinkedHashMap和HashMap的区别
- 最大区别在于迭代元素的顺序。`HashMap` 迭代元素的顺序是不确定的，而 `LinkedHashMap` 提供了按照插入顺序或访问顺序迭代元素的功能。
- `LinkedHashMap` 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 `HashMap` 则没有这个链表。因此，`LinkedHashMap` 插入性能比 `HashMap` 略低，但提供了更多功能且迭代起来比`HashMap`更高效。

### Queue/Deque区别
- `Queue` 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。
- `Deque` 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 `push()`等方法，可用于模拟栈。

### ArrayDeque/LinkedList区别
- `ArrayDeque` 基于**可变长数组** 和**双指针** 来实现，而 `LinkedList` 通过链表来实现。
- `ArrayDeque` 不能存储 `NULL` 数据，`LinkedList` 能。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。

### PriorityQueue
PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。
- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据
- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。
- 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
- 默认是小顶堆，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

> `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。

### BlockingQueue及其实现类
`BlockingQueue`(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于**生产者-消费者模型** 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。

**实现类**
- `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
- `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。
- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口且不能插入 `null` 元素。
- `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。
- `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

### ArrayBlockingQueue
- `put()`、`take()`：插入和删除元素时，如果队列已满或者为空，会阻塞等待。
- `offer()`、`poll()`：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 `false` 或者 `null`。
- 并发控制采用可重入锁 `ReentrantLock` 保证线程安全，插入/读取操作都需获取到锁才能进行，且支持公平/非公平两种方式的锁访问机制，默认是非公平锁。

### ArrayBlockingQueue实现原理
- `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。
- 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。
- 通过 `Condition` 接口实现线程间的等待和唤醒操作。

线程间的等待和唤醒具体的实现：
- 当队列已满时，生产者线程会调用 `notFull.await()` 方法让生产者进行等待，等待队列非满时插入（非满条件）。
- 当队列为空时，消费者线程会调用 `notEmpty.await()`方法让消费者进行等待，等待队列非空时消费（非空条件）。
- 当有新的元素被添加时，生产者线程会调用 `notEmpty.signal()`方法唤醒正在等待消费的消费者线程。
- 当队列中有元素被取出时，消费者线程会调用 `notFull.signal()`方法唤醒正在等待插入元素的生产者线程。

### ArrayBlockingQueue/LinkedBlockingQueue区别
二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：
- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
- 锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。因此，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

### DelayQueue底层
是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

**底层**
`DelayQueue` 底层用 `PriorityQueue` 存储元素，`PriorityQueue` 采用**二叉小顶堆**的思想确保值小的元素排在最前面，使得 `DelayQueue` 对于延迟任务优先级的管理非常方便。同时 `DelayQueue` 为了保证线程安全还用到了可重入锁 `ReentrantLock`,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 `Condition`接口，通过 `Condition` 的 `await` 和 `signal` 方法完成多线程之间的等待唤醒。

> ```java
> //可重入锁，实现线程安全的关键
> private final transient ReentrantLock lock = new ReentrantLock();
> //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列
> private final PriorityQueue<E> q = new PriorityQueue<E>();
> //指向准备执行优先级最高的线程
> private Thread leader = null;
> //实现多线程之间等待唤醒的交互
> private final Condition available = lock.newCondition();
> ```
> `leader` : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 `leader` 来管理延迟任务，只有 `leader` 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 `leader` 线程执行完手头的延迟任务后唤醒它。
> `available` : 等待唤醒操作的交互是通过 `available` 实现的，假如一个线程尝试在空的 `DelayQueue` 获取任务时，`available` 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 `available` 的 `signal` 方法将其唤醒。


### DelayQueue是否线程安全？
`DelayQueue`是线程安全的，它通过 `ReentrantLock` 实现了互斥访问和 `Condition` 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。

### DelayQueue使用场景
通常用于实现定时任务调度和缓存过期删除等场景。
- 在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 `DelayQueue` 中，`DelayQueue` 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。
- 缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 `key` 封装成一个延迟的删除任务，并将其添加到 `DelayQueue` 中，当数据过期时，拿到这个任务的 `key`，将这个 `key` 从内存中移除。

### DelayQueue中Delayed接口的作用是什么？
`DelayQueue` 中存放的元素必须实现 `Delayed` 接口，并且需要重写 `getDelay()`方法。`Delayed`接口定义了元素的剩余延迟时间(`getDelay()`)和元素之间的比较规则(继承 `Comparable` 接口),否则 `DelayQueue` 无法得知当前任务剩余时长和任务优先级的比较。

### DelayQueue/Timer/TimerTask区别
都可以用于实现定时任务调度，但实现方式不同。
- `DelayQueue` 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；
- `Timer/TimerTask` 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。
- `DelayQueue` 支持动态添加/移除任务，`Timer/TimerTask` 只能在创建时指定任务。

-----------------
### ✅并发

### 进程/线程/协程
https://blog.csdn.net/m0_60505735/article/details/131047046
https://blog.csdn.net/weixin_49199646/article/details/109210547
- 进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。
- 线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
- 协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。

**进程与线程的区别**
- 根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。
- 地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。
- 上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。

**进程与线程的联系**
一个进程由共享空间（包括堆、代码区、数据区、进程空间和打开的文件描述符）和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。

*进程与线程的选择**
- 线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；
- 线程上下文切换的速度比进程快，需要大量计算时优先选用线程；
- 线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程
- 线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。

综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。

### Java线程和操作系统线程有何区别
现在的 Java 线程的本质其实就是操作系统的线程。

- JDK1.2之前Java线程基于绿色线程（`Green Threads`）实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。
- JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一（一个用户线程对应一个内核线程）、 多对一、 多对多。

在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。

### 程序计数器为啥是私有的
程序计数器主要有下面两个作用：
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 如果执行的是 `native` 方法，那么程序计数器记录的是 `undefined` 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

### 虚拟机栈和本地方法栈为啥是私有的
- 虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

### 一句话简单了解堆和方法区
堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 如何创建线程
- 继承`Thread`类并重写`run()`方法
- 实现`Runnable`接口并重写`run()`方法
- 实现`Callable`接口并重写`call()`方法
- 使用线程池`ThreadPoolExecutor`创建线程
- 等等......

其实只有一种方式可以创建线程，那就是通过 `new Thread().start()` 创建。不管是哪种方式，最终还是依赖于`new Thread().start()`。

### 线程的生命周期和状态
Java 线程 6 种状态：
`NEW`: 初始状态，线程被创建出来但没有被调用 `start()` 。
`RUNNABLE`: 运行状态，线程被调用了 `start()`等待运行的状态。
`BLOCKED`：阻塞状态，需要等待锁释放。
`WAITING`：线程执行`wait()`方法等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
`TIME_WAITING`：超时等待状态，调用`sleep(long millis)`可以在指定的时间后自行返回而不是像 `WAITING` 那样一直等待。
`TERMINATED`：执行完`run()`方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

### 线程上下文切换
线程在执行过程中会有自己的运行条件和状态（也称**上下文**），比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。
- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。

线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

### Thread.sleep()方法和Object.wait()方法对比
共同点：两者都可以暂停线程的执行。
区别：
- `sleep()` 方法没有释放锁，`wait()` 方法释放锁 。
- `sleep()`通常被用于暂停执行，`wait()` 通常被用于线程间交互/通信。
- `wait()`方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()`方法。`sleep()`方法执行完成后，线程会自动苏醒(或者也可以使用`wait(long timeout)`超时后线程会自动苏醒)。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

### 锁的基本概念
Java 中，每个对象都有一个与之关联的监视器（`monitor`），也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。

### 为什么wait()方法不定义在Thread中
- 锁是对象级别的，每个对象都有一把锁。
- `wait()` 方法是对对象的监视器（锁）进行操作，释放的是对象的锁，而不是线程的锁。

### 为什么sleep()方法定义在Thread中
- `sleep()` 是线程控制方法，作用对象是线程本身。
- 线程暂停执行，不涉及到对象类，也不需要获得对象锁。

### sleep()如何控制当前线程沉睡
调用 `Thread.sleep()` 会作用于调用它的线程（当前线程）。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。

### 可以直接调用Thread类的run方法吗
可以但不建议。`new` 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 `main` 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。

### 并发/并行区别
- 并发：两个及两个以上的作业在同一 **时间段** 内执行。
- 并行：两个及两个以上的作业在同一 **时刻** 执行。

### 同步/异步区别
- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。

### 为什么要使用多线程
- 线程切换和调度的成本远远小于进程。
- 单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。
- 多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。
- 并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。

### 使用多线程风险
- 线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。
- 死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。
- 内存泄漏：线程未正确释放资源，导致内存泄漏。
- 上下文切换：线程频繁切换，会增加系统开销。
- ...

### 如何理解线程安全和不安全
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其**正确性** 和**一致性** 的描述。
- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

### 单核CPU上运行多个线程效率一定会高吗
如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。
如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。

### 死锁
死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

> 线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

产生死锁的四个必要条件：
- 互斥条件：该资源任意一个时刻只由一个线程占用。
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

### 如何检测死锁
- 一般死锁可能会导致 CPU 使用率飙升，线程处于 `BLOCKED` 状态，可以通过监控工具查看。
- jConsole: 可以检测死锁，查看线程的状态。
- jstack: 如有死锁，会输出`Found one Java-level deadlock: `线程的状态信息

### 如何预防和避免死锁
破坏死锁的产生的必要条件：
- 破坏请求与保持条件：一次性申请所有的资源。
- 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

避免死锁就是在资源分配时，借助于算法（比如**银行家算法** ）对资源分配进行计算评估，使其进入安全状态。

> 安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。

### Java内存模型JMM
JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

### 为什么需要Java内存模型
- Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。
- JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。
- 对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 `volatile`、`synchronized`、各种 `Lock`）即可开发出并发安全的程序。

### Java内存区域和Java内存模型有什么区别
- Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。
- Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。

### JMM是如何抽象线程和主内存之间的关系
Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。

### 主内存与工作内存
- 主内存：所有的变量（实例字段、静态字段和数组元素）都存储在主内存中，主内存是所有线程共享的内存区域。
- 工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作（读写等）都必须在工作内存中进行，不能直接操作主内存中的变量。

### 并发编程三大特性
可见性、原子性和有序性
- 可见性（Visibility）：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、`volatile`关键字、`synchronized`块等手段来实现可见性。
- 原子性（Atomicity）：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制（如锁）来保证原子性。
- 有序性（Ordering）：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的`happens-before`规则，确保代码的执行顺序对多线程环境是可预测的。

JMM通过上面三种属性来确保线程之间的内存一致性。

### 如何保证变量的可见性(volatile)
`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

### 如何禁止指令重排序
`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 `volatile` ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。

### volatile可以保证原子性
`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。

### 乐观锁/悲观锁
- 悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。
  - `synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
  - 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。
  - 悲观锁可能会存在死锁问题。
  - 通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。
- 乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。
  - 具体方法可以使用版本号机制或 CAS 算法，`AtomicInteger`、`LongAdder`等都是乐观锁的实现。
  - 高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。
  - 如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。
    - `LongAdder`以空间换时间的方式就解决了大量重试问题。
  - 通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。

### 如何实现乐观锁
- 版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。
- CAS算法：`compare and swap`，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。
  - V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。

> 举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。

### CAS算法存在问题

### ABA问题
变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 "ABA"问题。

ABA问题的解决思路是在变量前面追加上版本号或者时间戳。

**循环时间长开销大**
CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。

**只能保证一个共享变量的原子操作**
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用`AtomicReference`。

### synchronized关键字
`synchronized` 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

### JDK1.6之后synchronized的优化
在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，`synchronized`引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。

### 锁升级原理了解吗
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

### 如何使用synchronized
- 修饰实例方法：锁住当前实例对象。
```java
synchronized void method() {
    //业务代码
}
```
- 修饰静态方法：锁住当前类的 Class 对象。
```java
synchronized static void method() {
    //业务代码
}
```
- 修饰代码块：锁住括号里面的对象。
  - `synchronized(object)` 表示进入同步代码库前要获得 给定对象的锁。
  - `synchronized(类.class)` 表示进入同步代码前要获得 给定 `Class` 的锁

```
synchronized(对象) {
    //业务代码
}
synchronized(类.class) {
    //业务代码
}
```

### synchronized底层原理
`synchronized` 关键字是通过对象内部的一个叫做监视器锁（`monitor`）来实现的。

- `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。
- `synchronized` 修饰的方法使用 `ACC_SYNCHRONIZED` 标识，JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

两者的本质都是对对象监视器 `monitor` 的获取。

### ReentrantLock
`ReentrantLock` 是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承抽象类 `AQS（AbstractQueuedSynchronizer，抽象队列同步器）`，添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

### AQS核心思想
AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于`CLH`锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。

以可重入互斥锁 `ReentrantLock` 为例，其内部维护了一个使用`volatile`修饰(保证线程可见性)的`state`变量，用来表示锁的占用状态。`state` 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 `lock()` 方法时，会尝试通过 `tryAcquire()` 方法独占该锁，并让 `state` 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(`CLH` 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(`state` 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 `state` 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。

> `CLH`锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 `CLH` 队列锁的一个结点(`Node`)来实现锁的分配。在 `CLH` 队列锁中，一个节点表示一个线程，它保存着线程的引用(`thread`)、 当前节点在队列中的状态(`waitStatus`)、前驱节点(`prev`)、后继节点(`next`)。

### AQS资源共享模式
AQS 支持两种资源共享方式：独占和共享。
- `Exclusive`（独占，只有一个线程能执行，如`ReentrantLock`）
- `Share`（共享，多个线程可同时执行，如`Semaphore/CountDownLatch`）

> 也可以自定义同步器同时实现独占和共享，如`ReentrantReadWriteLock`，读操作时多个线程可以同时进行，写操作时只能一个线程进行。

### Semaphore
`Semaphore` 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的`state`表示许可数(>=1)，当一个线程调用 `acquire()` 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 `release()` 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。

### 公平锁/非公平锁
- 公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

### synchronized和ReentrantLock有什么区别？
两者都是可重入锁
- `synchronized` 是关键字，是内置的语言实现，`ReentrantLock` 是一个类。
- `synchronized` 是 JVM 实现的，`ReentrantLock` 是 JDK 实现的(也就是 API 层面，需要 `lock()` 和 `unlock()` 方法配合 `try/finally` 语句块来完成)
- `ReentrantLock` 比 `synchronized` 增加了一些高级功能:
  - 等待可中断 : `ReentrantLock`提供一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()`实现。
  - 可实现公平锁: `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。通过`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。
  - 可实现选择性通知（锁可以绑定多个条件）: `synchronized`关键字与`wait()`和`notify()/notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以，但需借助`Condition`接口与`newCondition()`方法。

> 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个`synchronized`修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。

### 可中断锁/不可中断锁
- 可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。`ReentrantLock` 是可中断锁。
- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 是不可中断锁。

### ReentrantReadWriteLock
是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。

`ReentrantReadWriteLock` 其实是两把锁，一把是 `WriteLock` (写锁)，一把是 `ReadLock`（读锁） 。读锁是**共享锁**，写锁是**独占锁**。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。

> 一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。
> 读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。

### 共享锁/独占锁
- 共享锁：一把锁可以被多个线程同时获得。
- 独占锁：一把锁只能被一个线程获得。

### 线程持有读锁还能获取写锁吗
- 在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。
- 在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。

### 读锁为什么不能升级为写锁
- 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。
- 可能会有死锁问题发生。

### StampedLock
`StampedLock` 是 JDK 1.8 引入的性能更好的读写锁，没有实现 `Lock`或 `ReadWriteLock`接口，而是基于 `CLH` 锁独立实现的。

提供三种访问模式：
- 写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。
- 读锁 （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。
- 乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比`ReadWriteLock`更好的原因)

### ThreadLocal
`ThreadLocal` 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

### ThreadLocal原理
`ThreadLocal` 通过 `ThreadLocalMap` 来实现线程内部的数据存储。`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，每个线程中都有一个 `ThreadLocalMap`，`ThreadLocal` 通过 `get()`、`set()` 方法访问 `ThreadLocalMap`。在一个线程中创造多个`ThreadLocal`对象，这个许多个`ThreadLocal`对象会被放到一个`ThreadLocalMap`中。

> `ThreadLocalMap`可以理解为一个定制化的 `HashMap`，`key` 是 `ThreadLocal` 对象，`value` 是存储的值。
> 可以存在这种情况: 在线程 1 中创建了两个 `ThreadLocal` 对象，在线程 1 中只有一个 `ThreadLocal` 对象。

### ThreadLocal内存泄漏
`ThreadLocalMap` 中使用的 `key` 为 `ThreadLocal` 的弱引用，而 `value` 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，`key` 会被清理掉，而 `value` 不会被清理掉。这样一来就会出现 `key` 为 `null` 的 键值对。如果不做任何措施的话，`value` 永远无法被 GC 回收，这个时候就可能会产生内存泄露。

其实`ThreadLocalMap`实现中已经考虑了内存泄漏问题，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 `key` 为 `null` 的记录。不过使用完 `ThreadLocal`方法后最好手动调用`remove()`方法。

> `HashMap` 的 `key` 和 `value` 都是强引用，因此不会存在弱引用导致的内存泄漏问题。

### 线程池
线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

### 为什么用线程池
- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

> 在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。

### 创建线程池的方式
- 通过`ThreadPoolExecutor`构造函数来创建 _**(推荐)**_ 。
- 通过`Executors`工具类来创建 _**(不推荐)**_ 。通过这种方式可以创建出多种类型的线程池
  - `FixedThreadPool`：固定大小的线程池。
  - `SingleThreadPool`：只有一个线程的线程池。
  - `CachedThreadPool`：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。
  - `ScheduledThreadPool`：定时任务的线程池。

### 为什么不推荐使用内置线程池
- `FixedThreadPool`，`SingleThreadPool`，`ScheduledThreadPool`：使用的是无界的 `LinkedBlockingQueue`，允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。
- `CachedThreadPool`：使用同步队列`SynchronousQueue`，允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量线程，从而导致 OOM。

### ThreadPoolExecutor参数
3 个最重要的参数：
- corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

其他常见参数 :
- keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。
- unit : keepAliveTime 参数的时间单位。
- threadFactory :executor 创建新线程的时候会用到。
- handler :拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。

### 线程池的拒绝策略
- `AbortPolicy`：直接抛出异常，阻止系统正常工作。
- `CallerRunsPolicy`：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。
- `DiscardOldestPolicy`：丢弃最早的未处理的任务请求。
- `DiscardPolicy`：不处理新任务，直接丢弃掉。

### CallerRunsPolicy策略风险及解决方案
**风险**
`CallerRunsPolicy` 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。

**解决方案**
1. 使用`CallerRunsPolicy`是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列`BlockingQueue`中，这样在内存允许的情况下，可以增加阻塞队列`BlockingQueue`的大小以容纳更多的任务，同时调整线程池的`maximumPoolSize` （最大线程数）参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。
2. 使用`ThreadPoolExecutor`的`setRejectedExecutionHandler`方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 `Redis`缓存任务。

### 线程池常用阻塞队列
- `LinkedBlockingQueue`：基于链表的阻塞队列，大小默认为 `Integer.MAX_VALUE`，即任务队列永远不会放满。`FixedThreadPool` 和 `SingleThreadExector`使用，前者只能创建核心线程数的线程，后者只能创建一个线程。
- `SyncronousQueue`：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。
- `DelayedWorkQueue`：延迟阻塞队列，`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。

### 线程池处理任务流程
1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。
3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。

### 线程池中线程异常后销毁还是复用？
两种情况：
- 使用`execute()`时，未捕获异常导致线程终止，线程池创建新线程替代；
- 使用`ExecutorService.submit()`时，异常被封装在`Future`中，线程继续复用。

### 如何设定线程池大小
- CPU 密集型任务(N+1)： 将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。
- I/O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I/O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。

### 如何设计一个根据任务优先级执行的线程池
- 使用`PriorityBlockingQueue`作为任务队列，队列中的任务按照优先级顺序执行。
- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。

这样还存在一些问题：
- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。
  - 解决方法：继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 `false 。
- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。
  - 解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。

### 异步调用Future类

`Future` 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。

`Future`类是一个泛型接口，主要包含下面几个方法：
```
// V 代表了Future执行的任务返回值的类型
public interface Future<V> {
    // 取消任务执行，成功取消返回 true，否则返回 false
    boolean cancel(boolean mayInterruptIfRunning);
    // 判断任务是否被取消
    boolean isCancelled();
    // 判断任务是否已经执行完成
    boolean isDone();
    // 获取任务执行结果
    V get() throws InterruptedException, ExecutionException;
    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutExceptio
}
```

### Callable和Future关系
`Callable` 用于定义可以返回结果的任务，`Future` 用于获取 `Callable` 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。
- 任务提交与执行：通常通过 `ExecutorService` 提交 `Callable` 任务，`submit` 方法返回一个 `Future` 对象。
- 异步结果获取：`Future` 对象可以用来获取 `Callable` 任务的返回结果或处理异常。

### CompletableFuture类有什么用？
`CompletableFuture` 类是 Java 8 中引入的一个增强版 `Future`，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 `Future` 相比，`CompletableFuture` 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。

### Atomic原子类







### 堆和栈的区别
https://blog.csdn.net/qq_44944221/article/details/126692973
- 栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；
- 堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；

区别:
- 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；
- 共享性不同：栈是线程私有，而堆是线程共享；
- 异常错误不同：当内存不足时；栈抛出的是`StackOverFlowError`异常，而堆抛出的是`OutOfMemoryError`；
- 空间大小不同：堆空间大小远远大于栈的内存空间。


### 强引用/软引用/弱引用/虚引用
https://blog.csdn.net/u013718071/article/details/134789666
Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。
- 强引用（Strong Reference）：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 `OutOfMemoryError` 错误，也不会回收这种对象。
- 软引用（Soft Reference）：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 `SoftReference` 类来实现软引用。
- 弱引用（Weak Reference）：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 `WeakReference` 类来实现弱引用。
- 虚引用（Phantom Reference）：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。

以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。强引用对对象的生命周期没有影响，而软引用、弱引用和虚引用可以让对象在系统内存不足时被垃圾回收器回收。软引用和弱引用可以通过Java提供的相应类来创建，而虚引用需要借助 `PhantomReference` 类来实现。这些不同类型的引用给提供了更灵活的内存控制机制，用于满足不同的需求。

### 垃圾回收机制



## 网络



## 操作系统


## MySQL




## Redis



## spring boot/cloud ???


## Linux



## 其他



## 面经



