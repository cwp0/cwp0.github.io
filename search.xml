<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手撕相关</title>
      <link href="/posts/17772.html"/>
      <url>/posts/17772.html</url>
      
        <content type="html"><![CDATA[<p>this is a test file.</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 手撕技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架等面经</title>
      <link href="/posts/17771.html"/>
      <url>/posts/17771.html</url>
      
        <content type="html"><![CDATA[<h2 id="spring-boot-cloud"><a href="#spring-boot-cloud" class="headerlink" title="spring boot&#x2F;cloud ???"></a>spring boot&#x2F;cloud ???</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/posts/17769.html"/>
      <url>/posts/17769.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 是一种关系型数据库</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：数据库中途突然因为某些原因挂掉了。客户端突然因为网络原因连接不上数据库了。并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。……上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。</p><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul><li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li><li>一致性(Consistency)：事务执行前后，数据库的完整性约束没有被破坏。</li><li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p><p>优点：使用索引可以大大加快数据的检索速度(大大减少检索的数据量), 减少 IO 次数，这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>缺点：创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。</p><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>存储引擎是数据库底层的软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平以及查询处理方式。MySQL 支持多种存储引擎，常见的存储引擎有 InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、NDB、Merge、Federated、Example 等。</p><p>默认存储引擎是 InnoDB，它是 MySQL 5.5.5 版本之后的默认存储引擎。InnoDB 存储引擎支持事务、行级锁、外键等特性，适合于事务处理和多用户并发的应用。MyISAM 存储引擎不支持事务和行级锁，但它提供了全文索引的功能，适合于查询频繁的应用。</p><h3 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。</p><h3 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h3><p>锁是一种常见的并发事务的控制方式。</p><h3 id="表级锁-行级锁"><a href="#表级锁-行级锁" class="headerlink" title="表级锁&#x2F;行级锁"></a>表级锁&#x2F;行级锁</h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p><p>InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可(对一行或者多行记录加锁)，所以对于并发写入操作来说， InnoDB 的性能更高。</p><p>表级锁和行级锁对比：</p><ul><li>表级锁： MySQL 中锁定粒度最大的一种锁(全局锁除外)，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li>行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Redis 中比较常见的数据类型有下面这些：</p><ul><li>5 种基础数据类型：String(字符串)、List(列表)、Set(集合)、Hash(散列)、Zset(有序集合)。</li><li>3 种特殊数据类型：HyperLogLog(基数统计)、Bitmap (位图)、Geospatial (地理位置)。</li></ul><p>除了上面提到的之外，还有一些其他的比如 Bloom filter(布隆过滤器)open in new window、Bitfield(位域)。</p><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了做数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p><ul><li>快照(snapshotting，RDB)</li><li>只追加文件(append-only file, AOF)</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> mongodb </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/posts/17770.html"/>
      <url>/posts/17770.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="http-和-https"><a href="#http-和-https" class="headerlink" title="http 和 https"></a>http 和 https</h3><p><strong>基本概念</strong></p><ul><li>http: 是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</li><li>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li></ul><p><strong>http 和 https 的区别及优缺点？</strong></p><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>域名</code>。</li></ul><p><strong>https 协议的工作原理</strong><br>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书(证书中包含了公钥)，传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><h3 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p><ul><li><strong>TCP(Transmission Control Protocol，传输控制协议 )<strong>：提供 <strong>面向连接</strong> 的，</strong>可靠</strong> 的数据传输服务。</li><li><strong>UDP(User Datagram Protocol，用户数据协议)<strong>：提供 <strong>无连接</strong> 的，</strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li></ul><blockquote><p>TCP与UDP区别总结：<br>1、TCP面向连接(如打电话要先拨号建立连接);UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p>原文链接：<a href="https://blog.csdn.net/Li_Ning_/article/details/52117463">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p></blockquote><h3 id="TCP-UDP应用场景"><a href="#TCP-UDP应用场景" class="headerlink" title="TCP&#x2F;UDP应用场景"></a>TCP&#x2F;UDP应用场景</h3><p><a href="https://blog.csdn.net/qq_44273429/article/details/131375961">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p><p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p><ul><li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li><li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li><li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li><li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li><li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li></ul><p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p><ul><li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li><li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li><li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li><li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li></ul><h3 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h3><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ul><li>一次握手:客户端发送带有 SYN(SEQ&#x3D;x) 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；</li><li>二次握手:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态；</li><li>三次握手:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li></ul><p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ul><li>第一次挥手：客户端发送一个 FIN(SEQ&#x3D;x) 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li><li>第二次挥手：服务端收到这个 FIN(SEQ&#x3D;X) 标志的数据包，它发送一个 ACK (ACK&#x3D;x+1)标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li><li>第三次挥手：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li><li>第四次挥手：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ul><p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><a href="https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B">https://javaguide.cn/cs-basics/network/other-network-questions.html#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B</a><br><a href="https://learn.skyofit.com/archives/1313">https://learn.skyofit.com/archives/1313</a></p><ul><li>应用层、为计算机提供服务</li><li>表示层、数据处理(编码、解码、加密解密、压缩解压缩)</li><li>会话层、管理(建立、维护、重连)应用程序之间的会话</li><li>传输层、为两台主机进程之间的通信提供通用的数据传输服务</li><li>网络层、路由和寻址(决定数据在网络中的游走路径)</li><li>数据链路层、帧编码和误差纠正控制</li><li>物理层、透明地传送比特流传输</li></ul><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测开面经</title>
      <link href="/posts/17768.html"/>
      <url>/posts/17768.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：下面内容一部分来自于我舍友的博客</p></blockquote><h3 id="测开自我介绍"><a href="#测开自我介绍" class="headerlink" title="测开自我介绍"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>测试开发岗位</strong>。</p><p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p><p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p><p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p><h3 id="为什么选择测开"><a href="#为什么选择测开" class="headerlink" title="为什么选择测开"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p><blockquote><p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p></blockquote><h3 id="做过哪些关于测开的工作"><a href="#做过哪些关于测开的工作" class="headerlink" title="做过哪些关于测开的工作"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p><p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p><p>主要工作：</p><ul><li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li><li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li></ul><p>技术细节</p><ul><li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li><li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul><li>测试添加一个策略，添加多个策略</li><li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li><li>测试更新一个策略，测试更新多个策略。</li></ul></li></ul><p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>又叫功能测试，功能测试在测试工作中占有比例最大。 测试人员不需要了解软件的内部结构，只关心输入和输出之间的关系是否符合预期。 无法保证软件代码内各主要路径都被覆盖到，导致测试不完全。</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>又叫结构测试，测试人员对软件的内部结构和工作原理有深入的了解，针对软件代码和路径进行测试。 软件代码改变，测试用例也需要改变。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p><h3 id="测试用例的设计方法"><a href="#测试用例的设计方法" class="headerlink" title="测试用例的设计方法"></a>测试用例的设计方法</h3><ul><li>等价类划分：将输入数据划分为若干等价类，认为每个等价类中的所有数据都会引起相同的处理结果。</li><li>边界值分析：测试边界值</li><li>决策表测试：针对多个输入条件的复杂逻辑，构建决策表，通过表格的形式明切输入条件极其对应的输出结果</li><li>随机测试：随机生成输入数据进行测试</li></ul><h3 id="如何理解测试开发中的开发"><a href="#如何理解测试开发中的开发" class="headerlink" title="如何理解测试开发中的开发"></a>如何理解测试开发中的开发</h3><ul><li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li><li>编写自动化测试脚本： 测试开发人员使用编程语言（如Java、Python、JavaScript等）编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架（如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等）来组织和运行测试。</li><li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li><li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li><li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li></ul><h3 id="如何测试一个Java项目？"><a href="#如何测试一个Java项目？" class="headerlink" title="如何测试一个Java项目？"></a>如何测试一个Java项目？</h3><ul><li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li><li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li><li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li><li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li></ul><h3 id="如何判断所写接口功能正常？"><a href="#如何判断所写接口功能正常？" class="headerlink" title="如何判断所写接口功能正常？"></a>如何判断所写接口功能正常？</h3><ul><li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li><li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li><li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li><li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li></ul><h3 id="怎么构造无用测试用例？"><a href="#怎么构造无用测试用例？" class="headerlink" title="怎么构造无用测试用例？"></a>怎么构造无用测试用例？</h3><ul><li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li><li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li><li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li></ul><h3 id="如何感知线上项目出现问题"><a href="#如何感知线上项目出现问题" class="headerlink" title="如何感知线上项目出现问题"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p><h3 id="小红书购物搜索框设计测试用例"><a href="#小红书购物搜索框设计测试用例" class="headerlink" title="小红书购物搜索框设计测试用例"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p><ul><li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li></ul><p>测试用例名称：搜索框输入无效关键词</p><ul><li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面提示“未找到相关商品”。</li></ul><p>测试用例名称：搜索框输入空关键词</p><ul><li>输入：在搜索框中不输入任何内容。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面显示全部商品列表。</li></ul><p>测试用例名称：搜索框联想功能</p><ul><li>输入：在搜索框中输入部分关键词，例如“连衣”。</li><li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li><li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li></ul><p>测试用例名称：搜索框输入并选择联想词</p><ul><li>输入：在搜索框中输入部分关键词，例如“连衣”。</li><li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li><li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li></ul><p>测试用例名称：搜索框清空功能</p><ul><li>输入：在搜索框中输入关键词，例如“连衣裙”。</li><li>操作：点击搜索框右侧的清空按钮。</li><li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li></ul><h3 id="登录设计测试样例"><a href="#登录设计测试样例" class="headerlink" title="登录设计测试样例"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p><ul><li>输入：有效的用户名和密码。</li><li>操作：在登录页面输入用户名和密码，点击登录按钮。</li><li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li></ul><p>测试用例名称：输入无效的用户名和密码登录</p><ul><li>输入：无效的用户名和密码。</li><li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li></ul><p>测试用例名称：输入不存在的用户名登录</p><ul><li>输入：不存在的用户名和有效密码。</li><li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名不存在的错误信息。</li></ul><p>测试用例名称：输入正确的用户名和空密码登录</p><ul><li>输入：有效的用户名和空密码。</li><li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li><li>预期结果：登录失败，提示密码不能为空的错误信息。</li></ul><p>测试用例名称：输入空用户名和正确密码登录</p><ul><li>输入：空用户名和有效的密码。</li><li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名不能为空的错误信息。</li></ul><p>测试用例名称：输入特殊字符的用户名和密码登录</p><ul><li>输入：包含特殊字符的用户名和密码。</li><li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li></ul><p>测试用例名称：记住登录状态</p><ul><li>输入：有效的用户名和密码。</li><li>操作：在登录页面勾选“记住我”选项后登录。</li><li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li></ul><p>测试用例名称：登录页链接验证</p><ul><li>输入：无。</li><li>操作：检查登录页面上的链接。</li><li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li></ul><p>测试用例名称：跳转到登录页面</p><ul><li>输入：未登录状态。</li><li>操作：尝试访问需要登录权限的页面。</li><li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li></ul><p>测试用例名称：登录界面的响应速度</p><ul><li>输入：无。</li><li>操作：在不同网络环境下打开登录页面。</li><li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li></ul><h3 id="微信发送文件的测试用例"><a href="#微信发送文件的测试用例" class="headerlink" title="微信发送文件的测试用例"></a>微信发送文件的测试用例</h3><p>功能测试</p><ul><li>正常发送文件</li><li>发送支持的文件类型</li></ul><p>边界值测试</p><ul><li>发送最大允许大小的文件</li><li>发送超过最大允许大小的文件</li></ul><p>异常情况测试</p><ul><li>发送空文件</li><li>发送损坏文件</li><li>网络中断后重新发送</li></ul><p>性能测试</p><ul><li>同时发送多个文件</li><li>选择一个接近最大允许大小的文件</li></ul><p>用户体验测试</p><ul><li>发送文件时的用户提示</li><li>文件发送记录</li></ul><p>安全性测试</p><ul><li>发送包含敏感信息的文件</li><li>病毒文件检测</li></ul><p>跨平台测试</p><h3 id="微信发送红包的测试用例"><a href="#微信发送红包的测试用例" class="headerlink" title="微信发送红包的测试用例"></a>微信发送红包的测试用例</h3><ul><li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p></li><li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p></li><li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p></li><li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p></li></ul><p>用户体验测试</p><p>跨平台测试</p><p>性能测试</p><ul><li>高频发送红包</li><li>大规模红包领取（拼手气红包）</li></ul><h3 id="电影订票功能的测试样例"><a href="#电影订票功能的测试样例" class="headerlink" title="电影订票功能的测试样例"></a>电影订票功能的测试样例</h3><p>功能测试</p><ul><li>检查电影本身的信息和电影院（不同的电影院）、场次（不同的场次）、座位信息（已售出和可售状态）是否显示正确</li><li>验证不同支付方式是否可用</li><li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li></ul><p>边界和异常情况测试</p><ul><li>无效的账户或者账户余额不足进行支付</li><li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li></ul><p>性能测试</p><ul><li>系统负载测试：高并发访问</li><li>正常负载和高负载下的响应时间是否正常</li></ul><p>兼容性测试</p><h3 id="Github-Workflow自动化测试"><a href="#Github-Workflow自动化测试" class="headerlink" title="Github Workflow自动化测试"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p><ol><li><strong>持续集成（CI）：</strong> 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li><li><strong>持续部署（CD）：</strong> 自动将代码部署到生产环境或其他目标环境。</li><li><strong>代码分析和质量检查：</strong> 运行静态代码分析工具，以检查代码质量和一致性。</li><li><strong>构建和发布：</strong> 自动构建应用程序并发布构建产物，比如发布到包管理工具（如npm、PyPI）或者生成文档。</li><li><strong>自动化任务：</strong> 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li></ol><p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p><p><strong>示例：</strong></p><p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p><ol><li><strong>Checkout code</strong>：检出代码仓库。</li><li><strong>Set up Node.js</strong>：设置 Node.js 环境。</li><li><strong>Install dependencies</strong>：安装依赖。</li><li><strong>Run tests</strong>：运行测试。</li></ol><p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul><li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li><li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li><li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li><li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 测试开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端&amp;移动端面经</title>
      <link href="/posts/17767.html"/>
      <url>/posts/17767.html</url>
      
        <content type="html"><![CDATA[<p>this is a test file.</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 移动端 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端面经</title>
      <link href="/posts/17766.html"/>
      <url>/posts/17766.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href="https://javaguide.cn/">JavaGuide</a></p></blockquote><h2 id="简历相关"><a href="#简历相关" class="headerlink" title="简历相关"></a>简历相关</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p><p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p><p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><h3 id="Casbin明日之星实习"><a href="#Casbin明日之星实习" class="headerlink" title="Casbin明日之星实习"></a>Casbin明日之星实习</h3><ol><li><p>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</p></li><li><p>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</p></li><li><p>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</p></li></ol><h3 id="中科院开源之夏项目"><a href="#中科院开源之夏项目" class="headerlink" title="中科院开源之夏项目"></a>中科院开源之夏项目</h3><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问 性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p><p><strong>项目诉求</strong></p><ol><li><p>对微信第三方登录的移动端支持</p><ul><li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li></ul></li><li><p>对flutter、react-native、unity等sdk的开发及功能的增强</p><ul><li>对flutter-sdk的增强如第一点</li></ul></li><li><p>临时加上的开发casdoor-app诉求，对标Google Authenticator</p></li></ol><p><strong>技术细节</strong></p><ol><li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p><ul><li><p>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</p></li><li><p>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</p></li><li><p>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</p></li></ul></li></ol><p>接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p><ol start="2"><li>分为两部分<ol><li>casdoor-unity-example<ul><li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li><li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li><li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li><li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li></ul></li><li>casdoor-react-native-sdk、example<ul><li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li><li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li><li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li></ul></li></ol></li><li>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。<ul><li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li><li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li></ul></li></ol><blockquote><p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p></blockquote><p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p><h3 id="单点登录SSO原理"><a href="#单点登录SSO原理" class="headerlink" title="单点登录SSO原理"></a>单点登录SSO原理</h3><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p><p>在企业发展初期，涉及的系统不多，可能只需要一个系统就可以满足业务需求，用户只需要用账号密码登录这个系统就可以完成验证。但是随着企业发展，业务也变得越来越多，随之演变越来越多的子系统，用户每进一个系统都可能需要登录一次，才能进行相关操作。为了解决这类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他系统再次登录，就可以得到其他所有系统的信任。</p><p>流程：</p><ol><li>用户访问app系统，而app需要登录，假设这个时候用户没用登录，则系统会触发一个302的重定向请求，转到CAS server，也就是SSO登录系统。 SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。 验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li><li>此时当用户访问app2系统，app2系统没有登录会跳转到SSO，由于SSO在访问app系统的时候已经是登录态了，所以不需要重新登录验证，也就是不用输入账号密码。这个时候SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li></ol><p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p><h3 id="OAuth-2-0原理"><a href="#OAuth-2-0原理" class="headerlink" title="OAuth 2.0原理"></a>OAuth 2.0原理</h3><p><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p><p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。 OAuth 2 为 Web 和桌面应用程序以及移动设备提供授权流程。</p><p>定义了4种角色：</p><ul><li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li><li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由 API 进行验证。</li><li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li><li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li></ul><p>步骤：</p><ol><li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。</li><li>如果用户授权该请求，应用程序会收到授权准许(<code>Authorization Grant</code>)。</li><li>应用程序通过提供其自身的身份验证和授权准许(<code>Authorization Grant</code>)来向授权服务器 (API) 请求访问令牌(<code>access_token</code>)。</li><li>如果应用程序身份通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器(API)向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li><li>应用程序从资源服务器(API)请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li><li>如果访问令牌(<code>access_token</code>)有效，则资源服务器 (API) 向应用程序提供资源。</li></ol><p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth 2 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p><ol><li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li><li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li><li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li></ol><h3 id="Casbin-Casdoor-介绍"><a href="#Casbin-Casdoor-介绍" class="headerlink" title="Casbin Casdoor 介绍"></a>Casbin Casdoor 介绍</h3><blockquote><p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p><ol><li><strong>多种访问控制模型支持</strong>：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li><li><strong>灵活的策略管理</strong>：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li><li><strong>细粒度的权限控制</strong>：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li><li><strong>跨语言支持</strong>：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li></ol></blockquote><blockquote><p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p><ol><li>**单点登录(SSO)**：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li><li><strong>用户管理</strong>：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li><li><strong>权限控制</strong>：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li><li><strong>开源社区</strong>：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li></ol></blockquote><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><blockquote><p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p><ul><li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li><li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li><li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li><li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li><li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li></ul><p>特点：</p><ul><li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li><li>标准化操作：利用HTTP动词来描述对资源的操作。 </li><li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li><li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li><li>无状态交互：每个请求独立，不依赖于之前的请求。</li></ul><p>优点 </p><ul><li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li><li>性能高：无状态和可缓存性提高了性能。 </li><li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li><li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li></ul><p>缺点 </p><ul><li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li><li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li><li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li></ul><p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p></blockquote><h3 id="国家电网项目"><a href="#国家电网项目" class="headerlink" title="国家电网项目"></a>国家电网项目</h3><p><strong>简介</strong></p><p>自己导师接的项目，江苏省国家电网智能诊断数据分析平台</p><p><strong>项目诉求</strong></p><ul><li>对相应指标进行增删改查</li><li>可以导入、导出一些excel表格</li><li>对数据进行智能诊断分析</li></ul><p><strong>技术细节</strong></p><p>react、Antd、Flask、mongodb</p><h3 id="江南布衣实习"><a href="#江南布衣实习" class="headerlink" title="江南布衣实习"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p><ol><li><p><strong>新入职员工设备管理</strong>：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p></li><li><p><strong>离职员工设备回收和资料销毁</strong>：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p></li><li><p><strong>订货会期间设备组装和网络连接</strong>：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p></li><li><p><strong>员工设备报修响应与问题解决</strong>：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p></li></ol><p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p><blockquote><p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p><ol><li><strong>网络配置</strong>：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li><li><strong>身份验证</strong>：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li><li><strong>访问内部资源</strong>：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li></ol></blockquote><h3 id="印象最深的一个项目"><a href="#印象最深的一个项目" class="headerlink" title="印象最深的一个项目"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 async-sqlalchemy-adapter，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p><p><strong>亮点</strong></p><ol><li><p><strong>异步支持</strong>：</p><ul><li><strong>亮点</strong>：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li><li><strong>回答</strong>：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li></ul></li><li><p><strong>灵活的过滤机制</strong>：</p><ul><li><strong>亮点</strong>：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li><li><strong>回答</strong>：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li></ul></li><li><p><strong>可扩展性</strong>：</p><ul><li><strong>亮点</strong>：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li><li><strong>回答</strong>：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li></ul></li><li><p><strong>事务处理</strong>：</p><ul><li><strong>亮点</strong>：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li><li><strong>回答</strong>：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li></ul></li></ol><p><strong>难点</strong></p><ol><li><strong>异步编程的复杂性</strong>：<ul><li><strong>难点</strong>：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li><li><strong>回答</strong>：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li></ul></li><li><strong>数据库模型的灵活性与一致性</strong>：<ul><li><strong>难点</strong>：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li><li><strong>回答</strong>：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li></ul></li><li><strong>复杂的策略更新逻辑</strong>：<ul><li><strong>难点</strong>：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li><li><strong>回答</strong>：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li></ul></li><li><strong>高效的批量操作</strong>：<ul><li><strong>难点</strong>：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li><li><strong>回答</strong>：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li></ul></li></ol><p>测试方面</p><ul><li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li><li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li></ul><p>技术细节</p><ul><li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li><li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul><li>测试添加一个策略，添加多个策略</li><li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li><li>测试更新一个策略，测试更新多个策略。</li></ul></li></ul><p>通过强调这些亮点和难点，可以展示你在该项目中的成就和技术深度，突出你在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li><li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li><li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li><li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li></ul><blockquote><p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p></blockquote><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p><code>&lt;&lt;</code>: 左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>: 带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>: 无符号右移，忽略符号位，空位都以 0 补齐。</p><p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p><h3 id="基本数据类型-包装类型-及区别"><a href="#基本数据类型-包装类型-及区别" class="headerlink" title="基本数据类型&#x2F;包装类型 及区别"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code></li></ul><blockquote><p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>: 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>: 双引号。</p></blockquote><p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p><strong>区别</strong></p><ul><li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li><li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li><li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h3 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p><h3 id="如何解决浮点数运算的精度丢失问题"><a href="#如何解决浮点数运算的精度丢失问题" class="headerlink" title="如何解决浮点数运算的精度丢失问题"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p><h3 id="局部变量-成员变量-静态变量"><a href="#局部变量-成员变量-静态变量" class="headerlink" title="局部变量&#x2F;成员变量&#x2F;静态变量"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul><li>语法形式：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li></ul><p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><ul><li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ul></li></ul><h3 id="面向对象和面向过程区别"><a href="#面向对象和面向过程区别" class="headerlink" title="面向对象和面向过程区别"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h3 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h3><p>共同点: 都不能被实例化<br><a href="https://learn.skyofit.com/archives/351">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p><ul><li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li><li>抽象类可以有构造方法，接口不能有构造方法。</li><li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li><li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li><li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li><li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li></ul><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p><a href="https://blog.csdn.net/qq_44944221/article/details/126692973">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p><ul><li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li><li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li></ul><p>区别:</p><ul><li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li><li>共享性不同：栈是线程私有，而堆是线程共享；</li><li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li><li>空间大小不同：堆空间大小远远大于栈的内存空间。</li></ul><h3 id="深拷贝-浅拷贝-引用拷贝"><a href="#深拷贝-浅拷贝-引用拷贝" class="headerlink" title="深拷贝&#x2F;浅拷贝&#x2F;引用拷贝"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul><li>深拷贝: 完全复制整个对象，包括这个对象所包含的内部对象。</li><li>浅拷贝: 浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>引用拷贝: 引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li></ul><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li><li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li><li>线程安全的懒汉式<ul><li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li><li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li></ul></li><li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li><li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class="line">                <span class="comment">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 注意 上面不是 class 是 enum</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singelton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        singleton.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参-实参"><a href="#形参-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h3><ul><li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li><li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li></ul><h3 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h3><ul><li>值传递：方法接收的是实参值的拷贝，会创建副本。</li><li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>Java 中只有值传递，C++ 中有值传递和引用传递。</p><h3 id="和equals-区别"><a href="#和equals-区别" class="headerlink" title="&#x3D;&#x3D;和equals()区别"></a>&#x3D;&#x3D;和equals()区别</h3><ul><li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul><li>基本数据类型：比较的是值是否相等</li><li>引用数据类型：比较的是引用地址是否相等</li><li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li></ul></li><li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul><li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li><li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li></ul></li></ul><h3 id="hashCode-和equal"><a href="#hashCode-和equal" class="headerlink" title="hashCode()和equal()"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li></ul><p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String&#x2F;StringBuffer&#x2F;StringBuilder"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul><li><p><code>String</code> : 字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p></li><li><p><code>StringBuffer</code> : 字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p></li><li><p><code>StringBuilder</code> : 字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p></li><li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p></li><li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p></li><li><p><code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li></ul><p>** <code>String</code> 为什么不可变？**</p><ul><li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，并且 <code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ul><h3 id="字符串拼接使用-还是StringBuilder？"><a href="#字符串拼接使用-还是StringBuilder？" class="headerlink" title="字符串拼接使用+还是StringBuilder？"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p><h3 id="String-equals-Object-equals"><a href="#String-equals-Object-equals" class="headerlink" title="String.equals()&#x2F;Object.equals()"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>: 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>: 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p><h3 id="Checked-Unchecked-Exception"><a href="#Checked-Unchecked-Exception" class="headerlink" title="Checked&#x2F;Unchecked Exception"></a>Checked&#x2F;Unchecked Exception</h3><ul><li><code>Checked Exception</code>即受检查异常 ，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<ul><li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常 。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li></ul></li><li><code>Unchecked Exception</code> 即不受检查异常 ，在编译过程中 ，即使不处理也可以正常通过编译。<ul><li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li></ul></li></ul><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p><blockquote><p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>使用泛型参数，可以增强代码的可读性以及稳定性。</li><li>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p><ul><li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li><li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h3 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List-Set-Queue-Map区别"><a href="#List-Set-Queue-Map区别" class="headerlink" title="List&#x2F;Set&#x2F;Queue&#x2F;Map区别"></a>List&#x2F;Set&#x2F;Queue&#x2F;Map区别</h3><ul><li>List: 存储的元素是有序的、可重复的。</li><li>Set: 存储的元素不可重复的。</li><li>Queue: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map: 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p><ul><li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选用 <code>ConcurrentHashMap</code> 。</li><li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li></ul><h3 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p><h3 id="ArrayList和Array区别"><a href="#ArrayList和Array区别" class="headerlink" title="ArrayList和Array区别"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p><ul><li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li><li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li><li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li><li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><blockquote><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p></blockquote><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><ul><li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul><li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li><li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li></ul></li><li>二者都是线程不安全的。</li><li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li><li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li></ul><blockquote><p>项目中一般不会使用 <code>LinkedList</code>。</p></blockquote><h3 id="ArrayList和LinkedList插入-删除效率"><a href="#ArrayList和LinkedList插入-删除效率" class="headerlink" title="ArrayList和LinkedList插入&#x2F;删除效率"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p><ul><li>头部插入&#x2F;删除：O(n), 需要移动元素。</li><li>指定位置插入&#x2F;删除：O(n), 需要移动元素。</li><li>尾部插入&#x2F;删除：O(1), 直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。<br><code>LinkedList</code></li><li>头部插入&#x2F;删除：O(1), 只需改变指针指向。</li><li>尾部插入&#x2F;删除：O(1), 只需改变指针指向。</li><li>指定位置插入&#x2F;删除：O(n), 需要先移动到指定位置再插入和删除。</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p><ul><li><strong>读多写少</strong>：大部分操作都是读取数据，写操作相对较少。</li><li><strong>不要求实时性</strong>：因为写操作需要创建数组副本，可能会有短暂的延迟。</li></ul><p><code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p><p><strong>优点</strong></p><ul><li><strong>线程安全</strong>：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li><li><strong>简化并发控制</strong>：不需要显式的同步块或锁定机制。</li><li><strong>迭代器安全</strong>：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li></ul><p><strong>缺点</strong></p><ul><li><strong>内存开销大</strong>：每次写操作都会创建数组副本，可能会占用较多的内存。</li><li><strong>写操作开销大</strong>：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li><li><strong>读取旧数据</strong>：在高并发场景下，可能会读取到旧的数据。</li></ul><p><strong>适用场景</strong></p><ul><li>配置类数据：如系统配置参数、常量集合等。</li><li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li></ul><p><strong>不适用场景</strong></p><ul><li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li><li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li></ul><p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。但对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p><h3 id="HashSet-LinkedHashSet-TreeSet"><a href="#HashSet-LinkedHashSet-TreeSet" class="headerlink" title="HashSet&#x2F;LinkedHashSet&#x2F;TreeSet"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul><li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li><li>主要区别在于底层数据结构不同。<ul><li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li><li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li><li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h3 id="Map-重要"><a href="#Map-重要" class="headerlink" title="Map(重要)"></a>Map(重要)</h3><h3 id="HashMap-HashTable区别"><a href="#HashMap-HashTable区别" class="headerlink" title="HashMap&#x2F;HashTable区别"></a>HashMap&#x2F;HashTable区别</h3><ul><li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li><li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li><li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li><li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和value，否则会报错<code>NullPointerException</code>。</li><li>初始容量大小和每次扩充容量大小的不同： <ul><li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li><li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li></ul></li></ul><blockquote><p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p></blockquote><h3 id="HashMap长度为什么是2的幂次方"><a href="#HashMap长度为什么是2的幂次方" class="headerlink" title="HashMap长度为什么是2的幂次方"></a>HashMap长度为什么是2的幂次方</h3><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p><p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p><h3 id="HashMap-TreeMap区别"><a href="#HashMap-TreeMap区别" class="headerlink" title="HashMap&#x2F;TreeMap区别"></a>HashMap&#x2F;TreeMap区别</h3><ul><li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li><li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li><li><code>HashMap</code> 的键值对允许有一个 <code>null</code> 键和多个 <code>null</code> 值，<code>TreeMap</code> 不允许有 <code>null</code> 键，但允许有 <code>null</code> 值。</li><li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li></ul><p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在add()方法的返回值处返回插入前是否存在相同元素。</p><h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p><p><code>HashMap</code> 通过 key 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p><ul><li>扰动函数 <code>hash()</code> 可以减少碰撞。</li><li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li><li>“拉链法”中，数组的 index 就是通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li></ul><p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p><ul><li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li><li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li></ul><h3 id="HashMap多线程扩容死循环问题"><a href="#HashMap多线程扩容死循环问题" class="headerlink" title="HashMap多线程扩容死循环问题"></a>HashMap多线程扩容死循环问题</h3><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p><blockquote><p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p></blockquote><h3 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h3><ul><li>JDK1.7及之前版本，存在多线程扩容死循环问题，如上。</li><li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。</li></ul><p><strong>数据丢失</strong><br>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><blockquote><p>例子：<br>线程 1,2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></blockquote><h3 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a>遍历HashMap</h3><p>七种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ForEach EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ForEach KeySet</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器EntrySet</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器KeySet</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Streams API 单线程</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Streams API 多线程</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="ConcurrentHashMap-Hashtable区别"><a href="#ConcurrentHashMap-Hashtable区别" class="headerlink" title="ConcurrentHashMap&#x2F;Hashtable区别"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul><li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong> 。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li><li>实现线程安全的方式：<ul><li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li><li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li></ul></li></ul><h3 id="ConcurrentHashMap底层"><a href="#ConcurrentHashMap底层" class="headerlink" title="ConcurrentHashMap底层"></a>ConcurrentHashMap底层</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为**<code>Segment</code>数组+<code>HashEntry</code>数组+链表** 。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p><p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，**<code>Node</code>数组+链表&#x2F;红黑二叉树** 。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p><h3 id="JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？"><a href="#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul><li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li>Hash 碰撞解决方法 : JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li><li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap能保证复合操作的原子性吗？"><a href="#ConcurrentHashMap能保证复合操作的原子性吗？" class="headerlink" title="ConcurrentHashMap能保证复合操作的原子性吗？"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul><li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li><li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li></ul><h3 id="什么是LinkedHashMap"><a href="#什么是LinkedHashMap" class="headerlink" title="什么是LinkedHashMap"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性:</p><ul><li>支持遍历时会按照插入顺序有序进行迭代</li><li>支持按照元素访问顺序排序,<em><strong>适用于封装 LRU 缓存工具</strong></em> 。</li><li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li></ul><blockquote><p>在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p></blockquote><h3 id="LinkedHashMap如何按照访问顺序迭代元素？"><a href="#LinkedHashMap如何按照访问顺序迭代元素？" class="headerlink" title="LinkedHashMap如何按照访问顺序迭代元素？"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p><h3 id="如何实现LRU缓存"><a href="#如何实现LRU缓存" class="headerlink" title="如何实现LRU缓存"></a>如何实现LRU缓存</h3><ul><li><code>accessOrder</code> &#x3D; <code>true</code> </li><li>继承<code>LinkedHashMap</code></li><li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">1f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedHashMap和HashMap的区别"><a href="#LinkedHashMap和HashMap的区别" class="headerlink" title="LinkedHashMap和HashMap的区别"></a>LinkedHashMap和HashMap的区别</h3><ul><li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li><li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li></ul><h3 id="Queue-Deque区别"><a href="#Queue-Deque区别" class="headerlink" title="Queue&#x2F;Deque区别"></a>Queue&#x2F;Deque区别</h3><ul><li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li><li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li></ul><h3 id="ArrayDeque-LinkedList区别"><a href="#ArrayDeque-LinkedList区别" class="headerlink" title="ArrayDeque&#x2F;LinkedList区别"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul><li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li><li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><blockquote><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p></blockquote><h3 id="BlockingQueue及其实现类"><a href="#BlockingQueue及其实现类" class="headerlink" title="BlockingQueue及其实现类"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p><p><strong>实现类</strong></p><ul><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue不同的是， 它仅支持非公平的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li><li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li><li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li></ul><h3 id="ArrayBlockingQueue实现原理"><a href="#ArrayBlockingQueue实现原理" class="headerlink" title="ArrayBlockingQueue实现原理"></a>ArrayBlockingQueue实现原理</h3><ul><li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li><li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li><li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li></ul><p>线程间的等待和唤醒具体的实现：</p><ul><li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li><li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li><li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li><li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li></ul><h3 id="ArrayBlockingQueue-LinkedBlockingQueue区别"><a href="#ArrayBlockingQueue-LinkedBlockingQueue区别" class="headerlink" title="ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul><h3 id="DelayQueue底层"><a href="#DelayQueue底层" class="headerlink" title="DelayQueue底层"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p><p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁，实现线程安全的关键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;E&gt;();</span><br><span class="line"><span class="comment">//指向准备执行优先级最高的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//实现多线程之间等待唤醒的交互</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p><code>leader</code> : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code> : 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p></blockquote><h3 id="DelayQueue是否线程安全？"><a href="#DelayQueue是否线程安全？" class="headerlink" title="DelayQueue是否线程安全？"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p><h3 id="DelayQueue使用场景"><a href="#DelayQueue使用场景" class="headerlink" title="DelayQueue使用场景"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p><ul><li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li><li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li></ul><h3 id="DelayQueue中Delayed接口的作用是什么？"><a href="#DelayQueue中Delayed接口的作用是什么？" class="headerlink" title="DelayQueue中Delayed接口的作用是什么？"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口),否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p><h3 id="DelayQueue-Timer-TimerTask区别"><a href="#DelayQueue-Timer-TimerTask区别" class="headerlink" title="DelayQueue&#x2F;Timer&#x2F;TimerTask区别"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p><ul><li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li><li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li><li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li></ul><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程&#x2F;线程&#x2F;协程"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href="https://blog.csdn.net/m0_60505735/article/details/131047046">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href="https://blog.csdn.net/weixin_49199646/article/details/109210547">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p><ul><li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li><li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li><li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li></ul><p><strong>进程与线程的区别</strong></p><ul><li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ul><p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p><p><em>进程与线程的选择</em>*</p><ul><li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li><li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li><li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li><li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li></ul><p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p><h3 id="Java线程和操作系统线程有何区别"><a href="#Java线程和操作系统线程有何区别" class="headerlink" title="Java线程和操作系统线程有何区别"></a>Java线程和操作系统线程有何区别</h3><p>现在的 Java 线程的本质其实就是操作系统的线程。</p><ul><li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li><li>JDK 1.2 及以后，Java 线程改为基于原生线程(Native Threads)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li></ul><p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p><h3 id="程序计数器为啥是私有的"><a href="#程序计数器为啥是私有的" class="headerlink" title="程序计数器为啥是私有的"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li><li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li></ul><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h3 id="虚拟机栈和本地方法栈为啥是私有的"><a href="#虚拟机栈和本地方法栈为啥是私有的" class="headerlink" title="虚拟机栈和本地方法栈为啥是私有的"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul><li>虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h3><ul><li>继承<code>Thread</code>类并重写<code>run()</code>方法</li><li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li><li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li><li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li><li>等等……</li></ul><p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p>Java 线程 6 种状态：<br><code>NEW</code>: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，比如上文所说到过的程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完(因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="Thread-sleep-方法和Object-wait-方法对比"><a href="#Thread-sleep-方法和Object-wait-方法对比" class="headerlink" title="Thread.sleep()方法和Object.wait()方法对比"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p><ul><li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁 。</li><li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li><li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><h3 id="锁的基本概念"><a href="#锁的基本概念" class="headerlink" title="锁的基本概念"></a>锁的基本概念</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p><h3 id="为什么wait-方法不定义在Thread中"><a href="#为什么wait-方法不定义在Thread中" class="headerlink" title="为什么wait()方法不定义在Thread中"></a>为什么wait()方法不定义在Thread中</h3><ul><li>锁是对象级别的，每个对象都有一把锁。</li><li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li></ul><h3 id="为什么sleep-方法定义在Thread中"><a href="#为什么sleep-方法定义在Thread中" class="headerlink" title="为什么sleep()方法定义在Thread中"></a>为什么sleep()方法定义在Thread中</h3><ul><li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li><li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li></ul><h3 id="sleep-如何控制当前线程沉睡"><a href="#sleep-如何控制当前线程沉睡" class="headerlink" title="sleep()如何控制当前线程沉睡"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p><h3 id="可以直接调用Thread类的run方法吗"><a href="#可以直接调用Thread类的run方法吗" class="headerlink" title="可以直接调用Thread类的run方法吗"></a>可以直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p><h3 id="并发-并行区别"><a href="#并发-并行区别" class="headerlink" title="并发&#x2F;并行区别"></a>并发&#x2F;并行区别</h3><ul><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h3 id="同步-异步区别"><a href="#同步-异步区别" class="headerlink" title="同步&#x2F;异步区别"></a>同步&#x2F;异步区别</h3><ul><li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><ul><li>线程切换和调度的成本远远小于进程。</li><li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li><li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li><li>并发编程是当代互联网发展趋势(现在的系统动不动就要求百万级甚至千万级的并发量)。</li></ul><h3 id="使用多线程风险"><a href="#使用多线程风险" class="headerlink" title="使用多线程风险"></a>使用多线程风险</h3><ul><li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li><li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li><li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li><li>上下文切换：线程频繁切换，会增加系统开销。</li><li>…</li></ul><h3 id="如何理解线程安全和不安全"><a href="#如何理解线程安全和不安全" class="headerlink" title="如何理解线程安全和不安全"></a>如何理解线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h3 id="单核CPU上运行多个线程效率一定会高吗"><a href="#单核CPU上运行多个线程效率一定会高吗" class="headerlink" title="单核CPU上运行多个线程效率一定会高吗"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><blockquote><p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p></blockquote><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul><h3 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h3><ul><li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li><li>jConsole: 可以检测死锁，查看线程的状态。</li><li>jstack: 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li></ul><h3 id="如何预防和避免死锁"><a href="#如何预防和避免死锁" class="headerlink" title="如何预防和避免死锁"></a>如何预防和避免死锁</h3><p>破坏死锁的产生的必要条件：</p><ul><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong> )对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p>安全状态 指的是系统能够按照某种线程推进顺序(P1、P2、P3……Pn)来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 &lt;P1、P2、P3…..Pn&gt; 序列为安全序列。</p></blockquote><h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p><h3 id="为什么需要Java内存模型"><a href="#为什么需要Java内存模型" class="headerlink" title="为什么需要Java内存模型"></a>为什么需要Java内存模型</h3><ul><li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li><li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li><li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li></ul><h3 id="Java内存区域和Java内存模型有什么区别"><a href="#Java内存区域和Java内存模型有什么区别" class="headerlink" title="Java内存区域和Java内存模型有什么区别"></a>Java内存区域和Java内存模型有什么区别</h3><ul><li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li><li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li></ul><h3 id="JMM是如何抽象线程和主内存之间的关系"><a href="#JMM是如何抽象线程和主内存之间的关系" class="headerlink" title="JMM是如何抽象线程和主内存之间的关系"></a>JMM是如何抽象线程和主内存之间的关系</h3><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及happens-before规则，来保证多线程程序的正确性和可预测性。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><ul><li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li><li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li></ul><h3 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h3><p>可见性、原子性和有序性</p><ul><li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li><li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li><li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li></ul><p>JMM通过上面三种属性来确保线程之间的内存一致性。</p><h3 id="如何保证变量的可见性-volatile"><a href="#如何保证变量的可见性-volatile" class="headerlink" title="如何保证变量的可见性(volatile)"></a>如何保证变量的可见性(volatile)</h3><p><code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><h3 id="如何禁止指令重排序"><a href="#如何禁止指令重排序" class="headerlink" title="如何禁止指令重排序"></a>如何禁止指令重排序</h3><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p><h3 id="volatile可以保证原子性"><a href="#volatile可以保证原子性" class="headerlink" title="volatile可以保证原子性"></a>volatile可以保证原子性</h3><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h3><ul><li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul><li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li><li>悲观锁可能会存在死锁问题。</li><li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li></ul></li><li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul><li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li><li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li><li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul><li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li></ul></li><li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li></ul></li></ul><h3 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h3><ul><li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li><li>CAS算法：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul><li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li></ul></li></ul><blockquote><p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题)。i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p></blockquote><h3 id="CAS算法存在问题"><a href="#CAS算法存在问题" class="headerlink" title="CAS算法存在问题"></a>CAS算法存在问题</h3><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p><p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p><p><strong>循环时间长开销大</strong><br>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p><p><strong>只能保证一个共享变量的原子操作</strong><br>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h3 id="JDK1-6之后synchronized的优化"><a href="#JDK1-6之后synchronized的优化" class="headerlink" title="JDK1.6之后synchronized的优化"></a>JDK1.6之后synchronized的优化</h3><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p><h3 id="锁升级原理了解吗"><a href="#锁升级原理了解吗" class="headerlink" title="锁升级原理了解吗"></a>锁升级原理了解吗</h3><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="如何使用synchronized"><a href="#如何使用synchronized" class="headerlink" title="如何使用synchronized"></a>如何使用synchronized</h3><ul><li>修饰实例方法：锁住当前实例对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修饰静态方法：锁住当前类的 Class 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修饰代码块：锁住括号里面的对象。<ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">    //业务代码</span><br><span class="line">&#125;</span><br><span class="line">synchronized(类.class) &#123;</span><br><span class="line">    //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p><ul><li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li><li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li></ul><p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p><p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p><blockquote><p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p></blockquote><h3 id="AQS资源共享模式"><a href="#AQS资源共享模式" class="headerlink" title="AQS资源共享模式"></a>AQS资源共享模式</h3><p>AQS 支持两种资源共享方式：独占和共享。</p><ul><li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li><li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li></ul><blockquote><p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p></blockquote><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p><h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h3><ul><li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h3 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h3><p>两者都是可重入锁</p><ul><li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li><li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li><li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能:<ul><li>等待可中断 : <code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li><li>可实现公平锁: <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li>可实现选择性通知(锁可以绑定多个条件): <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul></li></ul><blockquote><p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p></blockquote><h3 id="可中断锁-不可中断锁"><a href="#可中断锁-不可中断锁" class="headerlink" title="可中断锁&#x2F;不可中断锁"></a>可中断锁&#x2F;不可中断锁</h3><ul><li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li></ul><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁) 。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><blockquote><p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p></blockquote><h3 id="共享锁-独占锁"><a href="#共享锁-独占锁" class="headerlink" title="共享锁&#x2F;独占锁"></a>共享锁&#x2F;独占锁</h3><ul><li>共享锁：一把锁可以被多个线程同时获得。</li><li>独占锁：一把锁只能被一个线程获得。</li></ul><h3 id="线程持有读锁还能获取写锁吗"><a href="#线程持有读锁还能获取写锁吗" class="headerlink" title="线程持有读锁还能获取写锁吗"></a>线程持有读锁还能获取写锁吗</h3><ul><li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li></ul><h3 id="读锁为什么不能升级为写锁"><a href="#读锁为什么不能升级为写锁" class="headerlink" title="读锁为什么不能升级为写锁"></a>读锁为什么不能升级为写锁</h3><ul><li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li><li>可能会有死锁问题发生。</li></ul><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p><p>提供三种访问模式：</p><ul><li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。</li><li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。</li><li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p><blockquote><p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况: 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p></blockquote><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><blockquote><p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><blockquote><p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><h3 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h3><ul><li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li><li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul><li><code>FixedThreadPool</code>：固定大小的线程池。</li><li><code>SingleThreadPool</code>：只有一个线程的线程池。</li><li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li><li><code>ScheduledThreadPool</code>：定时任务的线程池。</li></ul></li></ul><h3 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h3><ul><li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li></ul><h3 id="ThreadPoolExecutor参数"><a href="#ThreadPoolExecutor参数" class="headerlink" title="ThreadPoolExecutor参数"></a>ThreadPoolExecutor参数</h3><p>3 个最重要的参数：</p><ul><li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>其他常见参数 :</p><ul><li>keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :executor 创建新线程的时候会用到。</li><li>handler :拒绝策略,当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li></ul><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><ul><li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li><li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li><li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li></ul><h3 id="CallerRunsPolicy策略风险及解决方案"><a href="#CallerRunsPolicy策略风险及解决方案" class="headerlink" title="CallerRunsPolicy策略风险及解决方案"></a>CallerRunsPolicy策略风险及解决方案</h3><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p><p><strong>解决方案</strong></p><ol><li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li><li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li></ol><h3 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h3><ul><li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li><li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h3 id="线程池处理任务流程"><a href="#线程池处理任务流程" class="headerlink" title="线程池处理任务流程"></a>线程池处理任务流程</h3><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li></ol><h3 id="线程池中线程异常后销毁还是复用？"><a href="#线程池中线程异常后销毁还是复用？" class="headerlink" title="线程池中线程异常后销毁还是复用？"></a>线程池中线程异常后销毁还是复用？</h3><p>两种情况：</p><ul><li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li><li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li></ul><h3 id="如何设定线程池大小"><a href="#如何设定线程池大小" class="headerlink" title="如何设定线程池大小"></a>如何设定线程池大小</h3><ul><li>CPU 密集型任务(N+1)： 将线程数设置为 N(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li><li>I&#x2F;O 密集型任务(2N)： 这种情况系统大部分的时间用来处理 I&#x2F;O 交互，此时可以将 CPU 交出给其它线程使用，可以多配些线程。</li></ul><h3 id="如何设计一个根据任务优先级执行的线程池"><a href="#如何设计一个根据任务优先级执行的线程池" class="headerlink" title="如何设计一个根据任务优先级执行的线程池"></a>如何设计一个根据任务优先级执行的线程池</h3><ul><li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ul><p>这样还存在一些问题：</p><ul><li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul><li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 &#96;false 。</li></ul></li><li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul><li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li></ul></li></ul><h3 id="异步调用Future类"><a href="#异步调用Future类" class="headerlink" title="异步调用Future类"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用傻傻等待耗时任务执行完成。等事情干完后，再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// V 代表了Future执行的任务返回值的类型</span><br><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    // 取消任务执行，成功取消返回 true，否则返回 false</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    // 判断任务是否被取消</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    // 判断任务是否已经执行完成</span><br><span class="line">    boolean isDone();</span><br><span class="line">    // 获取任务执行结果</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable和Future关系"><a href="#Callable和Future关系" class="headerlink" title="Callable和Future关系"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p><ul><li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li><li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li></ul><h3 id="CompletableFuture类有什么用？"><a href="#CompletableFuture类有什么用？" class="headerlink" title="CompletableFuture类有什么用？"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p><h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h3><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p><p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p><p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p><strong>优点</strong></p><ul><li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li><li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li><li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li></ul><p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p><p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream/Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream/Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="Java为什么要分字节流和字符流"><a href="#Java为什么要分字节流和字符流" class="headerlink" title="Java为什么要分字节流和字符流"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p><ul><li>字符流自动处理字符编码问题，非常适合文本数据；</li><li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li></ul><h3 id="字节流和字符流区别"><a href="#字节流和字符流区别" class="headerlink" title="字节流和字符流区别"></a>字节流和字符流区别</h3><ul><li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li><li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li><li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li></ul><h3 id="IO设计模式总结"><a href="#IO设计模式总结" class="headerlink" title="IO设计模式总结"></a>IO设计模式总结</h3><ul><li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li><li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li><li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li><li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li></ul><h3 id="装饰器模式和适配器模式区别"><a href="#装饰器模式和适配器模式区别" class="headerlink" title="装饰器模式和适配器模式区别"></a>装饰器模式和适配器模式区别</h3><ul><li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li><li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li></ul><h3 id="3种常见的IO模型"><a href="#3种常见的IO模型" class="headerlink" title="3种常见的IO模型"></a>3种常见的IO模型</h3><ul><li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul><li>优点：编程简单，代码易于理解。</li><li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li></ul></li><li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul><li>优点：单线程可以处理多个连接，提高并发性能。</li><li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li></ul></li><li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul><li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li><li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li></ul></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>Java内存区域通常被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p><p>线程私有的内存区域包括：</p><ul><li><strong>程序计数器</strong>：<ul><li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li><li>如果正在执行的是本地方法，这个计数器是未指定值(undefined)。</li></ul></li><li><strong>Java虚拟机栈</strong>：<ul><li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li><li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li></ul></li><li><strong>本地方法栈</strong>：<ul><li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li><li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li></ul></li></ul><p>线程共享的内存区域包括：</p><ul><li><strong>堆</strong>：<ul><li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li><li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li><li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul><li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li></ul></li></ul></li><li><strong>方法区</strong>：<ul><li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li></ul></li><li><strong>运行时常量池</strong>：<ul><li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li><li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li></ul></li></ul><p>本地内存：</p><ul><li>直接内存：<ul><li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li><li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li><li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li></ul></li></ul><p><strong>内存模型与内存管理</strong></p><ul><li>**内存模型(Java Memory Model, JMM)**：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li><li>**垃圾收集(Garbage Collection, GC)**：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li></ul><p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p><h3 id="对象的创建过程-5步"><a href="#对象的创建过程-5步" class="headerlink" title="对象的创建过程(5步)"></a>对象的创建过程(5步)</h3><ol><li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li><li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li>执行 init 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域: </p><ul><li>对象头(<code>Header</code>): <ul><li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul></li><li>实例数据(<code>Instance Data</code>): 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li><li>对齐填充(<code>Padding</code>): 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p><ul><li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li><li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li></ul><p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p><p><strong>堆空间结构</strong><br>堆内存是垃圾回收的主要区域，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p><p><strong>内存分配和回收原则</strong></p><ul><li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li><li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li><li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li></ul><p>垃圾回收的基本步骤分两步：</p><ul><li>查找内存中不再使用的对象(GC判断策略)</li><li>释放这些对象占用的内存(GC收集算法)</li></ul><p><strong>死亡对象&#x2F;GC判断策略</strong></p><ul><li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul><li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li></ul></li><li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul><li>这些对象可以用作 GC Roots: <ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI(Java Native Interface)引用的对象</li></ul></li></ul></li></ul><blockquote><p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p></blockquote><p><strong>垃圾回收算法</strong></p><ul><li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul><li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li></ul></li><li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul><li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li></ul></li><li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul><li>问题：整理的过程效率也不高。</li></ul></li><li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li></ul><p><strong>垃圾回收器</strong><br>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20: G1(Garbage-First)收集器</p><ul><li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。。Serial 收集器适用于单核处理器和小内存的环境。</li><li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。</li><li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。</li><li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。</li><li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。</li><li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。</li><li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。</li><li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。</li></ul><blockquote><p>HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><ul><li>部分收集 (<code>Partial GC</code>)：<ul><li>新生代收集(Minor GC &#x2F; Young GC)：只对新生代进行垃圾收集；</li><li>老年代收集(Major GC &#x2F; Old GC)：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集(Mixed GC)：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li></ul></blockquote><h3 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h3><ul><li><strong>防止内存泄漏</strong>：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li><li><strong>提高开发效率</strong>：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li><li><strong>系统性能和稳定性</strong>：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li></ul><h3 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用</h3><p><a href="https://blog.csdn.net/u013718071/article/details/134789666">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p><ul><li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li><li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li><li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li><li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li></ul><p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p><h3 id="如何判断一个类是无用的"><a href="#如何判断一个类是无用的" class="headerlink" title="如何判断一个类是无用的"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p><p>其中验证、准备、解析 3 部分统称为连接。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p><p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><blockquote><p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p></blockquote><p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p><ol><li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul><li>如验证类是否有父类</li></ul></li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul><li>如验证函数的参数是否正确</li></ul></li><li>符号引用验证：确保解析动作能正确执行。<ul><li>如验证该类要使用的其他类、方法是否存在。</li></ul></li></ol><p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p><ul><li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>初始值是数据类型的默认值，如 0、null 等。</li></ul><p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p><p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p><p>卸载类需要满足 3 个要求:</p><ul><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ul><p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> )是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p><blockquote><p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p></blockquote><p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p><p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p><p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p><h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN/LSTM/GRU/GCN</title>
      <link href="/posts/17765.html"/>
      <url>/posts/17765.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p></blockquote><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/587276701">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/605750441">https://zhuanlan.zhihu.com/p/605750441</a></p></blockquote><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p><p>由此诞生了RNN。</p><p>循环神经网络（Recurrent Neural Network, RNN）是一类以序列（sequence）数据为输入，在序列的演进方向进行递归（recursion）且所有节点（循环单元）按链式连接的递归神经网络。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_1.png" alt="img_1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x 输入层 向量</span><br><span class="line">U 输入层到隐藏层的 权重矩阵</span><br><span class="line">s 隐藏层 向量</span><br><span class="line">V 隐藏层到输出层的 权重矩阵</span><br><span class="line">o 输出层 向量</span><br><span class="line">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure><p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_2.png" alt="img_2.png"></p><p>具体的抽象图：<br><img src="/../image/RNN-LSTM-GRU-GCN/img.png" alt="img.png"></p><h2 id="长短期记忆网络LSTM"><a href="#长短期记忆网络LSTM" class="headerlink" title="长短期记忆网络LSTM"></a>长短期记忆网络LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_3.png" alt="img_3.png"><br>(左：RNN，右：LSTM)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MARL</title>
      <link href="/posts/17763.html"/>
      <url>/posts/17763.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p></blockquote><blockquote><p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p></blockquote><p>知乎专栏：<a href="https://www.zhihu.com/column/c_1061939147282915328">https://www.zhihu.com/column/c_1061939147282915328</a></p><h2 id="基础知识与博弈"><a href="#基础知识与博弈" class="headerlink" title="基础知识与博弈"></a>基础知识与博弈</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值（reward）来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p><p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p><ol><li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li><li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li><li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li><li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li></ol><p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p><h3 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h3><p><img src="/../image/MARL/img_1.png" alt="img_1.png"></p><h3 id="完全混合策略"><a href="#完全混合策略" class="headerlink" title="完全混合策略"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p><h3 id="纯策略"><a href="#纯策略" class="headerlink" title="纯策略"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p><h3 id="零和博弈"><a href="#零和博弈" class="headerlink" title="零和博弈"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p><h3 id="一般和博弈"><a href="#一般和博弈" class="headerlink" title="一般和博弈"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p><blockquote><p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href="https://zhuanlan.zhihu.com/p/53474965">https://zhuanlan.zhihu.com/p/53474965</a></p></blockquote><h2 id="Minimax-Q"><a href="#Minimax-Q" class="headerlink" title="Minimax-Q"></a>Minimax-Q</h2><p>论文：<a href="https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf">Markov games as a framework for multi-agent reinforcement learning</a></p><p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p><p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p><p><img src="/../image/MARL/img_2.png" alt="img_2.png"></p><p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p><ol><li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li><li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li><li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法（opponent-independent algorithm），不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li></ol><h2 id="Nash-Q-Learning"><a href="#Nash-Q-Learning" class="headerlink" title="Nash Q-Learning"></a>Nash Q-Learning</h2><p>论文：<a href="https://www.jmlr.org/papers/volume4/temp/hu03a.pdf">Nash Q-learning for general-sum stochastic games</a></p><p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p><p>其算法流程如下：</p><p><img src="/../image/MARL/img_3.png" alt="img_3.png"></p><p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p><h2 id="Friend-or-Foe-Q-Learning"><a href="#Friend-or-Foe-Q-Learning" class="headerlink" title="Friend-or-Foe Q-Learning"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href="https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf">Friend-or-foe Q-learning in general-sum games</a></p><p>Friend-or-Foe Q-Learning（FFQ）算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p><p>其纳什均衡策略求解方法如下所示：</p><p><img src="/../image/MARL/img_4.png" alt="img_4.png"></p><p>算法流程如下：</p><p><img src="/../image/MARL/img_5.png" alt="img_5.png"></p><p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p><p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p><p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p><h2 id="WoLF-Policy-Hill-Climbing"><a href="#WoLF-Policy-Hill-Climbing" class="headerlink" title="WoLF Policy Hill-Climbing"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href="https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk">Multiagent learning using a variable learning rate</a></p><p><img src="/../image/MARL/img_6.png" alt="img_6.png"></p><p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p><p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p><p>其算法流程如下：</p><p><img src="/../image/MARL/img_7.png" alt="img_7.png"></p><p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p><p>其算法流程如下所示：</p><p><img src="/../image/MARL/img_8.png" alt="img_8.png"></p><blockquote><p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href="https://www.cnblogs.com/zuti666/p/16909220.html">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href="https://zhuanlan.zhihu.com/p/53563792">https://zhuanlan.zhihu.com/p/53563792</a></p></blockquote><h2 id="MADDPG"><a href="#MADDPG" class="headerlink" title="MADDPG"></a>MADDPG</h2><p>论文：<a href="https://arxiv.org/abs/1706.02275">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p><p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p><p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p><p>MADDPG算法具有以下三点特征： </p><ol><li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li><li>不需要知道环境的动力学模型以及特殊的通信需求。 </li><li>该算法不仅能用于合作环境，也能用于竞争环境。</li></ol><p>MADDPG算法具有以下三点技巧：</p><ol><li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li><li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li><li>利用策略集合效果优化（policy ensemble）：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li></ol><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h4><p>深度Q网络（deep Q-network）<br><img src="/../image/MARL/img_9.png" alt="img_9.png"></p><h4 id="SPG"><a href="#SPG" class="headerlink" title="SPG"></a>SPG</h4><p>随机策略梯度（stochastic policy gradient）</p><p><img src="/../image/MARL/img_10.png" alt="img_10.png"></p><h4 id="DPG"><a href="#DPG" class="headerlink" title="DPG"></a>DPG</h4><p>确定性策略梯度（deterministic policy gradient）</p><p><img src="/../image/MARL/img_11.png" alt="img_11.png"></p><h3 id="MADDPG-1"><a href="#MADDPG-1" class="headerlink" title="MADDPG"></a>MADDPG</h3><h4 id="多智能体AC设计"><a href="#多智能体AC设计" class="headerlink" title="多智能体AC设计"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息（全局信息）进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src="/../image/MARL/img_12.png" alt="img_12.png"><br><img src="/../image/MARL/img_13.png" alt="img_13.png"></p><h4 id="估计其他智能体策略"><a href="#估计其他智能体策略" class="headerlink" title="估计其他智能体策略"></a>估计其他智能体策略</h4><p><img src="/../image/MARL/img_14.png" alt="img_14.png"></p><h4 id="策略集合优化"><a href="#策略集合优化" class="headerlink" title="策略集合优化"></a>策略集合优化</h4><p><img src="/../image/MARL/img_15.png" alt="img_15.png"></p><h3 id="相关PPT"><a href="#相关PPT" class="headerlink" title="相关PPT"></a>相关PPT</h3><p><img src="/../image/MARL/img_16.png" alt="img_16.png"><br><img src="/../image/MARL/img_17.png" alt="img_17.png"><br><img src="/../image/MARL/img_18.png" alt="img_18.png"><br><img src="/../image/MARL/img_19.png" alt="img_19.png"><br><img src="/../image/MARL/img_20.png" alt="img_20.png"></p><h2 id="IQL"><a href="#IQL" class="headerlink" title="IQL"></a>IQL</h2><p>论文：<a href="https://arxiv.org/abs/1511.08779">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p><p>Independent Q-Learning</p><p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立（用原文的话说就是each agent is controlled by an independent Deep Q-Network）。</p><p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p><p>IQL（independent Q-learning）算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p><p>其他没啥要讲的。。。</p><p><img src="/../image/MARL/img_21.png" alt="img_21.png"></p><h2 id="COMA"><a href="#COMA" class="headerlink" title="COMA"></a>COMA</h2><p>论文：<a href="https://arxiv.org/abs/1705.08926">Counterfactual Multi-Agent Policy Gradients</a></p><p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE（central training decentralize execution）。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src="/../image/MARL/img_23.png" alt="img_23.png"></p><p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p><p>那么这些算法都在解决什么问题呢？</p><p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配（credit assignment）问题。</p><p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A（遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值），用来计算反事实基线（counterfactual baseline）。</p><p><img src="/../image/MARL/img_24.png" alt="img_24.png"></p><p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p><p><img src="/../image/MARL/img_25.png" alt="img_25.png"></p><p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p><p>COMA算法具体框架如下图所示：<br><img src="/../image/MARL/img_22.png" alt="img_22.png"></p><p>网络架构：<br><img src="/../image/MARL/img_26.png" alt="img_26.png"></p><h2 id="VDN"><a href="#VDN" class="headerlink" title="VDN"></a>VDN</h2><p>论文：<a href="https://arxiv.org/abs/1706.05296">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p><p>VDN（Value-Decomposition Networks）算法是一种用于多智能体强化学习（MARL）的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p><p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src="/../image/MARL/img_27.png" alt="img_27.png"></p><p>作者假定如下等式成立：<br><img src="/../image/MARL/img_29.png" alt="img_29.png"></p><p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p><p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src="/../image/MARL/img_30.png" alt="img_30.png"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src="/../image/MARL/img_31.png" alt="img_31.png"></p><p>网络架构：<br><img src="/../image/MARL/img_28.png" alt="img_28.png"></p><p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p><h2 id="QMIX"><a href="#QMIX" class="headerlink" title="QMIX"></a>QMIX</h2><p>论文：<a href="https://arxiv.org/abs/1803.11485">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p><p>深度多智能体强化学习的单调值函数分解</p><p>QMIX是一个多智能体强化学习算法，具有如下特点： </p><ol><li>学习得到分布式策略。 </li><li>本质是一个值函数逼近算法。 </li><li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li><li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li><li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li><li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li><li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li><li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li><li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程（Dec-POMDP）。</li></ol><h3 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="MARL核心问题"><a href="#MARL核心问题" class="headerlink" title="MARL核心问题"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p><h4 id="Dec-POMDP"><a href="#Dec-POMDP" class="headerlink" title="Dec-POMDP"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程（Decentralized Partially Observable Markov Decision Process）。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src="/../image/MARL/img_32.png" alt="img_32.png"></p><h4 id="IQL-1"><a href="#IQL-1" class="headerlink" title="IQL"></a>IQL</h4><p>IQL（independent Q-learning）就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p><h4 id="VDN-1"><a href="#VDN-1" class="headerlink" title="VDN"></a>VDN</h4><p>如前介绍：<br><img src="/../image/MARL/img_33.png" alt="img_33.png"></p><h4 id="DRQN"><a href="#DRQN" class="headerlink" title="DRQN"></a>DRQN</h4><p>DRQN是一个用来处理POMDP（部分可观马尔可夫决策过程）的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p><h3 id="QMIX-1"><a href="#QMIX-1" class="headerlink" title="QMIX"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p><p>QMIX约束条件：<br><img src="/../image/MARL/img_34.png" alt="img_34.png"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的（都对全局有不小于0的贡献）。</p><p>具体网络结构如下：<br><img src="/../image/MARL/img_35.png" alt="img_35.png"></p><p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p><p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p><p>为了能够更多的利用到系统的状态信息st ，采用一种超网络（hypernetwork），将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p><p>QMIX的Loss：<br><img src="/../image/MARL/img_36.png" alt="img_36.png"></p><p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src="/../image/MARL/img_37.png" alt="img_37.png"></p><p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p><h2 id="QTRAN"><a href="#QTRAN" class="headerlink" title="QTRAN"></a>QTRAN</h2><p>论文：<a href="https://arxiv.org/abs/1905.05408">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p><p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p><p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p><p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p><p><img src="/../image/MARL/img_38.png" alt="img_38.png"></p><p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p><p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src="/../image/MARL/img_41.png" alt="img_41.png"></p><h3 id="TRAN-base"><a href="#TRAN-base" class="headerlink" title="TRAN-base"></a>TRAN-base</h3><p>分为三部分：</p><ol><li>独立 Q 网络</li><li>联合 Q 网络</li><li>联合 V 网络</li></ol><p>整体的Loss如下：<br><img src="/../image/MARL/img_39.png" alt="img_39.png"><br><img src="/../image/MARL/img_40.png" alt="img_40.png"></p><h3 id="TRAN-alt"><a href="#TRAN-alt" class="headerlink" title="TRAN-alt"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN（Q-function Transfer）算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p><p>作者认为约束：<br><img src="/../image/MARL/img_42.png" alt="img_42.png"></p><p>在原始 QTRAN 算法中，对于非零动作的约束（对应公式中的第二个约束），可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p><p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src="/../image/MARL/img_43.png" alt="img_43.png"><br>这个约束更多的聚焦于非0的训练数据（这一部分数据占训练初期训练集的大部分）。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p><p><img src="/../image/MARL/img_44.png" alt="img_44.png"></p><p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p><p>算法流程：<br><img src="/../image/MARL/img.png" alt="img.png"></p><h2 id="MFMARL"><a href="#MFMARL" class="headerlink" title="MFMARL"></a>MFMARL</h2><p>论文：<a href="https://arxiv.org/abs/1802.05438v4">Mean Field Multi-Agent Reinforcement Learning</a></p><p>平均场多智能体强化学习</p><p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p><p>MFMARL算法借用了平均场论（Mean Field Theory，MFT）的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用（该智能体与其所有邻居的均值）。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p><p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p><h3 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="随机博弈"><a href="#随机博弈" class="headerlink" title="随机博弈"></a>随机博弈</h4><p><img src="/../image/MARL/img_45.png" alt="img_45.png"></p><h4 id="Nash-Q"><a href="#Nash-Q" class="headerlink" title="Nash-Q"></a>Nash-Q</h4><p><img src="/../image/MARL/img_46.png" alt="img_46.png"></p><h3 id="Mean-Field-MARL"><a href="#Mean-Field-MARL" class="headerlink" title="Mean Field MARL"></a>Mean Field MARL</h3><p><img src="/../image/MARL/img_50.png" alt="img_50.png"></p><h4 id="平均场近似"><a href="#平均场近似" class="headerlink" title="平均场近似"></a>平均场近似</h4><p><img src="/../image/MARL/img_47.png" alt="img_47.png"></p><p><img src="/../image/MARL/img_48.png" alt="img_48.png"></p><p><img src="/../image/MARL/img_49.png" alt="img_49.png"></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p><h4 id="MF-Q"><a href="#MF-Q" class="headerlink" title="MF-Q"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src="/../image/MARL/img_51.png" alt="img_51.png"></p><p>对上式求导可以得出参数梯度方向如下:<br><img src="/../image/MARL/img_52.png" alt="img_52.png"></p><p>通过梯度下降法可以得到参数更新公式。</p><p>算法流程：<br><img src="/../image/MARL/img_53.png" alt="img_53.png"></p><h4 id="MF-AC"><a href="#MF-AC" class="headerlink" title="MF-AC"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p><p>类似SPG，actor策略梯度公式可以写为：<br><img src="/../image/MARL/img_54.png" alt="img_54.png"></p><p>critic类似于MF-Q的更新方式(9)</p><p><img src="/../image/MARL/img_55.png" alt="img_55.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../image/MARL/img_56.png" alt="img_56.png"></p><blockquote><p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
          <category> 多智能体强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
            <tag> 多智能体强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/posts/17762.html"/>
      <url>/posts/17762.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p></blockquote><p>原文： <a href="https://zhuanlan.zhihu.com/p/111895463">https://zhuanlan.zhihu.com/p/111895463</a></p><p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p><p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p><blockquote><p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p></blockquote><p>学习路线：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png" alt="学习路线"></p><h2 id="马尔可夫树"><a href="#马尔可夫树" class="headerlink" title="马尔可夫树"></a>马尔可夫树</h2><p>强化学习的任务：</p><ul><li>我们希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li><li>智能体学习和工作的地方，称为<strong>环境</strong>。</li><li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li></ul><h3 id="经典马尔可夫链"><a href="#经典马尔可夫链" class="headerlink" title="经典马尔可夫链"></a>经典马尔可夫链</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png" alt="马尔科夫链.png"></p><ul><li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul><li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li></ul></li><li>动作(action)：智能体做出的具体行为。<ul><li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么我们的方向就有4个。也就是说，动作空间为4个动作。</li></ul></li><li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul><li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li></ul></li></ul><h3 id="RL一般步骤"><a href="#RL一般步骤" class="headerlink" title="RL一般步骤"></a>RL一般步骤</h3><ol><li>智能体在环境中，观察到状态(S)；</li><li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li><li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li><li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li></ol><h3 id="马尔可夫树-1"><a href="#马尔可夫树-1" class="headerlink" title="马尔可夫树"></a>马尔可夫树</h3><p>马尔科夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往过去看，所以是一条确定的路径。但如果我们往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png" alt="马尔科夫树.png"></p><p>这种”不确定性”来自两个方面： </p><ul><li>智能体的行动选择(策略)。</li><li>环境的不确定性。</li></ul><h2 id="RL中的Q值和V值"><a href="#RL中的Q值和V值" class="headerlink" title="RL中的Q值和V值"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而我们需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p><p>我们希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p><ul><li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li><li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li></ul><p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p><h3 id="V值的定义"><a href="#V值的定义" class="headerlink" title="V值的定义"></a>V值的定义</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="V值的定义.png"></p><p>假设现在需要求某状态S的V值，可以这样：</p><ol><li>从S点出发，并影分身出若干个自己;</li><li>每个分身按照当前的策略 选择行为;</li><li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li><li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li></ol><p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p><p><code>V值跟选择的策略有很大的关系</code> 。</p><p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png" alt="例子1.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png" alt="策略1.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png" alt="策略2.png"></p><p>可以看出不同的策略，计算出的V值是不一样的。</p><h3 id="Q值的定义"><a href="#Q值的定义" class="headerlink" title="Q值的定义"></a>Q值的定义</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="Q值的定义.png"></p><p>现在需要计算，某个状态S0下的一个动作A的Q值： </p><ol><li>从A这个节点出发，使用影分身之术； </li><li>每个影分身走到最终状态,并记录所获得的奖励； </li><li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li></ol><p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p><p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p><h3 id="V值和Q值关系"><a href="#V值和Q值关系" class="headerlink" title="V值和Q值关系"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p><h4 id="Q值转V值"><a href="#Q值转V值" class="headerlink" title="Q值转V值"></a>Q值转V值</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png" alt="Q值转V值.png"></p><p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p><p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p><p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png" alt="Q值转V值1.png"></p><p>更正式的公式如下：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png" alt="公式1.png"></p><p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p><h4 id="V值转Q值"><a href="#V值转Q值" class="headerlink" title="V值转Q值"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png" alt="V值转Q值.png"></p><p><code>当选择A，并转移到新的状态时，就能获得奖励，我们必须把这个奖励也算上！</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png" alt="V值转Q值1.png"></p><p>更正式的公式如下：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png" alt="公式2.png"></p><blockquote><p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。</p></blockquote><h3 id="V值转V值"><a href="#V值转V值" class="headerlink" title="V值转V值"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png" alt="V值转V值.png"></p><h2 id="MC"><a href="#MC" class="headerlink" title="MC"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p><h3 id="蒙地卡罗算法"><a href="#蒙地卡罗算法" class="headerlink" title="蒙地卡罗算法"></a>蒙地卡罗算法</h3><ol><li>把智能体放到环境的任意状态；</li><li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li><li>重复步骤2，直到最终状态；</li><li>从最终状态开始向前回溯：计算每个状态的G值。</li><li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li></ol><h3 id="G值的意义"><a href="#G值的意义" class="headerlink" title="G值的意义"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png" alt="G值的意义.png"></p><ul><li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li><li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li></ul><p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p><p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p><p>理解：</p><ol><li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li><li><code>V和G的关系：V是G的平均数。</code></li></ol><h3 id="V和策略相关"><a href="#V和策略相关" class="headerlink" title="V和策略相关"></a>V和策略相关</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png" alt="策略3.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png" alt="策略4.png"></p><p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p><h3 id="蒙地卡罗算法的缺点"><a href="#蒙地卡罗算法的缺点" class="headerlink" title="蒙地卡罗算法的缺点"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p><h3 id="MC的更新公式"><a href="#MC的更新公式" class="headerlink" title="MC的更新公式"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p><p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p><h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p><p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p><ul><li>V_old：原来的V值</li><li>G：这一次回溯后，计算出来的G值</li><li>N: 这个状态被经过多少次</li><li>V_new：新计算出来的V值</li></ul><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>这样计算还是比较麻烦，我们甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<code>学习率</code>。</p><p>这就相当于，我们新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p><p>这里的G，也称为V的更新目标。</p><p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p><h4 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png" alt="两种理解方式.png"></p><h2 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p><h3 id="TD和MC的比较"><a href="#TD和MC的比较" class="headerlink" title="TD和MC的比较"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p><ol><li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li><li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li><li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul><li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候我们就当这个状态为0. </li><li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后我们开始回溯。</li></ul></li></ol><h3 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p><p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png" alt="TD(0).png"></p><p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p><h3 id="更新公式"><a href="#更新公式" class="headerlink" title="更新公式"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p><p><code>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png" alt="更新公式.png"></p><h2 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png" alt="TD(0)更新公式.png"></p><p>图解：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png" alt="TD(0)图解.png"></p><p>TD能够用在V值，那么也能用在计算Q值上。</p><h3 id="TD之于Q值估算"><a href="#TD之于Q值估算" class="headerlink" title="TD之于Q值估算"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png" alt="用TD估计Q值.png"></p><ul><li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li><li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li></ul><p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png" alt="用下一个动作的Q代替V.png"></p><p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p><p>因为<code>马尔可夫树!</code><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt="坑的解释.png"></p><p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p><p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p><ol><li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li><li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li></ol><h3 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png" alt="SARSA.png"></p><p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png" alt="SARSA公式.png"><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png" alt="TD(0)与SARSA对比.png"></p><p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p><h3 id="Qlearning"><a href="#Qlearning" class="headerlink" title="Qlearning"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png" alt="Qlearning图解.png"></p><p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png" alt="Qlearning公式.png"></p><p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png" alt="SARSA公式.png"></p><p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li><li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li><li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li><li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul><li>SARSA 选择的是在St同一个策略产生的动作。 </li><li>Qlearning 选择的是能够产生最大的Q值的动作。</li></ul></li></ol><h3 id="Qlearning-实现"><a href="#Qlearning-实现" class="headerlink" title="Qlearning 实现"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="深度神经网络"><a href="#深度神经网络" class="headerlink" title="深度神经网络"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p><p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 我们的任务就是需要求这个Magic函数。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png" alt="Magic(X).png"></p><p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p><p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p><p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p><p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p><p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p><p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p><p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png" alt="Magic&#39;(X).png"></p><h4 id="放大镜下的深度神经网络"><a href="#放大镜下的深度神经网络" class="headerlink" title="放大镜下的深度神经网络"></a>放大镜下的深度神经网络</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png" alt="数据加工厂.png"></p><p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p><p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p><p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p><p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p><p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p><p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p><p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p><p>但产品y’是否是一个合格的产品，我们还需要我们真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p><p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p><p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><blockquote><p><code>DQN: TD + 神经网络</code></p></blockquote><p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p><p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p><p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p><p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p><p><code>Deep network + Qlearning = DQN</code></p><p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p><h3 id="理解DQN中的神经网络"><a href="#理解DQN中的神经网络" class="headerlink" title="理解DQN中的神经网络"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="Qtable三维可视化.png"></p><p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p><p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png" alt="扭曲的曲线.png"></p><p>从二维状态看：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png" alt="二维曲线.png"></p><p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p><p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p><h3 id="更新目标"><a href="#更新目标" class="headerlink" title="更新目标"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p><p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p><p>DQN和Qlearning一样：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png" alt="DQN.png"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p><ol><li>执行A，往前一步，到达St+1; </li><li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li><li>获得最大的Q值加上奖励R作为更新目标； </li><li>计算损失 <ul><li>Q(S,A)相当于有监督学习中的logits</li><li>maxQ(St+1) + R 相当于有监督学习中的lables </li><li>用mse函数，得出两者的loss </li><li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li></ul></li><li>用loss更新Q网络。(反向传播)</li></ol><blockquote><p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p></blockquote><p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png" alt="DQN公式.png"></p><p>总结：</p><ol><li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li><li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li><li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li></ol><h3 id="DQN-实现"><a href="#DQN-实现" class="headerlink" title="DQN 实现"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h2><h3 id="经验回放"><a href="#经验回放" class="headerlink" title="经验回放"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p><p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p><p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p><p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p><h3 id="DQN的问题"><a href="#DQN的问题" class="headerlink" title="DQN的问题"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p><p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p><p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p><p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p><h3 id="Fixed-Q-targets"><a href="#Fixed-Q-targets" class="headerlink" title="Fixed Q-targets"></a>Fixed Q-targets</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png" alt="fix-Q-targets.png"></p><p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p><ul><li>原来的Q网络，用于估算Q(s);</li><li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul><li><code>y = r + gamma * max(targetQ(s&#39;))</code></li><li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li></ul></li></ul><h3 id="Double-DQN-1"><a href="#Double-DQN-1" class="headerlink" title="Double DQN"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p><p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p><p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p><h3 id="Double-DQN-实现"><a href="#Double-DQN-实现" class="headerlink" title="Double DQN 实现"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="Duel-DQN"><a href="#Duel-DQN" class="headerlink" title="Duel DQN"></a>Duel DQN</h2><h3 id="Dueling-DQN原理"><a href="#Dueling-DQN原理" class="headerlink" title="Dueling DQN原理"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p><ul><li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li><li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li></ul><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png" alt="Q=S+A表格.png"></p><p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png" alt="普通DQN.png"></p><p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p><p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png" alt="DuelDQN.png"></p><p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p><blockquote><p>这样调整最后的数值是对的吗？放心，在DuelingDQN，我们只是优先调整S值。但最终我们的target目标是没有变的，所以我们最后更新出来也是对的。</p></blockquote><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png" alt="DuelDQN网络架构.png"></p><p>可以把dueling DQN分为三部分：</p><ul><li>第一部分：和普通DQN一样，用来处理和学习数据。</li><li>第二部分：计算svalue，就是让网络预估的平均值。</li><li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul><li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li></ul></li></ul><p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p><h3 id="Duel-DQN-实现"><a href="#Duel-DQN-实现" class="headerlink" title="Duel DQN 实现"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h2><p>策略梯度(Policy Gradient)</p><p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上我们的最终目的是要找一个策略，能获得最多的奖励。</p><p>这就是<code>策略梯度(Policy Gradient)</code></p><h3 id="PG原理"><a href="#PG原理" class="headerlink" title="PG原理"></a>PG原理</h3><p>认识到：</p><blockquote><p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p></blockquote><p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p><p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png" alt="复习MC.png"></p><h3 id="直观感受PG"><a href="#直观感受PG" class="headerlink" title="直观感受PG"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png" alt="直观感受PG1.png"></p><p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png" alt="直观感受PG2.png"></p><p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png" alt="直观感受PG3.png"></p><p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p><h3 id="PG-实现"><a href="#PG-实现" class="headerlink" title="PG 实现"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h2><blockquote><p><code>AC: PG + DQN(TD + 神经网络)</code></p></blockquote><p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p><p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，我们需要计算G值；那么在TD中，我们应该怎样估算每一步的Q值呢？答案是用神经网络。</p><p>也就是说，Actor-Critic，其实是用了两个网络：</p><p>两网络都输入状态S，Critic比Actor多一个St+1: </p><ul><li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li><li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li></ul><h3 id="TD-error"><a href="#TD-error" class="headerlink" title="TD-error"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png" alt="为什么不估算Q.png"></p><p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p><p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p><p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png" alt="TD-error.png"></p><p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p><p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p><p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li><li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以我们得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li><li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li><li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>定义两个network：Actor 和 Critic</li><li>进行N次更新。<ol><li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li><li>记录的数据。</li><li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li><li>把输入到Actor，计算策略分布。</li></ol></li></ol><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png" alt="AC算法.png"></p><p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p><h3 id="AC-实现"><a href="#AC-实现" class="headerlink" title="AC 实现"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h2><p>PPO是基于AC框架的</p><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p><ul><li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li><li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li></ul><p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png" alt="离散动作-策略分布.png"></p><p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="连续型概率分布示意图.png"></p><p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; （action）代表在策略下，选择某个action的概率P。</p><p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p><p>这样，只用两个参数就可以表示了。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="正态分布.png"></p><p>正态分布：</p><ul><li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li><li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li></ul><p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p><h3 id="AC的问题"><a href="#AC的问题" class="headerlink" title="AC的问题"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p><ul><li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p></li><li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p></li><li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p><ul><li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li><li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li></ul></li><li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p><ul><li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li><li>无需环境互动：训练过程中不需要实时环境反馈。</li></ul></li></ul><p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p><p>例如PG，就是一个在线策略。因为PG用于产生数据的策略（行为策略），和需要更新的策略（目标策略）是一致。 而DQN则是一个离线策略。我们会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p><p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p><p>看一个例子：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png" alt="策略P和策略B.png"></p><blockquote><p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p></blockquote><p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p><p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p><p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p><p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="策略P和策略B更新示意图.png"></p><p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p><p><strong>为什么DQN可以多次重复使用数据？</strong></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png" alt="DQN更新的是Q值.png"></p><p>两个角度：</p><ul><li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li><li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li></ul><blockquote><p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数（Value Function）V，而不是动作值函数（Q函数）。</p></blockquote><h3 id="重要性采样技术"><a href="#重要性采样技术" class="headerlink" title="重要性采样技术"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p><p>在这里<code>IW = P（a）/ B（a）</code></p><p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p><ul><li>目标策略：要更新的策略。</li><li>行为策略：数据的策略。</li></ul><p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png" alt="重要性权重表格.png"></p><p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p><p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p><h3 id="N步更新"><a href="#N步更新" class="headerlink" title="N步更新"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png" alt="TD(N).png"></p><p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p><p><code>V = R + gamma * V(s&#39;)</code></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p><ol><li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li><li>PPO延展了TD(0)，变成TD(N)的N步更新； </li><li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li></ol><h3 id="PPO-实现"><a href="#PPO-实现" class="headerlink" title="PPO 实现"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="DDPG"><a href="#DDPG" class="headerlink" title="DDPG"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p><ul><li>deep: 深度网络。</li><li>policy gradient: PG</li><li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li></ul><p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p><h3 id="回顾DQN"><a href="#回顾DQN" class="headerlink" title="回顾DQN"></a>回顾DQN</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png" alt="回顾DQN.png"></p><p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回我们动作action的取值，这个取值能够让q值最大。</p><h3 id="理解DDPG"><a href="#理解DDPG" class="headerlink" title="理解DDPG"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png" alt="理解DDPG1.png"></p><p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png" alt="理解DDPG2.png"></p><blockquote><p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p></blockquote><p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p><h3 id="DDPG-1"><a href="#DDPG-1" class="headerlink" title="DDPG"></a>DDPG</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png" alt="DDPG1.png"></p><p>整理下：</p><h4 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h4><ol><li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li><li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li><li>Critic网络的loss其还是和AC一样，用的是TD-error。</li></ol><h4 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h4><ol><li>和AC不同，Actor输出的是一个动作；</li><li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li><li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li></ol><p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p><p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png" alt="DDPG2.png"></p><blockquote><p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p></blockquote><h3 id="DDPG-实现"><a href="#DDPG-实现" class="headerlink" title="DDPG 实现"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p><p>TD3是对DDPG的优化，三个重要优化。</p><h3 id="double-network"><a href="#double-network" class="headerlink" title="double network"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p><p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p><p>回顾DDPG：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png" alt="DDPG2.png"></p><p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p><p>TD3需要用到6个网络：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png" alt="TD3.png"></p><p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p><h4 id="Critic部分的学习"><a href="#Critic部分的学习" class="headerlink" title="Critic部分的学习"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p><p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p><p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p><p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p><p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p><p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p><h4 id="Actor部分的学习"><a href="#Actor部分的学习" class="headerlink" title="Actor部分的学习"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p><p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p><p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p><h3 id="actor延迟更新"><a href="#actor延迟更新" class="headerlink" title="actor延迟更新"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p><p>为什么要这样做呢？</p><p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png" alt="理解DDPG1.png"><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png" alt="理解DDPG2.png"></p><p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p><p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p><h3 id="target网络噪声"><a href="#target网络噪声" class="headerlink" title="target网络噪声"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p><p>为什么要这样呢？</p><p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png" alt="Q&#39;估算Q 1.png"></p><p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p><p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围（准确来说是在s_这条线上的一定范围）的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png" alt="Q&#39;估计Q 2.png"></p><p>这里注意三个地方：</p><ol><li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li><li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li><li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li></ol><h3 id="TD3-实现"><a href="#TD3-实现" class="headerlink" title="TD3 实现"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p><h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p><p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p><p>由此诞生了A3C。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png" alt="A3C.png"></p><p>注意几点：</p><ol><li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote><p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p></blockquote></li><li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li></ol><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png" alt="A3C1.png"></p><h3 id="A3C-实现"><a href="#A3C-实现" class="headerlink" title="A3C 实现"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="DPPO"><a href="#DPPO" class="headerlink" title="DPPO"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p><p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p><p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p><h3 id="DPPO-实现"><a href="#DPPO-实现" class="headerlink" title="DPPO 实现"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react技巧</title>
      <link href="/posts/56292.html"/>
      <url>/posts/56292.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href="https://github.com/cwp0/casdoor-app">casdoor-app</a></p></blockquote><blockquote><p>后面如果做react的话可能也会做一些总结，到时候再加。</p></blockquote><h1 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h1><h2 id="React-Context"><a href="#React-Context" class="headerlink" title="React Context"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p><p>使用方法：</p><p>例如要共享 <code>userInfo</code></p><ol><li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p><p><code>UserContext.js</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserProvider</span> = <span class="title class_">UserContext</span>.<span class="property">Provider</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserConsumer</span> = <span class="title class_">UserContext</span>.<span class="property">Consumer</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">UserContext</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p><p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">PaperProvider</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NavigationBar</span> <span class="keyword">from</span> <span class="string">&quot;./NavigationBar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavigationContainer</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@react-navigation/native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./Header&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">UserProvider</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [userInfo, setUserInfo] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProvider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;userInfo,</span> <span class="attr">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">PaperProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavigationBar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">PaperProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">UserProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li><li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p><p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p><p><code>Header.js</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Appbar</span>, <span class="title class_">Avatar</span>, <span class="title class_">Button</span>, <span class="title class_">Menu</span>, <span class="title class_">Text</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserContext</span> <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CasdoorLoginPage</span>, &#123;<span class="title class_">CasdoorLogout</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Header</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;userInfo, setUserInfo&#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">UserContext</span>);</span><br><span class="line">  <span class="keyword">const</span> [showLoginPage, setShowLoginPage] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [menuVisible, setMenuVisible] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">openMenu</span> = (<span class="params"></span>) =&gt; <span class="title function_">setMenuVisible</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">closeMenu</span> = (<span class="params"></span>) =&gt; <span class="title function_">setMenuVisible</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleMenuLogoutClicked</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">handleCasdoorLogout</span>();</span><br><span class="line">    <span class="title function_">closeMenu</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCasdoorLogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowLoginPage</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCasdoorLogout</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">CasdoorLogout</span>();</span><br><span class="line">    <span class="title function_">setUserInfo</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleHideLoginPage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowLoginPage</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Appbar.Header</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> <span class="attr">40</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Appbar.Content</span> <span class="attr">title</span>=<span class="string">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">visible</span>=<span class="string">&#123;menuVisible&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">anchor</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &lt;<span class="attr">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>, <span class="attr">backgroundColor:</span> &quot;<span class="attr">transparent</span>&quot;, <span class="attr">height:</span> <span class="attr">40</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onPress</span>=<span class="string">&#123;userInfo</span> === <span class="string">null</span> ? <span class="attr">handleCasdoorLogin</span> <span class="attr">:</span> <span class="attr">openMenu</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;</span></span><br><span class="line"><span class="language-xml">                userInfo === null ?</span></span><br><span class="line"><span class="language-xml">                  null :</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">Avatar.Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">size</span>=<span class="string">&#123;32&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>, <span class="attr">backgroundColor:</span> &quot;<span class="attr">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  /&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>&#125;&#125; <span class="attr">variant</span>=<span class="string">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Appbar.Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;showLoginPage &amp;&amp; <span class="tag">&lt;<span class="name">CasdoorLoginPage</span> <span class="attr">onWebviewClose</span>=<span class="string">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Header</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件使用父组件的函数等参数"><a href="#子组件使用父组件的函数等参数" class="headerlink" title="子组件使用父组件的函数等参数"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p><p>定义好相关函数及变量，将参数传递给子组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [placeholder, setPlaceholder] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">closeEditAccountModal</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowEditAccountModal</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onAccountEdit</span> = (<span class="params">accountDescp</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> accountToEdit = accountList.<span class="title function_">find</span>(<span class="function"><span class="params">account</span> =&gt;</span> account.<span class="title function_">getEditStatus</span>() === <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (accountToEdit) &#123;</span><br><span class="line">      accountToEdit.<span class="title function_">setTitle</span>(accountDescp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setPlaceholder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="title function_">closeEditAccountModal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在子组件中：</p><p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Text</span>, <span class="title class_">TextInput</span>, <span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Button</span>, <span class="title class_">IconButton</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">EnterAccountDetails</span>(<span class="params">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">EnterAccountDetails</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">onClose</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">onEdit</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [description, setDescription] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">onEdit</span>(description);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>, <span class="attr">justifyContent:</span> &quot;<span class="attr">center</span>&quot;, <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span> <span class="attr">24</span>, <span class="attr">marginBottom:</span> <span class="attr">5</span>&#125;&#125;&gt;</span>Enter new description<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flexDirection:</span> &quot;<span class="attr">row</span>&quot;, <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">IconButton</span> <span class="attr">icon</span>=<span class="string">&quot;account-details&quot;</span> <span class="attr">size</span>=<span class="string">&#123;35&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TextInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;description&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChangeText</span>=<span class="string">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class="line"><span class="language-xml">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">backgroundColor:</span> &quot;#<span class="attr">E6DFF3</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderRadius:</span> <span class="attr">5</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">margin:</span> <span class="attr">10</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">position:</span> &quot;<span class="attr">absolute</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">top:</span> <span class="attr">160</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">width:</span> <span class="attr">300</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onPress</span>=<span class="string">&#123;handleConfirm&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span> <span class="attr">18</span>, <span class="attr">width:</span> <span class="attr">280</span>&#125;&#125;&gt;</span>Confirm<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">IconButton</span> <span class="attr">icon</span>=<span class="string">&#123;</span>&quot;<span class="attr">close</span>&quot;&#125; <span class="attr">size</span>=<span class="string">&#123;30&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;onClose&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span> &quot;<span class="attr">absolute</span>&quot;, <span class="attr">top:</span> <span class="attr">5</span>, <span class="attr">right:</span> <span class="attr">5</span>&#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父组件使用自组件的函数等参数"><a href="#父组件使用自组件的函数等参数" class="headerlink" title="父组件使用自组件的函数等参数"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p><p>将父组件要使用的函数导出：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">WebView</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-webview&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Portal</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CasdoorSdkConfig</span> <span class="keyword">from</span> <span class="string">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">SDK</span> <span class="keyword">from</span> <span class="string">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserContext</span> <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="comment">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class="line"><span class="comment">// LogBox.ignoreAllLogs();</span></span><br><span class="line"><span class="keyword">const</span> sdk = <span class="keyword">new</span> <span class="title function_">SDK</span>(<span class="title class_">CasdoorSdkConfig</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CasdoorLoginPage</span> = (<span class="params">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">CasdoorLoginPage</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">onWebviewClose</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;setUserInfo&#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">UserContext</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getCasdoorSignInUrl</span> = <span class="keyword">async</span>(<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> signinUrl = <span class="keyword">await</span> sdk.<span class="title function_">getSigninUrl</span>();</span><br><span class="line">    <span class="title function_">setCasdoorLoginURL</span>(signinUrl);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getCasdoorSignInUrl</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onNavigationStateChange</span> = <span class="keyword">async</span>(<span class="params">navState</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (navState.<span class="property">url</span>.<span class="title function_">startsWith</span>(<span class="title class_">CasdoorSdkConfig</span>.<span class="property">redirectPath</span>)) &#123;</span><br><span class="line">      <span class="title function_">onWebviewClose</span>();</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> sdk.<span class="title function_">getAccessToken</span>(navState.<span class="property">url</span>);</span><br><span class="line">      <span class="keyword">const</span> userInfo = sdk.<span class="title class_">JwtDecode</span>(token);</span><br><span class="line">      <span class="title function_">setUserInfo</span>(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Portal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">WebView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onNavigationStateChange</span>=<span class="string">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">mixedContentMode</span>=<span class="string">&quot;always&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">javaScriptEnabled</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Portal</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">CasdoorLogout</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  sdk.<span class="title function_">clearState</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure><p>在父组件中：</p><p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 移动端 </tag>
            
            <tag> react </tag>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云笔记系统扩容</title>
      <link href="/posts/36313.html"/>
      <url>/posts/36313.html</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p><p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p><h3 id="大体思路："><a href="#大体思路：" class="headerlink" title="大体思路："></a>大体思路：</h3><ol><li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li><li>备份数据</li><li>删除旧的 <code>pod</code></li><li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li><li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li><li>重新部署相应 <code>pod</code></li><li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li></ol><blockquote><p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p></blockquote><h2 id="1-确定pod所在的node节点"><a href="#1-确定pod所在的node节点" class="headerlink" title="1. 确定pod所在的node节点"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p><p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png" alt="pod"></p><p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png" alt="pod-node"></p><p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p><h2 id="2-备份数据"><a href="#2-备份数据" class="headerlink" title="2. 备份数据"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png" alt="vmware"></p><p>账号密码为 <code>root 123456</code>，登陆后如下：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png" alt="login"></p><p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png" alt="backup"></p><p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p><p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png" alt="xftp"></p><p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png" alt="backup-desktop"></p><p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p><h2 id="3-删除旧的pod"><a href="#3-删除旧的pod" class="headerlink" title="3. 删除旧的pod"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mysql-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mysql.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mongodb-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mongodb.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png" alt="delete-pod"></p><p>此时查看 <code>pod</code>结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png" alt="pod-after-deleted"></p><p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p><h2 id="4-修改pv、pvc"><a href="#4-修改pv、pvc" class="headerlink" title="4. 修改pv、pvc"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p><p><code>note-mongodb-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mysql-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p><code>yaml</code>文件里已经将内存修改为目标内存。</p><h2 id="5-指定亲和性"><a href="#5-指定亲和性" class="headerlink" title="5. 指定亲和性"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p><p>首先需要为 <code>node</code>节点添加标签。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为节点6和7添加label</span></span><br><span class="line">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class="line">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png" alt="add-labels"></p><p>指定完标签就可以添加亲和性了，如下：</p><p><code>note-mongodb-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mongodb</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mysql-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mongodb.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">mongodb</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30017</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><p><code>note-mysql.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mysql-pvc</span> <span class="comment"># 使用之前创建的持久卷声明</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30006</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>这样，亲和性就修改完毕了。</p><h2 id="6-重新部署相应的pod"><a href="#6-重新部署相应的pod" class="headerlink" title="6. 重新部署相应的pod"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mysql-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mysql.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mongodb-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mongodb.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png" alt="pod-deploy"></p><p>查看部署的结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">note</span> <span class="string">-o</span> <span class="string">wide</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png" alt="pod-after-deploy"></p><p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p><h2 id="7-扩容节点的虚拟机"><a href="#7-扩容节点的虚拟机" class="headerlink" title="7. 扩容节点的虚拟机"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png" alt="vmware"></p><p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png" alt="shutdown"></p><p>然后右键 <code>sx-k8s-node6</code>，点设置</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png" alt="setting"></p><p>点击硬盘后点击右下角扩展</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png" alt="expand"></p><p>对硬盘容量进行修改。</p><p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p><p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p><p>此时打开网址，访问成功！扩容成功！</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问（连校园网，关梯子）：</p><p><a href="http://192.10.84.209:33395/cloudNote/">http://192.10.84.209:33395/cloudNote/</a></p><p>账号：姓名小写拼音</p><p>密码：123456</p><p>效果：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> k8s </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s部署云笔记系统</title>
      <link href="/posts/16330.html"/>
      <url>/posts/16330.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p></blockquote><h2 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h2><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建namespace</span><br><span class="line">kubectl create namespace note</span><br></pre></td></tr></table></figure><h2 id="1-部署MySQL"><a href="#1-部署MySQL" class="headerlink" title="1. 部署MySQL"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure><h3 id="1-1-挂载数据卷"><a href="#1-1-挂载数据卷" class="headerlink" title="1.1 挂载数据卷"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line"><span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line"><span class="attr">requests:</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure><p>查看是否部署成功：</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png" alt="mysql是否部署成功"></p><h3 id="1-2-部署mysql"><a href="#1-2-部署mysql" class="headerlink" title="1.2 部署mysql"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line"><span class="attr">persistentVolumeClaim:</span></span><br><span class="line">  <span class="attr">claimName:</span> <span class="string">note-mysql-pvc</span> <span class="comment"># 使用之前创建的持久卷声明</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">nodePort:</span> <span class="number">30006</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line"><span class="attr">targetPort:</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="2-部署redis"><a href="#2-部署redis" class="headerlink" title="2. 部署redis"></a>2. 部署redis</h2><p>note-redis.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-redis-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-redis</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-redis-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30079</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="3-部署mongodb"><a href="#3-部署mongodb" class="headerlink" title="3. 部署mongodb"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure><h3 id="3-1-挂载数据卷"><a href="#3-1-挂载数据卷" class="headerlink" title="3.1 挂载数据卷"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure><p>查看是否装好：</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png" alt="mongodb-pvc"></p><h3 id="3-2-部署"><a href="#3-2-部署" class="headerlink" title="3.2 部署"></a>3.2 部署</h3><p>note-mongodb.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30017</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure><p>检查部署情况</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png" alt="mongodb"></p><h2 id="4-部署服务bert-flask"><a href="#4-部署服务bert-flask" class="headerlink" title="4. 部署服务bert_flask"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bert-flask-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bert-flask</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bert-flask-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30050</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure><p>检查部署情况<br><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png" alt="bert_flask"></p><h2 id="5-部署服务note-cloud"><a href="#5-部署服务note-cloud" class="headerlink" title="5. 部署服务note_cloud"></a>5. 部署服务note_cloud</h2><h3 id="5-1-配置ConfigMap"><a href="#5-1-配置ConfigMap" class="headerlink" title="5.1 配置ConfigMap"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">note-redis-service</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">      <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span> <span class="comment"># JSON处理时忽略非空字段</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">10MB</span></span><br><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">base64-encoded-secret-key:</span> <span class="string">lab_of_njust_cloud_computing</span> <span class="comment"># jwt的签名密码</span></span><br><span class="line"><span class="attr">bert-base-chinese-service:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bert-flask-service</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure><p>   查看部署状态<br>   <img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png" alt="部署效果"></p><h3 id="5-2-部署服务"><a href="#5-2-部署服务" class="headerlink" title="5.2 部署服务"></a>5.2 部署服务</h3><p>note-cloud.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-cloud-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-cloud</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/app/config</span> <span class="comment"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">note-cloud-config</span> <span class="comment"># 引用之前创建的 ConfigMap</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-cloud-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note</span><br><span class="line">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure><h2 id="6-部署前端"><a href="#6-部署前端" class="headerlink" title="6. 部署前端"></a>6. 部署前端</h2><p>note-nginx.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30088</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="最终部署pod查看"><a href="#最终部署pod查看" class="headerlink" title="最终部署pod查看"></a>最终部署pod查看</h2><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png" alt="pod"></p><p>访问（连校园网，关梯子）：</p><p><a href="http://192.10.84.209:33395/cloudNote/">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p><p>最终效果：<br><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> k8s </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
