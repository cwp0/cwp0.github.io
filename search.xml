<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式/高性能/高可用</title>
      <link href="/posts/17780.html"/>
      <url>/posts/17780.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式-高性能-高可用"><a href="#分布式-高性能-高可用" class="headerlink" title="分布式&#x2F;高性能&#x2F;高可用"></a>分布式&#x2F;高性能&#x2F;高可用</h1><h2 id="分布式✅"><a href="#分布式✅" class="headerlink" title="分布式✅"></a>分布式✅</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论是分布式系统设计中的一个重要理论。</p><ul><li>一致性(Consistency)：所有节点访问同一份最新的数据副本</li><li>可用性(Availability)：非故障的节点在合理的时间内返回合理的响应(不是错误或者超时的响应)。</li><li>分区容错性(Partition Tolerance)：分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><blockquote><p>网络分区：分布式系统中的多节点网络原本是连通的，但因为故障导致某些节点间不连通了，网络分为几块区域。</p></blockquote><p>当网络发生分区后，如果要继续服务的话，P是前提，必须要实现。然后在C和A之间二选一。因此分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</p><p>如果网络分区正常的话(系统在绝大部分时候所处的状态)，也就说不需要保证 P 的时候，C 和 A 能够同时保证。</p><h4 id="为什么要首先保证P"><a href="#为什么要首先保证P" class="headerlink" title="为什么要首先保证P"></a>为什么要首先保证P</h4><ul><li>分布式系统的本质：分区容错性(P)是指系统在网络分区发生时，仍然能够继续提供服务的能力。在分布式系统中，网络分区是不可避免的，因此分区容错性是分布式系统必须具备的基本属性。</li><li>保证系统的高可用性：如果不保证分区容错性，那么一旦网络分区发生，系统可能会因为无法处理分区而崩溃或停止服务，这将严重影响系统的可用性和稳定性。通过P确保系统的高可用性。</li><li>符合分布式系统的设计理念：分布式系统的设计初衷就是为了提高系统的可扩展性、可靠性和容错性。如果放弃分区容错性，那么分布式系统就失去了其最重要的优势之一。<ul><li>在分布式系统中，通过将数据和服务分布在多个节点上，可以实现负载均衡、故障转移和容错处理等功能。这些功能的实现都依赖于分区容错性的支持。</li></ul></li><li>实际应用高并发的需求：在实际应用中，分布式系统往往需要处理大量的并发请求和数据，同时还需要面对各种复杂的网络环境和故障情况。<ul><li>如果不保证分区容错性，那么系统在面对这些挑战时可能会显得力不从心，无法满足实际应用的需求。</li></ul></li></ul><h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><p>RPC(Remote Procedure Call)框架是一种允许程序调用另一个地址空间(通常是网络上的另一台机器)上的过程或函数，就像调用本地程序中的函数一样。RPC 框架隐藏了网络通信的复杂性，使得开发者可以更加专注于业务逻辑的实现，而不是底层的网络通信和序列化&#x2F;反序列化等细节。</p><p>RPC 框架通常包含以下几个关键组件：</p><ul><li>客户端(Client)：发起远程过程调用的程序。客户端负责将调用请求发送给服务器，并等待服务器的响应。</li><li>服务端(Server)：提供远程过程或函数供客户端调用的程序。服务端接收来自客户端的请求，执行相应的操作，并将结果返回给客户端。</li><li>通信协议(Protocol)：客户端和服务端之间通信所遵循的规则。这包括数据的编码方式、传输方式(如TCP&#x2F;IP)、请求和响应的格式等。</li><li>序列化&#x2F;反序列化(Serialization&#x2F;Deserialization)：由于客户端和服务端可能运行在不同的机器上，它们之间的数据交换需要通过网络进行。序列化是将数据结构或对象状态转换成可以存储或传输的格式的过程，反序列化则是其逆过程。RPC 框架需要处理这些数据的序列化和反序列化。</li><li>服务注册与发现(Service Registry and Discovery)：在微服务架构中，服务注册与发现是一个重要的组成部分。服务注册允许服务实例向注册中心注册自己的信息，服务发现则允许客户端从注册中心查询所需服务的信息，以便进行远程调用。</li><li>负载均衡(Load Balancing)：当服务有多个实例时，负载均衡器负责将请求分发到不同的服务实例上，以提高系统的可用性和吞吐量。</li></ul><p>在Java中，有多种RPC(远程过程调用)框架可供选择，这些框架为开发分布式系统提供了强大的支持。以下是一些常见的Java RPC框架：</p><ol><li>Dubbo<br>简介：Dubbo是阿里巴巴开源的高性能RPC框架，具有简单易用、高性能、可扩展等特点。它支持多种协议和负载均衡策略，提供了服务注册、发现和调用的解决方案。<br>特点：面向接口的远程方法调用、智能容错和负载均衡、服务自动注册和发现等。<br>适用场景：广泛应用于许多大型互联网公司，特别是需要高性能和可扩展性的分布式系统。</li><li>Spring Cloud<br>简介：Spring Cloud是Spring家族的一个开源项目，它提供了许多分布式系统的解决方案，其中包括了RPC框架。它利用Spring Boot的特性，整合了开源行业中优秀的组件，为微服务架构提供了一整套服务治理的解决方案。<br>特点：支持服务注册发现、服务调用、负载均衡等，可以方便地实现RPC通信。<br>适用场景：适合需要快速构建微服务架构的Java应用。</li><li>Thrift<br>简介：Thrift是由Facebook开源的跨语言RPC框架，支持多种编程语言，包括Java。它使用接口描述语言(IDL)定义服务接口，通过生成和序列化代码来实现跨语言的通信。<br>特点：高效的序列化和传输机制，支持多种传输协议和压缩算法，适用于各种复杂的分布式应用场景。<br>适用场景：当系统需要支持多种编程语言，且对性能和效率有较高要求时，Thrift是一个很好的选择。</li><li>gRPC<br>简介：gRPC是由Google开源的高性能RPC框架，它使用Protocol Buffers作为接口描述语言，并使用HTTP&#x2F;2作为传输协议。gRPC支持多种编程语言，包括Java。<br>特点：简单易用、高效可靠，适用于构建微服务和移动应用后端服务。<br>适用场景：当系统需要高性能的RPC调用，并且希望使用HTTP&#x2F;2协议和Protocol Buffers作为序列化方式时，gRPC是一个不错的选择。</li><li>Apache CXF<br>简介：Apache CXF是一个开源的全功能的服务框架，它支持多种和Web服务相关的标准和协议，包括SOAP、REST和WS-*协议。Apache CXF提供了丰富的功能和扩展点，可以方便地实现RPC调用。<br>特点：支持多种传输协议和安全机制，适用于构建复杂的分布式系统。<br>适用场景：当系统需要支持多种Web服务标准和协议时，Apache CXF是一个很好的选择。</li><li>其他RPC框架<br>除了上述几种常见的Java RPC框架外，还有一些其他的框架如RMI(基于JRMP通信协议)、Hessian(基于二进制RPC协议)等，它们各自具有不同的特点和适用场景。</li></ol><p>Java中的RPC框架有多种选择，开发人员可以根据具体需求选择合适的框架来实现远程过程调用。这些框架的出现极大地简化了分布式系统的开发，提高了开发效率和系统性能。</p><h2 id="高性能✅"><a href="#高性能✅" class="headerlink" title="高性能✅"></a>高性能✅</h2><h3 id="CDN工作原理详解"><a href="#CDN工作原理详解" class="headerlink" title="CDN工作原理详解"></a>CDN工作原理详解</h3><p>CDN(Content Delivery Network&#x2F;Content Distribution Network)，内容分发网络，其将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</p><p>CDN和全站加速不同，全站加速既可以加速静态资源又可以加速动态资源，CDN主要针对静态资源。</p><ol><li>基本概念<ul><li>CDN节点：CDN节点是部署在不同地理位置的服务器。它们可以缓存内容并处理用户请求。</li><li>源站：源站是内容的原始服务器，即CDN未介入时用户直接访问的服务器。</li><li>POP(Point of Presence)：指的是一个CDN服务点，通常是一个小型的数据中心，包含多个CDN节点。</li><li>缓存：CDN节点会缓存从源站获取的内容，以减少对源站的请求频率和用户的访问延迟。</li></ul></li><li>CDN的基本工作流程<ol><li>用户请求内容：当用户访问一个使用CDN的网页时，用户的请求首先会被重定向到离用户最近的CDN节点。</li><li>查找缓存内容：<ul><li>缓存命中：如果该CDN节点已经缓存了所请求的内容(缓存命中)，则直接将内容返回给用户。</li><li>缓存未命中：如果缓存中没有请求的内容(缓存未命中)，该节点会向源站发起请求以获取内容，然后将内容返回给用户，同时缓存该内容以供后续请求使用。</li></ul></li><li>全局负载均衡：CDN利用全局负载均衡系统根据地理位置、服务器负载、网络状况等因素，将用户请求引导至最合适的节点。</li><li>内容刷新与失效：CDN可以根据配置设置内容的缓存时间，过期后需要重新从源站获取。同时，源站也可以主动通知CDN刷新或失效某些内容。</li></ol></li><li>CDN的优化<ul><li>预热：预热是指在 CDN 上提前将内容缓存到 CDN 节点上。</li></ul></li><li>使用CDN的优势<ul><li>降低延迟：由于CDN节点分布在全球各地，用户请求可以在离用户最近的节点上得到响应，减少了物理距离带来的延迟。</li><li>提高可用性：CDN通过分布式架构可以在某些节点发生故障时自动切换到其他节点，提高服务的可靠性。</li><li>分担源站压力：通过将大量的内容缓存到CDN节点，减少了对源站的直接请求，特别是在流量高峰期，显著减轻了源站的压力。</li><li>加速内容分发：CDN可以通过多种优化手段加速内容分发，提升用户体验。</li></ul></li><li>常见的应用场景<ul><li>网站加速：静态内容(如图像、CSS、JavaScript文件)的加速分发。</li><li>视频点播：将视频内容缓存到各个CDN节点，提高视频播放的流畅性。</li><li>实时流媒体：利用CDN的低延迟特点，确保实时视频流的顺畅传输。</li><li>下载加速：通过CDN分发大文件(如软件、游戏安装包等)，加快下载速度。</li></ul></li></ol><h4 id="如何找到最合适的-CDN-节点？"><a href="#如何找到最合适的-CDN-节点？" class="headerlink" title="如何找到最合适的 CDN 节点？"></a>如何找到最合适的 CDN 节点？</h4><p>GSLB(Global Server Load Balance，全局负载均衡)是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点：</p><ol><li>浏览器向 DNS 服务器发送域名请求；</li><li>DNS 服务器向根据 CNAME(Canonical Name) 别名记录向 GSLB 发送请求；</li><li>GSLB 返回性能最好(通常距离请求地址最近)的 CDN 节点(边缘服务器，真正缓存内容的地方)的IP地址给浏览器；</li><li>浏览器根据IP地址直接访问指定的 CDN 节点。</li></ol><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。</p><p>一般分为服务端负载均衡和客户端负载均衡：</p><ul><li>服务端负载均衡主要发生在网关层，可以使用软件(便宜，性能也够用)或者硬件(贵，但是性能好)实现。软件负载均衡通过如Nginx之类的软件实现，可在传输层、应用层实现负载均衡<ul><li>传输层主要协议是 TCP&#x2F;UDP，该层能看到数据包里的源端口地址和目的端口地址，会基于这些信息通过一定的负载均衡算法将数据包转发到后端真实服务器，核心就是 IP+端口层面的负载均衡。</li><li>应用层主要协议是 HTTP，该层的负载均衡会读取报文的数据部分，根据读取到的(URL、Cookie)做出负载均衡决策。执行第七层负载均衡的设备通常被称为 反向代理服务器。</li></ul></li><li>客户端负载均衡主要应用于系统内部的不同的服务之间。客户端会自己维护一份服务器的地址列表，发送请求之前，客户端会根据对应的负载均衡算法来选择具体某一台服务器处理请求。(通过Spring Cloud Load Balancer)</li></ul><h4 id="常见负载均衡算法"><a href="#常见负载均衡算法" class="headerlink" title="常见负载均衡算法"></a>常见负载均衡算法</h4><ol><li>随机法：随机选择一台服务器处理请求。<ul><li>优点：实现简单，适用于分布较为均匀的场景。</li><li>缺点：不保证请求的均匀分配，可能导致短时间内某些服务器负载过重。</li></ul></li><li>轮询法：将请求依次分配给服务器，以循环的方式逐一选择服务器。<ul><li>优点：实现简单，能够较为均衡地分配请求。</li><li>缺点：对于性能差异较大的服务器，可能导致某些服务器过载。</li></ul></li><li>两次随机法：随机选择两台服务器，比较它们的负载，将请求分配给负载较轻的那台服务器。<ul><li>优点：较普通随机法更为均衡，性能也较为优越。</li><li>缺点：仍存在一定的随机性，可能不完全均衡。</li></ul></li><li>哈希法：根据请求的某些特征(如源IP、URL)计算哈希值，并根据哈希值选择相应的服务器。<ul><li>优点：对相同特征的请求分配到相同的服务器，适合需要会话保持的场景。</li><li>缺点：难以应对服务器动态变化，如增加或减少服务器。</li></ul></li><li>一致性Hash法：将服务器和请求都映射到一个哈希环上，请求沿环顺时针找到最近的服务器。<ul><li>优点：当服务器增加或减少时，只有一小部分请求会被重新分配，适合于动态变化的分布式系统。</li><li>缺点：实现较为复杂，对哈希函数的选择有要求。</li></ul></li><li>最小连接法：将请求分配给当前连接数最少的服务器。<ul><li>优点：动态调整负载，适用于长连接的场景。</li><li>缺点：需要实时监控服务器的连接数，较为复杂。</li></ul></li><li>最少活跃法：将请求分配给当前处理请求最少的服务器。<ul><li>优点：能更精确地反映服务器的实时负载，较为公平地分配请求。</li><li>缺点：实现和计算较为复杂。</li></ul></li><li>最快响应时间法：将请求分配给响应时间最快的服务器。<ul><li>优点：可以提供更好的用户体验，适用于对响应时间要求较高的场景。</li><li>缺点：实现难度较大，需要实时监控和记录每台服务器的响应时间。</li></ul></li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是一种存放消息的容器，当需要使用消息的时候，直接从容器中取出使用即可。参与消息传递的双方是生产者和消费者，生产者负责生产并发送消息，消费者负责处理消息。</p><blockquote><p>这里提到的消息队列不是操作系统进程通信中的消息队列，而是各个服务以及系统内部各个组件&#x2F;模块之前的通信，属于一种中间件。<br>中间件(英语：Middleware)，又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。</p></blockquote><h2 id="高可用✅"><a href="#高可用✅" class="headerlink" title="高可用✅"></a>高可用✅</h2><h3 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h3><p>高可用描述的是一个系统在大部分时间都是可用的，可以提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p><ul><li>99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了</li><li>系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</li></ul><h3 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h3><ul><li>黑客攻击；</li><li>硬件故障，比如服务器坏掉。</li><li>并发量&#x2F;用户请求量激增导致整个服务宕掉或者部分服务不可用。</li><li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li><li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li><li>自然灾害或者人为破坏。</li><li>……</li></ul><h3 id="提高系统高可用的方法"><a href="#提高系统高可用的方法" class="headerlink" title="提高系统高可用的方法"></a>提高系统高可用的方法</h3><p><strong>注重代码质量，测试严格把关</strong><br>代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。比较实际可用的提高代码质量方法就是 CodeReview。</p><p><strong>使用集群，减少单点故障</strong><br>比如使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p><p><strong>限流</strong><br>流量控制，其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p><strong>超时和重试机制设置</strong><br>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。在读取第三方服务的时候，尤其适合设置超时和重试机制。一般使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力(部分场景使用失败重试机制会不太适合)。</p><p><strong>熔断机制</strong><br>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p><p><strong>异步调用</strong><br>异步调用的话我们不需要关心最后的结果，这样就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。</p><p><strong>使用缓存</strong><br>如果系统属于并发量比较高的话，如果单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p><p><strong>其他</strong></p><ul><li>核心应用和服务优先使用更好的硬件</li><li>监控系统资源使用情况增加报警设置。</li><li>注意备份，必要时候回滚。</li><li>灰度发布：将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li><li>定期检查&#x2F;更换硬件： 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li><li>……</li></ul><h3 id="冗余设计"><a href="#冗余设计" class="headerlink" title="冗余设计"></a>冗余设计</h3><p>冗余设计是保证系统和数据高可用的最常的手段。</p><ul><li>对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。</li><li>对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。</li></ul><p>高可用集群(High Availability Cluster，简称 HA Cluster)、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。</p><ul><li>高可用集群：同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。</li><li>同城灾备：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。</li><li>异地灾备：类似于同城灾备，不同的是，相同服务部署在异地(通常距离较远，甚至是在不同的城市或者国家)的不同机房中</li><li>同城多活：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。</li><li>异地多活：将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。</li></ul><h3 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h3><h4 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h4><p>原理是将时间划分为固定大小的窗口，在每个窗口内限制请求的数量或速率，即固定窗口计数器算法规定了系统单位时间处理的请求数量。<br>假如规定系统中某个接口 1 分钟只能被访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p><ul><li>将时间划分固定大小窗口，这里是 1 分钟一个窗口。</li><li>给定一个变量 counter 来记录当前接口处理的请求数量，初始值为 0(代表接口当前 1 分钟内还未处理请求)。</li><li>1 分钟之内每处理一个请求之后就将 counter+1 ，当 counter&#x3D;33 之后(也就是说在这 1 分钟内接口已经被访问 33 次的话)，后续的请求就会被全部拒绝。</li><li>等到 1 分钟结束后，将 counter 重置 0，重新开始计数。</li></ul><p>优点：实现简单，易于理解。<br>缺点：</p><ul><li>限流不够平滑。例如限制某个接口每分钟只能访问 30 次，假设前 30 秒就有 30 个请求到达的话，那后续 30 秒将无法处理请求，这是不可取的，用户体验极差！</li><li>无法保证限流速率，因而无法应对突然激增的流量。例如限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</li></ul><h4 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h4><p>滑动窗口计数器算法限流的颗粒度更小，其把固定窗口算法中的固定窗口再次划分为若干片。</p><p>例如接口限流每分钟处理 60 个请求，可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 60(请求数)&#x2F;60(窗口数)的请求，如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。很显然，当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>优点：</p><ul><li>相比于固定窗口算法，滑动窗口计数器算法可以应对突然激增的流量。</li><li>相比于固定窗口算法，滑动窗口计数器算法的颗粒度更小，可以提供更精确的限流控制。</li></ul><p>缺点：</p><ul><li>与固定窗口计数器算法类似，滑动窗口计数器算法依然存在限流不够平滑的问题。</li><li>相比较于固定窗口计数器算法，滑动窗口计数器算法实现和理解起来更复杂一些。</li></ul><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>可以把发请求的动作比作成注水到桶中，处理请求的过程可以比喻为漏桶漏水。往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后定期从队列中拿请求来执行就好了(和消息队列削峰&#x2F;限流的思想是一样的)。</p><p><img src="/./image/Java-backend/loutong-algo.png" alt="漏桶算法"></p><p>优点：</p><ul><li>实现简单，易于理解。</li><li>可以控制限流速率，避免网络拥塞和系统过载。</li></ul><p>缺点：</p><ul><li>无法应对突然激增的流量，因为只能以固定的速率处理请求，对系统资源利用不够友好。</li><li>桶流入水(发请求)的速率如果一直大于桶流出水(处理请求)的速率的话，那么桶会一直是满的，一部分新的请求会被丢弃，导致服务质量下降。</li></ul><p>实际业务场景中，基本不会使用漏桶算法。</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>和漏桶算法算法一样，过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃(删除)。根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。<br><img src="/./image/Java-backend/lingpaitong-algo.png" alt="令牌桶算法"></p><p>优点：</p><ul><li>可以限制平均速率和应对突然激增的流量。</li><li>可以动态调整生成令牌的速率。</li></ul><p>缺点：</p><ul><li>如果令牌产生速率和桶的容量设置不合理，可能会出现问题比如大量的请求被丢弃、系统过载。</li><li>相比于其他限流算法，实现和理解起来更复杂一些。</li></ul><h3 id="针对什么来进行限流？"><a href="#针对什么来进行限流？" class="headerlink" title="针对什么来进行限流？"></a>针对什么来进行限流？</h3><p>实际项目中，还需要确定限流对象，也就是针对什么来进行限流。常见的限流对象如下：</p><ul><li>IP ：针对 IP 进行限流，适用面较广，简单粗暴。</li><li>业务 ID：挑选唯一的业务 ID 以实现更针对性地限流。例如，基于用户 ID 进行限流。</li><li>个性化：根据用户的属性或行为，进行不同的限流策略。例如， VIP 用户不限流，而普通用户限流。根据系统的运行指标(如 QPS、并发调用数、系统负载等)，动态调整限流策略。例如，当系统负载较高的时候，控制每秒通过的请求减少。</li></ul><h3 id="单机限流怎么做"><a href="#单机限流怎么做" class="headerlink" title="单机限流怎么做"></a>单机限流怎么做</h3><p>可使用令牌桶算法</p><h3 id="分布式限流怎么做"><a href="#分布式限流怎么做" class="headerlink" title="分布式限流怎么做"></a>分布式限流怎么做</h3><p>分布式限流针对的分布式&#x2F;微服务应用架构应用，在这种架构下，单机限流就不适用了，因为会存在多种服务，并且一种服务也可能会被部署多份。<br>分布式限流常见的方案：</p><ul><li>借助中间件限流：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li><li>网关层限流：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件&#x2F;框架。就比如 Spring Cloud Gateway 的分布式限流实现RedisRateLimiter就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li></ul><p>如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。为什么建议 Redis+Lua 的方式？主要有两点原因：</p><ul><li>减少了网络开销：可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</li><li>原子性：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li></ul><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级指的是在服务压力过大或部分功能出现故障时，主动减少或关闭某些非核心功能，从而确保核心功能的正常运行。通过降级，系统可以在不影响主要功能的情况下，减轻负载，避免因部分功能故障导致整个系统不可用。</p><p>应用场景：</p><ul><li>系统负载过高：当系统承受的请求量过大，可能会导致性能下降。此时，可以通过关闭一些耗资源的非关键功能，确保核心服务的响应速度。</li><li>依赖服务异常：如果系统依赖的某个外部服务发生故障或延迟过大，可以选择临时关闭与该服务相关的功能，而不是完全停掉系统的服务。</li><li>业务需求波动：在某些特殊时期(如促销活动)，为了应对突增的流量，可以提前降级部分非核心功能。</li></ul><p>实现方式：</p><ul><li>关闭某些功能：通过开关、配置中心等手段，临时禁用部分功能或模块。</li><li>提供默认值：在依赖服务不可用时，返回默认数据或缓存数据。</li><li>减少服务质量：降低服务的质量，例如降低图像分辨率、减少查询结果数量等。</li></ul><p>优势：</p><ul><li>保障系统核心功能的可用性。</li><li>减轻系统负载，避免雪崩效应。</li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>熔断是一种故障隔离机制，当系统某个组件(如外部服务)出现问题时，熔断器会自动切断对该组件的请求，从而避免故障蔓延到整个系统。熔断器在一段时间后会尝试恢复连接，如果故障消失，系统会恢复正常调用。</p><p>熔断的状态：</p><ul><li>关闭状态(Closed)：正常情况下，所有请求都通过，熔断器处于关闭状态。</li><li>打开状态(Open)：当外部服务持续出现故障，超过一定阈值时，熔断器切换到打开状态，直接拒绝请求并返回错误响应。</li><li>半开状态(Half-Open)：熔断器在一段时间后尝试恢复连接，允许少量请求通过，测试外部服务是否恢复正常。如果请求成功，熔断器切回到关闭状态；如果失败，继续保持打开状态。</li></ul><p>应用场景：</p><ul><li>依赖服务不可用：当依赖的外部服务出现异常或性能下降时，频繁的调用失败会导致资源浪费和系统阻塞。此时，熔断器可以及时切断这些无效请求，保护系统的其他部分不受影响。</li><li>防止级联故障：在分布式系统中，如果一个服务的故障导致下游服务的负载激增，可能引发连锁反应。熔断可以防止这种级联故障的发生。</li></ul><p>实现方式：</p><ul><li>错误率监控：根据外部服务的错误率或响应时间来判断是否触发熔断。</li><li>超时设置：如果外部服务的响应时间超过设定的阈值，触发熔断。</li><li>自动恢复：熔断器在一段时间后自动尝试恢复连接。</li></ul><p>优势：</p><ul><li>防止故障扩散，保障系统的稳定性。</li><li>提高系统的容错能力和恢复能力。</li></ul><h3 id="降级与熔断的区别"><a href="#降级与熔断的区别" class="headerlink" title="降级与熔断的区别"></a>降级与熔断的区别</h3><ul><li>目标不同：降级的目标是保障核心功能在高负载或异常情况下仍然可用；熔断的目标是防止系统因依赖的某个组件故障而出现更大范围的故障。</li><li>触发条件不同：降级通常是基于系统的负载、请求量等情况进行主动调整；熔断则是基于对外部服务的健康状态监控进行被动触发。</li><li>恢复方式不同：降级通常需要手动干预恢复，比如流量减少后手动恢复被关闭的功能；熔断则具有自动恢复机制，当外部服务恢复正常后熔断器会自动切换到关闭状态。</li></ul><h3 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h3><p><strong>超时机制</strong>用于防止请求长时间等待而不返回结果。它为每个请求设定一个最大等待时间，一旦超过这个时间，系统就会认为该请求失败，从而采取相应的措施(如重试、降级或直接返回错误)。</p><p>关键点：</p><ul><li>超时的设定：超时时间应根据具体业务需求、网络延迟和系统性能来合理设定。超时过短可能导致误判，超时过长又可能影响用户体验和系统响应时间。</li><li>超时的作用：防止资源的长期占用，减少系统的线程或连接被长时间挂起，从而保持系统的响应能力。</li><li>分级超时：在复杂的分布式系统中，不同的服务或组件可以有不同的超时设置，以适应各自的性能特点和业务需求。</li></ul><p>示例：<br>在微服务架构中，假设服务 A 需要调用服务 B，B 可能由于各种原因(如高负载、网络抖动)无法及时响应。A 可以设置一个超时时间(如 2 秒)，如果 B 在 2 秒内没有响应，A 会认为调用失败并处理该情况。</p><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p><strong>重试机制</strong>用于在请求失败时自动重试，以应对临时性故障。重试可以显著提高成功率，特别是在分布式系统中，网络故障、资源争用等问题可能只是暂时的。</p><p>关键点：</p><ul><li>重试策略：重试机制需要设计合理的策略，包括：<ul><li>重试次数：设定最大重试次数，防止无限重试导致系统过载。</li><li>重试间隔：设置重试之间的等待时间，可以是固定时间间隔，也可以是指数退避(每次重试间隔逐渐增加)。</li><li>重试条件：明确哪些错误或状态需要重试，如网络超时、连接中断等。</li></ul></li><li>幂等性考虑：重试机制要求操作是幂等的，即同一操作多次执行不会产生副作用。如果操作不可避免地产生副作用(如扣款操作)，需要设计幂等处理逻辑。如购买商品时判断是否已经购买过了。</li></ul><p>示例：<br>在支付系统中，用户支付请求可能由于网络抖动而失败。系统可以在支付失败后自动重试 3 次，每次间隔 1 秒。如果第 3 次重试后仍然失败，则返回错误给用户。</p><h3 id="超时与重试的协作"><a href="#超时与重试的协作" class="headerlink" title="超时与重试的协作"></a>超时与重试的协作</h3><p>超时和重试通常结合使用，以实现更高的可用性：</p><ul><li>超时后重试：请求在超时后进行重试，直到达到最大重试次数。</li><li>分布式场景中的挑战：在分布式系统中，超时和重试可能会放大问题，例如请求风暴或级联故障。因此，在设计时要特别注意这些可能的副作用。</li></ul><p><strong>总结：</strong></p><ul><li><strong>超时机制</strong>防止请求长时间挂起，提升系统的资源利用效率。</li><li><strong>重试机制</strong>则通过自动化的重试操作，提高请求的成功率和系统的容错能力。</li><li>两者结合使用时，需要精心设计超时和重试策略，以确保系统的高可用性和稳定性。</li></ul><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h4 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h4><p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p><h4 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h4><p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。负载测试说白点就是测试系统的上限。</p><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p><h4 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h4><p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p><h4 id="常见性能优化策略"><a href="#常见性能优化策略" class="headerlink" title="常见性能优化策略"></a>常见性能优化策略</h4><p>性能优化之前需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p><ol><li>系统是否需要缓存？</li><li>系统架构本身是不是就有问题？</li><li>系统是否存在死锁的地方？</li><li>系统是否存在内存泄漏？(Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏)</li><li>数据库索引使用是否合理？</li><li>…</li></ol><h4 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h4><ul><li>QPS(Query Per Second)：服务器每秒可以执行的查询次数；</li><li>TPS(Transaction Per Second)：服务器每秒处理的事务数(这里的一个事务可以理解为客户发出请求到收到服务器的过程)；</li><li>RT：响应时间RT(Response-time)就是用户发出请求到用户收到系统处理结果所需要的时间。</li><li>并发数：可以简单理解为系统能够同时供多少人访问使用也就是说系统同时能处理的请求数量。</li><li>吞吐量：吞吐量指的是系统单位时间内系统处理的请求数量。</li></ul><p>QPS(TPS) &#x3D; 并发数&#x2F;平均响应时间(RT)<br>并发数 &#x3D; QPS * 平均响应时间(RT)</p><blockquote><p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个 TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器 2 次，一次访问，产生一个“T”，产生 2 个“Q”。</p></blockquote><h3 id="处理上限为100的接口，突然10000个请求过来了，怎么办？"><a href="#处理上限为100的接口，突然10000个请求过来了，怎么办？" class="headerlink" title="处理上限为100的接口，突然10000个请求过来了，怎么办？"></a>处理上限为100的接口，突然10000个请求过来了，怎么办？</h3><p>当接口突然接收到超出其处理能力的大量请求时，需要采取一些策略来防止系统过载，并确保服务的可用性。</p><ul><li>限流：通过限制每个时间单位内允许处理的请求数量来防止过载。常见的限流算法包括漏桶算法和令牌桶算法。</li><li>负载均衡：使用负载均衡器将请求分配到多个服务器上，以均衡负载。可以使用软件解决方案(如 Nginx 或 Apache)。</li><li>缓存：缓存可以减轻数据库和后端服务的压力。对于一些可以缓存的请求结果，可以使用 Redis 进行缓存。</li><li>降级：在高负载时，可以对某些非关键功能进行降级，例如延迟处理或返回默认值。</li><li>消息队列：将请求放入消息队列中进行异步处理，如使用 Kafka、RabbitMQ 或 ActiveMQ。</li><li>扩展资源：根据实际情况扩展服务器资源，包括水平扩展(增加服务器数量)和垂直扩展(增加单个服务器的处理能力)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏研发面经</title>
      <link href="/posts/17779.html"/>
      <url>/posts/17779.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要应聘游戏研发这个岗位"><a href="#为什么要应聘游戏研发这个岗位" class="headerlink" title="为什么要应聘游戏研发这个岗位"></a>为什么要应聘游戏研发这个岗位</h3><h3 id="玩过哪些游戏？如何设计出一个游戏？"><a href="#玩过哪些游戏？如何设计出一个游戏？" class="headerlink" title="玩过哪些游戏？如何设计出一个游戏？"></a>玩过哪些游戏？如何设计出一个游戏？</h3><h3 id="UDP在游戏中为什么丢了包不影响"><a href="#UDP在游戏中为什么丢了包不影响" class="headerlink" title="UDP在游戏中为什么丢了包不影响"></a>UDP在游戏中为什么丢了包不影响</h3><p>在游戏中使用 UDP(用户数据报协议)而丢包不影响游戏体验的原因主要有以下几点：</p><ol><li><strong>实时性要求高</strong>：许多游戏(特别是在线游戏)需要实时传输数据，保证游戏的流畅性和响应速度。UDP是一种无连接协议，不需要建立连接就能发送数据，传输速度快，延迟低，适合实时数据传输。</li><li><strong>数据包丢失容忍度高</strong>：游戏中的许多数据(如玩家的位置、动作等)会频繁更新。即使有些数据包丢失了，也很快会被新的数据包覆盖，因此不会对游戏体验造成明显影响。相比之下，TCP需要确认每个数据包的接收，这会导致延迟，影响游戏的实时性。</li><li><strong>自定义重传机制</strong>：一些游戏会自行实现数据包丢失的检测和重传机制，而不是依赖于底层协议的重传机制。这种方式更灵活，可以根据具体需要决定是否重传丢失的数据包。</li><li><strong>不重要的数据</strong>：一些数据(如瞬时状态更新)即使丢失也不会对游戏产生重大影响。游戏开发者可以根据数据的重要性选择是否采用UDP来传输这些数据。</li></ol><p>这些特点使得UDP在许多需要快速、实时数据传输的游戏中得到了广泛应用。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 游戏研发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/posts/17777.html"/>
      <url>/posts/17777.html</url>
      
        <content type="html"><![CDATA[<h3 id="8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球"><a href="#8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球" class="headerlink" title="8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球"></a>8个外形一样的球，其中有一个偏重，如何只通过两次测量找到重球</h3><p>为了在只使用两次测量的情况下找到8个球中偏重的那个球，可以采用以下方法：</p><ul><li>将8个球分成3组：<ul><li>第一组：A、B、C</li><li>第二组：D、E、F</li><li>第三组：G、H</li></ul></li><li>第一次测量：<ul><li>将第一组(A、B、C)放在天平的左边，第二组(D、E、F)放在天平的右边。<br>可能的结果有三种：</li><li>左边重(A、B、C中有一个是重球)</li><li>右边重(D、E、F中有一个是重球)</li><li>两边一样重(G、H中有一个是重球)</li></ul></li><li>第二次测量：<ul><li>如果第一次测量左边重：从A、B、C中任选两个球进行测量，例如A和B。<ul><li>如果A和B重量相等，则重球是C。</li><li>如果A和B不等，则重球是较重的那个。</li></ul></li><li>如果第一次测量右边重：从D、E、F中任选两个球进行测量，例如D和E。<ul><li>如果D和E重量相等，则重球是F。</li><li>如果D和E不等，则重球是较重的那个。</li></ul></li><li>如果第一次测量两边一样重：对G和H进行测量。<ul><li>如果G和H重量相等，则重球不存在(但由于题意重球必存在，所以这个情况不会出现)。</li><li>如果G和H不等，则重球是较重的那个。</li></ul></li></ul></li></ul><p>通过这种方法，可以在两次测量内准确找到8个球中偏重的那个球。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计</title>
      <link href="/posts/17778.html"/>
      <url>/posts/17778.html</url>
      
        <content type="html"><![CDATA[<h3 id="实现多个客户端访问一个服务端"><a href="#实现多个客户端访问一个服务端" class="headerlink" title="实现多个客户端访问一个服务端"></a>实现多个客户端访问一个服务端</h3><p>使用<code>Socket</code>编程来实现一个简单的客户端-服务端模型。</p><p>服务端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义服务端的IP地址和端口</span></span><br><span class="line">server_ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">server_port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((server_ip, server_port))</span><br><span class="line">server_socket.listen(<span class="number">5</span>)  <span class="comment"># 最大连接数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;服务器启动，监听端口: <span class="subst">&#123;server_port&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            message = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> message:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;收到消息: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">            response = <span class="string">f&quot;服务器收到消息: <span class="subst">&#123;message&#125;</span>&quot;</span></span><br><span class="line">            client_socket.send(response.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> ConnectionResetError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client_socket, client_address = server_socket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;连接来自: <span class="subst">&#123;client_address&#125;</span>&quot;</span>)</span><br><span class="line">    client_handler = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">    client_handler.start()</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义服务端的IP地址和端口</span></span><br><span class="line">server_ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">server_port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Socket对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(<span class="string">&quot;请输入发送给服务器的消息: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> message.lower() == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client_socket.send(message.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    response = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;服务器回应: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><p>服务端代码:</p><ul><li>创建一个<code>Socket</code>对象并绑定到指定的IP地址和端口。</li><li>使用<code>listen()</code>方法开始监听连接。</li><li>当有客户端连接时，接受连接并创建一个新的线程来处理该客户端的通信。</li><li><code>handle_client</code>函数负责处理与客户端的通信，包括接收消息和发送响应。</li></ul><p>客户端代码:</p><ul><li>创建一个<code>Socket</code>对象并连接到服务端的IP地址和端口。</li><li>进入一个循环，从用户输入获取消息并发送到服务端。</li><li>接收服务端的响应并打印出来。</li><li>当用户输入<code>&#39;exit&#39;</code>时，关闭连接。</li></ul><p>这种方法使用多线程来处理多个客户端的连接，每个客户端都有一个单独的线程来处理，从而实现了多个客户端访问一个服务端。</p><h3 id="置顶和加精如何设计"><a href="#置顶和加精如何设计" class="headerlink" title="置顶和加精如何设计"></a>置顶和加精如何设计</h3><p>执行置顶和加精的设计通常涉及后端系统的多个层面，包括数据库设计、API接口设计、权限控制以及前端展示等。以下是一个基于通用场景的设计方案：</p><ol><li>数据库设计：在数据库中需要为帖子(或文章)表添加相应的字段以支持置顶和加精功能。常见的做法是为帖子表添加两个字段：<ul><li><code>is_top</code>(或类似名称)：用于标识帖子是否置顶。该字段通常为布尔类型或整型(0表示未置顶，1表示已置顶)。</li><li><code>is_wonderful</code>(或类似名称)：用于标识帖子是否加精。该字段同样为布尔类型或整型(0表示未加精，1表示已加精)。</li></ul></li><li>API接口设计：在API层面，需要设计相应的接口来支持置顶和加精操作。<ul><li>置顶接口：接受帖子的ID作为参数，将对应帖子的<code>is_top</code>字段设置为1(或相应的值)，并返回操作结果。</li><li>取消置顶接口：与置顶接口类似，但将<code>is_top</code>字段设置回0(或相应的值)。</li><li>加精接口：接受帖子的ID作为参数，将对应帖子的<code>is_wonderful</code>字段设置为1(或相应的值)，并返回操作结果。</li><li>取消加精接口：与加精接口类似，但将<code>is_wonderful</code>字段设置回0(或相应的值)。</li></ul></li><li>权限控制：在执行置顶和加精操作时，还需要进行权限控制，以确保只有具有相应权限的用户(如版主或管理员)才能执行这些操作。这通常通过以下方式实现： <ul><li>用户认证：首先，用户需要登录系统，并通过身份验证。</li><li>角色和权限检查：系统检查用户的角色(如版主、管理员等)和权限，以确定用户是否有权执行置顶或加精操作。</li></ul></li><li>前端展示：在前端展示方面，需要为具有相应权限的用户显示置顶和加精的按钮或链接，并在帖子列表中根据帖子的<code>is_top</code>和<code>is_wonderful</code>字段的值来展示相应的标识(如置顶标签、加精图标等)。</li><li>额外考虑<ul><li>数据一致性：在执行置顶和加精操作时，需要确保数据的一致性。例如，如果系统只允许一个帖子置顶，那么在置顶新帖子时需要先取消其他帖子的置顶状态。</li><li>性能优化：对于高并发的系统，需要考虑如何优化置顶和加精操作的性能。例如，可以通过缓存技术来减少数据库的访问次数。</li><li>日志记录：为了追踪和审计操作，系统应该记录每次置顶和加精操作的详细信息，包括操作时间、操作人、帖子ID等。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python知识点</title>
      <link href="/posts/17776.html"/>
      <url>/posts/17776.html</url>
      
        <content type="html"><![CDATA[<h3 id="Python内存模型"><a href="#Python内存模型" class="headerlink" title="Python内存模型"></a>Python内存模型</h3><p>Python 的内存模型包括几个重要的概念和机制，帮助解释如何管理和操作内存。以下是关键点：</p><ol><li>对象模型：在 Python 中，一切皆对象。变量实际上是对对象的引用。对象分为可变对象(如列表、字典等)和不可变对象(如整数、字符串、元组等)。</li><li>引用计数：Python 使用引用计数来管理内存。每个对象都有一个引用计数器，当对象被引用时计数加1，当引用被删除时计数减1。当引用计数为0时，对象被回收。</li><li>垃圾回收：除了引用计数，Python 还使用垃圾回收机制来处理循环引用。Python 的垃圾回收器会定期检查并回收那些不再被引用的对象。</li><li>内存分配器：Python 使用私有堆来管理内存。Python 内存分配器负责从操作系统获取内存并将其分配给对象。常用的内存分配器包括 <code>PyObject_Malloc</code> 和 <code>PyMem_Malloc</code>。</li><li>小对象池化：Python 对小对象(通常是小于256字节的对象)进行池化，以提高内存分配和释放的效率。这意味着相同的小对象可能会被多次重用。</li><li>全局解释器锁(GIL)：GIL 是 Python 的一个机制，用于保护 Python 对象的访问，确保多线程环境下的内存安全。虽然 GIL 可以简化内存管理，但它也限制了多线程的并发执行性能。</li></ol><p><strong>示例</strong><br>以下是一个简单的示例，展示了引用计数和垃圾回收的基本概念：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对象</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;引用计数: <span class="subst">&#123;sys.getrefcount(a)&#125;</span>&quot;</span>)  <span class="comment"># 初始引用计数</span></span><br><span class="line"><span class="comment"># 增加引用</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;引用计数: <span class="subst">&#123;sys.getrefcount(a)&#125;</span>&quot;</span>)  <span class="comment"># 引用计数增加</span></span><br><span class="line"><span class="comment"># 删除引用</span></span><br><span class="line"><span class="keyword">del</span> b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;引用计数: <span class="subst">&#123;sys.getrefcount(a)&#125;</span>&quot;</span>)  <span class="comment"># 引用计数减少</span></span><br><span class="line"><span class="comment"># 删除所有引用</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="comment"># 强制执行垃圾回收</span></span><br><span class="line">gc.collect()</span><br></pre></td></tr></table></figure><p><strong>内存管理工具</strong></p><ol><li><code>sys.getsizeof()</code>：返回对象占用的内存大小。</li><li><code>gc</code> 模块：提供接口访问垃圾回收器，如 <code>gc.collect()</code> 可以手动触发垃圾回收。</li></ol><p>通过理解这些内存管理机制，Python 开发者可以更有效地编写高效和内存友好的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点</title>
      <link href="/posts/17775.html"/>
      <url>/posts/17775.html</url>
      
        <content type="html"><![CDATA[<h3 id="C-常用数据结构"><a href="#C-常用数据结构" class="headerlink" title="C++常用数据结构"></a>C++常用数据结构</h3><ul><li>数组(Array)：数组是固定大小的连续内存块，用于存储相同类型的数据。</li><li>动态数组(Vector)：<code>std::vector</code> 是一个动态数组，可以根据需要自动调整大小。</li><li>栈(Stack)：栈是一种后进先出(LIFO)的数据结构。C++ 中可以使用 <code>std::stack</code> 实现栈。</li><li>队列(Queue)：队列是一种先进先出(FIFO)的数据结构。C++ 中可以使用 <code>std::queue</code> 实现队列。</li><li>双端队列(Deque)：双端队列允许在两端进行插入和删除操作。C++ 中可以使用 <code>std::deque</code> 实现双端队列。</li><li>集合(Set)：集合是一种无序且不允许重复元素的数据结构。C++ 中可以使用 <code>std::set</code> 实现集合。</li><li>映射(Map)：映射是一种键值对的数据结构。C++ 中可以使用 <code>std::map</code> 实现映射。</li><li>优先队列(Priority Queue)：优先队列是一种元素带有优先级的队列，C++ 中可以使用 <code>std::priority_queue</code> 实现优先队列。</li><li>哈希表(Unordered Map)：哈希表是一种基于哈希函数的数据结构，用于高效地进行查找、插入和删除操作。C++ 中可以使用 <code>std::unordered_map</code> 实现哈希表。</li></ul><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++中的lambda表达式是一种轻量级的匿名函数，允许在需要时内联定义函数，通常用于一次性操作或局部范围内的操作。它们可以捕获周围作用域的变量，并且可以作为参数传递给算法或其他函数。以下是基本用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 输出 12</span></span><br></pre></td></tr></table></figure><h3 id="new-malloc的区别"><a href="#new-malloc的区别" class="headerlink" title="new&#x2F;malloc的区别"></a>new&#x2F;malloc的区别</h3><p>在 C++ 中，<code>new</code> 和 <code>malloc</code> 都可以用于动态内存分配，但它们有一些关键的区别：</p><ol><li><strong>类型安全</strong>:<ul><li><code>new</code> 是类型安全的，它会根据指定的类型自动进行类型转换。</li><li><code>malloc</code> 返回的是 <code>void*</code>，需要手动进行类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;       <span class="comment">// 自动类型转换</span></span><br><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 需要手动类型转换</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>构造函数和析构函数</strong>:<ul><li><code>new</code> 会调用对象的构造函数来初始化对象。</li><li><code>delete</code> 会调用对象的析构函数来清理对象。</li><li><code>malloc</code> 只分配内存，不会调用构造函数。</li><li><code>free</code> 只释放内存，不会调用析构函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="comment">/* 构造函数 */</span> &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="comment">/* 析构函数 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass* obj1 = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="keyword">delete</span> obj1;                    <span class="comment">// 调用析构函数</span></span><br><span class="line"></span><br><span class="line">MyClass* obj2 = (MyClass*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass)); <span class="comment">// 不调用构造函数</span></span><br><span class="line"><span class="built_in">free</span>(obj2);                                       <span class="comment">// 不调用析构函数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>操作符和函数</strong>:<ul><li><code>new</code> 和 <code>delete</code> 是运算符。</li><li><code>malloc</code> 和 <code>free</code> 是库函数，定义在 <code>&lt;cstdlib&gt;</code> 头文件中。</li></ul></li><li><strong>内存分配失败时的行为</strong>:<ul><li><code>new</code> 在内存分配失败时会抛出 <code>std::bad_alloc</code> 异常。</li><li><code>malloc</code> 在内存分配失败时返回 <code>NULL</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000000000</span>]; <span class="comment">// 如果分配失败会抛出异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::bad_alloc&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* q = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">1000000000</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>使用场景</strong>:<ul><li><code>new</code> 和 <code>delete</code> 更适合用于 C++ 中的面向对象编程，因为它们支持对象的构造和析构。</li><li><code>malloc</code> 和 <code>free</code> 更适合于需要兼容 C 语言代码的场合，或者在特定情况下需要精细控制内存分配。</li></ul></li></ol><p>总结来说，<code>new</code> 和 <code>malloc</code> 各有其适用的场景，选择使用哪一个取决于具体的需求和代码风格。在 C++ 中，通常建议使用 <code>new</code> 和 <code>delete</code>，因为它们更符合 C++ 的编程范式，支持对象的生命周期管理。</p><h3 id="malloc的实现原理"><a href="#malloc的实现原理" class="headerlink" title="malloc的实现原理"></a>malloc的实现原理</h3><p><code>malloc</code> 是 C 语言中的一个函数，用于在堆内存中动态分配指定大小的内存块。它的全称是 “memory allocation”。<code>malloc</code> 的实现涉及操作系统和运行时库的协同工作。下面是 <code>malloc</code> 实现的一些基本概念和步骤：</p><ol><li><strong>初始化内存池</strong>：当程序启动时，运行时库会从操作系统请求一块内存作为堆的初始大小。这块内存通常使用 <code>brk</code> 或 <code>sbrk</code> 系统调用来分配。</li><li><strong>内存分配</strong>：<ul><li>当调用 <code>malloc</code> 时，它会根据请求的大小在堆中查找合适的空闲块。</li><li>这通常使用自由链表(free list)来管理空闲块。自由链表是一种数据结构，存储了所有空闲内存块的信息。</li><li>如果找到合适的块，<code>malloc</code> 会从自由链表中移除这个块并返回给调用者。如果块太大，可能会拆分块并将剩余部分放回自由链表。</li></ul></li><li><strong>请求更多内存</strong>：<ul><li>如果当前堆内存不够满足分配请求，<code>malloc</code> 会向操作系统请求更多的内存。通常是通过 <code>sbrk</code> 或 <code>mmap</code> 系统调用。</li><li>请求到的内存会被加入到自由链表中，然后重新进行分配。</li></ul></li><li><strong>合并空闲块</strong>：<ul><li>当内存块被释放(使用 <code>free</code> 函数)时，它会被放回自由链表。</li><li>为了避免内存碎片化，释放时会尝试将相邻的空闲块合并成一个更大的块。</li></ul></li></ol><h3 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h3><p><a href="https://blog.csdn.net/qq_42048450/article/details/117282640">https://blog.csdn.net/qq_42048450/article/details/117282640</a><br>在实现c++多态时会用到虚函数。虚函数使用的其核心目的是通过基类访问派生类定义的函数。所谓虚函数就是在基类定义一个未实现的函数名，为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">base</span>();</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>; <span class="comment">//定义的一个虚函数</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      har *basePStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码在基类中定义了一个test的虚函数，所有可以在其子类重新定义父类的做法这种行为成为覆盖(override),或者为重写。</p><p>常见用法：声明基类指针，利用指针指向任意一个子类对象，调用相关的虚函数，动态绑定，由于编写代码时不能确定被调用的是基类函数还是那个派生类函数，所以被称为“”虚“”函数。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经汇总</title>
      <link href="/posts/17773.html"/>
      <url>/posts/17773.html</url>
      
        <content type="html"><![CDATA[<h3 id="腾讯-WXG-移动客户端开发-实习"><a href="#腾讯-WXG-移动客户端开发-实习" class="headerlink" title="腾讯 WXG - 移动客户端开发 实习"></a>腾讯 WXG - 移动客户端开发 实习</h3><p>基础微信&amp;视频号团队<br>2024&#x2F;3&#x2F;19 40多分钟 一面</p><ul><li>自我介绍</li><li>研究生成绩、本科生成绩</li><li>研究生主要专业课</li><li>Java - 强引用 弱引用</li><li>Java - 垃圾回收机制</li><li>TCP连接如何保成可靠性</li><li>HTTP状态码</li><li>拷打实习、项目</li><li>你的开源线上实习主要都做的啥？</li><li>你在开源实习过程中遇到的最难的是什么？</li><li>你的单点登录系统大前端项目中 主要都做了什么东西？</li><li>手撕代码<ul><li>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</li></ul></li><li>意向城市是上海，组内基本都在广州，这个你有什么问题吗？</li><li>为什么会想要投移动客户端开发？</li><li>除了在实习项目中，你还在有通过其他途径了解到移动客户端开发吗？</li><li>反问：<ul><li>面试官您觉得我的表现如何？</li><li>组内日常工作？</li></ul></li></ul><h3 id="淘天集团-天猫技术部前端-实习"><a href="#淘天集团-天猫技术部前端-实习" class="headerlink" title="淘天集团 - 天猫技术部前端 实习"></a>淘天集团 - 天猫技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 14:00  70多分钟。。感觉好难。。。</p><ul><li>面试官介绍部门、自我介绍</li><li>自己自我介绍</li><li>RN和React的区别</li><li>单点登录SSO原理</li><li>PKCE</li><li>Flutter RN区别，如何实现跨平台的</li><li>项目中使用了unity，具体做了什么？</li><li>具体讲2FA是什么</li><li>sdk实现的原理过程是什么</li><li>原型和原型链</li><li>事件循环机制</li><li>react 钩子hooks</li><li>JS 函数是类吗？函数与类的区别在哪？</li><li>反问：<ul><li>前端知识很零散很杂，对此您有何看法？</li></ul></li></ul><h3 id="淘天集团-闲鱼技术部前端-实习"><a href="#淘天集团-闲鱼技术部前端-实习" class="headerlink" title="淘天集团 - 闲鱼技术部前端 实习"></a>淘天集团 - 闲鱼技术部前端 实习</h3><p>2024&#x2F;3&#x2F;26 19:00 40多分钟</p><ul><li>为什么想要走前端的这条路？对前端看法是怎么样的？</li><li>Casbin线上实习做了什么</li><li>以RN sdk为例子，讲一下sdk的工作流程，具体做了啥？</li><li>大前端系统做了什么</li><li>国家电网项目做了什么？</li><li>JS this指针</li><li>JS Promise函数</li><li>JS ES6新特性有哪些</li><li>JS 变量作用域</li></ul><h3 id="淘天集团-闲鱼技术部移动端开发-实习"><a href="#淘天集团-闲鱼技术部移动端开发-实习" class="headerlink" title="淘天集团 - 闲鱼技术部移动端开发 实习"></a>淘天集团 - 闲鱼技术部移动端开发 实习</h3><p>2024&#x2F;4&#x2F;1 16:00 20多分钟。。。 太菜了。。。多练啊。。。练习时长两天半还敢出来混啊卧槽了。</p><ul><li>自我介绍</li><li>为什么想要走移动端开发这种道路。</li><li>Casbin是做什么的？</li><li>RN的原理</li><li>单点登录SSO原理</li><li>我看你简历上很多移动端开发的经历，可以讲讲吗？</li><li>有学过什么计算机专业相关的专业课吗？</li><li>常用的数据结构有什么？</li><li>哈希表的结构</li><li>排序算法的复杂度</li><li>给一个数组，和一个数字，返回这个数字所在的index，有什么方法，复杂度是什么？</li><li>给一个排好序的数组，且里面有很多重复的元素，这个时候如何返回一个指定数字的index？</li><li>反问：<ul><li>移动端开发如何去学习？</li><li>移动客户端开发有什么学习的一些网站吗？</li></ul></li></ul><h3 id="腾讯-移动客户端开发-实习"><a href="#腾讯-移动客户端开发-实习" class="headerlink" title="腾讯 - 移动客户端开发 实习"></a>腾讯 - 移动客户端开发 实习</h3><p>2024&#x2F;4&#x2F;2 19:00 60多分钟</p><ul><li>自我介绍</li><li>印象最深刻的实习或者项目</li><li>TCP、UDP区别</li><li>TCP三次握手、四次挥手</li><li>Java堆和栈区别</li><li>进程线程区别</li><li>OSI七层模型</li><li>死锁</li><li>常见Linux线程间的通信方式</li><li>HTTP状态码</li><li>Java为什么会堆栈溢出</li><li>C++多态</li><li>C++是面向过程的语言吗？</li><li>i++和++i的区别</li><li>302状态码是什么？</li><li>Java同步关键字</li><li>操作系统的虚拟内存</li><li>成员变量和全局变量都存在哪里？</li><li>Java最基础的类是什么类，有哪些方法？</li><li>Java异常机制</li><li>从增加删除元素的角度说数组和链表的区别</li><li>分别向链表数组中插入元素的复杂度</li><li>用户态和内核态</li><li>手撕两道题：<ul><li>单例模式，如何保证一个类只创建一次</li><li>不含重复字符的最长子串的长度</li></ul></li><li>反问：<ul><li>移动客户端开发的学习路线是什么</li></ul></li></ul><h3 id="携程-移动客户端开发iOS-Android"><a href="#携程-移动客户端开发iOS-Android" class="headerlink" title="携程 - 移动客户端开发iOS&#x2F;Android"></a>携程 - 移动客户端开发iOS&#x2F;Android</h3><p>2024&#x2F;4&#x2F;11 18:00 40分钟</p><ul><li>你在大前端项目里主要做了什么？</li><li>react的原理</li><li>Dom树</li><li>js的闭包</li><li>js的原型&amp;原型链</li><li>C++的三大特性</li><li>手撕两道题<ul><li>有序链表合并</li><li>二叉树前序遍历，然后转为数组</li></ul></li><li>反问：<ul><li>前端学习路线</li><li>工作城市</li></ul></li></ul><p>其实后面面试官说，你做的项目跟公司现在做的很契合，然后第二天下午打了个电话没接到，应该是二面。后面假期过后就给我进人才池了，有点亏。。。</p><h3 id="腾讯金融科技-测试开发工程师"><a href="#腾讯金融科技-测试开发工程师" class="headerlink" title="腾讯金融科技 - 测试开发工程师"></a>腾讯金融科技 - 测试开发工程师</h3><p>2024&#x2F;4&#x2F;19 17:00 40 分钟</p><ul><li>自我介绍</li><li>你最近认为做的最有难度最好的一次项目经历。</li><li>开源项目</li><li>你在开源实习和项目中使用的技术栈是什么，你学到了什么？</li><li>国家电网项目</li><li>手撕代码<ul><li>最长重复子串</li></ul></li><li>数据库</li><li>Linux 系统</li><li>反问：<ul><li>测开的学习路线</li><li>工作地点和时间，加班多吗？</li></ul></li></ul><h3 id="美团到店-后端开发工程师-实习生"><a href="#美团到店-后端开发工程师-实习生" class="headerlink" title="美团到店 - 后端开发工程师 - 实习生"></a>美团到店 - 后端开发工程师 - 实习生</h3><p>2024&#x2F;4&#x2F;24 14:00 一个小时</p><ul><li>面试流程、部门介绍</li><li>自我介绍</li><li>项目介绍</li><li>2FA</li><li>TOTP</li><li>OTP</li><li>PKCE</li><li>Java 如何实现高并发</li><li>高并发会出现什么问题，Java如何解决的？</li><li>上下文切换开销</li><li>Java虚拟机内存</li><li>HashMap底层、java7和java8有什么改进</li><li>ConcurrentHashMap如何实现多进程，java7和java8有什么改进</li><li>Java有哪些锁。</li><li>乐观锁悲观锁</li><li>进程、线程区别</li><li>mysql</li><li>redis</li><li>TCP、UDP区别</li><li>三次握手四次挥手</li><li>手撕代码： 二选一<ul><li>反转部分链表</li><li>旋转数组后查找元素</li></ul></li><li>反问：<ul><li>部门寻找实习生的标准是什么样的？</li><li>实习生日常工作时间</li></ul></li></ul><h3 id="美团核心-软件开发工程师-前端-移动端方向-实习"><a href="#美团核心-软件开发工程师-前端-移动端方向-实习" class="headerlink" title="美团核心 - 软件开发工程师-前端&amp;移动端方向 实习"></a>美团核心 - 软件开发工程师-前端&amp;移动端方向 实习</h3><p>2024&#x2F;5&#x2F;15 19:00</p><ul><li>自我介绍</li><li>介绍开源项目主要的工作</li><li>在父元素中调整子元素位置你用哪种方式用的多</li><li>position和display</li><li>css 让如何让元素居中</li><li>直接开始手撕：<ul><li>实现二分查找，然后将while循环改成递归。</li></ul></li><li>反问：<ul><li>组内用了什么技术</li><li>美团app用了什么框架？</li></ul></li></ul><h3 id="荣耀-通用软件开发工程师-实习"><a href="#荣耀-通用软件开发工程师-实习" class="headerlink" title="荣耀 - 通用软件开发工程师 - 实习"></a>荣耀 - 通用软件开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;21 16:30</p><ul><li>自我介绍</li><li>开源项目介绍演示</li><li>你还会点前端？会点前端挺好的</li><li>讲讲国家电网项目</li><li>Java中你用过哪些集合 介绍一下</li><li>HashMap为什么不支持高并发</li><li>有一个要执行的东西，丢到异步线程执行，执行完获取结果。如何实现？</li><li>在开发中有遇到过高并发嘛？</li><li>redis中有哪几种数据类型</li><li>手撕：<ul><li>LRU缓存，面试官口述，我没太听懂，之前也没做过这题，然后没撕出来。。。 到最后才跟我讲这是leetcode146，还说回去后好好看看。。</li></ul></li></ul><h3 id="阿里国际-测试开发工程师-实习"><a href="#阿里国际-测试开发工程师-实习" class="headerlink" title="阿里国际 - 测试开发工程师 - 实习"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;5&#x2F;22 11:00 40min</p><ul><li>部门介绍</li><li>自我介绍</li><li>开源项目是做什么？</li><li>国家电网项目是做什么的？数据量多少？如何智能？</li><li>TCP和UDP原理及区别</li><li>如何将UDP变为TCP那样可靠</li><li>用户态和和内核态</li><li>数据库的事务</li><li>反问：<ul><li>测开学习路线</li><li>面试的是测开，但是问的时候都没怎么问？</li></ul></li></ul><h3 id="饿了么-测开实习-一面"><a href="#饿了么-测开实习-一面" class="headerlink" title="饿了么 - 测开实习 - 一面"></a>饿了么 - 测开实习 - 一面</h3><p>2024&#x2F;6&#x2F;12 15:00 50 多分钟</p><ul><li>自我介绍</li><li>我看你本科不是计算机的，为啥想走计算机这条道路</li><li>介绍一下你所工作的开源社区</li><li>印象最深的一个项目，难点与亮点</li><li>国家电网项目，数据结构如何设计的</li><li>mysql 两张表联合查询</li><li>mysql 事务</li><li>浏览器输入一个 url 发生了什么？</li><li>http&#x2F;https区别</li><li>SSL 加密了解过吗？</li><li>Java 数据类型</li><li>手撕：<ul><li>Java 单例模式</li><li>删除链表的一个节点</li></ul></li><li>对于上述删除链表节点的题，围绕这个点做功能测试如何设计测试用例？</li><li>饿了么外面搜索框功能测试，你该测试什么内容？</li><li>对于现在大模型盛行的时代，你是如何看待大模型的？有用到过没？谈谈你的理解。</li><li>反问：<ul><li>最快什么时候入职</li></ul></li></ul><h3 id="阿里国际-测试开发工程师-实习-1"><a href="#阿里国际-测试开发工程师-实习-1" class="headerlink" title="阿里国际 - 测试开发工程师 - 实习"></a>阿里国际 - 测试开发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;17，15:00 电话面，20 多分钟</p><ul><li>为什么会选择测开这个岗位</li><li>你对测开具体哪个部分感兴趣？</li><li>自我介绍</li><li>你在开源项目中印象最深的一个项目</li><li>国家电网项目介绍</li><li>学生生涯过程中遇到的一些挫折和应对策略</li><li>电商满减优惠券测试用例设计</li><li>反问：<ul><li>如果面试通过的话最快入职时间</li><li>一面二面间隔多久</li></ul></li></ul><h3 id="网易互娱-游戏研发工程师-实习"><a href="#网易互娱-游戏研发工程师-实习" class="headerlink" title="网易互娱 - 游戏研发工程师 - 实习"></a>网易互娱 - 游戏研发工程师 - 实习</h3><p>2024&#x2F;6&#x2F;25 55 min</p><ul><li>自我介绍</li><li>开源实习&#x2F;开源项目介绍</li><li>国家电网项目介绍</li><li>HashMap底层</li><li>HashMap线程安全吗？线程安全用什么？</li><li>ArrayList底层，线程安全吗？线程安全用什么？</li><li>死锁的产生，如何避免？</li><li>线程池的作用</li><li>内存池了解过吗？内存池如何解决内存碎片化问题？</li><li>LRU了解过吗？用什么数据结构实现 LRU？</li><li>如何保证线程安全？</li><li>Java 垃圾回收机制</li><li>Java设计模式用过吗？</li><li>C++、Python语言使用过吗？</li><li>C++常用数据结构</li><li>C++ lambda 表达式用过吗？</li><li>Python内存模型</li><li>浏览器输入URL到展示的过程</li><li>TCP&#x2F;UDP 区别</li><li>TCP 属于哪一层的协议？</li><li>应用层协议有哪些？</li><li>我怎么感觉你研究生什么都没做？有什么科研成果吗？</li><li>具体讲讲小论文的创新点</li><li>TCP 如何保证连接可靠性</li><li>TCP 的丢包问题如何解决？只有重传机制吗？</li><li>多个客户端访问一个服务端，如何实现？</li><li>看过Redis源码吗？</li><li>Redis主要是做什么的？</li><li>如果要你自己实现一个缓存，你会怎么做？</li><li>处理上限为 100 的接口，突然 10000 个请求过来了，怎么办？</li><li>A*算法了解过吗？</li><li>为什么要应聘游戏研发这个岗位</li><li>玩过哪些游戏？如何设计出一个游戏？</li><li>反问：<ul><li>会给实习生分配什么样的工作？竟然说这不是你该考虑的事情。。。。还建议我如果走游戏研发的话要多学学C++。。。完犊子喽。</li><li>前面 40 分钟都是一个面试官问，到后面我才知道原来有俩面试官。。。第二个面试官有点凶神恶煞的。。</li></ul></li></ul><p>2024&#x2F;6&#x2F;28更新，官网流程挂，游戏研发还是得 C++还有 Python 啊，Java 性能不行。</p><h3 id="饿了么-测试开发实习生-二面"><a href="#饿了么-测试开发实习生-二面" class="headerlink" title="饿了么- 测试开发实习生 - 二面"></a>饿了么- 测试开发实习生 - 二面</h3><p>2024&#x2F;6&#x2F;25 14:00 一个小时</p><ul><li>手撕代码：<ul><li>写一个实现rm -rf path 命令功能的函数</li></ul></li><li>针对上面写的函数，写测试用例</li><li>上面函数在Linux 系统下使用会有什么问题？</li><li>Linux用过吗</li><li>给1000 万个整形数据，使用哪种排序算法找到前 1000 个大的数字。</li><li>支部宝转账测试用例</li><li>针对于转账的高并发情况，在系统层面如何优化？</li><li>数据库事务了解吗？</li><li>你刚说转账是一系列操作，具体指？</li><li>数据库索引了解吗？有什么优缺点</li><li>Java反射</li><li>Java中除了空指针异常，还有有哪些异常？</li><li>自我介绍</li><li>挑一个项目或者实习介绍一下你的工作内容及成就</li><li>你的项目中有用Java写的没？</li><li>迄今为止遇到过得最大困难是什么？怎么解决的？</li><li>我看你本科专业不是计算机的，还是保研的，保研不是都保本专业吗，为什么想转专业？</li><li>本科专业排名</li><li>跨度很大，有系统的学习过相关课程和编程语言吗？</li><li>转专业后学习过程中，有遇到过困难吗？</li><li>研究生研究方向？</li><li>项目和科研不太相关，这是怎么回事？</li><li>智力题：<ul><li>8个外形一样的球，其中有一个偏重，求如何只使用两次测量就找到重的球。</li></ul></li><li>谈谈未来职业规划以及为什么要做测开？为什么不选算法岗和开发岗。</li><li>反问：<ul><li>测试开发系统学习路线</li><li>最快什么时候入职</li></ul></li></ul><p>2024&#x2F;6&#x2F;28更新<br>nb，我很奇怪，这个面试官问的我答的还可以，手撕也撕出来了(之前有人发过面经)，但是今天看官网流程，发现挂了。。。太难了</p><h3 id="阿里大文娱-优酷测开-实习生电话面"><a href="#阿里大文娱-优酷测开-实习生电话面" class="headerlink" title="阿里大文娱 - 优酷测开 - 实习生电话面"></a>阿里大文娱 - 优酷测开 - 实习生电话面</h3><p>2024&#x2F;6&#x2F;26 14:00 20多分钟电话面</p><ul><li>自我介绍</li><li>我看你是软件工程专业，而且项目经历也是开发较多，为什么要投测试开发的岗位</li><li>你对测试相关知识有了解吗，介绍一下</li><li>你刚说的黑盒测试和白盒测试，可不可以只有黑盒测试或者白盒测试？</li><li>你刚介绍的那个模块，你如何保证它的质量</li><li>写过测试用例吗？</li><li>测试用例的一些设计方法</li><li>优酷视频这个软件，从系统层面说一说如何进行测试</li><li>你理解的 Java线程安全指的是什么？</li><li>如何实现线程安全</li><li>同步和异步指的是什么？</li><li>如何实现异步调用？</li><li>除了 Future 类还有其他实现异步调用的方法吗？</li><li>内存溢出和内存泄漏区别</li><li>了解 SQL注入吗？</li><li>什么是事务</li><li>慢查询的原因</li><li>常见网络模型？</li><li>你还会点前端是吧，什么是跨域？</li><li>跨域是为了防止什么？</li><li>反问：<ul><li>目前部门还缺人吗</li><li>如果面试通过了的话，最快什么时候入职？</li><li>一共有几轮面试</li><li>官网流程快不快？</li></ul></li></ul><p>其实面试体验挺不佳的，本来跟面试官约的两点面嘛，然后加了钉钉，之后到 14:10还没收到钉钉电话，我去问加钉钉那个人，结果他不是面试官，只是联系人，他去帮我问，原来是有好几个候选人，有一个候选人也姓陈，面试官给搞混了，给他打过去电话开始面试，然后把我给晾在这了。</p><p>然后第一个面了一个多小时，到了 15:20才给我打电话，我就面了 20多分钟，结束了，结束后还跟我讲，你的测试开发相关知识比较薄弱啊，如果后面要面的话还需要再加强。我反问我是不是挂了，他说不是。。。。</p><p>刚面完就看到官网流程更新，从简历评估到面试安排中了，反手一条邮件发过来，是测评。。应该是过了一面吧。。。</p><p>hhh原来这个并不是一面，而是先了解下有没有进行面试的资格，如果有再安排面试。。。</p><h3 id="阿里大文娱-优酷测开-实习生在线笔试"><a href="#阿里大文娱-优酷测开-实习生在线笔试" class="headerlink" title="阿里大文娱 - 优酷测开 - 实习生在线笔试"></a>阿里大文娱 - 优酷测开 - 实习生在线笔试</h3><p>2024&#x2F;6&#x2F;28 15：00 40min</p><p>俩面试官，两道题</p><ul><li>无重复字符的最长子串，直接滑动窗口秒了</li><li>关于一个代码优化的题。。。给一个 Users类，有id, name, age，然后给了一个函数，参数是一个 Users 数组，和 id 数组，该函数根据 id 数组查找 Users 数组，返回一个 results 列表。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Users</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Users</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Users&gt; <span class="title function_">findUsers</span><span class="params">(Users[] users, <span class="type">int</span>[] ids)</span> &#123;</span><br><span class="line">    List&lt;Users&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id : ids) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Users user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getId() == id) &#123;</span><br><span class="line">                results.add(user);  <span class="comment">// 这里可以优化</span></span><br><span class="line">                <span class="comment">// 找到后可以直接返回，不用继续遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 这里也可以优化，具体忘了。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Users[] users = <span class="keyword">new</span> <span class="title class_">Users</span>[<span class="number">3</span>];</span><br><span class="line">    users[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Users</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    users[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Users</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    users[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Users</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span>[] ids = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    List&lt;Users&gt; results = findUsers(users, ids);</span><br><span class="line">    <span class="keyword">for</span> (Users user : results) &#123;</span><br><span class="line">        System.out.println(user.getId() + <span class="string">&quot; &quot;</span> + user.getName() + <span class="string">&quot; &quot;</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>反问：<ul><li>关于刚才的代码优化问题</li><li>最快什么时候出结果</li></ul></li></ul><h3 id="阿里大文娱-优酷测开-实习生二面-主管？？？"><a href="#阿里大文娱-优酷测开-实习生二面-主管？？？" class="headerlink" title="阿里大文娱 - 优酷测开 - 实习生二面(主管？？？)"></a>阿里大文娱 - 优酷测开 - 实习生二面(主管？？？)</h3><p>2024&#x2F;7&#x2F;1 15:00 40min</p><ul><li>自我介绍</li><li>缓存雪崩概念，如何产生的，如何解决</li><li>Spring IoC原理</li><li>开源项目中如何跟踪用户需求</li><li>你如何确定问题出在你们这边而不是用户那边</li><li>如何准确复现问题</li><li>你在江南布衣服饰公司实习中的针对多种问题场景提出持久性解决方案，具体是什么？</li><li>你觉得什么是一段好的代码</li><li>你的研究生方向及小论文</li></ul><p>反问：</p><ul><li>组内会给实习生安排什么样子的工作</li><li>最快几天出结果</li><li>如果通过，后面的面试也是主管面吗？</li><li>方便问一下我的表现如何吗？</li></ul><p>给我的建议：</p><ul><li>说话要有逻辑一点，自顶向下，回答问题先确定概要，再一步一步回答。</li></ul><p>我笑死，我能答上来就不错了好吧。。。</p><p>面完秒挂。。。唉。。。</p><h3 id="腾讯-PCG-后台开发-QQ-实习初试"><a href="#腾讯-PCG-后台开发-QQ-实习初试" class="headerlink" title="腾讯 PCG - 后台开发 QQ - 实习初试"></a>腾讯 PCG - 后台开发 QQ - 实习初试</h3><p>2024&#x2F;7&#x2F;4 19:30 70多分钟 </p><ul><li>部门介绍</li><li>可以过来深圳实习吗？</li><li>最快什么时候可以过来？</li><li>导师让实习吗？学校还有没有什么事情？</li><li>自我介绍</li><li>我看你得了很多一等奖学金，这是怎么回事？</li><li>ArrayList 和 LinkedList 区别，你觉得哪个性能更好</li><li>Java 高并发如何实现</li><li>JVM 垃圾回收机制</li><li>有安卓开发的经验吗？</li><li>介绍一下你的开源项目中的 SDK 及做的app</li><li>国家电网项目是研究型项目吗？是前端？</li><li>你的研究生方向是什么？</li><li>为什么不把科研内容写进简历</li><li>为什么想转专业？</li><li>在 AI 方向做出了什么成果？</li><li>你觉得你在开源实习中收获了什么？</li><li>手撕：<ul><li>颜色分类：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 <ul><li>注意：不能使用代码库中的排序函数来解决这道题。</li><li>样例1:[输入][2,0,2,1,1,0][输出][0,0,1,1,2,2]</li></ul></li><li>最大连续子数组和</li></ul></li></ul><p>反问：</p><ul><li>组内主要是安卓开发吗？</li></ul><p>写完面经，去官网看流程，进复试了。。加油～</p><p>过了一周，给我发了面试反馈邮件，去官网一看，已经挂了。。。唉。。。还是好好准备秋招了。</p><h3 id="字节跳动-飞书前端实习生-一面"><a href="#字节跳动-飞书前端实习生-一面" class="headerlink" title="字节跳动-飞书前端实习生-一面"></a>字节跳动-飞书前端实习生-一面</h3><p>2024&#x2F;7&#x2F;18 56min</p><ul><li>自我介绍</li><li>手撕<ul><li>实现快排</li><li>接雨水</li></ul></li><li>对前端哪些技术比较了解？</li><li>ES6新特性</li><li>let和const区别</li><li>箭头函数和普通函数的区别</li><li>JS是单线程还是多线程</li><li>JS事件循环机制</li><li>Promise函数</li><li>静态Promise有了解过吗？</li><li>Promise.all和Promise.race区别</li><li>还了解过其他异步处理方法吗？</li><li>script执行中async和defer区别</li><li>线程和进程区别</li><li>HTTP和HTTPS区别</li><li>SSL加密原理</li><li>加密过程中数据被篡改怎么办</li><li>浏览器的架构是什么样子的</li><li>React 生命周期</li><li>hooks用过哪些？</li><li>useEffect和useLayoutEffect区别</li><li>useEffect可以实现点击某个组件后更新一次吗？如何实现？</li><li>有做过react性能优化相关吗？</li><li>以后的职业发展是想往那方面发展？</li></ul><p>反问：</p><ul><li>我有听说飞书大裁员，这是真的吗？(反正也没啥戏，索性胆子大点嘻嘻)</li><li>团队主要做什么？</li></ul><p>面试官人很好，但是就是最近一直在准备后端啊，前端就随便面面吧，反正都忘得差不多了。。。除了手撕和计算机基础，其他全程尬聊，苦笑。。不说了做项目去了</p><h3 id="美团-后端开发-AI面试"><a href="#美团-后端开发-AI面试" class="headerlink" title="美团-后端开发-AI面试"></a>美团-后端开发-AI面试</h3><p>2024&#x2F;8&#x2F;18 30min</p><ul><li>选择最熟悉的语言(Java)</li><li>三次握手和四次挥手是什么？有什么作用？</li><li>如何获取Stream中的最大值和最小值</li><li>Linux系统如何查看内存使用情况？</li><li>数据库的分区表是什么？有什么优点？</li><li>Java的异常检查，checked和unchecked异常的区别</li><li>设计一个用户的隐私管理系统，可以让用户控制是否展示或者隐藏自己的信息，如何设计？</li><li>描述一次你学习新语言或者框架的经历，你是如何学习的？</li><li>描述一次你需要在有限资源、时间、人力、技术等下解决问题的经历<ul><li>追问：如何确保在短暂的一个月内完成这个项目？你有什么方案吗？</li></ul></li></ul><h3 id="腾讯-软件开发-后台开发-QQ浏览器"><a href="#腾讯-软件开发-后台开发-QQ浏览器" class="headerlink" title="腾讯-软件开发-后台开发-QQ浏览器"></a>腾讯-软件开发-后台开发-QQ浏览器</h3><p>2024&#x2F;8&#x2F;20 19:00 60min</p><p>全程项目，毫无八股，问麻了</p><ul><li>我看你本科不是计算机，为什么想转计算机？</li><li>我们这边主要是做开发，你看你有什么问题？</li><li>自我介绍</li><li>我看你前面面过很多岗位啊，像前端、测试、移动端，为什么想做后端？</li><li>为什么没有找实习呢？</li><li>开源项目介绍</li><li>SSO原理</li><li>你在开源项目中的主要工作</li><li>异步的持久化器是什么？</li><li>你在开源项目中遇到过最难的问题？</li><li>是什么契机让你接触开源的？</li><li>介绍一下你的优点评项目</li><li>秒杀如何实现的？</li><li>超卖问题如何解决？</li><li>异步秒杀思路？</li><li>缓存穿透、缓存击穿、缓存雪崩的区别</li><li>旁路缓存模式如何解决缓存与数据库双写一致性问题？</li><li>有一个计数器需要每天凌晨持久化，用Redis如何实现？</li><li>手撕：<ul><li>最接近的三数之和</li></ul></li><li>你现在在学校是吧？手上有没有其他offer</li><li>反问：<ul><li>组内技术栈</li><li>面试结果什么时候出？</li></ul></li></ul><p>第二天挂</p><h3 id="百度提前批-Java研发-一面"><a href="#百度提前批-Java研发-一面" class="headerlink" title="百度提前批-Java研发-一面"></a>百度提前批-Java研发-一面</h3><p>2024&#x2F;8&#x2F;26 18:00 50min</p><ul><li>自我介绍</li><li>TOTP原理是什么</li><li>你的TOTP生成用的什么算法</li><li>如果用户端和服务器端的时间不同步，TOTP会有什么问题？如何解决</li><li>Java中常见的集合</li><li>多线程为什么用ConcurrentHashMap，HashMap存在什么问题？</li><li>HashMap底层</li><li>HasMap查询复杂度是多少</li><li>为什么查询复杂度是O(1)</li><li>ArrayList会动态扩缩容吗？查询复杂度是多少？</li><li>如果一直往ArrayList里面插入元素会怎么样，他会一直扩容吗？</li><li>ArrayList存放在哪里？</li><li>为什么多个线程共享堆中的空间</li><li>操作系统中的页表</li><li>进程的切换</li><li>用户态和内核态区别</li><li>进程的切换是在用户态还是内核态</li><li>如何实现多线程？</li><li>锁在什么时候用</li><li>如何避免死锁</li><li>死锁在JVM中用什么命令可以排查吗</li><li>按照你刚才说的，写一段代码，模仿死锁</li><li>使用你刚才说的命令来排查死锁</li><li>MySQL中的索引作用</li><li>为什么减少IO次数就能加快查询？</li><li>如果把数据库放在固态硬盘里面而不是机械硬盘，那么IO次数还会是MySQL的瓶颈吗</li><li>反问：<ul><li>组内技术栈</li><li>岗位都在北京吗？</li></ul></li></ul><h3 id="快手-Java开发-一面"><a href="#快手-Java开发-一面" class="headerlink" title="快手-Java开发-一面"></a>快手-Java开发-一面</h3><p>2024&#x2F;8&#x2F;27 50min<br>部门是交易中心</p><ul><li>自我介绍</li><li>社区及工作简介</li><li>单点登录SSO原理</li><li>假如一个用户想接入这个系统的话，具体该怎么做</li><li>如果是你，要接入的话，session存储到哪里，那个中间件？</li><li>你对Redis很熟悉吗？为什么Redis这么快？</li><li>Redis你都用到过哪些数据结构？</li><li>Bitmap使用场景</li><li>MySQL中的索引，在什么时候需要创建索引</li><li>binlog是用来干什么的</li><li>undolog是用来干什么的</li><li>synchronized关键字作用</li><li>volatile关键字</li><li>介绍下JVM的内存区域</li><li>你刚介绍到方法区，你了解过方法区的垃圾回收吗？</li><li>常用的垃圾回收器你了解几个</li><li>CMS回收器的算法用的哪个？</li><li>手撕：<ul><li>使用三个线程有序打印1-100(没写出来。。)</li><li>二叉树的最大路径和</li></ul></li><li>反问：<ul><li>组内技术栈</li><li>最快的话几天出结果。</li></ul></li></ul><h3 id="字节跳动-后端开发-数据平台-一面"><a href="#字节跳动-后端开发-数据平台-一面" class="headerlink" title="字节跳动-后端开发-数据平台-一面"></a>字节跳动-后端开发-数据平台-一面</h3><p>2024&#x2F;8&#x2F;28 11:00 55min</p><ul><li>自我介绍</li><li>社区、开源经历介绍</li><li>你在开源经历中遇到的困难及解决思路介绍？</li><li>对于微信支付的对接，详细讲讲具体的难点在哪里？</li><li>三个项目都是自己做的练手项目吗，介绍下。</li><li>国家电网项目中为什么会选择使用mongodb进行存储呢？</li><li>你的工作是什么？</li><li>数据量大吗？</li><li>线程池的核心参数</li><li>线程池处理任务的流程</li><li>CPU密集型&#x2F;IO密集型任务如何设置线程池大小？</li><li>在IO密集型任务中，有了结果具体怎么设置线程池大小吗？</li><li>在项目或者自己编码过程中有遇到过什么困难吗？以及解决的思路。</li><li>Redis高可用你了解吗？</li><li>集群模式以及哨兵模式</li><li>对于Redis集群，如何横向扩展数据存储量</li><li>手撕：<ul><li>二叉树的最近公共祖先(每个节点有val指针和指向父亲节点的parent指针)</li><li>最近公共公共祖先常规版(每个节点有指向左右节点的left、right指针和val指针)</li></ul></li><li>反问：<ul><li>数据平台指的是什么？</li><li>部门的技术栈</li><li>最快多久出面试结果</li></ul></li></ul><p>操作系统<br><a href="https://www.xiaolincoding.com/os/#%E5%B0%8F%E7%99%BD%E9%80%82%E5%90%88%E7%9C%8B%E5%90%97">https://www.xiaolincoding.com/os/#%E5%B0%8F%E7%99%BD%E9%80%82%E5%90%88%E7%9C%8B%E5%90%97</a><br><a href="https://blog.csdn.net/weixin_53946852/article/details/140904754">https://blog.csdn.net/weixin_53946852/article/details/140904754</a></p><p>分布式</p><p>高性能</p><p>高可用</p><p>Linux相关命令。。。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕相关</title>
      <link href="/posts/17772.html"/>
      <url>/posts/17772.html</url>
      
        <content type="html"><![CDATA[<h2 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1, p2 = l2;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span> (p1.val &gt; p2.val) &#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="给定x分解单链表，使得小于x的数都在x之前"><a href="#给定x分解单链表，使得小于x的数都在x之前" class="headerlink" title="给定x分解单链表，使得小于x的数都在x之前"></a>给定x分解单链表，使得小于x的数都在x之前</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p1, p2 指针负责生成结果链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> dummy1, p2 = dummy2;</span><br><span class="line">    <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">    <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt;= x) &#123;</span><br><span class="line">            p2.next = p;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1.next = p;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能直接让 p 指针前进，</span></span><br><span class="line">        <span class="comment">// p = p.next</span></span><br><span class="line">        <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.next;</span><br><span class="line">        p.next = <span class="literal">null</span>;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接两个链表</span></span><br><span class="line">    p1.next = dummy2.next;</span><br><span class="line">    <span class="keyword">return</span> dummy1.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回链表的倒数第k个节点"><a href="#返回链表的倒数第k个节点" class="headerlink" title="返回链表的倒数第k个节点"></a>返回链表的倒数第k个节点</h4><p>快慢指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line">ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找链表的中间节点"><a href="#寻找链表的中间节点" class="headerlink" title="寻找链表的中间节点"></a>寻找链表的中间节点</h4><p>快慢指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><p>快慢指针法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果链表有环，找到环的入口"><a href="#如果链表有环，找到环的入口" class="headerlink" title="如果链表有环，找到环的入口"></a>如果链表有环，找到环的入口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode fast, slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新指向头结点</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断两链表是否相交"><a href="#判断两链表是否相交" class="headerlink" title="判断两链表是否相交"></a>判断两链表是否相交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">        <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">        <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h4><ul><li>递归法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一个单链表头结点，将该链表反转，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next); <span class="comment">// 除了头结点外，反转其余结点，last 为新的头结点</span></span><br><span class="line">    head.next.next = head; <span class="comment">// 其余节点反转好了，将反转后的链表的尾结点指向头节点</span></span><br><span class="line">    head.next = <span class="literal">null</span>; <span class="comment">// 头结点原本指向第二个元素，现在指向空节点</span></span><br><span class="line">    <span class="keyword">return</span> last; <span class="comment">// 返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转部分链表"><a href="#反转部分链表" class="headerlink" title="反转部分链表"></a>反转部分链表</h4><p>递归法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 后驱节点</span></span><br><span class="line">ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 reverseN</span></span><br><span class="line">    head.next = reverseBetween(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反转以 head 为起点的前 n 个节点，返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，反转前 n - 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next, n - <span class="number">1</span>); <span class="comment">// 除了头节点，反转地 2-n 个节点，last 为第 n 个节点，也是新的头节点</span></span><br><span class="line">    head.next.next = head; <span class="comment">// 其余节点反转好了，将反转后的链表的尾结点指向头节点</span></span><br><span class="line">    head.next = successor; <span class="comment">// 让反转之后的 head 节点和后面的节点successor连起来</span></span><br><span class="line">    <span class="keyword">return</span> last; <span class="comment">// 返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k-个一组翻转链表"><a href="#k-个一组翻转链表" class="headerlink" title="k 个一组翻转链表"></a>k 个一组翻转链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反转区间 [a, b) 的元素，注意是左闭右开</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="literal">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">    <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h4><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        HashMap&lt;Node, Node&gt; originToClone = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第一次遍历，先把所有节点克隆出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!originToClone.containsKey(p)) &#123;</span><br><span class="line">                originToClone.put(p, <span class="keyword">new</span> <span class="title class_">Node</span>(p.val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次遍历，把克隆节点的结构连接好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                originToClone.get(p).next = originToClone.get(p.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.random != <span class="literal">null</span>) &#123;</span><br><span class="line">                originToClone.get(p).random = originToClone.get(p.random);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回克隆之后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> originToClone.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序链表删除重复元素-一个不留"><a href="#有序链表删除重复元素-一个不留" class="headerlink" title="有序链表删除重复元素(一个不留)"></a>有序链表删除重复元素(一个不留)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveDuplicates</span> &#123;</span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isDuplicate</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span> &amp;&amp; current.val == current.next.val) &#123;</span><br><span class="line">                isDuplicate = <span class="literal">true</span>;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isDuplicate) &#123;</span><br><span class="line">                prev.next = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Utility function to print the linked list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// Read input</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(scanner.nextInt());</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(scanner.nextInt());</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Process</span></span><br><span class="line">        head = deleteDuplicates(head);</span><br><span class="line">        <span class="comment">// Output result</span></span><br><span class="line">        printList(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>LRU(Least Recently Used)策略是一种常见的缓存淘汰策略，它的核心思想是：如果数据最近被访问过，那么将来被访问的几率也更高。LRU 算法的实现可以通过哈希表和双向链表来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">    <span class="comment">// 用LinkedHashMap作为cache，尾部为新使用过的数据，头部为未使用过的数据。</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        makeNew(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        makeNew(key);</span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt; <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 头部的元素是最老的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让key变为新使用的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeNew</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        cache.remove(key);</span><br><span class="line">        <span class="comment">// 将key添加到LinkedHashMap尾部</span></span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">1f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lruCache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        lruCache.put(<span class="number">4</span>, <span class="string">&quot;watermelon&quot;</span>);</span><br><span class="line">        lruCache.put(<span class="number">5</span>, <span class="string">&quot;peach&quot;</span>);</span><br><span class="line">        System.out.println(lruCache);</span><br><span class="line">        lruCache.put(<span class="number">6</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        System.out.println(lruCache);</span><br><span class="line">        lruCache.get(<span class="number">4</span>);</span><br><span class="line">        System.out.println(lruCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LFU淘汰策略"><a href="#LFU淘汰策略" class="headerlink" title="LFU淘汰策略"></a>LFU淘汰策略</h4><p>LFU(Least Frequently Used)策略是根据数据使用的频率来决定淘汰哪一个数据的策略。使用频率最少的数据会被淘汰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;  <span class="comment">// 缓存的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minFrequency;  <span class="comment">// 当前缓存中最小的频率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; valueMap;  <span class="comment">// 存储键到值的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; frequencyMap;  <span class="comment">// 存储键到频率的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; frequencyListMap;  <span class="comment">// 存储频率到具有该频率的键集合的映射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;  <span class="comment">// 初始化缓存容量</span></span><br><span class="line">        <span class="built_in">this</span>.minFrequency = <span class="number">0</span>;  <span class="comment">// 初始最小频率为0</span></span><br><span class="line">        <span class="built_in">this</span>.valueMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 初始化键值映射表</span></span><br><span class="line">        <span class="built_in">this</span>.frequencyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 初始化键频率映射表</span></span><br><span class="line">        <span class="built_in">this</span>.frequencyListMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 初始化频率到键集合的映射表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!valueMap.containsKey(key)) &#123;  <span class="comment">// 如果缓存中不包含该键，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> frequencyMap.get(key);  <span class="comment">// 获取该键的当前频率</span></span><br><span class="line">        frequencyMap.put(key, frequency + <span class="number">1</span>);  <span class="comment">// 更新该键的频率</span></span><br><span class="line">        frequencyListMap.get(frequency).remove(key);  <span class="comment">// 从当前频率的键集合中移除该键</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前频率的键集合为空且频率等于最小频率，移除该频率并增加最小频率</span></span><br><span class="line">        <span class="keyword">if</span> (frequencyListMap.get(frequency).isEmpty()) &#123;</span><br><span class="line">            frequencyListMap.remove(frequency);</span><br><span class="line">            <span class="keyword">if</span> (frequency == minFrequency) &#123;</span><br><span class="line">                minFrequency++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该键添加到新的频率集合中</span></span><br><span class="line">        frequencyListMap.computeIfAbsent(frequency + <span class="number">1</span>, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;()).add(key);</span><br><span class="line">        <span class="keyword">return</span> valueMap.get(key);  <span class="comment">// 返回该键对应的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 如果缓存容量为0或更小，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueMap.containsKey(key)) &#123;  <span class="comment">// 如果键已存在，更新其值，并更新频率</span></span><br><span class="line">            valueMap.put(key, value);</span><br><span class="line">            get(key);  <span class="comment">// 调用get方法来更新该键的频率</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存已满，执行淘汰操作</span></span><br><span class="line">        <span class="keyword">if</span> (valueMap.size() &gt;= capacity) &#123;</span><br><span class="line">            <span class="comment">// 获取并移除最小频率集合中的第一个键</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">evictKey</span> <span class="operator">=</span> frequencyListMap.get(minFrequency).iterator().next();</span><br><span class="line">            frequencyListMap.get(minFrequency).remove(evictKey);</span><br><span class="line">            <span class="keyword">if</span> (frequencyListMap.get(minFrequency).isEmpty()) &#123;  <span class="comment">// 如果最小频率集合为空，移除该频率</span></span><br><span class="line">                frequencyListMap.remove(minFrequency);</span><br><span class="line">            &#125;</span><br><span class="line">            valueMap.remove(evictKey);  <span class="comment">// 从键值映射表中移除被淘汰的键</span></span><br><span class="line">            frequencyMap.remove(evictKey);  <span class="comment">// 从键频率映射表中移除被淘汰的键</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入新键值对，初始频率为1</span></span><br><span class="line">        valueMap.put(key, value);</span><br><span class="line">        frequencyMap.put(key, <span class="number">1</span>);</span><br><span class="line">        minFrequency = <span class="number">1</span>;  <span class="comment">// 插入新键后，最小频率重置为1</span></span><br><span class="line">        <span class="comment">// 将新键添加到频率为1的集合中</span></span><br><span class="line">        frequencyListMap.computeIfAbsent(<span class="number">1</span>, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;()).add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FIFO淘汰策略"><a href="#FIFO淘汰策略" class="headerlink" title="FIFO淘汰策略"></a>FIFO淘汰策略</h4><p>FIFO(First In First Out)策略是根据数据进入缓存的顺序来决定淘汰哪一个数据的策略。最早进入缓存的数据会被淘汰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FIFOCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">evictKey</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            map.remove(evictKey);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        queue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><blockquote><p>链接：<a href="https://learn.skyofit.com/archives/1291">https://learn.skyofit.com/archives/1291</a></p></blockquote><p><strong>复杂度</strong><br><img src="/./image/Hand-Torn-Code/20230615083937874.png" alt="排序算法总结"></p><p>概念：</p><ul><li>稳定：如果a原本在b前面且a&#x3D;b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面且a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li><li>In-Place：占用常数内存，不占用额外内存。比如：程序里没有创建新数组来保存数据，只用了临时变量。</li><li>Out-Place：占用额外内存。比如：创建了新的数组来保存或者处理数据。</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>基本思想</strong><br>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>算法描述</strong></p><ol><li>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;  <span class="comment">//外层循环一次为一趟排序</span></span><br><span class="line">        <span class="comment">/*设置标识，判断这趟排序是否发生了交换。</span></span><br><span class="line"><span class="comment">       如果未发生交换，则说明数组已经有序，不必再排序了*/</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSwap</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//内层循环一次为一次相邻比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">                isSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isSwap)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：冒泡排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li><li>最好情况：如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li><li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 3 * n * (n-1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li><li>空间复杂度：冒泡排序使用了常数空间，空间复杂度为O(1)</li><li>稳定性：当 array[j] &#x3D;&#x3D; array[j+1] 的时候，不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。</li></ul><blockquote><p>拓展：鸡尾酒排序<br>又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cocktailSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = array.length-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)</span><br><span class="line">         <span class="keyword">if</span>(array[i] &gt; array[i+<span class="number">1</span>])</span><br><span class="line">               swap(array,i,i + <span class="number">1</span>);</span><br><span class="line">       right--;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt; left; i--)</span><br><span class="line">         <span class="keyword">if</span>(array[i] &lt; array[i-<span class="number">1</span>])</span><br><span class="line">               swap(array,i,i-<span class="number">1</span>);</span><br><span class="line">       left++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸡尾酒排序是稳定的。它的平均时间复杂度为O(n2)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n2)。空间复杂度为O(1)。</p></blockquote><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>基本思想</strong><br>简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>算法描述</strong><br>n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：</p><ol><li>初始状态：无序区为R[1..n]，有序区为空； </li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>(n-1)趟结束，数组有序化了。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex]; <span class="comment">//将最小数和无序区的第一个数交换</span></span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。</li><li>最好情况：如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n – 1) &#x2F; 2 次比较。</li><li>最坏情况：如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n – 1) &#x2F; 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n – 1)次。<ul><li>需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。</li></ul></li><li>空间复杂度：简单选择排序使用了常数空间，空间复杂度为O(1)</li><li>稳定性：简单选择排序不稳定，比如序列 2、4、2、1，知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法。</li></ul><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><strong>基本思想</strong><br>直接插入排序(Insertion-Sort)的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong><br>一般来说，直接插入排序都采用in-place(原地算法)在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素(已排序)大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="type">int</span> current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        current = array[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：直接插入排序平均时间复杂度为O(n2)，最好时间复杂度为O(n)，最坏时间复杂度为O(n2)。</li><li>最好情况：如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n – 1) 和 0，因此最好情况的时间复杂度为O(n)。</li><li>最坏情况：如果待排序元素本来是逆序的，需要进行 (n – 1) 趟排序，所需比较和移动次数分别为 n * (n – 1) &#x2F; 2和 n * (n – 1) &#x2F; 2。因此最坏情况下的时间复杂度为O(n2)。</li><li>空间复杂度：直接插入排序使用了常数空间，空间复杂度为O(1)</li><li>稳定性：直接插入排序是稳定的。</li></ul><blockquote><p>拓展：在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即二分插入排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] BinaryInsertionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i - <span class="number">1</span>;  <span class="comment">// left 和 right 分别为有序区的左右边界 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> array[i];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//搜索有序区中第一个大于 current 的位置，即为 current 要插入的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; current)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;j &gt;= left;j--) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = current; <span class="comment">// left 为第一个大于 current 的位置，插入 current</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分插入排序是稳定的。它的平均时间复杂度是O(n2)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</p></blockquote><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本思想</strong><br>1959年Shell发明，第一个突破O(n2)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>算法描述</strong><br>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列(每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n &#x2F; gap 个元素)分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap &#x3D;&#x3D; 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下(接近最好情况)，效率是很高的。gap初始值一般取 len &#x2F; 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ShellSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="type">int</span> current, gap = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            current = array[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current) &#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + gap] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。</li><li>空间复杂度：希尔排序使用了常数空间，空间复杂度为O(1)</li><li>稳定性：由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。</li></ul><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>基本思想</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>算法描述</strong></p><ol><li>把长度为 n 的输入序列分成两个长度为 n &#x2F; 2 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] MergeSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将两段有序数组结合成一个有序数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">   <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[left.length + right.length];</span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">            result[k++] = left[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">        result[k++] = left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">        result[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li><li>空间复杂度：归并排序空间复杂度为O(n)</li><li>稳定性：归并排序是稳定的。</li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>基本思想</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>算法描述</strong><br>快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”(pivot)；</li><li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面(相同的数可以到任一边)，该基准就处于数列的中间位置。这称为分区(partition)操作；</li><li>递归地(recursive)对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li></ol><p><strong>代码实现</strong><br>快速排序最核心的步骤就是partition操作，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面(相同的数可以到任一边)，该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。</p><p>两种方法：左右指针法、挖坑法<br>左右指针法：</p><ol><li>将数组的最后一个数 right 作为基准数 key。</li><li>分区过程：从数组的首元素 begin 开始向后找比 key 大的数(begin 找大)；end 开始向前找比 key 小的数(end 找小)；找到后交换两者(swap)，直到 begin &gt;&#x3D; end 终止遍历。最后将 begin(此时begin &#x3D;&#x3D; end)和最后一个数交换( 这个时候 end 不是最后一个位置)，即 key 作为中间数(左区间都是比key小的数，右区间都是比key大的数)</li><li>再对左右区间重复第二步，直到各区间只有一个数。<br><img src="/./image/Hand-Torn-Code/20230615085001544.png" alt="左右指针法"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// left 数列左边界 right 数列右边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>( p &lt; q ) &#123;</span><br><span class="line">            <span class="comment">//p找大</span></span><br><span class="line">            <span class="keyword">while</span>(p &lt; q &amp;&amp; array[p] &lt;= array[key])</span><br><span class="line">                p++;</span><br><span class="line">            <span class="comment">//q找小</span></span><br><span class="line">            <span class="keyword">while</span>(p &lt; q &amp;&amp; array[q] &gt;= array[key])</span><br><span class="line">                q--;</span><br><span class="line">            <span class="keyword">if</span>(p &lt; q)</span><br><span class="line">                swap(array, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, p, key);</span><br><span class="line">        sort(array, left, p - <span class="number">1</span>);</span><br><span class="line">        sort(array, q + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换数组内两个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>挖坑法：</li><li>定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key(right)，作为坑。</li><li>left 寻找比基准(key)大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数(key)小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑(最终：key的左边都是比key小的数，key的右边都是比key大的数)，然后进行递归操作。<br><img src="/./image/Hand-Torn-Code/20230615085019913.png" alt="挖坑法"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序方法 left 数列左边界 right 数列右边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Quicksort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> array[right];<span class="comment">//初始坑</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//left找大</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= key )</span><br><span class="line">            left++;</span><br><span class="line">        array[right] = array[left];<span class="comment">//赋值，然后left作为新坑</span></span><br><span class="line">        <span class="comment">//right找小</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;right &amp;&amp; array[right] &gt;= key)</span><br><span class="line">            right--;</span><br><span class="line">        array[left] = array[right];<span class="comment">//right作为新坑</span></span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = key;</span><br><span class="line">    <span class="comment">/*将key赋值给left和right的相遇点，保持key的左边都是比key小的数，key的右边都是比key大的数*/</span></span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">//最终返回基准</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>之前选择基准的策略都是固定基准，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大(小)值，快排的性能不好(因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n2))。</p><p><strong>优化一：随机基准</strong><br>每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。<br>只需要在 partition 函数前增加如下操作即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机选择 left ~ right 之间的一个位置作为基准</span></span><br><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>) (left + Math.random() * (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//把基准值交换到右边界</span></span><br><span class="line">swap(array, random, right);</span><br></pre></td></tr></table></figure><p><strong>优化二：三数取中法</strong><br>取第一个数，最后一个数，第(N&#x2F;2)个数即中间数，三个数中数值中间的那个数作为基准值。</p><p>举个例子，对于int[] array &#x3D; { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第(N&#x2F;2)个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。</p><p>实现getMid函数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMid</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> array[left];</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> array[mid];</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> array[right];</span><br><span class="line">    <span class="keyword">if</span> ((b &lt;= a &amp;&amp; a &lt;= c) || (c &lt;= a &amp;&amp; a &lt;= b)) &#123; <span class="comment">//a为中间值</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= b &amp;&amp; b &lt;= c) || (c &lt;= b &amp;&amp; b &lt;= a)) &#123; <span class="comment">//b为中间值</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= c &amp;&amp; c &lt;= b) || (b &lt;= c &amp;&amp; c &lt;= a)) &#123; <span class="comment">//c为中间值</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化三：当待排序序列的长度分割到一定大小后，使用插入排序</strong><br>在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。</p><p>实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。</p><p>此时QuickSort()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Quicksort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &gt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insertionSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化四：三路划分</strong><br>如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。</p><p>三路划分的思想是利用 partition 函数将待排序列划分为三部分：第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。这样在递归排序区间的时候，就不必再对第二部分元素均相等的区间进行快排了，这在待排序列存在大量相同元素的情况下能大大提高快排效率。<br><img src="/./image/Hand-Torn-Code/20230615085141896.png" alt="三路划分示意图"></p><p>红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。</p><p>left 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数(即小于v的最右位置)，more 指针指向蓝色部分的第一个数(即大于v的最左位置)。cur 指针指向白色部分(未知部分)的第一个数，即下一个要判断大小的位置。</p><p>算法思路：</p><ol><li>由于最初红色和蓝色区域没有元素，初始化 less &#x3D; left – 1，more &#x3D; right + 1，cur &#x3D; left。整个区间为未知部分(白色)。</li><li>如果当前 array[cur] &lt; v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格(less指针后移)，把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</li><li>如果当前 array[cur] &#x3D; v，则不必交换，直接 cur++</li><li>如果当前 array[cur] &gt; v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格(more指针前移)，把 array[cur] 交换到该位置。特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] array,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> array[right]; <span class="comment">//选择右边界为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>; <span class="comment">// &lt; v 部分的最后一个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right + <span class="number">1</span>; <span class="comment">// &gt; v 部分的第一个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[cur] &lt; v)&#123;</span><br><span class="line">            swap(array,++less,cur++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[cur] &gt; v)&#123;</span><br><span class="line">            swap(array,--more,cur);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;  <span class="comment">//返回的是 = v 区域的左右下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换数组内两个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Quicksort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span>[] p = partition(array,left,right);</span><br><span class="line">        Quicksort(array,left,p[<span class="number">0</span>] - <span class="number">1</span>); <span class="comment">//避开重复元素区间</span></span><br><span class="line">        Quicksort(array,p[<span class="number">1</span>] + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：快速排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(n2)。</li><li>最好情况：基准选择得当，partition函数每次恰好能均分序列，其递归树的深度就为logn，时间复杂度为O(nlogn)。</li><li>最坏情况：选择了最大或者最小数字作为基准，每次划分只能将序列分为一个元素与其他元素两部分，此时快速排序退化为冒泡排序，如果用树画出来，得到的将会是一棵单斜树，即所有的结点只有左(右)结点的树，树的深度为 n，时间复杂度为O(n2)。</li><li>空间复杂度：快速排序的空间复杂度主要考虑递归时使用的栈空间。在最好情况下，即partition函数每次恰好能均分序列，空间复杂度为O(logn)；在最坏情况下，即退化为冒泡排序，空间复杂度为O(n)。平均空间复杂度为O(logn)。</li><li>稳定性：快速排序是不稳定的。</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>基本思想</strong><br>堆排序是一种树形选择排序方法，它利用了堆这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大(最小)的元素。</p><p><strong>算法描述</strong></p><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为(n-1)，则整个排序过程完成。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> len;</span><br><span class="line"><span class="comment">// 堆排序算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] HeapSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">//1.构建一个大根堆</span></span><br><span class="line">        buildMaxHeap(array);</span><br><span class="line">        <span class="comment">//2.循环将堆顶(最大值)与堆尾交换，删除堆尾元素，然后重新调整大根堆</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--; <span class="comment">//原先的堆尾进入有序区，删除堆尾元素</span></span><br><span class="line">            adjustHeap(array, <span class="number">0</span>); <span class="comment">//重新调整大根堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 自顶向下调整以 i 为根的堆为大根堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; len &amp;&amp; array[<span class="number">2</span> * i + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; len &amp;&amp; array[<span class="number">2</span> * i + <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 自底向上构建初始大根堆</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始自底向上构造大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 交换数组内两个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拓展： <ul><li>插入元素：只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。</li><li>删除堆顶元素：只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。</li></ul></li><li>时间复杂度：堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</li><li>空间复杂度：堆排序使用了常数空间，空间复杂度为O(1)。</li><li>稳定性：堆排序是不稳定的。</li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><strong>基本思想</strong><br>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>算法描述</strong></p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加)；</li><li>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] CountingSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="type">int</span> bias, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">        min = Math.min(min, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上</span></span><br><span class="line">    bias = -min;</span><br><span class="line">    <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        bucket[array[i] + bias]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            array[index] = i - bias;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</li><li>空间复杂度：计数排序空间复杂度为O(k)，k为桶数组的长度。</li><li>稳定性：计数排序是稳定的。</li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><strong>基本思想</strong><br>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序(可能使用别的排序算法)，最后拼接各个桶中排好序的数据。映射函数人为设计，但要保证桶 i 中的数均小于桶 j (i &lt; j)中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i – min) &#x2F; arr.length。</p><p><strong>算法描述</strong></p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶的桶内元素进行排序(可以使用直接插入排序等)；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">        min = Math.min(min, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j (i &lt; j)的数，即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> (max - min) / array.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (array[i] - min) / (array.length);</span><br><span class="line">        bucketArr.get(num).add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; bucketArr.get(i).size();j++) &#123;</span><br><span class="line">           array[k++] = bucketArr.get(i).get(j);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。</li><li>空间复杂度：桶排序空间复杂度为O(n + k)。</li><li>稳定性：桶排序是稳定的。</li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>基本思想</strong><br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述</strong></p><ol><li>取得数组中的最大数，并取得位数；</li><li>array 为原始数组，从最低位开始取每个位组成 radix 数组；</li><li>对 radix 进行计数排序(利用计数排序适用于小范围数的特点)；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] RadixSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">     <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="comment">//2.进行maxDigit趟分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++,div *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (array[j] / div) % <span class="number">10</span>;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//3.收集</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。</li><li>空间复杂度：基数排序空间复杂度为O(n + k)。</li><li>稳定性：基数排序是稳定的。</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int binarySearch(int[] array, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = array.length - 1;</span><br><span class="line">        </span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2; // 防止整形的(left + right)/2溢出</span><br><span class="line">            if (array[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (array[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1; // 未找到目标值</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class="line">        int target = 7;</span><br><span class="line">        int result = binarySearch(array, target);</span><br><span class="line">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归实现</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int binarySearch(int[] array, int target, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (array[mid] == target) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if (array[mid] &lt; target) &#123;</span><br><span class="line">            return binarySearch(array, target, mid + 1, right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return binarySearch(array, target, left, mid - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;1, 3, 5, 7, 9, 11, 13&#125;;</span><br><span class="line">        int target = 7;</span><br><span class="line">        int result = binarySearch(array, target, 0, array.length - 1);</span><br><span class="line">        System.out.println(&quot;目标值的索引: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归删除文件夹"><a href="#递归删除文件夹" class="headerlink" title="递归删除文件夹"></a>递归删除文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDeleter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例：删除路径为&quot;example&quot;的文件或目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;example&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> deleteRecursively(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功: &quot;</span> + path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归删除文件或目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 要删除的文件或目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果成功删除，则返回true；否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRecursively</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在: &quot;</span> + file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录，则递归删除目录中的内容</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File child : files) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!deleteRecursively(child)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除文件或空目录</span></span><br><span class="line">        <span class="keyword">return</span> file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复最长子串"><a href="#无重复最长子串" class="headerlink" title="无重复最长子串"></a>无重复最长子串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">// 增大窗口</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 窗口变化后对数据进行处理</span></span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 是否需要缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (window.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 窗口变化后对数据进行处理</span></span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口后保证window内没有重复元素</span></span><br><span class="line">            res = Math.max(right - left, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 从 nums[start] 开始，计算有序数组 nums 中所有和为 target 的二元组</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">towSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> start, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Arrays.sort(nums); // 先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[low] + nums[high];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[low], right = nums[high]; <span class="comment">// 用来标记左右元素，对比重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(left, right)));</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == left) low++;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == right) high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先穷举第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 对 target - nums[i] 计算 twoSum</span></span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; twoSumRes = towSum(nums, i+<span class="number">1</span>, target -nums[i]);</span><br><span class="line">            <span class="comment">// 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组</span></span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; tuple : twoSumRes) &#123;</span><br><span class="line">                tuple.add(nums[i]);</span><br><span class="line">                res.add(tuple);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳过第一个数字重复的情况</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n-<span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ClosestSum</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 固定nums[i],从i+1开始</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + ClosestSum2(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(delta) &gt; Math.abs(target - sum)) &#123;</span><br><span class="line">                delta = target - sum;</span><br><span class="line">                <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target - delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最接近的两数之和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">ClosestSum2</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[low] + nums[high];</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(delta) &gt; Math.abs(target - sum)) &#123;</span><br><span class="line">                delta = target - sum;</span><br><span class="line">                <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target - delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法，备忘录优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 备忘录记录每个位置左右柱子高度的最大值</span></span><br><span class="line">        <span class="type">int</span>[] l_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n-<span class="number">1</span>] = height[n-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左到右计算l_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            l_max[i] = Math.max(height[i], l_max[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左计算r_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r_max[i] = Math.max(height[i], r_max[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            res += Math.min(l_max[i], r_max[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            l_max = Math.max(l_max, height[left]);</span><br><span class="line">            r_max = Math.max(r_max, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">                res += l_max - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += r_max - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">resIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// pq 存储元素值及索引</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素及其索引添加到 pq 中</span></span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">// 根据 index 移除掉超出的元素</span></span><br><span class="line">            <span class="keyword">while</span> (pq.peek()[<span class="number">1</span>] &lt;= i - k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当窗口大小达到 k 时，记录当前窗口的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[resIndex++] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否是质数"><a href="#判断是否是质数" class="headerlink" title="判断是否是质数"></a>判断是否是质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义：dp[i] 记录以 nums[i] 为结尾的「最大子数组和」</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 第一个元素前面没有子数组</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="comment">// dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i] + dp[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到 nums 的最大子数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">// 滑动窗口缩小条件</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 增大窗口</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= s.length() -<span class="number">1</span> &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            l --;</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里的l+1，原因是前面的while循环在s.charAt(l) == s.charAt(r)执行之前会l--和r++，在不满足前面条件时，已经进行了l--和r++，所以需要加回来。</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">            <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// res = longest(res, s1, s2)</span></span><br><span class="line">            res = res.length() &gt; s1.length() ? res : s1;</span><br><span class="line">            res = res.length() &gt; s2.length() ? res : s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 定义dp[i][j]为 s[i..j]之间的最长回文子序列</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// 每个字符处，最长回文子序列为其本身，长度1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i &gt; j处，不存在子序列，全部为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 状态转移函数</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">// 如果s在i处的字符和s在j处的字符相等，则两字符同时加入dp[i+1][j-1],长度+2</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果不相等，则两字符不能同时出现在最长回文子序列中，把两个字符都加入，看看哪个更长</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()][text2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(text1, <span class="number">0</span>, text2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义dp[s1, i, s2, j]为s1[i..]和s2[j..]的最长公共子序列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s1, <span class="type">int</span> i, String s2, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// 相当于是s1 最右边的空串 和s2 最右边的空串的最长公共子序列，为0</span></span><br><span class="line">        <span class="keyword">if</span> (i == s1.length() || j == s2.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移函数</span></span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 如果s1在i处的字符和s2在j处的字符相等，则该字符必定属于最长公共子序列，长度+1，s1、s2都前进向下一字符比较</span></span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1, i+<span class="number">1</span>, s2, j+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果s1在i处的字符和s2在j处的字符不相等，三种情况:</span></span><br><span class="line">            <span class="comment">// 1. s1在i处的字符不属于最长公共子序列，但s2所在j处的字符属于最长公共子序列，则s1前进至下一字符</span></span><br><span class="line">            <span class="comment">// 2. s2在j处的字符不属于最长公共子序列，但s1所在i处的字符属于最长公共子序列，则s2前进至下一字符</span></span><br><span class="line">            <span class="comment">// 3. s1在i处的字符和s2在j处的字符都不属于最长公共子序列，但这种情况下最长公共子序列的长度肯定没有前两种长，忽略dp(s1, i+1, s2, j+1)</span></span><br><span class="line">            memo[i][j] = Math.max(dp(s1, i+<span class="number">1</span>, s2, j), dp(s1, i, s2, j+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树前序遍历转链表"><a href="#二叉树前序遍历转链表" class="headerlink" title="二叉树前序遍历转链表"></a>二叉树前序遍历转链表</h4><p>二叉树的先序遍历，然后按照前序顺序将其转化为一个链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">trans</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>), p = dummy;</span><br><span class="line">        traverse(root, p);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, Node p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(root.val, <span class="literal">null</span>);</span><br><span class="line">        p.next = node;</span><br><span class="line">        p = p.next;</span><br><span class="line">        traverse(root.left, p);</span><br><span class="line">        traverse(root.right, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序数组转二叉平衡搜索树"><a href="#有序数组转二叉平衡搜索树" class="headerlink" title="有序数组转二叉平衡搜索树"></a>有序数组转二叉平衡搜索树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归构造平衡二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = dfs(nums, low, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = dfs(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据前序和中序遍历构造二叉树"><a href="#根据前序和中序遍历构造二叉树" class="headerlink" title="根据前序和中序遍历构造二叉树"></a>根据前序和中序遍历构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span>[] inOrder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preOrder[preStart];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(preOrder, preStart + <span class="number">1</span>, preStart + leftSize, inOrder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preOrder, preStart + leftSize + <span class="number">1</span>, preEnd, inOrder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据中序和后序遍历构造二叉树"><a href="#根据中序和后序遍历构造二叉树" class="headerlink" title="根据中序和后序遍历构造二叉树"></a>根据中序和后序遍历构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build 函数的定义：</span></span><br><span class="line">    <span class="comment">// 后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line">    <span class="comment">// 中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line">    <span class="comment">// 构造二叉树，返回该二叉树的根节点 </span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(inorder, inStart, index - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, index + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据前序和后序遍历构造二叉树"><a href="#根据前序和后序遍历构造二叉树" class="headerlink" title="根据前序和后序遍历构造二叉树"></a>根据前序和后序遍历构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 postorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(postorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]</span></span><br><span class="line">    <span class="comment">// 构建二叉树，并返回根节点。</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="comment">// root.left 的值是前序遍历第二个元素</span></span><br><span class="line">        <span class="comment">// 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点</span></span><br><span class="line">        <span class="comment">// 确定 preorder 和 postorder 中左右子树的元素区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// leftRootVal 在后序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(leftRootVal);</span><br><span class="line">        <span class="comment">// 左子树的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - postStart + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        <span class="comment">// 根据左子树的根节点索引和元素个数推导左右子树的索引边界</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize, postorder, postStart, index);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd, postorder, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现二叉树前序遍历"><a href="#迭代实现二叉树前序遍历" class="headerlink" title="迭代实现二叉树前序遍历"></a>迭代实现二叉树前序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(current.val); <span class="comment">// 前序遍历的操作</span></span><br><span class="line">            <span class="comment">// 将右子树和左子树添加到栈中，注意顺序(栈是后进先出)</span></span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现二叉树中序遍历"><a href="#迭代实现二叉树中序遍历" class="headerlink" title="迭代实现二叉树中序遍历"></a>迭代实现二叉树中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        result.add(current.val); <span class="comment">// 中序遍历的操作</span></span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代实现二叉树后续遍历"><a href="#迭代实现二叉树后续遍历" class="headerlink" title="迭代实现二叉树后续遍历"></a>迭代实现二叉树后续遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// result.addFirst(node.val);</span></span><br><span class="line">        result.add(<span class="number">0</span>, current.val); <span class="comment">// 后序遍历的操作，在结果列表的开头插入节点值</span></span><br><span class="line">        <span class="comment">// 先左后右的顺序入栈，保证出栈顺序为根右左，即后序遍历的顺序</span></span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h4><p>深度优先遍历有三种，前中后序遍历。如上。<br>广度优先遍历是层序遍历，即按照层级从上到下、从左到右逐层访问节点的遍历方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breadthFirstTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 将根节点入队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 出队</span></span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问节点</span></span><br><span class="line">            <span class="comment">// 左右子节点依次入队</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造二叉树示例</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Breadth-First Traversal:&quot;</span>);</span><br><span class="line">        bt.breadthFirstTraversal(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="comment">// 左右子树进队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先-LCA"><a href="#二叉树的最近公共祖先-LCA" class="headerlink" title="二叉树的最近公共祖先(LCA)"></a>二叉树的最近公共祖先(LCA)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(root, p.val, q.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line">    TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">            <span class="comment">// 如果遇到目标值，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">        <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a>二叉树的最大路径和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// 不能定义为static</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 没有节点，和为0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftVal</span> <span class="operator">=</span> dfs(node.left); <span class="comment">// 左子树最大链和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightVal</span> <span class="operator">=</span> dfs(node.right); <span class="comment">// 右子树最大链和</span></span><br><span class="line">        ans = Math.max(ans, leftVal + rightVal + node.val); <span class="comment">// 两条链拼接</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftVal, rightVal) + node.val, <span class="number">0</span>); <span class="comment">// 当前子树的最大链和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录节点和对应编号</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">( TreeNode node, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最大的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 标准 BFS 层序遍历算法</span></span><br><span class="line">        Queue&lt;Pair&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(root, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 从上到下遍历整棵树</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从左到右遍历每一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">Pair</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> cur.node;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curId</span> <span class="operator">=</span> cur.id;</span><br><span class="line">                <span class="comment">// 记录当前行第一个和最后一个节点的编号</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    start = curId;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == sz - <span class="number">1</span>) &#123;</span><br><span class="line">                    end = curId;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左右子节点入队，同时记录对应节点的编号</span></span><br><span class="line">                <span class="keyword">if</span> (curNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(curNode.left, curId * <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(curNode.right, curId * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用当前行的宽度更新最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, end - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录最左侧节点的编号</span></span><br><span class="line">    ArrayList&lt;Integer&gt; firstId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> id, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (firstId.size() == depth - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 因为代码是先 traverse(root.left) 后 traverse(root.right)，</span></span><br><span class="line">            <span class="comment">// 所以第一次到达这个深度一定是最左侧的节点，记录其编号</span></span><br><span class="line">            firstId.add(id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个深度的其他节点，负责计算更新当前深度的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, id - firstId.get(depth - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, id * <span class="number">2</span>, depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, id * <span class="number">2</span> + <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多叉树查找某个值"><a href="#多叉树查找某个值" class="headerlink" title="多叉树查找某个值"></a>多叉树查找某个值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义多叉树的节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    List&lt;TreeNode&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(TreeNode child)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.add(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiWayTree</span> &#123;</span><br><span class="line">    <span class="comment">// 在多叉树中查找值的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到目标值，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (root.value == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历子节点，递归查找</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (search(child, target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建多叉树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        root.addChild(child1);</span><br><span class="line">        root.addChild(child2);</span><br><span class="line">        root.addChild(child3);</span><br><span class="line">        child1.addChild(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>));</span><br><span class="line">        child1.addChild(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>));</span><br><span class="line">        child2.addChild(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>));</span><br><span class="line">        child3.addChild(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找某个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> search(root, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;Found target &quot;</span> + target + <span class="string">&quot;: &quot;</span> + found);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList实现最大堆"><a href="#ArrayList实现最大堆" class="headerlink" title="ArrayList实现最大堆"></a>ArrayList实现最大堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; heap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        heap.add(value);</span><br><span class="line">        heapifyUp(heap.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">extractMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> heap.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> heap.remove(heap.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            heap.set(<span class="number">0</span>, last);</span><br><span class="line">            heapifyDown(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyUp</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parentIndex</span> <span class="operator">=</span> (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap.get(index) &gt; heap.get(parentIndex)) &#123;</span><br><span class="line">                swap(index, parentIndex);</span><br><span class="line">                index = parentIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapifyDown</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> heap.size();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftChildIndex</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">largestIndex</span> <span class="operator">=</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftChildIndex &lt; size &amp;&amp; heap.get(leftChildIndex) &gt; heap.get(largestIndex)) &#123;</span><br><span class="line">                largestIndex = leftChildIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightChildIndex &lt; size &amp;&amp; heap.get(rightChildIndex) &gt; heap.get(largestIndex)) &#123;</span><br><span class="line">                largestIndex = rightChildIndex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (largestIndex != index) &#123;</span><br><span class="line">                swap(index, largestIndex);</span><br><span class="line">                index = largestIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap.get(index1);</span><br><span class="line">        heap.set(index1, heap.get(index2));</span><br><span class="line">        heap.set(index2, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MaxHeap</span> <span class="variable">maxHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>();</span><br><span class="line">        maxHeap.insert(<span class="number">10</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">20</span>);</span><br><span class="line">        maxHeap.insert(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max element: &quot;</span> + maxHeap.extractMax()); <span class="comment">// 输出 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Max element: &quot;</span> + maxHeap.extractMax()); <span class="comment">// 输出 10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Max element: &quot;</span> + maxHeap.extractMax()); <span class="comment">// 输出 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><p>保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><ul><li>对于遇到的每个 ‘(’ ，将它的下标放入栈中</li><li>对于遇到的每个 ‘)’ ，先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用栈来存储括号的位置，保持栈底元素是最后一个没有被匹配的右括号的下标</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>); <span class="comment">// 先在栈中加入-1，作为基准位置，用于计算有效长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符是 &#x27;(&#x27;，将它的位置压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符是 &#x27;)&#x27;，从栈中弹出一个位置</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">// 如果栈为空，说明当前的 &#x27;)&#x27; 没有匹配的 &#x27;(&#x27;，将当前位置压入栈中</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则，计算当前有效括号的长度，并更新最大长度</span></span><br><span class="line">                    maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长有效括号的长度</span></span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a>遍历HashMap</h3><p>七种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ForEach EntrySet</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ForEach KeySet</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器EntrySet</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器KeySet</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Streams API 单线程</span></span><br><span class="line">map.entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Streams API 多线程</span></span><br><span class="line">map.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">row.add(<span class="number">1</span>);</span><br><span class="line">row.add(<span class="number">2</span>);</span><br><span class="line">row.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 增强for循环</span></span><br><span class="line"><span class="keyword">for</span> (Integer number : row) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代起</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = row.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// forEach+Lambda表达式</span></span><br><span class="line">row.forEach(number -&gt; System.out.println(number));</span><br><span class="line"><span class="comment">// Streams API 单线程</span></span><br><span class="line">row.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;  <span class="comment">// 方向数组，分别代表上、下、左、右</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 新发现一个岛屿，结果+1</span></span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="comment">// 使用dfs将这个岛屿淹没</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// boolean[][] visited; 如果需要是否访问的话</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="comment">// 从 (i, j) 开始，将与之相邻的陆地都变成海水</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n) <span class="keyword">return</span>; <span class="comment">// 超出索引边界</span></span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>; <span class="comment">// 已经是水了</span></span><br><span class="line">        <span class="comment">// if (visited[i][j]) return;</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将(i, j)变成海水</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(grid, i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树(Trie)"></a>前缀树(Trie)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children; <span class="comment">// 指向子节点的指针数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd; <span class="comment">// 记录当前Trie节点是否为叶子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>]; <span class="comment">// 仅包含26个小写英文字母</span></span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 记录「路径」</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]; <span class="comment">//「路径」中的元素会被标记为 true，避免重复使用</span></span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123; <span class="comment">// 排除不合法的选择</span></span><br><span class="line">                <span class="comment">// nums[i] 已经在 track 中，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            backtrack(nums, track, used);</span><br><span class="line">            <span class="comment">// 取消选择</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的子集"><a href="#数组的子集" class="headerlink" title="数组的子集"></a>数组的子集</h3><p>给你一个整数数组 nums ，数组中的元素互不相同 。返回该数组所有可能的子集(幂集)。 解集不能包含重复的子集。你可以按任意顺序返回解集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; track = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, List&lt;Integer&gt; track)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            track.add(nums[i]); <span class="comment">// 做选择</span></span><br><span class="line">            backtrack(nums, i+<span class="number">1</span>, track); <span class="comment">// 回溯</span></span><br><span class="line">            track.remove(track.size() - <span class="number">1</span>); <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建三个线程有序打印1-100"><a href="#创建三个线程有序打印1-100" class="headerlink" title="创建三个线程有序打印1-100"></a>创建三个线程有序打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUMBER</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 定义最大数字为100</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 当前要打印的数字，初始值为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 锁对象，用于线程间的通信</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建三个线程，每个线程使用不同的threadId（0, 1, 2）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PrintTask</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PrintTask</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PrintTask</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> threadId;  <span class="comment">// 线程的标识符，用于控制打印顺序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PrintTask</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;  <span class="comment">// 锁定lock对象，保证同一时刻只有一个线程可以访问</span></span><br><span class="line">                    <span class="comment">// 如果当前数字不能被对应线程处理，则等待</span></span><br><span class="line">                    <span class="keyword">while</span> (number % <span class="number">3</span> != threadId) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();  <span class="comment">// 当前线程等待，释放锁</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            Thread.currentThread().interrupt();  <span class="comment">// 处理线程中断</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果当前数字超过最大值，通知其他线程并结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (number &gt; MAX_NUMBER) &#123;</span><br><span class="line">                        lock.notifyAll();  <span class="comment">// 通知其他所有线程</span></span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">// 退出循环，结束线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 打印当前数字并自增</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread-&quot;</span> + threadId + <span class="string">&quot; prints: &quot;</span> + number++);</span><br><span class="line">                    <span class="comment">// 唤醒其他等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟死锁"><a href="#模拟死锁" class="headerlink" title="模拟死锁"></a>模拟死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockSample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createDeadLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 get lock1&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程1休眠，确保线程2可以获取到lock2</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1 try get lock2.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 get lock2&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程2休眠，确保线程1可以获取到lock2</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 try get lock1.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLockSample</span> <span class="variable">deadLockSample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockSample</span>();</span><br><span class="line">        deadLockSample.createDeadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现生产者消费者模型"><a href="#实现生产者消费者模型" class="headerlink" title="实现生产者消费者模型"></a>实现生产者消费者模型</h3><p>使用<code>BlockingQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义缓冲区的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建一个共享缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(BUFFER_CAPACITY);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProducerConsumerExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConsumerExample</span>();</span><br><span class="line">        <span class="comment">// 启动生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(example.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="comment">// 启动消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(example.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    produce(value++);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产过程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">// 将产品放入缓冲区，若缓冲区满则等待</span></span><br><span class="line">            buffer.put(value);</span><br><span class="line">            System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费过程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">// 从缓冲区中取出产品，若缓冲区空则等待</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用wait()和notify()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="comment">// 定义缓冲区的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建一个共享缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProducerConsumerExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConsumerExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(example.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(example.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产者类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    produce(value++);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产过程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 如果缓冲区已满，等待消费者消费</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.size() == BUFFER_CAPACITY) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is full, producer is waiting...&quot;</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">                buffer.add(value);</span><br><span class="line">                System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">                <span class="comment">// 通知消费者有新的产品</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consume();</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费过程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 如果缓冲区为空，等待生产者生产</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is empty, consumer is waiting...&quot;</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从缓冲区中取出产品</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.poll();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                <span class="comment">// 通知生产者有空位</span></span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture实现异步调用"><a href="#CompletableFuture实现异步调用" class="headerlink" title="CompletableFuture实现异步调用"></a>CompletableFuture实现异步调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟一个长时间运行的任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 休眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class="line">        future.thenAccept(result -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务结果: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程继续执行其他操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行...&quot;</span>);</span><br><span class="line">        <span class="comment">// 阻塞主线程，直到异步任务完成(可选)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长重复子串-不会"><a href="#最长重复子串-不会" class="headerlink" title="最长重复子串(不会)"></a>最长重复子串(不会)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestDupSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 生成两个进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> random.nextInt(<span class="number">75</span>) + <span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> random.nextInt(<span class="number">75</span>) + <span class="number">26</span>;</span><br><span class="line">        <span class="comment">// 生成两个模</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod1</span> <span class="operator">=</span> random.nextInt(Integer.MAX_VALUE - <span class="number">1000000007</span> + <span class="number">1</span>) + <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod2</span> <span class="operator">=</span> random.nextInt(Integer.MAX_VALUE - <span class="number">1000000007</span> + <span class="number">1</span>) + <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 先对所有字符进行编码</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i] = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二分查找的范围是[1, n-1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>, start = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> check(arr, m, a1, a2, mod1, mod2);</span><br><span class="line">            <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 有重复子串，移动左边界</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                length = m;</span><br><span class="line">                start = idx;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无重复子串，移动右边界</span></span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start != -<span class="number">1</span> ? s.substring(start, start + length) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m, <span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> mod1, <span class="type">int</span> mod2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">aL1</span> <span class="operator">=</span> pow(a1, m, mod1);</span><br><span class="line">        <span class="type">long</span> <span class="variable">aL2</span> <span class="operator">=</span> pow(a2, m, mod2);</span><br><span class="line">        <span class="type">long</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;</span><br><span class="line">            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;</span><br><span class="line">            <span class="keyword">if</span> (h1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                h1 += mod1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                h2 += mod2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储一个编码组合是否出现过</span></span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;();</span><br><span class="line">        seen.add(h1 * mod2 + h2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>; start &lt;= n - m; ++start) &#123;</span><br><span class="line">            h1 = (h1 * a1 % mod1 - arr[start - <span class="number">1</span>] * aL1 % mod1 + arr[start + m - <span class="number">1</span>]) % mod1;</span><br><span class="line">            h2 = (h2 * a2 % mod2 - arr[start - <span class="number">1</span>] * aL2 % mod2 + arr[start + m - <span class="number">1</span>]) % mod2;</span><br><span class="line">            <span class="keyword">if</span> (h1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                h1 += mod1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                h2 += mod2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> h1 * mod2 + h2;</span><br><span class="line">            <span class="comment">// 如果重复，则返回重复串的起点</span></span><br><span class="line">            <span class="keyword">if</span> (!seen.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有重复，则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> m, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">contribute</span> <span class="operator">=</span> a;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * contribute % mod;</span><br><span class="line">                <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans += mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            contribute = contribute * contribute % mod;</span><br><span class="line">            <span class="keyword">if</span> (contribute &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                contribute += mod;</span><br><span class="line">            &#125;</span><br><span class="line">            m /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>A*(A-star)算法是一种启发式搜索算法，常用于图搜索和路径规划问题。它结合了广度优先搜索和贪心最佳优先搜索的优点，使用启发式估计函数来指导搜索路径。</p><p>下面是一个简单的A*算法的Java实现，用于在二维网格上寻找从起点到终点的最短路径。假设网格中的每个节点是一个单元格，可以是可通行或不可通行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 表示网格中的一个节点，包含节点的坐标、g 值(从起点到该节点的代价)、h 值(启发式估计值)和指向父节点的引用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> g, h;</span><br><span class="line">    <span class="keyword">public</span> Node parent; <span class="comment">// 指向父节点的引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> g, <span class="type">int</span> h, Node parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.g = g;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g + h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.getF(), other.getF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AStarAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] DIR_X = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] DIR_Y = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// aStar 方法执行 A* 搜索。它使用优先队列(基于节点的 F 值排序)来选择当前节点，并检查四个可能的移动方向(上下左右)。</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; <span class="title function_">aStar</span><span class="params">(<span class="type">int</span>[][] grid, Node start, Node goal)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt; openList = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Node&gt; closedList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        openList.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!openList.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> openList.poll();</span><br><span class="line">            <span class="keyword">if</span> (current.x == goal.x &amp;&amp; current.y == goal.y) &#123;</span><br><span class="line">                <span class="keyword">return</span> constructPath(current);</span><br><span class="line">            &#125;</span><br><span class="line">            closedList.add(current);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> current.x + DIR_X[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> current.y + DIR_Y[i];</span><br><span class="line">                <span class="keyword">if</span> (isValid(grid, newX, newY) &amp;&amp; !isInClosedList(closedList, newX, newY)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newG</span> <span class="operator">=</span> current.g + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newH</span> <span class="operator">=</span> heuristic(newX, newY, goal.x, goal.y);</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">neighbor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(newX, newY, newG, newH, current);</span><br><span class="line">                    <span class="keyword">if</span> (!isInOpenList(openList, neighbor)) &#123;</span><br><span class="line">                        openList.add(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// No path found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isValid 方法检查移动是否在网格范围内且该位置可通行。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.length &amp;&amp; y &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[x][y] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isInClosedList 方法检查节点是否在 closedList 中。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInClosedList</span><span class="params">(Set&lt;Node&gt; closedList, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> closedList.stream().anyMatch(node -&gt; node.x == x &amp;&amp; node.y == y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// isInOpenList 方法检查节点是否在 openList 中。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInOpenList</span><span class="params">(PriorityQueue&lt;Node&gt; openList, Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> openList.stream().anyMatch(n -&gt; n.x == node.x &amp;&amp; n.y == node.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// heuristic 方法计算节点到目标节点的启发式估计值。这里使用的是曼哈顿距离。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">heuristic</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(x1 - x2) + Math.abs(y1 - y2); <span class="comment">// Manhattan distance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructPath 方法从目标节点回溯构建路径。</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; <span class="title function_">constructPath</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            path.add(node);</span><br><span class="line">            node = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(path);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Main 方法：定义网格、起点和终点，运行 A* 算法并打印路径。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] grid = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">goal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">AStarAlgorithm</span> <span class="variable">aStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AStarAlgorithm</span>();</span><br><span class="line">        List&lt;Node&gt; path = aStar.aStar(grid, start, goal);</span><br><span class="line">        <span class="keyword">for</span> (Node node : path) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Node: (&quot;</span> + node.x + <span class="string">&quot;, &quot;</span> + node.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h4><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p><ul><li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li><li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li><li>线程安全的懒汉式<ul><li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li><li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li></ul></li><li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li><li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class="line">                <span class="comment">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 注意 上面不是 class 是 enum</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singelton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        singleton.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式(Factory Pattern)"></a>工厂模式(Factory Pattern)</h4><p>工厂模式定义了一个用于创建对象的接口，但由子类决定实例化哪个类。它使得类的实例化延迟到子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown product type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> ProductFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        product.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h4><p>适配器模式将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要适配的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Specific request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h4><p>装饰者模式允许向一个现有的对象添加新的功能，同时又不改变其结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteComponent operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象装饰者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体装饰者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecoratorA additional operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体装饰者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorB</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecoratorB additional operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="type">Component</span> <span class="variable">decoratedComponentA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(component);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">decoratedComponentB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorB</span>(decoratedComponentA);</span><br><span class="line">        decoratedComponentB.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h4><p>策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationSubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationAdd</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationSubtract</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationMultiply</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式(Observer Pattern)"></a>观察者模式(Observer Pattern)</h4><p>观察者模式定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;Observer 1&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;Observer 2&quot;</span>);</span><br><span class="line">        subject.registerObserver(observer1);</span><br><span class="line">        subject.registerObserver(observer2);</span><br><span class="line">        subject.setMessage(<span class="string">&quot;Hello Observers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏桶算法-Leaky-Bucket"><a href="#漏桶算法-Leaky-Bucket" class="headerlink" title="漏桶算法(Leaky Bucket)"></a>漏桶算法(Leaky Bucket)</h3><p>漏桶算法是一种流量整形(Traffic Shaping)和速率限制算法，用于控制数据传输速率。它通过固定容量的桶来限制数据的传输速率，当数据到达时，将数据放入桶中，然后以固定速率从桶中取出数据进行传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> rate;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger water;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucket</span><span class="params">(<span class="type">int</span> capacity, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.water = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期漏水</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> / rate);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                water.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">grant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWater</span> <span class="operator">=</span> water.get();</span><br><span class="line">        <span class="keyword">if</span> (currentWater &lt; capacity) &#123;</span><br><span class="line">            water.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶算法-Token-Bucket"><a href="#令牌桶算法-Token-Bucket" class="headerlink" title="令牌桶算法(Token Bucket)"></a>令牌桶算法(Token Bucket)</h3><p>令牌桶算法是一种流量整形(Traffic Shaping)和速率限制算法，用于控制数据传输速率。它通过固定容量的桶来限制数据的传输速率，当数据到达时，需要获取令牌才能进行传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> refillRate;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> refillInterval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucket</span><span class="params">(<span class="type">int</span> capacity, <span class="type">int</span> refillRate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.refillRate = refillRate;</span><br><span class="line">        <span class="built_in">this</span>.tokens = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(capacity);</span><br><span class="line">        <span class="built_in">this</span>.refillInterval = <span class="number">1000</span> / refillRate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定期添加令牌</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(refillInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                tokens.updateAndGet(current -&gt; Math.min(capacity, current + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">grant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentTokens</span> <span class="operator">=</span> tokens.get();</span><br><span class="line">        <span class="keyword">if</span> (currentTokens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tokens.decrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限流队列"><a href="#限流队列" class="headerlink" title="限流队列"></a>限流队列</h3><p>结合漏桶算法和消息队列，实现一个限流队列，用于控制任务的执行速率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeakyBucket rateLimiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiterQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">int</span> rate, <span class="type">int</span> queueSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rateLimiter = <span class="keyword">new</span> <span class="title class_">LeakyBucket</span>(capacity, rate);</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(queueSize);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> taskQueue.take();</span><br><span class="line">                    <span class="keyword">if</span> (rateLimiter.grant()) &#123;</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 限流，重新加入队列</span></span><br><span class="line">                        taskQueue.offer(task);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!taskQueue.offer(task)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务队列已满，拒绝任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RateLimiterQueue</span> <span class="variable">rateLimiterQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateLimiterQueue</span>(<span class="number">100</span>, <span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            rateLimiterQueue.submitTask(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;处理任务：&quot;</span> + taskId);</span><br><span class="line">                <span class="comment">// 模拟任务处理时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 手撕技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架</title>
      <link href="/posts/17771.html"/>
      <url>/posts/17771.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考 <a href="https://javaguide.cn/">JavaGuide</a></p></blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h3><p>Spring 是一款基于 Java 的轻量级开源开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>Spring 框架(Spring Framework)是很多模块的集合，使用这些模块可以很方便地协助进行开发。Spring 支持控制反转(Inversion of Control, IOC) 和 面向切面编程(Aspect-Oriented Programming, AOP)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件(电子邮件，任务，调度，缓存等等)、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><p>Spring的核心功能主要是 <code>IoC</code> 和 <code>AOP</code>，核心思想是不重新造轮子，开箱即用，提高开发效率。</p><h3 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p><img src="/./image/Framework/Spring-4-x.png" alt="Spring 4.x"></p><p>Spring5.x 版本中 Web 模块的 <code>Portlet</code> 组件已经被废弃掉，同时增加了用于异步响应式处理的 <code>WebFlux</code> 组件。</p><ul><li><code>Core Container</code>：Spring 框架的核心模块、基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块。<ul><li><code>spring-core</code>：Spring 框架基本的核心工具类。</li><li><code>spring-beans</code>：提供对 <code>bean</code> 的创建、配置和管理等功能的支持。</li><li><code>spring-context</code>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><code>spring-expression</code>：提供对表达式语言(Spring Expression Language, SpEL)的支持，只依赖于 <code>core</code> 模块，不依赖于其他模块，可以单独使用。</li></ul></li><li><code>AOP</code>：面向切面编程，提供对切面编程的支持。<ul><li><code>spring-aop</code>：提供了面向切面的编程实现。</li><li><code>spring-aspects</code>：该模块为与 <code>AspectJ</code> 的集成提供支持。</li><li><code>spring-instrument</code>：提供了为 JVM 添加代理(agent)的功能。其为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。</li></ul></li><li><code>Data Access/Integration</code>：数据访问&#x2F;集成层，提供对数据库访问、事务管理、ORM、OXM、JMS 等功能的支持。<ul><li><code>spring-jdbc</code>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><code>spring-tx</code>：提供事务管理的支持。</li><li><code>spring-orm</code>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</li><li><code>spring-oxm</code>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><code>spring-jms</code>：消息服务。自 Spring Framework 4.1 以后，它还提供了对 <code>spring-messaging</code> 模块的继承。</li></ul></li><li><code>Spring Web</code>：Web 模块，提供对 Web 应用开发的支持。<ul><li><code>spring-web</code>：提供了基本的 Web 功能，如多文件上传、使用 <code>Servlet</code> 监听器初始化 Spring IoC 容器等。</li><li><code>spring-webmvc</code>：提供了 Spring MVC 的实现。</li><li><code>spring-websocket</code>：提供了对 WebSocket 的支持，可以让客户端和服务端进行双向通信。</li><li><code>spring-webflux</code>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul></li><li><code>Messaging</code>：<code>spring-messaging</code> 是Spring4.0新加入的模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li><li><code>Spring Test</code>：Spring有控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。Spring 的测试模块对 JUnit(单元测试框架)、TestNG(类似 JUnit)、Mockito(主要用来 Mock 对象)、PowerMock(解决 Mockito 的问题比如无法模拟 <code>final</code>，<code>static</code>，<code>private</code> 方法)等等常用的测试框架支持的都比较好。</li></ul><p><img src="/./image/Framework/Spring%E5%90%84%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="Spring各模块依赖关系"></p><h3 id="Spring-Spring-Boot-Spring-MVC之间的关系"><a href="#Spring-Spring-Boot-Spring-MVC之间的关系" class="headerlink" title="Spring&#x2F;Spring Boot&#x2F;Spring MVC之间的关系"></a>Spring&#x2F;Spring Boot&#x2F;Spring MVC之间的关系</h3><ul><li>Spring是基于 Java 的轻量级开源框架，包含众多模块，其中最重要的是<code>Spring-Core</code>(主要提供 <code>IoC</code> 依赖注入功能的支持)模块， Spring中的其他模块(如 <code>Spring MVC</code>)的功能实现基本都需要依赖于该模块。</li><li><code>Spring MVC</code> 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</li><li>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。过于麻烦，所以 <code>Spring Boot</code> 诞生了，其只是简化了配置，如果需要构建 MVC 架构的 Web 程序，还是需要使用 <code>Spring MVC</code> 作为 MVC 框架，只是说 <code>Spring Boot</code> 简化了 <code>Spring MVC</code> 的很多配置，真正做到开箱即用！<ul><li>Spring 旨在简化 J2EE 企业应用程序开发。<code>Spring Boot</code> 旨在简化 Spring 开发(减少配置文件，开箱即用！)。</li></ul></li></ul><h3 id="Spring-IoC✅"><a href="#Spring-IoC✅" class="headerlink" title="Spring IoC✅"></a>Spring IoC✅</h3><h3 id="什么是Spring-IoC"><a href="#什么是Spring-IoC" class="headerlink" title="什么是Spring IoC"></a>什么是Spring IoC</h3><p>控制反转(Inversion of Control, IoC)是一种设计思想，而不是一个具体的技术实现，并非Spring特有。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p><p>现有类 A 依赖于类 B</p><ul><li>传统的开发方式 ：往往是在类 A 中手动通过 <code>new</code> 关键字来 new 一个 B 的对象出来</li><li>使用 IoC 思想的开发方式 ：不通过 <code>new</code> 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。</li></ul><p>IoC使开发者丧失了创建、管理对象的权利，但是也使得开发者不用再考虑对象的创建、管理等一系列的事情，只需要专注于业务逻辑的实现。</p><h3 id="IoC解决了什么问题"><a href="#IoC解决了什么问题" class="headerlink" title="IoC解决了什么问题"></a>IoC解决了什么问题</h3><ol><li><strong>依赖管理和解耦</strong>：在传统的Java应用中，类与类之间的依赖是通过硬编码实现的，这导致了代码的高度耦合和难以维护。Spring IoC通过依赖注入(Dependency Injection，DI)模式，将对象的创建和依赖关系的管理交给Spring容器处理，从而实现了组件之间的解耦，提升了代码的可维护性和可测试性。</li><li><strong>对象生命周期管理</strong>：Spring容器负责管理Bean的生命周期，从创建、初始化到销毁，开发者可以通过配置和注解来控制这些生命周期方法，从而避免了手动管理对象生命周期的复杂性。</li><li><strong>配置集中管理</strong>：通过Spring IoC，可以将应用程序的配置信息集中在一个或多个配置文件中(如XML文件、Java配置类或注解)，从而使得配置更加集中和统一，便于管理和维护。</li><li><strong>代码的可测试性</strong>：通过依赖注入，可以轻松地替换实际的依赖对象为模拟对象(mock objects)，从而提高了单元测试的可行性和便捷性。</li><li><strong>模块化和可插拔性</strong>：Spring IoC支持通过不同的配置方式(XML、注解、Java配置类等)来实现模块化配置，便于扩展和维护。同时，Spring IoC容器支持不同类型的Bean作用域(如单例、原型等)，增强了系统的灵活性和可扩展性。</li></ol><p>通过Spring IoC的依赖注入和面向接口编程的方式，开发者可以更加专注于业务逻辑的实现，而不必过多关心对象的创建和管理，从而提升了开发效率和代码质量。</p><h3 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h3><p>控制反转指将对象的创建和依赖关系的管理从应用程序代码中抽离出来，交给Spring容器进行管理。</p><p><strong>控制反转</strong></p><ul><li>控制：指的是对象创建(实例化、管理)的权力</li><li>反转：控制权交给外部环境(Spring 框架、<code>IoC</code> 容器)</li></ul><p>实现控制反转有多种方式：</p><ul><li>依赖注入：通过注入方式实现依赖管理，易于测试和维护，广泛应用于现代开发框架(如Spring)。</li><li>服务定位器模式：通过中央注册器获取服务，使用方便，但可能引入全局状态和隐藏依赖。</li><li>事件驱动架构：通过事件进行解耦，适用于异步处理和复杂业务流程。</li><li>依赖查找：通过标准API查找依赖，适用于某些特定场景，但查找过程可能较为复杂。</li></ul><p><strong>Spring IoC容器</strong><br>Spring IoC容器是负责管理对象及其依赖关系的核心组件。IoC 容器实际上就是个 Map(key，value)，Map 中存放的是各种对象。主要的IoC容器有：</p><ul><li><code>BeanFactory</code>：最基础的IoC容器，提供基本的依赖注入功能。</li><li><code>ApplicationContext</code>：继承自<code>BeanFactory</code>，提供更多高级功能，如事件发布、国际化、AOP等。</li></ul><h3 id="什么是Spring-Bean"><a href="#什么是Spring-Bean" class="headerlink" title="什么是Spring Bean"></a>什么是Spring Bean</h3><p>在Spring中，bean是由IoC容器管理的对象。bean的定义和配置可以通过以下几种方式：</p><ul><li>XML配置文件：在XML文件中定义<code>bean</code>及其依赖关系。</li><li>注解配置：通过Java注解(如<code>@Component</code>、<code>@Autowired</code>等)定义和注入<code>bean</code>。</li><li>Java配置类：使用<code>@Configuration</code>和<code>@Bean</code>注解，通过Java类定义<code>bean</code>。</li></ul><h3 id="将一个类声明为Bean的注解有哪些"><a href="#将一个类声明为Bean的注解有哪些" class="headerlink" title="将一个类声明为Bean的注解有哪些"></a>将一个类声明为Bean的注解有哪些</h3><ul><li><code>@Component</code>：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code>： 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code>： 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code>： 对应 <code>Spring MVC</code> 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="Component-Bean区别"><a href="#Component-Bean区别" class="headerlink" title="@Component&#x2F;@Bean区别"></a>@Component&#x2F;@Bean区别</h3><p><strong>主要区别</strong></p><ol><li>定义方式：</li></ol><ul><li><code>@Component</code> 是在类上使用，Spring 自动扫描并注册 Bean。</li><li><code>@Bean</code> 是在方法上使用，返回值被注册为 Bean。</li></ul><ol start="2"><li>适用场景：</li></ol><ul><li><code>@Component</code> 适用于开发人员自己编写的类。</li><li><code>@Bean</code> 适用于第三方库的类或需要复杂配置的 Bean。</li></ul><ol start="3"><li>扫描和配置：</li></ol><ul><li><code>@Component</code> 需要启用组件扫描。</li><li><code>@Bean</code> 通常与配置类一起使用，不需要组件扫描。</li></ul><p>总结来说，<code>@Component</code> 更适合于直接在类上进行标注，简化了配置过程；而 <code>@Bean</code> 则提供了更多的灵活性，可以在配置类中以编程的方式定义 Bean。</p><p><strong>@Component</strong></p><ul><li>用途：<code>@Component</code> 用于标记一个类为 Spring 容器的组件(Bean)。</li><li>使用方式：直接在类上使用。Spring 会自动扫描带有 <code>@Component</code> 注解的类，并将其注册为 Spring 容器中的 Bean。</li><li>扫描：需要在配置类上使用 <code>@ComponentScan</code> 注解来启用自动扫描。</li><li>适用范围：通常用于标记服务层、数据访问层、控制层等组件类。</li><li>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 服务实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>@Bean</strong></li><li>用途：<code>@Bean</code> 用于在配置类中定义一个方法，该方法的返回值会被注册为 Spring 容器中的 Bean。</li><li>使用方式：在配置类的方法上使用，方法的返回值会作为 Bean 注册到 Spring 容器中。</li><li>配置类：通常与 <code>@Configuration</code> 注解一起使用，表明这是一个配置类。</li><li>适用范围：通常用于定义第三方库的 Bean，或者需要复杂初始化的 Bean。</li><li>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用于注入Bean的注解有哪些？"><a href="#用于注入Bean的注解有哪些？" class="headerlink" title="用于注入Bean的注解有哪些？"></a>用于注入Bean的注解有哪些？</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li><strong>用途</strong>：<code>@Autowired</code> 用于自动注入 Bean，Spring 会自动满足标记了该注解的依赖。</li><li><strong>使用位置</strong>：可以用在字段、构造方法、Setter 方法以及普通方法上。</li><li><strong>特点</strong>：默认按类型注入，可以结合 <code>@Qualifier</code> 按名称注入。</li><li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul><li><strong>用途</strong>：<code>@Resource</code> 是 JSR-250 标准的注解，可以按名称或类型注入。</li><li><strong>使用位置</strong>：字段、Setter 方法。</li><li><strong>特点</strong>：默认按名称注入，如果找不到匹配的 Bean，则按类型注入。</li><li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name = &quot;myRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul><li><strong>用途</strong>：与 <code>@Autowired</code> 一起使用，按名称注入 Bean。</li><li><strong>使用位置</strong>：字段、构造方法参数、Setter 方法参数。</li><li><strong>特点</strong>：解决同类型 Bean 多个实例的冲突问题。</li><li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;specificRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><ul><li><strong>用途</strong>：<code>@Inject</code> 是 JSR-330 标准的注解，功能与 <code>@Autowired</code> 类似。</li><li><strong>使用位置</strong>：字段、构造方法、Setter 方法。</li><li><strong>特点</strong>：仅支持按类型注入，可以结合 <code>@Named</code> 注解按名称注入。</li><li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用构造方法注入</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ul><li><strong>用途</strong>：<code>@Value</code> 用于注入简单值，比如基本类型、字符串、Spring EL 表达式等。</li><li><strong>使用位置</strong>：字段、构造方法参数、Setter 方法参数。</li><li><strong>特点</strong>：可以注入配置文件中的属性值。</li><li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>@Autowired</code> 和<code>@Resource</code>用的多一些。</p><h3 id="Autowired-Resource区别"><a href="#Autowired-Resource区别" class="headerlink" title="@Autowired&#x2F;@Resource区别"></a>@Autowired&#x2F;@Resource区别</h3><ul><li>默认注入方式：<ul><li><code>@Autowired</code> 默认根据接口类型(<code>byType</code>)去匹配并注入Bean(接口的实现类)。当一个接口存在多个实现类的话，<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定类名称。</li><li><code>@Resource</code> 当一个接口存在多个实现类的话，默认按类名称(<code>byName</code>)注入。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</li></ul></li><li>注解来源：<ul><li><code>@Autowired</code>：Spring 框架提供的注解。</li><li><code>@Resource</code>：JSR-250(JDK) 标准提供的注解。</li></ul></li><li>使用位置：<ul><li><code>@Autowired</code> 可以用在构造函数、方法、字段以及参数上。</li><li><code>@Resource</code> 通常用在字段和 Setter 方法上的注入。</li></ul></li><li>配置属性：<ul><li><code>@Autowired</code>：可以结合 <code>@Qualifier</code> 按名称注入。</li><li><code>@Resource</code>：可以通过 <code>name</code> 属性指定 <code>Bean</code> 名称，通过 <code>type</code> 属性指定 Bean 类型。</li></ul></li><li>处理机制：<ul><li><code>@Autowired</code>：使用 Spring 的依赖注入机制。</li><li><code>@Resource</code>：使用 JNDI 进行资源查找，适合在 Java EE 容器环境中使用。</li></ul></li></ul><p>总的来说，<code>@Autowired</code> 更加灵活和强大，适合在 Spring 应用中广泛使用；而 <code>@Resource</code> 则提供了一种更标准化的方式进行依赖注入，特别是在需要与 Java EE 容器进行集成时。</p><blockquote><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>(名称)、<code>type</code>(类型)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code>和<code>type</code>属性(不建议这么做)则注入方式为<code>byType</code>+<code>byName</code>。</p></blockquote><h3 id="Bean的作用域有哪些？"><a href="#Bean的作用域有哪些？" class="headerlink" title="Bean的作用域有哪些？"></a>Bean的作用域有哪些？</h3><p>在 Spring 框架中，Bean 的作用域(scope)定义了 Bean 的生命周期和可见性。Spring 提供了以下几种常见的 Bean 作用域：</p><ul><li><code>Singleton</code><ul><li><strong>描述</strong>：默认作用域。在整个 Spring 容器中只有一个 Bean 实例，每次请求该 Bean 时都会返回同一个实例。</li><li><strong>使用场景</strong>：大多数情况下使用，适用于无状态的 Bean。</li></ul></li><li><code>Prototype</code><ul><li><strong>描述</strong>：每次请求该 Bean 时，都会创建一个新的实例。</li><li><strong>使用场景</strong>：适用于有状态的 Bean 或需要每次使用时创建新实例的 Bean。</li></ul></li><li><code>Request</code><ul><li><strong>描述</strong>：在一个 HTTP 请求中，每次请求该 Bean 时，都会创建一个新的实例。该作用域仅在 Web 应用程序中有效。</li><li><strong>使用场景</strong>：适用于每个 HTTP 请求需要一个独立 Bean 实例的情况，例如处理用户请求的控制器。</li></ul></li><li><code>Session</code><ul><li><strong>描述</strong>：在一个 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域仅在 Web 应用程序中有效。</li><li><strong>使用场景</strong>：适用于需要在整个用户会话期间保持状态的 Bean。</li></ul></li><li><code>Global Session</code><ul><li><strong>描述</strong>：在一个全局 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域主要用于 Portlet 应用程序。</li><li><strong>使用场景</strong>：适用于需要在全局 Portlet 会话期间保持状态的 Bean。</li></ul></li><li><code>Application</code><ul><li><strong>描述</strong>：在整个应用程序生命周期内，每次请求该 Bean 时，都会返回同一个实例。通常在 Web 应用程序中使用。</li><li><strong>使用场景</strong>：适用于需要在整个应用程序生命周期内共享的 Bean。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope中可以指定Bean的作用域，取值：singleton、prototype、request、session、globalSession、application</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingletonBean</span> &#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h3><p>在 Spring 框架中，Bean 的线程安全性取决于其作用域和状态。以下是一些常见情况：</p><h4 id="Singleton-Bean"><a href="#Singleton-Bean" class="headerlink" title="Singleton Bean"></a>Singleton Bean</h4><ul><li><strong>默认作用域</strong>：<code>@Scope(&quot;singleton&quot;)</code></li><li><strong>描述</strong>：单例 Bean 在 Spring 容器中只有一个实例，并且该实例会被多个线程共享。</li><li><strong>线程安全性</strong>：单例 Bean 本身并不是线程安全的。如果单例 Bean 中包含可变的共享状态，则需要确保其线程安全。这可以通过以下方式实现：<ul><li>不在单例 Bean 中使用可变状态。</li><li>使用线程安全的数据结构(如 <code>ConcurrentHashMap</code>)。</li><li>在访问可变状态时使用同步(如 <code>synchronized</code>)。</li><li>采用无状态的设计模式。</li></ul></li></ul><h4 id="Prototype-Bean"><a href="#Prototype-Bean" class="headerlink" title="Prototype Bean"></a>Prototype Bean</h4><ul><li><strong>作用域</strong>：<code>@Scope(&quot;prototype&quot;)</code></li><li><strong>描述</strong>：原型 Bean 每次请求时都会创建一个新的实例，因此每个线程都会获得一个新的实例。</li><li><strong>线程安全性</strong>：由于每个线程都有自己的实例，原型 Bean 通常是线程安全的。但是，原型 Bean 的生命周期由使用它的对象管理，可能需要注意其创建和销毁的时机。</li></ul><h4 id="Request-Session-Scoped-Beans"><a href="#Request-Session-Scoped-Beans" class="headerlink" title="Request &amp; Session Scoped Beans"></a>Request &amp; Session Scoped Beans</h4><ul><li><strong>作用域</strong>：<code>@Scope(&quot;request&quot;)</code> 和 <code>@Scope(&quot;session&quot;)</code></li><li><strong>描述</strong>：请求作用域的 Bean 在一个 HTTP 请求中创建和销毁。会话作用域的 Bean 在一个 HTTP 会话中创建和销毁。</li><li><strong>线程安全性</strong>：请求作用域的 Bean 通常是线程安全的，因为每个请求都是独立的。会话作用域的 Bean 可能会被多个线程共享，需要考虑线程安全性。</li></ul><h4 id="Application-Scoped-Beans"><a href="#Application-Scoped-Beans" class="headerlink" title="Application Scoped Beans"></a>Application Scoped Beans</h4><ul><li><strong>作用域</strong>：<code>@Scope(&quot;application&quot;)</code></li><li><strong>描述</strong>：应用程序作用域的 Bean 在整个应用程序生命周期内共享。</li><li><strong>线程安全性</strong>：与单例 Bean 类似，应用程序作用域的 Bean 需要注意线程安全性问题。</li></ul><h4 id="Global-Session-Scoped-Beans"><a href="#Global-Session-Scoped-Beans" class="headerlink" title="Global Session Scoped Beans"></a>Global Session Scoped Beans</h4><ul><li><strong>作用域</strong>：<code>@Scope(&quot;globalSession&quot;)</code></li><li><strong>描述</strong>：全局会话作用域的 Bean 在 Portlet 应用程序的全局会话中共享。</li><li><strong>线程安全性</strong>：类似于会话作用域的 Bean，需要考虑线程安全性。</li></ul><p>总之，除非 Bean 的设计明确考虑了线程安全性，否则默认情况下 Spring 容器不会保证 Bean 的线程安全。确保线程安全的最佳实践包括无状态设计、使用线程安全的数据结构以及适当的同步机制。</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ol><li>创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</li><li>Bean 属性填充(依赖注入)：为 Bean 设置相关属性和依赖，如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li><li>Bean的初始化<ol><li>调用<code>Aware</code>接口的方法：<ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>如果实现了其他 *.Aware接口，就调用相应的方法。</li></ul></li><li>前置处理：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>初始化方法：如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li><li>后置处理：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li></ol></li><li>使用 Bean：Bean 可以被容器使用了，可以调用 Bean 的方法处理业务逻辑。</li><li>销毁 Bean：销毁并不是立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。<ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。</li><li>也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul></li></ol><p><img src="/./image/Framework/spring-bean-lifestyle.png" alt="Bean的生命周期"></p><blockquote><p>Spring 中提供的 Aware 接口主要有：<br><code>BeanNameAware</code>：注入当前 <code>bean</code> 对应 <code>beanName</code>；<br><code>BeanClassLoaderAware</code>：注入加载当前 <code>bean</code> 的 <code>ClassLoader</code>；<br><code>BeanFactoryAware</code>：注入当前 <code>BeanFactory</code> 容器的引用。</p></blockquote><h3 id="Spring-AOP✅"><a href="#Spring-AOP✅" class="headerlink" title="Spring AOP✅"></a>Spring AOP✅</h3><h3 id="对Spring-AOP的理解"><a href="#对Spring-AOP的理解" class="headerlink" title="对Spring AOP的理解"></a>对Spring AOP的理解</h3><p>面向切面编程(Aspect-Oriented Programming, AOP)是面向对象编程(OOP)的延续，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/./image/Framework/230ae587a322d6e4d09510161987d346.jpeg" alt="Spring AOP代理方式"></p><p>Spring AOP也集成了 AspectJ，可以使用 AspectJ 的注解来实现 AOP。</p><h3 id="AOP解决了什么问题"><a href="#AOP解决了什么问题" class="headerlink" title="AOP解决了什么问题"></a>AOP解决了什么问题</h3><ol><li><strong>横切关注点分离</strong>：在传统的面向对象编程中，某些功能(如日志记录、事务管理、安全性验证等)往往分散在多个类和方法中，导致代码的重复和耦合。AOP通过将这些横切关注点独立出来，以切面的形式进行集中管理，从而简化了核心业务逻辑。</li><li><strong>提高代码可读性和可维护性</strong>：通过将横切关注点分离出来，核心业务代码变得更加简洁、清晰。这样，开发者可以更加专注于业务逻辑的实现，提高代码的可读性和可维护性。</li><li><strong>动态代理和拦截功能</strong>：AOP提供了动态代理机制，可以在不修改原有代码的情况下，对方法进行拦截和增强。这种机制在处理权限验证、性能监控、缓存管理等场景时非常有用。</li><li><strong>代码重用</strong>：由于横切关注点可以以独立的切面形式存在，可以在不同的应用和模块之间共享和重用，提高了代码的复用性。</li><li><strong>减少代码耦合</strong>：通过AOP，将横切关注点从业务逻辑中分离出来，使得各个模块之间的耦合度降低，从而提高了系统的灵活性和可扩展性。</li></ol><h3 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h3><ol><li><strong>日志记录</strong>：可以在方法执行前后自动记录日志，而不需要在每个方法中手动添加日志代码。</li><li><strong>事务管理</strong>：可以在方法开始时开启事务，方法结束时提交或回滚事务，确保数据一致性。</li><li><strong>安全性验证</strong>：可以在方法执行前进行权限验证，确保用户有权限执行该操作。</li><li><strong>性能监控</strong>：可以统计方法的执行时间，进行性能分析和优化。</li><li><strong>异常处理</strong>：可以统一处理方法中的异常，避免重复的异常处理代码。</li></ol><h3 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h3><p>Spring AOP(面向切面编程)是Spring框架中的一个重要模块，用于在不修改现有代码的情况下向程序中添加新的行为。基本原理和关键概念如下：</p><ol><li>核心概念<ul><li>Target(目标)：被通知的对象</li><li>Proxy(代理)：向目标对象应用通知之后创建的代理对象</li><li>Join Point(连接点)：目标对象的所属类中，定义的所有方法均为连接点</li><li>Pointcut(切点)：切点是用于匹配连接点的表达式。被切面拦截 &#x2F; 增强的连接点(切入点一定是连接点，连接点不一定是切入点)</li><li>Advice(通知)：增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情。Spring AOP支持五种类型的通知：前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li><li>Aspect(切面)：切面是AOP的核心概念。切入点(Pointcut)+通知(Advice)。</li><li>Weaving(织入)：将通知应用到目标对象，进而生成代理对象的过程动作。Spring AOP在运行时通过动态代理实现织入。</li></ul></li><li>实现机制<br>Spring AOP主要通过两种方式来实现AOP功能：<ul><li>JDK动态代理：适用于基于接口的代理。Spring AOP使用JDK动态代理来创建实现了一个或多个接口的代理对象。 </li><li>CGLIB代理：适用于没有实现接口的类。Spring AOP使用CGLIB库生成目标类的子类来实现代理。</li></ul></li><li>工作流程<ul><li>定义切面和通知：使用<code>@Aspect</code>注解定义切面，并在切面类中使用<code>@Before</code>、<code>@After</code>等注解定义通知。 </li><li>配置AOP：在Spring配置文件中启用AOP支持，或使用<code>@EnableAspectJAutoProxy</code>注解来启用AOP自动代理。 </li><li>应用切面：Spring容器根据配置和切点表达式在运行时生成代理对象，并将通知织入到目标方法的执行中。</li></ul></li></ol><p>Spring AOP的核心在于通过动态代理和切点表达式，实现了对横切关注点的模块化管理，使得代码更易于维护和扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 定义前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method executed: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启用AOP支持</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoggingAspect <span class="title function_">loggingAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoggingAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例中，定义了一个<code>LoggingAspect</code>切面，其中包含前置通知和后置通知。然后，在Spring配置中启用了AOP支持，并将切面类注册为Bean。Spring容器将在运行时生成代理对象，并在目标方法执行前后执行通知。</p><h3 id="Spring-AOP-AspectJ-AOP区别"><a href="#Spring-AOP-AspectJ-AOP区别" class="headerlink" title="Spring AOP&#x2F;AspectJ AOP区别"></a>Spring AOP&#x2F;AspectJ AOP区别</h3><ol><li>实现方式<ul><li>Spring AOP：基于代理机制(Proxy-based)，主要使用JDK动态代理和CGLIB动态代理。属于运行时增强 </li><li>AspectJ AOP：基于字节码操作(Bytecode Manipulation)，通过编译时、加载时和运行时织入(Weaving)实现。属于编译时增强</li></ul></li><li>功能<ul><li>Spring AOP：只支持方法级别的AOP。 </li><li>AspectJ AOP：提供更强大的功能和更高的性能，适用于类级别和方法级别的AOP。</li></ul></li><li>性能<ul><li>Spring AOP：由于基于代理机制，性能相对较低，适用于大多数应用场景，但在高性能要求的场景中可能不够高效。 </li><li>AspectJ AOP：由于直接操作字节码，性能较高，适用于对性能要求较高的应用场景。</li></ul></li><li>配置和使用<ul><li>Spring AOP：配置相对简单，使用Spring的注解和配置文件即可实现。适用于已经使用Spring框架的应用，容易集成和使用。 </li><li>AspectJ AOP：配置较为复杂，需要AspectJ编译器或AspectJ加载时编织器。需要对AspectJ的语法和配置有一定了解，适用于需要更强大AOP功能的应用。</li></ul></li><li>使用场景 <ul><li>Spring AOP：适用于大多数Spring应用，特别是那些只需要方法级别AOP的场景。 </li><li>AspectJ AOP：适用于需要更强大AOP功能、更高性能和更细粒度控制的场景。</li></ul></li></ol><p>如果项目已经在使用Spring框架并且AOP需求较为简单，Spring AOP是一个不错的选择；如果需要更强大和高性能的AOP功能，AspectJ AOP是更好的选择。</p><h3 id="AspectJ的五种通知类型"><a href="#AspectJ的五种通知类型" class="headerlink" title="AspectJ的五种通知类型"></a>AspectJ的五种通知类型</h3><ul><li>Before(前置通知)：目标对象的方法调用之前触发</li><li>After (后置通知)：目标对象的方法调用之后触发</li><li>AfterReturning(返回通知)：目标对象的方法调用完成，在返回结果值之后触发</li><li>AfterThrowing(异常通知)：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li>Around (环绕通知)：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h3 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制"></a>多个切面的执行顺序如何控制</h3><ol><li><p>通常使用<code>@Order</code> 注解直接定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="SpringMVC✅"><a href="#SpringMVC✅" class="headerlink" title="SpringMVC✅"></a>SpringMVC✅</h3><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层(处理业务)、Dao 层(数据库操作)、Entity 层(实体类)、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="MVC核心组件"><a href="#MVC核心组件" class="headerlink" title="MVC核心组件"></a>MVC核心组件</h3><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="SpringMVC工作原理"><a href="#SpringMVC工作原理" class="headerlink" title="SpringMVC工作原理"></a>SpringMVC工作原理</h3><p><img src="/./image/Framework/de6d2b213f112297298f3e223bf08f28.png" alt="SpringMVC工作原理"></p><p><strong>流程</strong></p><ol><li>客户端(浏览器)发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>(也就是 <code>Controller</code> 控制器) ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>(视图渲染)。</li><li>把 <code>View</code> 返回给请求者(浏览器)</li></ol><h3 id="Spring框架中用到了哪些设计模式"><a href="#Spring框架中用到了哪些设计模式" class="headerlink" title="Spring框架中用到了哪些设计模式"></a>Spring框架中用到了哪些设计模式</h3><ol><li>**工厂模式 (Factory Pattern)**：<ul><li>Spring 使用工厂模式来创建对象实例。<code>BeanFactory</code> 和 <code>ApplicationContext</code> 是 Spring 中的两种主要的工厂类，用于管理和创建 bean 对象。<ul><li><code>BeanFactory</code>：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code>：容器启动的时候，不管用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li></ul></li></ul></li><li>**单例模式 (Singleton Pattern)**：<ul><li>默认情况下，Spring 容器中的 bean 是单例的，这意味着在整个 Spring 容器中只有一个 bean 实例存在。这通过 Spring 的 IoC 容器来管理。</li></ul></li><li>**代理模式 (Proxy Pattern)**：<ul><li>Spring AOP (Aspect-Oriented Programming) 使用代理模式来实现横切关注点(如事务管理、日志记录等)的分离。Spring 提供了 JDK 动态代理和 CGLIB 代理两种方式。</li></ul></li><li>**模板模式 (Template Method Pattern)**：<ul><li>Spring 中的模板类(如 <code>JdbcTemplate</code>, <code>RestTemplate</code>)通过封装一系列的操作步骤，简化了数据库操作和 REST 调用等重复性的编程任务。</li></ul></li><li>**依赖注入模式 (Dependency Injection Pattern)**：<ul><li>依赖注入是 Spring 的核心设计模式，通过构造器注入、setter 注入和接口注入等方式，实现了对象之间的松耦合。</li></ul></li><li>**观察者模式 (Observer Pattern)**：<ul><li>Spring 事件机制使用了观察者模式。可以通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 在应用程序中发布和监听事件。</li></ul></li><li>**适配器模式 (Adapter Pattern)**：<ul><li>Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code>。</li><li>Spring MVC 中的 <code>HandlerAdapter</code> 用于适配不同类型的处理器方法，使得这些方法可以作为统一的处理器进行调用。</li></ul></li><li>**策略模式 (Strategy Pattern)**：<ul><li>Spring 中的某些功能(如事务管理)使用了策略模式，允许在运行时选择具体的实现策略。</li></ul></li><li>**装饰者模式 (Decorator Pattern)**：<ul><li>Spring 的 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 用于在 bean 初始化前后进行一些自定义的处理，这实际上是对原有 bean 的功能进行扩展和增强。</li></ul></li></ol><p>这些设计模式的使用，使得 Spring 框架具备高度的灵活性、可扩展性和可维护性。</p><h3 id="BeanFactory-ApplicationContext区别"><a href="#BeanFactory-ApplicationContext区别" class="headerlink" title="BeanFactory&#x2F;ApplicationContext区别"></a>BeanFactory&#x2F;ApplicationContext区别</h3><ul><li><p>功能：</p><ul><li><code>BeanFactory</code>是Spring的核心接口，提供了基本的IOC(Inversion of Control)容器功能，负责实例化、配置和管理bean。</li><li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，扩展了更多的企业级功能，如事件机制、国际化支持、AOP(面向切面编程)集成、Web应用上下文等。</li></ul></li><li><p>初始化：</p><ul><li><code>BeanFactory</code>采用懒加载机制，只有在第一次访问某个bean时，才会实例化该bean。这对启动性能有好处，但可能会导致首次访问时的延迟。</li><li><code>ApplicationContext</code>预初始化：其在启动时会预先实例化所有单例bean，确保在应用启动时所有必要的bean已经准备好。这有助于捕获配置问题并提升应用的响应速度。</li></ul></li><li><p>使用场景：</p><ul><li><code>BeanFactory</code>适用于资源受限的环境，如移动设备或嵌入式系统，适用于对性能要求高且对Spring的高级功能需求较少的应用。</li><li><code>ApplicationContext</code>适用于标准的企业级应用中，特别是Web应用，适用于需要Spring框架提供的所有功能和高级特性的应用。</li></ul></li><li><p>依赖查找：</p><ul><li><code>BeanFactory</code>依赖于显式的查找，开发者需要通过<code>getBean</code>方法手动获取bean。</li><li><code>ApplicationContext</code>除了显式查找外，还支持自动注入和其他更加灵活的依赖管理方式。</li></ul></li><li><p>如果应用需要完整的Spring功能，包括事件发布、国际化、AOP支持以及其他企业级特性，使用<code>ApplicationContext</code>。</p></li><li><p>如果应用在一个资源受限的环境中运行并且只需要基本的IOC容器功能，<code>BeanFactory</code>可能更合适。</p></li></ul><p>通常在实际的Spring应用开发中，大多数开发者会选择使用<code>ApplicationContext</code>，因为它提供了更丰富的功能和更好的开发体验。</p><h3 id="Spring循环依赖及解决方案"><a href="#Spring循环依赖及解决方案" class="headerlink" title="Spring循环依赖及解决方案"></a>Spring循环依赖及解决方案</h3><p>在Spring框架中，循环依赖是指两个或多个bean之间相互依赖，导致无法正常实例化的问题。例如，Bean A依赖Bean B，而Bean B又依赖Bean A。这种情况下，Spring容器无法确定先实例化哪个bean，从而陷入死循环。</p><p>Spring主要通过三级缓存解决循环依赖：<br>如果发生循环依赖的话，就去 三级缓存 <code>singletonFactories</code> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象(虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了)，并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p><p>循环依赖的问题主要有两种情况：</p><ol><li>构造函数循环依赖：构造函数循环依赖指的是两个bean在构造函数中相互依赖。这种情况由于在实例化bean时必须提供构造函数的参数，所以Spring无法解决这种类型的循环依赖。<ol><li>将构造函数注入改为setter注入：Setter注入是解决循环依赖的常用方法。Spring能够在实例化一个bean并将其放入singleton池后，通过setter方法注入其他bean的依赖。</li><li>使用<code>@Lazy</code>注解：<code>@Lazy</code>注解可以延迟bean的初始化，直到真正需要该bean时才进行实例化，从而打破循环依赖。</li><li>使用接口和代理：使用Spring AOP可以创建代理对象，从而打破循环依赖。通过AOP，Spring可以创建一个代理对象来代替实际的bean，这样即使两个bean相互依赖，Spring也能处理。</li></ol></li><li>Setter循环依赖：Setter循环依赖指的是两个bean通过setter方法相互依赖。Spring可以通过三级缓存机制来解决这种类型的循环依赖。<ol><li>Spring默认已经能够解决setter循环依赖，无需额外的配置。Spring会在实例化bean时，通过三级缓存提前暴露bean的引用，从而解决循环依赖。</li><li>使用<code>@PostConstruct</code>注解：使用<code>@PostConstruct</code>注解可以在依赖注入完成后执行初始化方法，这样可以在方法内部设置依赖，避免循环依赖。</li></ol></li></ol><h3 id="Spring的三级缓存"><a href="#Spring的三级缓存" class="headerlink" title="Spring的三级缓存"></a>Spring的三级缓存</h3><p>Spring通过三级缓存解决了循环依赖的问题。三级缓存分别是<code>singletonObjects</code>、<code>earlySingletonObjects</code>和<code>singletonFactories</code>，分别是三个 Map。</p><ul><li>一级缓存(singletonObjects)：存放最终形态的 Bean(已经实例化、属性填充、初始化)，单例池，为“Spring 的单例属性”⽽⽣。一般获取 Bean 都是从这里获取的，但非所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</li><li>二级缓存(earlySingletonObjects)：存放过渡 Bean(半成品，尚未属性填充)，也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</li><li>三级缓存(singletonFactories)：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法可以生成原始 Bean 对象或者代理对象。三级缓存只会对单例 Bean 生效。</li></ul><p><strong>缺点</strong></p><ul><li>增加了内存开销(需要维护三级缓存，也就是三个 Map)，降低了性能(需要进行多次检查和转换)。</li><li>少部分情况是不支持循环依赖的，比如非单例的 bean 和@Async注解的 bean 无法支持循环依赖。</li></ul><h3 id="Spring创建Bean流程"><a href="#Spring创建Bean流程" class="headerlink" title="Spring创建Bean流程"></a>Spring创建Bean流程</h3><ol><li>先去 一级缓存 <code>singletonObjects</code> 中获取，存在就返回；</li><li>如果不存在或者对象正在创建中，于是去 二级缓存 <code>earlySingletonObjects</code> 中获取；</li><li>如果还没有获取到，就去 三级缓存 <code>singletonFactories</code> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li></ol><p>Spring 在创建 Bean 的时候，如果允许循环依赖的话，Spring 就会将刚刚实例化完成，但是属性还没有初始化完的 Bean 对象给提前暴露出去。</p><h3 id="三级缓存解决循环依赖流程"><a href="#三级缓存解决循环依赖流程" class="headerlink" title="三级缓存解决循环依赖流程"></a>三级缓存解决循环依赖流程</h3><ul><li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li><li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 一二级缓存 中肯定没有 A；</li><li>那么此时就去三级缓存中调用 getObject() 方法去获取 A 的 前期暴露的对象 ，也就是调用上边加入的 getEarlyBeanReference() 方法，生成一个 A 的 前期暴露对象；</li><li>然后就将这个 ObjectFactory 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li></ul><h3 id="只有两级缓存可以吗"><a href="#只有两级缓存可以吗" class="headerlink" title="只有两级缓存可以吗"></a>只有两级缓存可以吗</h3><p>在没有 AOP 的情况下，确实可以只使用一级和三级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。</p><h3 id="Lazy解决循环依赖"><a href="#Lazy解决循环依赖" class="headerlink" title="@Lazy解决循环依赖"></a>@Lazy解决循环依赖</h3><p><code>@Lazy</code> 用来标识类是否需要懒加载&#x2F;延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。</p><ul><li>如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。</li><li>如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。</li></ul><p><code>@Lazy</code>解决循环依赖的原理：<br>举一个例子，比如说有两个 Bean，A 和 B发生了循环依赖。那么 A 的构造器上添加 <code>@Lazy</code> 注解之后(延迟 Bean B 的实例化)，加载的流程如下：</p><ol><li>创建BeanA实例：Spring开始创建BeanA实例。在创建BeanA实例时，Spring发现其构造函数参数BeanB上有<code>@Lazy</code>注解。</li><li>创建BeanB的代理对象：由于<code>@Lazy</code>注解的存在，Spring不会立即创建BeanB实例，而是创建一个BeanB的 _代理对象_。这个代理对象会延迟实际的BeanB实例化，直到代理对象的某个方法被调用时才创建目标bean。</li><li>注入代理对象：Spring将BeanB的代理对象注入到BeanA中。</li><li>完成BeanA的创建：Spring完成BeanA的创建，并继续执行BeanA的初始化方法。</li><li>创建BeanB实例：当BeanB需要创建时，代理对象会触发实际的BeanB实例化过程。</li><li>注入BeanA实例：在创建BeanB实例时，Spring会发现BeanB依赖于BeanA，此时BeanA已经创建完成并且在Spring容器中可用，所以可以直接注入BeanA实例。</li></ol><blockquote><p>这里的代理对象使用 AOP 实现，Spring可以创建两种类型的代理对象：</p><ul><li>JDK动态代理：使用Java的反射机制创建代理对象，适用于实现了接口的bean。</li><li>CGLIB代理：使用CGLIB库生成代理对象，适用于没有实现接口的bean。</li></ul></blockquote><h3 id="Spring事务✅"><a href="#Spring事务✅" class="headerlink" title="Spring事务✅"></a>Spring事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>四大特性：</p><ul><li>原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性(Consistency)：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性(Isolation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性(Durability)：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h3 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h3><p>程序是否支持事务首先取决于数据库 ，如使用 MySQL，若 存储引擎是 <code>innodb</code> 引擎，则可以支持事务的，若是 <code>myisam</code> 引擎，那就不支持事务的。</p><h3 id="Spring管理事务的两种方式"><a href="#Spring管理事务的两种方式" class="headerlink" title="Spring管理事务的两种方式"></a>Spring管理事务的两种方式</h3><ul><li>编程式事务：在代码中硬编码(在分布式系统中推荐使用) ：通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li><li>声明式事务：在 XML 配置文件中配置或者直接基于注解(单体应用或者简单业务系统推荐使用)：实际是通过 AOP 实现(基于@Transactional 的全注解方式使用最多)，开发中推荐使用，代码入侵性小。</li></ul><h3 id="Spring中的事务管理接口"><a href="#Spring中的事务管理接口" class="headerlink" title="Spring中的事务管理接口"></a>Spring中的事务管理接口</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li><code>PlatformTransactionManager</code>：(平台)事务管理器，Spring 事务策略的核心。Spring通过该接口，为JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等平台提供了对应的事务管理器，但具体由各个平台自己实现。<ul><li>主要定义了三个方法：<code>getTransaction()</code>、<code>commit()</code>、<code>rollback()</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得事务</span></span><br><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br></pre></td></tr></table></figure></li><li>该接口将事务管理行为抽象出来，然后不同的平台去实现它，这样可以保证提供给外部的行为不变，方便扩展。</li></ul></li><li><code>TransactionDefinition</code>：事务属性(包含五个方面：事务隔离级别、传播行为、事务超时、是否只读、回滚规则)。</li><li><code>TransactionStatus</code>：事务运行状态。<ul><li>该接口用来记录事务的状态 定义了一组方法，用来获取或判断事务的相应状态信息。</li></ul></li></ul><p>可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。</p><p><code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h3><p>在 Spring 框架中，事务传播行为(Transaction Propagation Behavior)定义了事务方法如何与现有事务协作。这些传播行为决定了一个事务方法是否在一个现有事务中运行，是否创建一个新的事务，或者是否在没有事务的情况下运行。</p><p>Spring 提供了七种事务传播行为：</p><ol><li><strong>PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是最常用的传播行为。<ul><li>行为：加入当前事务或创建一个新的事务。</li><li>适用场景：大多数业务场景，确保方法在一个事务中运行。</li></ul></li><li><strong>PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则将当前事务挂起。<ul><li>行为：始终创建一个新事务，并挂起当前事务(如果存在)。</li><li>适用场景：需要在一个完全独立的事务中运行的方法，例如日志记录。</li></ul></li><li><strong>PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。<ul><li>行为：如果有事务则使用事务，没有则非事务执行。</li><li>适用场景：既可以在事务中执行也可以在非事务中执行的方法。</li></ul></li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，则将当前事务挂起。<ul><li>行为：非事务方式执行，如果有事务则挂起当前事务。</li><li>适用场景：方法必须在非事务中执行，例如读操作不需要事务管理。</li></ul></li><li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。<ul><li>行为：非事务方式执行，如果有事务则抛出异常。</li><li>适用场景：确保方法绝对不会在事务中运行的情况。</li></ul></li><li><strong>PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<ul><li>行为：必须在事务中执行，如果没有事务则抛出异常。</li><li>适用场景：必须有现有事务的方法，例如依赖上游事务的操作。</li></ul></li><li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则与 <code>PROPAGATION_REQUIRED</code> 的效果相同。<ul><li>行为：如果有事务则创建一个嵌套事务，如果没有则创建一个新事务。</li><li>适用场景：需要保存部分回滚点的方法，适合复杂的业务场景。</li></ul></li></ol><h3 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h3><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="Transactional-rollbackFor-Exception-class-注解"><a href="#Transactional-rollbackFor-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解</h3><p>Exception 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时也可以在方法级别使用该标注来覆盖类级别的定义。</p><p><code>@Transactional</code> 注解默认回滚策略是只有在遇到<code>RuntimeException</code>(运行时异常) 或者 <code>Error</code> 时才会回滚事务，而不会回滚 <code>Checked Exception</code>(受检查异常)。这是因为 Spring 认为<code>RuntimeException</code>和 <code>Error</code> 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑来处理。</p><p>如果想要修改默认的回滚策略，可以使用 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性来指定哪些异常需要回滚，哪些异常不需要回滚。例如，如果想要让所有的异常都回滚事务，可以使用如下的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要让某些特定的异常不回滚事务，可以使用如下的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = CustomException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><p>Spring Data JPA 是 Spring Data 项目的一部分，它为 Java 持久化 API (JPA) 提供了一个高层次的抽象。其主要目的是简化与数据库交互的复杂性，通过最小化配置和编码，使开发者能够更轻松地创建、读取、更新和删除数据库中的数据。</p><p><strong>主要特点和功能</strong></p><ol><li><strong>简化的存储库接口</strong>：<ul><li>Spring Data JPA 提供了 <code>JpaRepository</code> 接口，继承该接口的存储库(Repository)可以自动拥有常见的数据操作方法，如 <code>save</code>、<code>findAll</code>、<code>findById</code>、<code>delete</code> 等。</li></ul></li><li><strong>自定义查询方法</strong>：<ul><li>通过定义遵循命名规则的方法名，Spring Data JPA 可以自动生成 SQL 查询。例如，<code>findByLastName</code> 方法会生成一个根据 <code>lastName</code> 字段进行查询的 SQL。</li></ul></li><li><strong>查询注解</strong>：<ul><li>可以使用 <code>@Query</code> 注解编写自定义的 JPQL 或原生 SQL 查询。</li></ul></li><li><strong>分页和排序</strong>：<ul><li>支持分页和排序，通过方法参数 <code>Pageable</code> 和 <code>Sort</code>，可以轻松实现分页和排序功能。</li></ul></li><li><strong>规格查询</strong>：<ul><li>使用 <code>Specification</code> 接口，可以创建复杂的动态查询。</li></ul></li><li><strong>自动实现</strong>：<ul><li>Spring Data JPA 可以根据接口自动生成实现类，无需手动编写实现代码。</li></ul></li></ol><p><strong>核心组件</strong></p><ol><li><strong>Repository 接口</strong>：<ul><li><code>CrudRepository</code>：提供基本的 CRUD 操作。</li><li><code>PagingAndSortingRepository</code>：在 <code>CrudRepository</code> 的基础上增加分页和排序功能。</li><li><code>JpaRepository</code>：在 <code>PagingAndSortingRepository</code> 的基础上增加 JPA 相关操作。</li></ul></li><li><strong>实体类</strong>：<ul><li>使用 JPA 注解(如 <code>@Entity</code>、<code>@Table</code>、<code>@Id</code> 等)来映射数据库表和字段。</li></ul></li><li><strong>Spring Data JPA 配置</strong>：<ul><li>通过配置文件(如 <code>application.properties</code> 或 <code>application.yml</code>)来配置数据源、JPA 供应商、数据库方言等。</li></ul></li></ol><p>通过这些组件，开发者可以快速创建与数据库交互的应用程序，而不必编写大量的样板代码。Spring Data JPA 的抽象和自动化能力，使得开发过程更加高效和简洁。</p><h3 id="JPA审计功能"><a href="#JPA审计功能" class="headerlink" title="JPA审计功能"></a>JPA审计功能</h3><p>审计功能主要是帮助记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><h3 id="实体之间的关联关系注解"><a href="#实体之间的关联关系注解" class="headerlink" title="实体之间的关联关系注解"></a>实体之间的关联关系注解</h3><ul><li><code>@OneToOne</code>：一对一。</li><li><code>@ManyToMany</code>：多对多。</li><li><code>@OneToMany</code>：一对多。</li><li><code>@ManyToOne</code>：多对一。</li></ul><p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>Spring Security 是一个强大的且高度可定制的认证和访问控制框架，属于 Spring 框架的一部分。它为基于 Spring 的企业应用程序提供了全面的安全性解决方案。以下是 Spring Security 的一些关键特性和功能：</p><ol><li>认证(Authentication)：Spring Security 提供了多种认证方式，包括基于表单的登录、HTTP Basic 认证、OAuth2 认证等。它还支持自定义认证逻辑，可以与数据库、LDAP、OAuth2 提供者等集成。</li><li>授权(Authorization)：授权是指控制用户对资源的访问权限。Spring Security 使用表达式和基于角色的访问控制来实现细粒度的授权控制。你可以通过注解(如 <code>@PreAuthorize</code>、<code>@Secured</code>)或基于 URL 的配置来定义访问规则。</li><li>安全上下文(Security Context)：Spring Security 维护一个安全上下文，其中包含当前用户的认证信息。这个安全上下文可以在应用程序的各个部分访问，用于确定用户的身份和权限。</li><li>防护机制：Spring Security 提供了多种安全防护机制来防止常见的攻击，如：<ul><li><strong>CSRF(跨站请求伪造)防护</strong>：通过生成和验证 CSRF 令牌来防止跨站请求伪造攻击。</li><li><strong>会话固定攻击防护</strong>：通过在用户登录后生成新的会话 ID 来防止会话固定攻击。</li><li>**内容安全策略(CSP)**：防止 XSS(跨站脚本攻击)和数据注入攻击。</li></ul></li><li>密码存储：Spring Security 提供了多种密码编码器(如 BCrypt、SCrypt、PBKDF2)来安全地存储用户密码。你可以选择合适的密码编码器来加强密码存储的安全性。</li><li>集成：Spring Security 与其他 Spring 项目(如 Spring Boot、Spring MVC)无缝集成，简化了安全配置和管理。使用 Spring Boot，可以通过自动配置快速启动安全功能。</li><li>可扩展性：Spring Security 是高度可定制的。你可以扩展或替换其默认实现来满足特定的安全需求。比如，自定义认证提供者、授权管理器、过滤器等。</li></ol><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis 是一个流行的持久层框架，用于简化 Java 应用程序与数据库之间的交互。主要提供下面功能：</p><ul><li>SQL 映射：MyBatis 允许你使用 XML 或注解的方式将 SQL 语句映射到 Java 方法上，这样可以直接在代码中调用这些方法来执行 SQL 查询和更新操作。</li><li>简化 JDBC 操作：MyBatis 封装了 JDBC 操作，使开发者不需要处理复杂的 JDBC API，如手动管理连接、结果集处理等。</li><li>动态 SQL：MyBatis 支持动态生成 SQL 语句，可以根据条件灵活构建查询或更新语句，避免了在代码中拼接 SQL 字符串的麻烦。</li><li>缓存支持：MyBatis 提供了一级缓存(默认开启)和二级缓存(可选配置)，通过缓存机制提高了数据库查询的性能。</li><li>灵活的配置：MyBatis 提供了多种配置方式，可以通过 XML 文件、注解和 Java 配置类进行配置，满足不同的使用需求。</li><li>扩展性：MyBatis 具有良好的扩展性，开发者可以通过插件机制自定义和扩展 MyBatis 的功能，如自定义类型处理器、插件等。</li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h3><ol><li>调用启动类的<code>main</code> 方法<ul><li>Spring Boot 应用通常是通过一个包含 <code>@SpringBootApplication</code> 注解的主类启动的，该类的 <code>main</code> 方法中调用<code>SpringApplication.run()</code>。</li></ul></li><li>创建 <code>SpringApplication</code> 实例<ul><li><code>SpringApplication.run()</code> 内部首先会创建一个 <code>SpringApplication</code> 实例，主要用于配置和管理整个应用的启动过程。</li><li>这个实例初始化了一些基本的属性，比如：启动参数、运行环境(如开发、生产)、应用类型(如 Web 应用或非 Web 应用)。</li></ul></li><li>设置启动配置<ul><li>Spring Boot 会根据应用的上下文和依赖来设置配置属性，例如：<ul><li>通过 <code>ApplicationContextInitializer</code> 实例对上下文进行初始化。</li><li>加载所有在 <code>META-INF/spring.factories</code> 文件中声明的 <code>ApplicationListener</code> 监听器。</li></ul></li><li>此时，<code>SpringApplication</code> 根据类路径、系统属性等配置自动决定应用类型(<code>Reactive</code>、<code>Servlet</code> 或 <code>None</code>)。</li></ul></li><li>启动引导器(<code>SpringApplicationRunListeners</code>)：Spring Boot 创建并启动 <code>SpringApplicationRunListeners</code>，它们会监听应用启动的各个阶段，并触发相应事件。主要包括以下几个事件：<ul><li>Starting：表示应用程序刚刚启动。</li><li>Environment Prepared：此阶段设置环境参数(例如配置文件、属性源等)。</li><li>Context Prepared：在创建并配置好 <code>ApplicationContext</code> 后触发。</li><li>Context Loaded：当所有 Bean 定义被加载到上下文但尚未被实例化时触发。</li><li>Started：表示 <code>ApplicationContext</code> 已经启动并准备接受请求。</li></ul></li><li>创建并准备 <code>ApplicationContext</code><ul><li>Spring Boot 根据应用的类型(比如 Web 应用)创建适当的 <code>ApplicationContext</code>，例如：<ul><li>Web 应用使用 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li><li>非 Web 应用使用 <code>AnnotationConfigApplicationContext</code>。</li></ul></li><li>然后，Spring Boot 开始加载 <code>@Configuration</code> 类、扫描组件并注册所有的 Bean 定义。</li></ul></li><li>配置环境 (<code>Environment</code>)<ul><li>在 <code>ApplicationContext</code> 准备好后，Spring Boot 开始配置运行时环境。</li><li>环境配置包含了系统属性、环境变量以及外部配置文件(如 <code>application.properties</code> 或 <code>application.yml</code>)，并通过 <code>ConfigurableEnvironment</code> 注入到上下文中。</li></ul></li><li>刷新 <code>ApplicationContext</code><ul><li>Spring Boot 调用 <code>refresh()</code> 方法，完成 <code>ApplicationContext</code> 的初始化，包括 Bean 的创建、依赖注入、生命周期管理等。</li><li>在此阶段，所有的 Bean 被完全加载和实例化，<code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 也会在此之后执行。</li></ul></li><li>启动内嵌的 Web 服务器(如果有)<ul><li>如果是 Web 应用，Spring Boot 会在应用上下文加载完成后启动内嵌的 Web 服务器(例如 Tomcat、Jetty 或 Undertow)。</li><li>这个步骤通常是通过 <code>WebServerStartStopLifecycle</code> 组件来完成的。</li></ul></li><li><code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 执行<ul><li>一旦所有的 Bean 都初始化完毕，Spring Boot 会执行所有实现了 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口的组件。这些组件通常用于执行一些应用启动后的初始化逻辑。</li></ul></li><li>完成启动，进入事件循环<ul><li>启动流程最后，Spring Boot 进入应用的主事件循环(对于 Web 应用来说)。此时应用已经可以接收 HTTP 请求或执行其他业务逻辑。</li></ul></li></ol><h4 id="Tomcat如何接收http请求"><a href="#Tomcat如何接收http请求" class="headerlink" title="Tomcat如何接收http请求"></a>Tomcat如何接收http请求</h4><ol><li>启动和初始化<ol><li>启动 Tomcat<ul><li>当 Tomcat 启动时，它会加载并初始化所有配置文件（如 <code>server.xml</code>、<code>web.xml</code>）。</li><li>它会创建并配置一个或多个 Connector 对象，这些对象负责接收来自客户端的 HTTP 请求。</li></ul></li><li>配置 Connector<ul><li>在 <code>server.xml</code> 文件中配置 Connector，例如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>Connector 会监听指定的端口（例如 8080），并处理进入的请求。</li></ul></li></ol></li><li>接收 HTTP 请求<ol><li>监听端口：Connector 监听配置的端口，接收来自客户端的 TCP 连接。</li><li>建立连接：当有客户端发起连接时，Connector 接受这个连接，并将其交给一个处理线程。</li></ol></li><li>请求处理<ol><li>请求解析：处理线程会解析 HTTP 请求数据，包括请求行（请求方法、请求 URI 和协议）、请求头和请求体。请求数据会被封装成一个 <code>HttpServletRequest</code> 对象。</li><li>请求路由：Tomcat 会根据请求的 URI 进行路由，将请求分发到相应的 <code>Servlet</code>。</li><li>调用 Servlet：请求会被传递到适当的 <code>Servlet</code> 实例的 <code>service()</code> 方法中。具体的处理由 <code>doGet()</code>、<code>doPost()</code> 等方法实现，取决于请求的方法类型。</li><li>生成响应：<code>Servlet</code> 处理完请求后，会生成响应内容并将其封装到 <code>HttpServletResponse</code> 对象中。响应内容包括响应状态码、响应头和响应体。</li><li>发送响应：处理线程将 <code>HttpServletResponse</code> 对象中的响应数据写回到客户端。Tomcat 会将响应数据通过网络发送回客户端，并关闭连接(如果是非持久连接)。</li></ol></li><li>关闭连接：根据请求的 <code>Connection</code> 头部的值（如 <code>Connection: keep-alive</code>），Tomcat 决定是否保持连接以处理后续请求。在处理完请求后，Tomcat 可能会关闭连接或重用以提高性能。</li></ol><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>自动装配(Auto-Configuration)是Spring Boot框架的一个核心特性之一，它通过扫描应用程序的classpath和依赖关系，自动配置和装配Spring应用程序所需的各种组件。</p><p>在传统的Spring应用程序中，开发者需要手动配置大量的bean，例如数据源、事务管理器、视图解析器等。这些配置过程繁琐而容易出错，加大了开发难度和成本。而Spring Boot的自动装配机制则能够自动完成这些配置过程，使得开发者可以更加专注于业务逻辑的实现。</p><ol><li>启动类注解扫描<br>@SpringBootApplication：这是Spring Boot应用程序的入口注解，它集成了多个关键功能，包括自动配置(@EnableAutoConfiguration)、组件扫描(@ComponentScan)和配置(@Configuration)。<br>@EnableAutoConfiguration：启动自动配置机制。<br>@ComponentScan：扫描@Component、@Service、@Controller等注解的Bean，将它们注册到Spring容器中。</li><li>自动配置类的加载<br>Spring Boot在启动时，会扫描项目依赖中的jar包，查找META-INF&#x2F;spring.factories文件。<br>这个文件中列出了所有自动配置类的全限定类名。<br>Spring Boot通过SpringFactoriesLoader读取这些类名，并加载相应的自动配置类。</li><li>条件化装配<br>自动配置类中的配置并不是无条件加载的，而是根据条件注解(如@ConditionalOnClass、@ConditionalOnBean、@ConditionalOnProperty等)来决定是否加载某个配置。<br>@ConditionalOnClass：当类路径中存在指定的类时，才加载配置。<br>@ConditionalOnBean：当容器中存在指定类型的Bean时，才加载配置。<br>@ConditionalOnProperty：当配置文件中存在指定的属性且值满足条件时，才加载配置。</li><li>配置类的注册与绑定<br>生效的配置类会将带有@Bean注解的组件注册到Spring的IOC容器中。<br>同时，配置类也可以进行配置绑定，通过@ConfigurationProperties注解将配置文件中的值绑定到对应的Properties类中。</li><li>配置文件的解析与覆盖<br>Spring Boot默认使用application.properties或application.yml作为全局配置文件。<br>开发者可以在这些文件中定义或覆盖自动配置的默认值，以满足特定的需求。</li><li>自定义配置与排除<br>开发者可以创建自定义的自动配置类，通过@Configuration和条件注解来定义自己的自动装配规则。<br>如果需要排除某个自动装配的组件或配置，可以使用@SpringBootApplication注解的exclude属性，或在配置文件中通过spring.autoconfigure.exclude属性来实现。</li><li>SpringApplication.run方法执行<br>当执行SpringApplication.run(XXX.class, args)方法时，Spring Boot会启动并执行上述流程。<br>这个方法会判断应用的类型(普通项目还是Web项目)，加载初始化器和应用程序监听器，推动并设置main方法的定义类，最终启动Spring容器。<br>综上所述，Spring Boot的自动装配流程是一个基于条件化装配的自动化过程，它通过注解、配置文件和条件注解来实现应用程序的自动配置和组件的自动注册。这个过程极大地简化了Spring应用程序的搭建和配置工作，让开发者能够更专注于业务逻辑的开发。</li></ol><h3 id="SpringBoot如何配置跨域"><a href="#SpringBoot如何配置跨域" class="headerlink" title="SpringBoot如何配置跨域"></a>SpringBoot如何配置跨域</h3><p>在Spring Boot中实现跨域操作，主要是通过配置CORS（跨源资源共享）来实现的。CORS是一个W3C标准，它允许你指定哪些动态资源允许跨域访问。Spring Boot通过提供@CrossOrigin注解和全局CORS配置两种方式来实现跨域请求的支持。</p><ol><li><p>使用@CrossOrigin注解<br>@CrossOrigin注解可以添加到控制器（Controller）类上或特定的方法上，以允许跨域请求。这个注解可以指定允许的源（origins）、HTTP方法、头部（headers）等。</p></li><li><p>全局CORS配置<br>如果应用中有多个控制器或方法需要跨域访问，那么使用全局CORS配置会更加方便。Spring Boot允许你通过添加一个配置类并实现WebMvcConfigurer接口来自定义CORS策略。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://example.com&quot;)</span> <span class="comment">// 只允许来自http://example.com的跨域请求  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;  </span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 允许所有路径  </span></span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://example.com&quot;</span>) <span class="comment">// 允许的源  </span></span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许的HTTP方法  </span></span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 允许的头信息  </span></span><br><span class="line">            .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否允许发送Cookie  </span></span><br><span class="line">            .maxAge(<span class="number">3600</span>); <span class="comment">// 缓存预检请求的结果的时间，单位为秒  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringClod"><a href="#SpringClod" class="headerlink" title="SpringClod"></a>SpringClod</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/posts/17769.html"/>
      <url>/posts/17769.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考 <a href="https://javaguide.cn/">JavaGuide</a></p></blockquote><h2 id="SQL-NoSQL基础"><a href="#SQL-NoSQL基础" class="headerlink" title="SQL&#x2F;NoSQL基础"></a>SQL&#x2F;NoSQL基础</h2><h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p><h3 id="DB-DBMS-DBS-DBA"><a href="#DB-DBMS-DBS-DBA" class="headerlink" title="DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul><li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li><li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li></ul><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul><li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li><li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li><li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li><li>行(<code>row</code>)：表中的一个记录。</li><li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li></ul><h3 id="元组-码-候选码-主码-外码-主属性-非主属性概念"><a href="#元组-码-候选码-主码-外码-主属性-非主属性概念" class="headerlink" title="元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul><li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li>码：码就是能唯一标识实体的属性，对应表中的列。</li><li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p><ul><li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li><li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li><li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p><ul><li>1NF(第一范式)：属性不可再分。<ul><li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li></ul></li><li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li><li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul><li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li></ul></li></ul><blockquote><ul><li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul><li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li></ul></li><li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul><li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li></ul></li><li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li><li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul><li>例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li></ul></li></ul></blockquote><h3 id="主键-外键区别"><a href="#主键-外键区别" class="headerlink" title="主键&#x2F;外键区别"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p><h3 id="为什么不推荐使用外键-级联"><a href="#为什么不推荐使用外键-级联" class="headerlink" title="为什么不推荐使用外键&amp;级联"></a>为什么不推荐使用外键&amp;级联</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p><ul><li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；</li><li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li><li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li></ul><p><strong>外键好处</strong></p><ul><li>保证了数据库数据的一致性和完整性；</li><li>级联操作方便，减轻了程序代码量；</li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p><p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><h3 id="DROP-TRUNCATE-DELETE区别"><a href="#DROP-TRUNCATE-DELETE区别" class="headerlink" title="DROP&#x2F;TRUNCATE&#x2F;DELETE区别"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol><li>用法不同</li></ol><ul><li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li></ul><p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p><ol start="2"><li>属于不同的数据库语言</li></ol><ul><li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li></ul><ol start="3"><li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li></ol><ul><li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li><li><code>DROP</code>命令会把表占用的空间全部释放掉。</li></ul><h3 id="数据库设计分为哪几个步"><a href="#数据库设计分为哪几个步" class="headerlink" title="数据库设计分为哪几个步"></a>数据库设计分为哪几个步</h3><ol><li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li><li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li>数据库实施：包括编程、测试和试运行</li><li>数据库的运行和维护：系统的运行与数据库的日常维护。</li></ol><h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p><blockquote><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p></blockquote><h3 id="SQL-NoSQL区别"><a href="#SQL-NoSQL区别" class="headerlink" title="SQL&#x2F;NoSQL区别"></a>SQL&#x2F;NoSQL区别</h3><table><thead><tr><th align="left"></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td align="left">数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td align="left">ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td align="left">性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td align="left">扩展</td><td>垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表</td><td>横向(增加服务器的方式横向扩展，通常是基于分片机制)</td></tr><tr><td align="left">用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td align="left">查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr><tr><td align="left">发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td align="left">例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr></tbody></table><h3 id="NoSQL优劣"><a href="#NoSQL优劣" class="headerlink" title="NoSQL优劣"></a>NoSQL优劣</h3><p><strong>优点</strong></p><ul><li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li><li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li><li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><p><strong>缺点</strong></p><ul><li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li><li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li></ul><h3 id="NoSQL分类"><a href="#NoSQL分类" class="headerlink" title="NoSQL分类"></a>NoSQL分类</h3><ul><li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p><ul><li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul><li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li></ul></li><li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul><li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li></ul></li><li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li><li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li></ul><h3 id="SQL三种注释方式"><a href="#SQL三种注释方式" class="headerlink" title="SQL三种注释方式"></a>SQL三种注释方式</h3><ul><li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li><li>多行注释：<code>/* 注释内容 */</code>。</li><li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li></ul><h3 id="DML语句✅"><a href="#DML语句✅" class="headerlink" title="DML语句✅"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p><h3 id="增删改查CRUD"><a href="#增删改查CRUD" class="headerlink" title="增删改查CRUD"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p><p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整的行</span></span><br><span class="line"><span class="comment">-- 插入一行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">12</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">18</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入行的一部分</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询出来的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> account; <span class="comment">-- 将account表中查询得到的name字段值插入到user表中的username字段</span></span><br></pre></td></tr></table></figure><p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>; <span class="comment">-- 更新user表中所有username为&#x27;root&#x27;的记录，将它们的username设置为&#x27;robot&#x27;，并将password也设置为&#x27;robot&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>删除数据</strong></p><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表中的指定数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空表中的数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>查询数据</strong></p><ul><li><code>SELECT</code> 语句用于从数据库中查询数据。</li><li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li><li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li><li><code>ASC</code>：升序(默认)</li><li><code>DESC</code>：降序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询单列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询多列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询不同的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">vend_id <span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制查询结果</span></span><br><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li><li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li><li><code>GROUP BY</code> 为每个组返回一个记录。</li><li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li><li><code>GROUP BY</code> 可以按一列或多列进行分组。</li><li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分组</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组后排序</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li><li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li><li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> NumberOfOrders</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="WHERE-HAVING对比"><a href="#WHERE-HAVING对比" class="headerlink" title="WHERE&#x2F;HAVING对比"></a>WHERE&#x2F;HAVING对比</h3><ul><li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li><li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>MySQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p><p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span>   table1 [, table2 ]</span><br><span class="line"><span class="keyword">WHERE</span>  column_name operator</span><br><span class="line">    (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">    <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">    [<span class="keyword">WHERE</span>])</span><br></pre></td></tr></table></figure></li><li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">WHERE</span>]) <span class="keyword">as</span> temp_table_name</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT语句中的WHERE</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- UPDATE语句中的WHERE</span></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Jack Jones&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DELETE语句中的WHERE</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>可以在 <code>WHERE</code> 子句中使用的操作符。<table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td></tr><tr><td><code>&lt;&gt;</code></td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>BETWEEN</code></td><td>在某个范围内</td></tr><tr><td><code>LIKE</code></td><td>搜索某种模式</td></tr><tr><td><code>IN</code></td><td>指定针对某个列的多个可能值</td></tr></tbody></table></li></ul><h3 id="IN-BETWEEN"><a href="#IN-BETWEEN" class="headerlink" title="IN&#x2F;BETWEEN"></a>IN&#x2F;BETWEEN</h3><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BETWEEN示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="AND-OR-NOT"><a href="#AND-OR-NOT" class="headerlink" title="AND&#x2F;OR&#x2F;NOT"></a>AND&#x2F;OR&#x2F;NOT</h3><ul><li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- AND示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li><li>只有字段是文本值时才使用 <code>LIKE</code>。</li><li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符出现任意次数。</li><li><code>_</code> 表示任何字符出现一次。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- _示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="连接JOIN"><a href="#连接JOIN" class="headerlink" title="连接JOIN"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1, table2.column2...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column1 <span class="operator">=</span> table2.common_column2; <span class="comment">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure><p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># JOIN....ON</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">ON</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="comment">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class="line"><span class="comment">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure><h3 id="内连接-外连接"><a href="#内连接-外连接" class="headerlink" title="内连接&#x2F;外连接"></a>内连接&#x2F;外连接</h3><ul><li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li><li><code>外连接</code>：<ul><li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li><li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li><li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">students表</span></span><br><span class="line"><span class="comment">student_idname</span></span><br><span class="line"><span class="comment">1        Alice</span></span><br><span class="line"><span class="comment">2        Bob</span></span><br><span class="line"><span class="comment">3        Carol</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">courses表</span></span><br><span class="line"><span class="comment">course_idstudent_idcourse_name</span></span><br><span class="line"><span class="comment">101        1        Math</span></span><br><span class="line"><span class="comment">102        2        Science</span></span><br><span class="line"><span class="comment">103        4        History</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">namecourse_name</span></span><br><span class="line"><span class="comment">AliceMath</span></span><br><span class="line"><span class="comment">BobScience</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">namecourse_name</span></span><br><span class="line"><span class="comment">AliceMath</span></span><br><span class="line"><span class="comment">BobScience</span></span><br><span class="line"><span class="comment">CarolNULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">namecourse_name</span></span><br><span class="line"><span class="comment">AliceMath</span></span><br><span class="line"><span class="comment">BobScience</span></span><br><span class="line"><span class="comment">NULLHistory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">namecourse_name</span></span><br><span class="line"><span class="comment">AliceMath</span></span><br><span class="line"><span class="comment">BobScience</span></span><br><span class="line"><span class="comment">CarolNULL</span></span><br><span class="line"><span class="comment">NULLHistory</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="ON-WHERE区别"><a href="#ON-WHERE区别" class="headerlink" title="ON&#x2F;WHERE区别"></a>ON&#x2F;WHERE区别</h3><ul><li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li><li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li></ul><h3 id="组合UNION"><a href="#组合UNION" class="headerlink" title="组合UNION"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li><li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><h3 id="WHERE-GROUP-BY-HAVING-ORDER-BY执行顺序"><a href="#WHERE-GROUP-BY-HAVING-ORDER-BY执行顺序" class="headerlink" title="WHERE,GROUP BY,HAVING,ORDER BY执行顺序"></a>WHERE,GROUP BY,HAVING,ORDER BY执行顺序</h3><ul><li>FROM：首先，指定从哪个表(或表的联接结果)中选择数据。</li><li>WHERE：接着，根据WHERE子句的条件过滤掉不满足条件的行。这一步是在选择列(SELECT)之前进行的，因为选择哪些行显然会影响最终的结果集。</li><li>GROUP BY：然后，如果查询中包含了GROUP BY子句，那么结果集会根据指定的列或列的组合进行分组。这一步是在选择列(SELECT)和可能的聚合函数(如SUM、AVG等)计算之后进行的，但在HAVING子句(如果有的话)之前。</li><li>HAVING(如果存在)：HAVING子句用于过滤分组后的结果集，其逻辑类似于WHERE子句，但它是应用于分组结果的。</li><li>SELECT：此时，根据SELECT子句指定的列或表达式，从前面步骤得到的结果集中选择数据。如果查询中包含了聚合函数，那么这些函数现在会被计算。</li><li>DISTINCT(如果存在)：如果查询中使用了DISTINCT关键字，那么结果集中的重复行将被移除。</li><li>ORDER BY：最后，根据ORDER BY子句指定的列或表达式对结果集进行排序。需要注意的是，ORDER BY是在所有其他处理(除了LIMIT和OFFSET)完成后才进行的，因为排序是基于完整的、已经过滤和分组(如果有的话)的结果集进行的。</li><li>LIMIT&#x2F;OFFSET(如果存在)：最后，根据LIMIT和OFFSET子句(如果有的话)限制结果集的大小或跳过结果集中的某些行。</li></ul><p>虽然这个顺序是从逻辑上理解的，但重要的是要记住，实际的执行计划可能会根据查询优化器的决策而有所不同。优化器会考虑多种因素，如索引的存在与否、数据的统计信息、表的大小和形状等，以选择最高效的执行路径。</p><h3 id="DDL语言✅"><a href="#DDL语言✅" class="headerlink" title="DDL语言✅"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p><h3 id="数据库DATABSE"><a href="#数据库DATABSE" class="headerlink" title="数据库DATABSE"></a>数据库DATABSE</h3><ul><li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li><li>删除数据库：<code>DROP DATABASE 数据库名;</code></li><li>选择数据库：<code>USE 数据库名;</code></li><li>查看数据库：<code>SHOW DATABASES;</code></li></ul><h3 id="数据表TABLE"><a href="#数据表TABLE" class="headerlink" title="数据表TABLE"></a>数据表TABLE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据已有表创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vip_user <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="comment">-- ALTER用于修改表</span></span><br><span class="line"><span class="keyword">ADD</span> age <span class="type">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> age tinyint;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h3 id="视图VIEW"><a href="#视图VIEW" class="headerlink" title="视图VIEW"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p><p>作用：</p><ul><li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li><li>提高数据安全性：用来限制用户访问敏感数据。</li><li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li><li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top_10_user_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure><h3 id="索引INDEX"><a href="#索引INDEX" class="headerlink" title="索引INDEX"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p><p><strong>优点</strong></p><ul><li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong></p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX user_index(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p><p><strong>约束类型</strong></p><ul><li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li><li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code>：保证列中的值符合指定的条件。</li><li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">  Id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增Id&#x27;</span>,</span><br><span class="line">  Username <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  Password <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  Email <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱地址&#x27;</span>,</span><br><span class="line">  Enabled TINYINT(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否有效&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (Id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="TCL语句✅"><a href="#TCL语句✅" class="headerlink" title="TCL语句✅"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p><h3 id="事务TRANSACTION"><a href="#事务TRANSACTION" class="headerlink" title="事务TRANSACTION"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p><p><strong>事务的四个特性(ACID)</strong></p><ul><li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li><li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li><li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li></ul><p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><blockquote><p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h3 id="DCL语句✅"><a href="#DCL语句✅" class="headerlink" title="DCL语句✅"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul><li>授予用户帐户权限，用<code>GRANT</code>命令。<ul><li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li><li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li><li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li><li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li><li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li></ul></li><li>撤销用户的权限，用<code>REVOKE</code>命令。<ul><li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li><li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li><li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li></ul></li></ul><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- GRANT用法</span></span><br><span class="line"><span class="keyword">GRANT</span> privilege,[privilege],.. <span class="keyword">ON</span> privilege_level</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> password]</span><br><span class="line">[REQUIRE tsl_option]</span><br><span class="line">[<span class="keyword">WITH</span> [GRANT_OPTION <span class="operator">|</span> resource_option]];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- REVOKE用法</span></span><br><span class="line"><span class="keyword">REVOKE</span> privilege_type [(column_list)]</span><br><span class="line">       [, priv_type [(column_list)]]...</span><br><span class="line"><span class="keyword">ON</span> [object_type] privilege_level</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>]...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改账户名</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="comment">-- 删除账户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br><span class="line"><span class="comment">-- 删除权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br><span class="line"><span class="comment">-- 更改密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser <span class="operator">=</span> <span class="string">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="游标CURSOR"><a href="#游标CURSOR" class="headerlink" title="游标CURSOR"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p><h3 id="触发器TRIGGER"><a href="#触发器TRIGGER" class="headerlink" title="触发器TRIGGER"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p><p><strong>优点</strong></p><ul><li>SQL 触发器提供了另一种检查数据完整性的方法。</li><li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li><li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li><li>SQL 触发器对于审计表中数据的更改非常有用。</li></ul><p><strong>缺点</strong></p><ul><li>SQL 触发器可能会增加数据库服务器的开销。</li><li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li></ul><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p><ul><li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li><li><code>AFTER INSERT</code>：将数据插入表格后激活。</li><li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li><li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li><li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li><li><code>AFTER DELETE</code>：从表中删除数据后激活。</li></ul><p><code>NEW</code> 和 <code>OLD</code>：</p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li><li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li></ul><h3 id="触发器语法"><a href="#触发器语法" class="headerlink" title="触发器语法"></a>触发器语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>trigger_name</code>：触发器名</li><li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li><li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li><li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li><li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL 注入(SQL Injection)是一种常见的网络安全漏洞，它通过在应用程序的输入字段中插入恶意的SQL代码，使得攻击者可以操纵数据库查询，获取、修改或删除数据库中的数据。</p><p>SQL 注入通常发生在应用程序未对用户输入进行充分的验证或转义的情况下。攻击者可以通过在输入字段中输入特定的SQL语句，来改变原本预期的SQL查询，从而达到攻击的目的。</p><p><strong>SQL 注入的类型</strong></p><ol><li>基于错误的SQL注入(Error-based SQL Injection)：利用数据库返回的错误信息来推断数据库的结构。</li><li>基于联合的SQL注入(Union-based SQL Injection)：使用 <code>UNION</code> 操作符将恶意查询与合法查询组合，以获取数据库中的更多数据。</li><li>基于布尔的盲注(Boolean-based Blind SQL Injection)：通过观察应用程序响应的变化来推断数据库中的信息。</li><li>基于时间的盲注(Time-based Blind SQL Injection)：通过在SQL语句中加入延迟操作，根据响应时间推断数据库中的信息。</li></ol><p><strong>SQL 注入的防护措施</strong></p><ol><li>参数化查询：使用参数化查询(Prepared Statements)，确保SQL语句与用户输入分离。</li><li>输入验证和转义：对用户输入进行严格的验证和转义，防止恶意代码注入。</li><li>最小权限原则：限制数据库用户的权限，确保即使发生注入攻击，攻击者也无法获得超出必要范围的权限。</li><li>使用ORM框架：使用对象关系映射(ORM)框架，减少直接编写SQL查询的机会。</li></ol><p><strong>示例</strong><br>以下是一个简单的SQL注入示例：<br>假设有一个登录页面，用户输入用户名和密码，然后系统会执行如下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;pass&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果用户输入 <code>user&#39; OR &#39;1&#39;=&#39;1</code> 作为用户名，输入 <code>pass</code> 作为密码，那么查询变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;pass&#x27;</span>;</span><br></pre></td></tr></table></figure><p>由于 <code>&#39;1&#39;=&#39;1&#39;</code> 永远为真，这条查询将返回所有用户的数据，从而绕过了认证。<br><strong>结论</strong><br>SQL 注入是一种非常危险的攻击手段，但通过采取适当的防护措施，如参数化查询和严格的输入验证，可以有效地防止这种攻击。</p><h3 id="SQL查询场景题"><a href="#SQL查询场景题" class="headerlink" title="SQL查询场景题"></a>SQL查询场景题</h3><h4 id="一张学生表和成绩表，关系是一对一，但是有的同学没有成绩，编写SQL查出没有成绩的同学。"><a href="#一张学生表和成绩表，关系是一对一，但是有的同学没有成绩，编写SQL查出没有成绩的同学。" class="headerlink" title="一张学生表和成绩表，关系是一对一，但是有的同学没有成绩，编写SQL查出没有成绩的同学。"></a>一张学生表和成绩表，关系是一对一，但是有的同学没有成绩，编写SQL查出没有成绩的同学。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span>  </span><br><span class="line"><span class="keyword">FROM</span> students s  </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grades g <span class="keyword">ON</span> s.student_id <span class="operator">=</span> g.student_id  <span class="comment">-- 返回左表中所有记录和右表中满足连接条件的记录</span></span><br><span class="line"><span class="keyword">WHERE</span> g.student_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>  </span><br><span class="line"><span class="keyword">FROM</span> students s  </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (  </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">FROM</span> grades g  </span><br><span class="line">    <span class="keyword">WHERE</span> g.student_id <span class="operator">=</span> s.student_id  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p><h3 id="MySQL基础✅"><a href="#MySQL基础✅" class="headerlink" title="MySQL基础✅"></a>MySQL基础✅</h3><h3 id="MySQL命名规范"><a href="#MySQL命名规范" class="headerlink" title="MySQL命名规范"></a>MySQL命名规范</h3><p>MySQL的命名规范对于数据库的设计、维护以及团队协作来说非常重要。一个清晰、一致的命名规范可以提高数据库的可读性、可维护性和可扩展性。</p><ol><li>数据库命名<ul><li>使用小写字母：虽然MySQL在Linux环境下对大小写不敏感，但在Windows环境下是敏感的。为了保持一致性，建议使用小写字母。</li><li>简短且描述性强：数据库名应该简短且能描述数据库的内容。</li><li>避免使用MySQL保留字：如user、select等。</li></ul></li><li>表命名<ul><li>使用复数形式：表名通常表示的是集合，因此使用复数形式更为直观。</li><li>小写字母加下划线：如users、order_details。</li><li>避免使用MySQL保留字。</li><li>表名前缀：对于大型项目，可以使用前缀来区分不同模块或功能的表，如sys_users、prd_products。</li></ul></li><li>字段命名<ul><li>小写字母加下划线：如user_id、first_name。</li><li>避免使用MySQL保留字。</li><li>使用有意义的名称：字段名应该能够清晰地描述字段的内容。</li><li>布尔类型字段：可以使用is_或has_作为前缀，如is_active、has_permission。</li></ul></li><li>索引命名<ul><li>主键索引：通常使用pk_作为前缀，后跟表名(或表名的缩写)和字段名，如pk_users_id。</li><li>唯一索引：使用uq_作为前缀，后跟表名和字段名，如uq_users_email。</li><li>普通索引：可以使用idx_作为前缀，后跟表名和字段名，如idx_products_category_id。</li><li>全文索引：使用ft_作为前缀，后跟表名和字段名，如ft_articles_content。</li></ul></li><li>视图、存储过程和函数命名<ul><li>视图：使用v_作为前缀，后跟视图名，如v_user_info。</li><li>存储过程：使用sp_作为前缀，后跟过程名，如sp_get_user_by_id。</li><li>函数：使用fn_作为前缀，后跟函数名，如fn_calculate_age。</li></ul></li><li>注意事项<ul><li>避免使用空格、特殊字符和MySQL保留字。</li><li>保持命名的一致性：在整个项目中，对于相同类型的对象(如表、字段、索引等)，应该使用相同的命名规则和风格。</li><li>考虑可读性：命名应该清晰、简洁，并尽可能描述对象的内容或用途。</li></ul></li></ol><h3 id="MySQL优点"><a href="#MySQL优点" class="headerlink" title="MySQL优点"></a>MySQL优点</h3><ul><li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li>开箱即用，操作简单，维护成本低。</li><li>兼容性好，支持常见的操作系统，支持多种开发语言。</li><li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li>支持分库分表、读写分离、高可用。</li></ul><h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p><h3 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p><ul><li>数值类型：<ul><li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li><li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li><li>定点数：<code>DECIMAL</code>。</li></ul></li><li>字符串类型：<ul><li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li><li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li></ul></li><li>日期和时间类型：<ul><li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li></ul></li></ul><h3 id="整数类型的UNSIGNED属性"><a href="#整数类型的UNSIGNED属性" class="headerlink" title="整数类型的UNSIGNED属性"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p><blockquote><p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p></blockquote><p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p><h3 id="CHAR-VARCHAR区别"><a href="#CHAR-VARCHAR区别" class="headerlink" title="CHAR&#x2F;VARCHAR区别"></a>CHAR&#x2F;VARCHAR区别</h3><ul><li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li><li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li><li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li><li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li></ul><h3 id="VARCHAR-100-VARCHAR-10-区别"><a href="#VARCHAR-100-VARCHAR-10-区别" class="headerlink" title="VARCHAR(100)&#x2F;VARCHAR(10)区别"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul><li>前者最大长度为 100，后者最大长度为 10。</li><li>二者存储相同的字符串所占用的存储空间是一样的。</li><li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li></ul><h3 id="DECIMAL和FLOAT-DOUBLE区别"><a href="#DECIMAL和FLOAT-DOUBLE区别" class="headerlink" title="DECIMAL和FLOAT&#x2F;DOUBLE区别"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p><h3 id="为什么不推荐使用TEXT-BLOB类型"><a href="#为什么不推荐使用TEXT-BLOB类型" class="headerlink" title="为什么不推荐使用TEXT&#x2F;BLOB类型"></a>为什么不推荐使用TEXT&#x2F;BLOB类型</h3><ul><li><code>TEXT</code>用于存储长文本数据，如博客数据。</li><li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li></ul><p>这两种类型有如下缺陷：</p><ul><li>不能有默认值。</li><li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。</li><li>检索效率较低。</li><li>不能直接创建索引，需要指定前缀长度。</li><li>可能会消耗大量的网络和 IO 带宽。</li><li>可能导致表上的 DML 操作变慢。</li></ul><h3 id="DATETIME-TIMESTAMP区别"><a href="#DATETIME-TIMESTAMP区别" class="headerlink" title="DATETIME&#x2F;TIMESTAMP区别"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul><li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li><li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul><li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li></ul></li><li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li></ul><h3 id="NULL和’’区别"><a href="#NULL和’’区别" class="headerlink" title="NULL和’’区别"></a>NULL和’’区别</h3><ul><li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul><li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li></ul></li><li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li><li><code>NULL</code> 会影响聚合函数的结果。<ul><li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li></ul></li></ul><p>不推荐使用<code>NULL</code>作为列默认值。</p><h3 id="Boolean类型如何在MySQL中存储"><a href="#Boolean类型如何在MySQL中存储" class="headerlink" title="Boolean类型如何在MySQL中存储"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p><h3 id="MySQL连接池✅"><a href="#MySQL连接池✅" class="headerlink" title="MySQL连接池✅"></a>MySQL连接池✅</h3><p>MySQL连接池(Connection Pool)是一种提高数据库访问效率和资源利用率的技术。它通过在应用程序和数据库之间维护一个预先建立的数据库连接集合，来减少创建和销毁连接的开销，同时限制并发连接数，从而优化数据库性能。有以下有点：</p><ul><li>减少连接开销：通过重用现有的连接，避免了每次请求时建立和销毁连接的开销。</li><li>提高响应速度：由于减少了连接的时间，因此可以更快地响应数据库请求。</li><li>资源控制：通过限制并发连接数，可以保护数据库服务器，防止因过多的连接请求而导致的资源耗尽。</li><li>提高数据库性能：通过优化连接管理，可以减轻数据库服务器的负载，从而提高整体性能。</li></ul><h3 id="MySQL基础架构✅"><a href="#MySQL基础架构✅" class="headerlink" title="MySQL基础架构✅"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p><ul><li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li><li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎，其中 <code>InnoDB</code> 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 <code>InnoDB</code>，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li></ul><p><img src="/../image/Database-Interview/13526879-3037b144ed09eb88.png" alt="MySQL基础架构图"></p><ul><li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li><li>查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。</li><li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li>优化器：按照 MySQL 认为最优的方案去执行。</li><li>执行器：执行语句，然后从存储引擎返回数据。</li><li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多种存储引擎。</li></ul><ol><li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p></li><li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p></li><li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p><ul><li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 <code>SELECT</code>，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li><li>第二步，语法分析，主要就是判断输入的 SQL 是否正确，是否符合 MySQL 的语法。</li></ul></li><li><p>优化器。<br>优化器以它认为的最优的执行方案去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等，经过了优化器之后语句具体该如何执行就已经定下来。</p></li><li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行。首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p></li></ol><h3 id="SQL语句在MySQL中的执行过程"><a href="#SQL语句在MySQL中的执行过程" class="headerlink" title="SQL语句在MySQL中的执行过程"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验—&gt;(如果命中缓存)查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student A <span class="keyword">WHERE</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">AND</span> A.name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接返回，如果没有，执行下一步。</li><li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询<code>SELECT</code>，提取需要查询的表名为 <code>tb_student</code>，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li><li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul><li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li><li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。</li></ul></li><li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li></ol><p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—<code>redo log</code>(<code>prepare</code> 状态)—&gt;<code>binlog</code>—&gt;<code>redo log</code>(<code>commit</code> 状态)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tb_student A <span class="keyword">SET</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">WHERE</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p><ol><li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li><li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li><li>更新完成。</li></ol><h3 id="MySQL存储引擎✅"><a href="#MySQL存储引擎✅" class="headerlink" title="MySQL存储引擎✅"></a>MySQL存储引擎✅</h3><h3 id="MySQL支持哪些存储引擎？"><a href="#MySQL支持哪些存储引擎？" class="headerlink" title="MySQL支持哪些存储引擎？"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p><p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p><h3 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义存储引擎。</p><h3 id="MyISAM-InnoDB存储引擎区别"><a href="#MyISAM-InnoDB存储引擎区别" class="headerlink" title="MyISAM&#x2F;InnoDB存储引擎区别"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul><li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li><li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>(可重读)隔离级别是可以解决幻读问题发生的(基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>)。</li><li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li><li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li><li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li><li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li><li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li><li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池(<code>Buffer Pool</code>)缓存数据页和索引页，<code>MyISAM</code> 使用键缓存(<code>Key Cache</code>)仅缓存索引页而不缓存数据页。</li></ul><h3 id="MySQL为什么减少IO次数可以加快查询"><a href="#MySQL为什么减少IO次数可以加快查询" class="headerlink" title="MySQL为什么减少IO次数可以加快查询"></a>MySQL为什么减少IO次数可以加快查询</h3><p>减少I&#x2F;O（输入&#x2F;输出）次数能加快MySQL查询的原因在于I&#x2F;O操作通常是数据库系统中最耗时的部分。具体原因如下：</p><ol><li>磁盘访问速度慢：尽管现代磁盘技术有所提升，但相比于CPU和内存的速度，磁盘的访问速度仍然非常慢。每次从磁盘读取数据都涉及到磁头寻道、旋转延迟等操作，这些物理操作的耗时远远大于从内存中读取数据的耗时。因此，减少磁盘I&#x2F;O次数可以显著提高查询速度。</li><li>缓存机制的利用：MySQL有多级缓存机制，如InnoDB的Buffer Pool，用来缓存常用的数据页。减少I&#x2F;O次数意味着更多的数据可以直接从缓存中读取，而不需要从磁盘加载，这样能极大提升查询性能。</li><li>减少上下文切换：每次进行I&#x2F;O操作，系统需要进行上下文切换，保存当前的状态，并等待I&#x2F;O操作完成后再恢复。减少I&#x2F;O次数能够减少这种上下文切换，从而减少CPU开销，提升查询效率。</li><li>批量处理：MySQL通过减少I&#x2F;O次数，可以更好地利用批量处理和预读技术，将多个查询操作合并到一次I&#x2F;O操作中完成，这样可以大大减少总的I&#x2F;O开销，提高性能。</li></ol><p>优化I&#x2F;O是数据库优化的一个关键部分，通过合理设计索引、使用合适的存储引擎、优化查询语句等方式，可以有效地减少I&#x2F;O次数，提升MySQL的查询性能。</p><h3 id="MySQL索引✅"><a href="#MySQL索引✅" class="headerlink" title="MySQL索引✅"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyISAM</code>，都使用了 <strong>B+树</strong> 作为索引结构。</p><p><strong>优点</strong></p><ul><li>大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong></p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h4 id="MySQL用B-树的特点"><a href="#MySQL用B-树的特点" class="headerlink" title="MySQL用B+树的特点"></a>MySQL用B+树的特点</h4><ul><li>B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li><li>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B+树的检索效率很稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>B+树的范围查询，只需要对链表进行遍历即可。</li></ul><h4 id="MySQL用B-树有什么优点"><a href="#MySQL用B-树有什么优点" class="headerlink" title="MySQL用B+树有什么优点"></a>MySQL用B+树有什么优点</h4><ul><li>B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。所有查询都会落到叶子节点，保证查询长度一致。</li><li>B+树是自平衡树，确保树的高度相对较低，使得从根节点到叶子节点的查找路径相对较短且长度一致，保证查询效率的稳定。</li><li>B+树的叶子节点之间通过指针相互连接，形成了一个有序链表。这使得在执行范围查询和顺序访问(全表扫描)的时候直接在叶子节点链表上进行，而无需回溯到内部节点，提高了范围查询和顺序访问的效率。</li><li>局部性原理：由于B+树的叶子节点通常存储在磁盘上，而磁盘访问时间远大于内存访问时间，因此磁盘I&#x2F;O是数据库操作的主要瓶颈。B+树通过将相关记录聚集在相邻的叶子节点中，并利用了磁盘的局部性原理(即当访问某个数据项时，其附近的数据项也很有可能被访问)，减少了磁盘I&#x2F;O的次数，提高了查询效率。</li></ul><h4 id="索引底层数据类型选型"><a href="#索引底层数据类型选型" class="headerlink" title="索引底层数据类型选型"></a>索引底层数据类型选型</h4><ol><li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(<code>Adaptive Hash Index</code>)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p></li><li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p></li><li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p></li><li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p></li><li><p>B树&amp;B+树<br>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced(平衡)的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br><strong>B树&amp;B+树区别</strong></p></li></ol><ul><li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li><li>B 树的叶子节点都是独立的; B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h4 id="在什么时候需要创建索引"><a href="#在什么时候需要创建索引" class="headerlink" title="在什么时候需要创建索引"></a>在什么时候需要创建索引</h4><p>在MySQL中，创建索引是为了提高查询效率，但并不是所有的列都需要创建索引。以下是一些需要考虑创建索引的场景：</p><ol><li>主键：主键默认会创建索引，确保数据的唯一性，并加快查询速度。</li><li>频繁作为查询条件的列：<ul><li>对于经常在<code>WHERE</code>子句中使用的列(特别是大数据量的表)，创建索引可以显著提高查询速度。</li><li>在连接操作中的<code>JOIN</code>条件列上创建索引，可以加快连接的速度。</li></ul></li><li>排序和分组列：如果查询语句中使用了<code>ORDER BY</code>或<code>GROUP BY</code>，在这些列上创建索引有助于加快排序和分组操作。</li><li>多表查询的关联列：在进行多表连接查询时，应该在连接条件涉及的列上创建索引，以提高连接效率。</li><li>覆盖索引：如果一个查询只需要访问索引中的列数据而不需要访问表中的其他列，可以考虑创建覆盖索引(包括所有查询需要的列)。这可以减少磁盘I&#x2F;O，提高查询速度。</li><li>频繁更新且查询速度要求较高的列：对于经常更新并且在查询中常用的列，可以权衡创建索引。如果更新频率高且查询优化效果明显，创建索引可能是有益的。</li></ol><blockquote><p>注意：并非所有情况都需要创建索引。过多的索引会导致写操作(如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>)的性能下降，因为每次写操作都需要更新相关的索引。因此，创建索引时应考虑查询频率与写操作性能的平衡。</p></blockquote><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>按照数据结构维度划分：</p><ul><li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li></ul><p>按照底层存储方式角度划分：</p><ul><li>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。<code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p>按照应用维度划分：</p><ul><li>主键索引：加速查询 + 列值唯一(不可以有 <code>NULL</code>)+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一(可以有 <code>NULL</code>)。</li><li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。</li><li>降序索引：之前的版本就支持通过 <code>DESC</code> 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 <code>GROUP BY</code> 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h4 id="MyISAM-InnoDB索引区别"><a href="#MyISAM-InnoDB索引区别" class="headerlink" title="MyISAM&#x2F;InnoDB索引区别"></a>MyISAM&#x2F;InnoDB索引区别</h4><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p><ul><li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。</li><li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。</li></ul><h4 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引&#x2F;非聚簇索引"></a>聚簇索引&#x2F;非聚簇索引</h4><p>✨聚簇索引(聚集索引)：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p><p><strong>优点</strong>：</p><ul><li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li><li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong>：</p><ul><li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li><li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><p>✨非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p><p><strong>缺点</strong>：</p><ul><li>依赖于有序的数据</li><li>可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p><p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p><p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p><ul><li>唯一索引(<code>Unique Key</code>)：唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li>普通索引(<code>Index</code>)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li><li>前缀索引(<code>Prefix</code>)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li><li>全文索引(<code>Full Text</code>)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li></ul><h4 id="覆盖索引-联合索引"><a href="#覆盖索引-联合索引" class="headerlink" title="覆盖索引&#x2F;联合索引"></a>覆盖索引&#x2F;联合索引</h4><ul><li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li></ul><h4 id="联合索引最左前缀匹配原则"><a href="#联合索引最左前缀匹配原则" class="headerlink" title="联合索引最左前缀匹配原则"></a>联合索引最左前缀匹配原则</h4><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h4 id="索引下推ICP"><a href="#索引下推ICP" class="headerlink" title="索引下推ICP"></a>索引下推ICP</h4><p>索引下推(<code>Index Condition Pushdown,ICP</code>) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p><p><strong>原理</strong><br><img src="/../image/Database-Interview/13526879-3037b144ed09eb88.png" alt="MySQL基础架构图"></p><p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p><p>索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;431200&#x27;</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(birthdate) <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li><li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li></ul><p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p><h3 id="MySQL查询缓存✅"><a href="#MySQL查询缓存✅" class="headerlink" title="MySQL查询缓存✅"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p><p>查询缓存不命中的情况：</p><ul><li>两个查询在任何字符上的不同都会导致缓存不命中。</li><li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li><li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。</li></ul><p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p><h3 id="MySQL三大日志✅"><a href="#MySQL三大日志✅" class="headerlink" title="MySQL三大日志✅"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>(归档日志)和事务日志 <code>redo log</code>(重做日志)和 <code>undo log</code>(回滚日志)。</p><p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>(重做日志)是 <code>InnoDB</code> 存储引擎独有的物理日志，用于实现数据的持久性和崩溃恢复。记录内容是数据页的物理修改操作，比如某个数据页的某个偏移量被改为了什么值。它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p><p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(<code>redo log buffer</code>)里，接着刷盘到 <code>redo log</code> 文件里。</p><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p><ul><li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li><li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li><li><code>Checkpoint</code>(检查点)：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li><li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li><li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</li></ul><h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p><ul><li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li><li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li><li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>(文件系统缓存)。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li></ul><p>默认策略为第二种。</p><h4 id="redo-log两阶段提交"><a href="#redo-log两阶段提交" class="headerlink" title="redo log两阶段提交"></a>redo log两阶段提交</h4><p><code>redo log</code>(重做日志)让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>(归档日志)保证了 MySQL 集群架构的数据一致性。</p><p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p><p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p><p>为了解决数据不一致问题，<code>InnoDB</code> 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p><ul><li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li><li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li></ul><p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p><p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p><p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><p><code>binlog</code> 有三种记录格式：</p><ul><li><code>Statement</code>：记录的是 SQL 语句，如 <code>UPDATE t SET c=c+1 WHERE id=2</code>。<ul><li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li></ul></li><li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul><li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li></ul></li><li><code>Mixed</code>：记录的是上面两种的混合模式。<ul><li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li></ul></li></ul><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</p><p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p><ul><li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul><li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li></ul></li><li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li><li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul><li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li></ul></li></ul><blockquote><p><code>write</code> 指把日志写入到文件系统的 <code>page cache</code>，并没有把数据持久化到磁盘，所以速度比较快。<br><code>fsync</code> 是指将数据持久化到磁盘的操作</p></blockquote><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code>用于实现事务回滚(Rollback)和多版本并发控制(MVCC)。当一个事务失败或被显式回滚时，可以通过 <code>undo log</code> 将数据恢复到事务开始前的状态。其属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p><p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p><p><code>undo log</code> 采用 <code>segment</code>(段)进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理(<code>purge</code>)的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p><h3 id="MySQL事务✅"><a href="#MySQL事务✅" class="headerlink" title="MySQL事务✅"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>MySQL的事务是通过<code>InnoDB</code>存储引擎实现的，因为<code>MyISAM</code>等引擎不支持事务。</p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul><li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li><li>一致性(Consistency)：执行事务前后，数据保持一致。</li><li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li></ul><blockquote><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p></blockquote><h3 id="并发事务存在的问题"><a href="#并发事务存在的问题" class="headerlink" title="并发事务存在的问题"></a>并发事务存在的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>解决：</p><ul><li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li></ul><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>解决：</p><ul><li>乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li><li>悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li></ul><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p><p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p><p>解决：</p><ul><li>执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li><li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li></ul><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p><p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>解决：</p><ul><li>执行 <code>INSERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li><li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li></ul><h3 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h3><ul><li>不可重复读：多次读取同一数据，发现数据不一致。</li><li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p><ul><li>解决不可重复读：执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li><li>解决幻读：执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li></ul><h3 id="并发事务的控制方式有哪些"><a href="#并发事务的控制方式有哪些" class="headerlink" title="并发事务的控制方式有哪些"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制(<code>MVCC，Multiversion concurrency control</code>)可以看作是乐观控制的模式。</p><ul><li>锁：<ul><li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li><li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li></ul></li><li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p><blockquote><p>注意：不论是表级锁还是行级锁，都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)这两类。</p></blockquote><p>MVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、<code>read view</code>、<code>undo log</code>。</p><ul><li><code>undo log</code>：<code>undo log</code> 用于记录某行数据的多个版本的数据。</li><li><code>read view</code> 和 隐藏字段： 用来判断当前版本数据的可见性。</li></ul><h3 id="事务隔离级别✅"><a href="#事务隔离级别✅" class="headerlink" title="事务隔离级别✅"></a>事务隔离级别✅</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">&#x2F;</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">基于 MVCC&#x2F;锁</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">基于 锁</td></tr></tbody></table><p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p><p><code>InnoDB</code> 实现的 <code>REPEATABLE-READ</code> 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li>快照读：由 <code>MVCC</code> 机制来保证不出现幻读。</li><li>当前读：使用 <code>Next-Key Lock</code> 进行加锁来保证不出现幻读，<code>Next-Key Lock</code> 是行锁(<code>Record Lock</code>)和间隙锁(<code>Gap Lock</code>)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code> ，不过 <code>InnoDB</code> 存储引擎默认使用 <code>REPEATABLE-READ</code>，这并不会有任何性能损失。<code>InnoDB</code> 存储引擎在分布式事务的情况下一般会用到 <code>SERIALIZABLE</code> 隔离级别。</p><h3 id="MVCC✅"><a href="#MVCC✅" class="headerlink" title="MVCC✅"></a>MVCC✅</h3><p>多版本并发控制(<code>Multi-Version Concurrency Control, MVCC</code>) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，<code>MVCC</code> 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p><ol><li><p>读操作(<code>SELECT</code>)<br>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：</p><ul><li>对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li><li>如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li><li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li></ul></li><li><p>写操作(<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>)<br>当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：</p><ul><li>对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li><li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li><li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li></ul></li><li><p>事务提交和回滚</p><ul><li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li><li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li></ul></li><li><p>版本回收<br>为了防止数据库中的版本无限增长，<code>MVCC</code> 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p></li></ol><p><code>MVCC</code> 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p><h3 id="一致性非锁定读-快照读"><a href="#一致性非锁定读-快照读" class="headerlink" title="一致性非锁定读&#x2F;快照读"></a>一致性非锁定读&#x2F;快照读</h3><p>一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。</p><p><code>InnoDB</code>中，<code>MVCC</code>就是对一致性非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(<code>snapshot read</code>)。</p><p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>SELECT</code> 语句(不包括 <code>SELECT ... lock in share mode</code> ，<code>SELECT ... FOR UPDATE</code>)则会使用一致性非锁定读(<code>MVCC</code>)。<code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p><h3 id="锁定读-当前读"><a href="#锁定读-当前读" class="headerlink" title="锁定读&#x2F;当前读"></a>锁定读&#x2F;当前读</h3><p>在锁定读下，读取的是数据的最新版本。下面语句都是锁定读&#x2F;当前读，会对读取到的记录加锁。</p><ul><li><code>SELECT ... lock in share mode</code>： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。</li><li><code>SELECT ... FOR UPDATE</code>： 对读取到记录加排他锁，其他事务不能加任何锁。</li><li><code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作：对读取到记录加排他锁，其他事务不能加任何锁。</li></ul><p>当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以 <code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据。</p><h3 id="InnoDB的MVCC实现"><a href="#InnoDB的MVCC实现" class="headerlink" title="InnoDB的MVCC实现"></a>InnoDB的MVCC实现</h3><p><code>MVCC</code> 的实现依赖于：隐藏字段、<code>Read View</code>、<code>undo log</code>。在内部实现中，<code>InnoDB</code> 通过数据行隐藏字段的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p><p><strong>隐藏字段</strong><br><code>InnoDB</code> 为每行数据添加了三个隐藏字段：</p><ul><li><code>DB_TRX_ID</code>：表示最后一次更新或插入操作的事务ID。<code>DELETE</code>操作也被视为更新。</li><li><code>DB_ROLL_PTR</code>：指向该行<code>undo log</code> 日志的指针。</li><li><code>DB_ROW_ID</code>：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 <code>DB_ROW_ID</code> 作为聚簇索引。</li></ul><p><strong>Read View</strong><br><code>Read View</code> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。</p><ul><li><code>m_low_limit_id</code>(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>(上限事务ID)：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>(活跃事务列表)：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务(正在内存中)</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><strong>undo log</strong><br>其有两个作用：</p><ul><li>事务回滚时用于将数据恢复到修改前的样子</li><li><code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前版本的快照数据，以此实现非锁定读</li></ul><h3 id="RC和RR隔离级别下MVCC的差异"><a href="#RC和RR隔离级别下MVCC的差异" class="headerlink" title="RC和RR隔离级别下MVCC的差异"></a>RC和RR隔离级别下MVCC的差异</h3><ul><li><code>Read Committed</code>：<code>MVCC</code> 会在每次<code>SELECT</code>读取数据时创建一个新的 <code>Read View</code>(<code>m_ids</code>列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 <code>Read View</code>，因此会导致一些不可重复读问题。</li><li><code>Repeatable Read</code>：<code>MVCC</code> 会在事务开始后第一次 <code>SELECT</code>创建一个 <code>Read View</code>，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。</li></ul><h3 id="RR隔离级别下的MVCC如何解决幻读"><a href="#RR隔离级别下的MVCC如何解决幻读" class="headerlink" title="RR隔离级别下的MVCC如何解决幻读"></a>RR隔离级别下的MVCC如何解决幻读</h3><p><code>MVCC</code>+<code>Next-key-Lock</code> 防止幻读</p><ul><li>执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul><li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li></ul></li><li>执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等当前读<ul><li>当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li></ul></li></ul><h3 id="MySQL锁✅"><a href="#MySQL锁✅" class="headerlink" title="MySQL锁✅"></a>MySQL锁✅</h3><h3 id="表级锁-行级锁区别"><a href="#表级锁-行级锁区别" class="headerlink" title="表级锁&#x2F;行级锁区别"></a>表级锁&#x2F;行级锁区别</h3><ul><li><p>表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，<code>MyISAM</code> 和 <code>InnoDB</code> 引擎都支持表级锁。</p></li><li><p>行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p></li><li><p><code>MyISAM</code> 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p></li><li><p><code>InnoDB</code> 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 <code>InnoDB</code>的并发性能更高</p></li></ul><h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><ul><li>记录锁(<code>Record Lock</code>)：也被称为记录锁，属于单个行记录上的锁。</li><li>间隙锁(<code>Gap Lock</code>)：锁定一个范围，不包括记录本身。</li><li>临键锁(<code>Next-Key Lock</code>)：<code>Record Lock</code>+<code>Gap Lock</code>，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><h3 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁&#x2F;排他锁"></a>共享锁&#x2F;排他锁</h3><p>表级锁和行级锁都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)两类。</p><ul><li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li><li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 </p><p>由于有<code>MVCC</code>机制，对于一般的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加任何锁。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。</p><p>意向锁是表级锁，有两种：</p><ul><li>意向共享锁(<code>Intention Shared Lock</code>，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁(<code>Intention Exclusive Lock</code>，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，<code>InnoDB</code> 会先获取该数据行所在在数据表的对应意向锁。</p><p>意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。</p><h3 id="当前读-快照读区别"><a href="#当前读-快照读区别" class="headerlink" title="当前读&#x2F;快照读区别"></a>当前读&#x2F;快照读区别</h3><ul><li>当前读(一致性锁定读)：执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code><ul><li>当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li></ul></li><li>快照读(一致性非锁定读)：执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul><li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li></ul></li></ul><h3 id="MySQL性能优化✅"><a href="#MySQL性能优化✅" class="headerlink" title="MySQL性能优化✅"></a>MySQL性能优化✅</h3><h3 id="慢查询原因及解决"><a href="#慢查询原因及解决" class="headerlink" title="慢查询原因及解决"></a>慢查询原因及解决</h3><p>MySQL 慢查询(slow query)是指执行时间超过预设阈值的查询。这种查询会导致数据库性能下降，影响应用程序的响应速度。慢查询的原因可以有很多，常见的包括：</p><ol><li>缺乏索引：没有为查询涉及的字段创建合适的索引，导致全表扫描。</li><li>索引使用不当：索引没有被正确使用，例如查询条件中使用了函数或类型转换，导致索引失效。</li><li>数据量大：表的数据量过大，查询需要扫描大量的数据。</li><li>复杂的查询：查询语句过于复杂，包含多个表的连接(JOIN)、子查询等，导致执行时间长。</li><li>硬件资源不足：服务器的CPU、内存或磁盘IO性能不足，无法快速处理查询。</li><li>数据库配置不当：MySQL的配置参数没有优化，例如<code>innodb_buffer_pool_size</code>、<code>query_cache_size</code>等。</li><li>锁争用：高并发环境下，表或行被频繁锁定，导致查询等待时间增加。</li><li>网络延迟：网络延迟也会影响查询的响应时间，尤其是在分布式数据库系统中。</li><li>不合理的查询设计：如没有合理的分页查询、重复查询等。</li></ol><p>解决慢查询问题的思路可以包括：</p><ol><li>分析查询日志：使用MySQL的慢查询日志(<code>slow query log</code>)找出执行时间长的查询。</li><li>使用<code>EXPLAIN</code>命令：分析查询的执行计划，找到可能的问题。</li><li>优化索引：根据查询条件创建合适的索引，避免全表扫描。</li><li>调整查询语句：简化查询语句，避免不必要的复杂操作。</li><li>优化数据库配置：调整MySQL的配置参数，提升性能。</li><li>分区和分表：对于大表，可以考虑分区或分表，减少单次查询的数据量。</li><li>提升硬件性能：增加服务器的硬件资源，如CPU、内存、磁盘等。</li></ol><p>通过这些方法，可以有效地减少MySQL慢查询，提升数据库的整体性能。</p><h3 id="十亿条评论如何找出top10的词"><a href="#十亿条评论如何找出top10的词" class="headerlink" title="十亿条评论如何找出top10的词"></a>十亿条评论如何找出top10的词</h3><ul><li>首先十亿条评论数据量巨大，直接在MySQL中进行复杂的文本处理和分词可能会非常慢并且效率低下。</li><li>由于MySQL不擅长直接进行分词和复杂的字符串处理，可以将评论数据导出到外部脚本进行处理。可以使用Python或其他编程语言来实现分词和词频统计。<ul><li>将所有评论数据采用批量处理的方式导出到一个外部文件或者直接传给处理脚本，这样可以减少数据库负载。</li></ul></li><li>在脚本中，对评论数据进行清洗，去除无意义的字符，如标点符号、空格等。</li><li>对清洗后的文本进行分词，统计词频。</li><li>将词和词频存储到一个新表，将处理结果导入到Mysql 中，采用批量插入的方法来提高效率。</li><li>在MySQL中使用一个简单的查询来获取词频最高的前十个词。例如，使用ORDER BY count DESC LIMIT 10来排序并限制结果数量。</li></ul><p>如此大量的数据，也可以使用分布式数据库如Apache Hadoop或Apache Spark来处理。</p><h3 id="1TB的文件如何快速从中找到想要的数据"><a href="#1TB的文件如何快速从中找到想要的数据" class="headerlink" title="1TB的文件如何快速从中找到想要的数据"></a>1TB的文件如何快速从中找到想要的数据</h3><ol><li>可以将文件分块，多线程处理。如要查找的数据是1MB，则可以每块都检查前后1MB范围内的数据，确保数据不会被分割。</li><li>分布式计算。可以借助于 Hadoop 或 Spark 来进行并行化处理。这些框架能够将数据分片分发到多个节点上进行并行处理，大幅度提高数据处理速度。</li><li>流式处理。不需要把完整的内容加载到内存，只需要按需处理。可以每次从硬盘中读取一部分，然后检索。这样可以避免内存溢出、以及可以使用多线程加快处理速度。</li><li>如果要查找的内容是字符串，还可以考虑使用 KMP 等高效的字符串匹配算法。</li><li>如果文件数据是按照某种顺序如ID、时间戳排列，考虑使用二分查找加速定位数据。</li><li>另外可以借助一些数据结构如HashMap，前提是可以建立HashMap，这样可以将查询复杂度降低到O(1)。</li><li>处理中，磁盘 I&#x2F;O 可能成为瓶颈，可以考虑将数据放入固态硬盘，加快读取速度。</li></ol><h3 id="可以用MySQL存储文件吗？"><a href="#可以用MySQL存储文件吗？" class="headerlink" title="可以用MySQL存储文件吗？"></a>可以用MySQL存储文件吗？</h3><p>可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。</p><h3 id="MySQL如何存储IP地址"><a href="#MySQL如何存储IP地址" class="headerlink" title="MySQL如何存储IP地址"></a>MySQL如何存储IP地址</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：</p><ul><li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li><li><code>INET_NTOA()</code>：把整型的 ip 转为地址</li></ul><p>存储数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，取出数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="如何分析SQL性能"><a href="#如何分析SQL性能" class="headerlink" title="如何分析SQL性能"></a>如何分析SQL性能</h3><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><h3 id="MySQL执行计划✅"><a href="#MySQL执行计划✅" class="headerlink" title="MySQL执行计划✅"></a>MySQL执行计划✅</h3><p>执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept_emp <span class="keyword">WHERE</span> emp_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no)<span class="operator">&gt;</span><span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys   <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">PRIMARY</span>,dept_no <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">16</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>各列含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><p><strong>type(重要)</strong><br>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code><br>常见的几种类型具体含义如下：</p><ul><li><code>system</code>：如果表使用的引擎对于表行数统计是精确的(如：<code>MyISAM</code>)，且表中只有一行记录的情况下，访问方法是 <code>system</code>，是 <code>const</code> 的一种特例。</li><li><code>const</code>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><code>eq_ref</code>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 <code>system</code> 与 <code>const</code> 之外最好的 <code>JOIN</code> 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><code>ref</code>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><code>index_merge</code>：当查询条件使用了多个索引时，表示开启了 <code>Index Merge</code> 优化，此时执行计划中的 <code>key</code> 列列出了使用到的索引。</li><li><code>range</code>：对索引列进行范围查询，执行计划中的 <code>key</code> 列表示哪个索引被使用了。</li><li><code>index</code>：查询遍历了整棵索引树，与 <code>ALL</code> 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><code>ALL</code>：全表扫描。</li></ul><p><strong>key(重要)</strong><br><code>key</code> 列表示 MySQL 实际使用到的索引。如果为 <code>NULL</code>，则表示未用到索引。</p><p><strong>Extra(重要)</strong></p><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><code>Using filesort</code>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><code>Using temporary</code>：MySQL 需要创建临时表来存储查询的结果，常见于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</li><li><code>Using index</code>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li><li><code>Using index condition</code>：表示查询优化器选择使用了索引条件下推这个特性。</li><li><code>Using where</code>：表明查询使用了 <code>WHERE</code> 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li><code>Using join buffer (Block Nested Loop)</code>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 <code>join buffer</code> 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>当 <code>Extra</code> 列包含 <code>Using filesort</code> 或 <code>Using temporary</code> 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p><h3 id="MySQL读写分离✅"><a href="#MySQL读写分离✅" class="headerlink" title="MySQL读写分离✅"></a>MySQL读写分离✅</h3><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。</p><p>一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p><h3 id="如何实现读写分离"><a href="#如何实现读写分离" class="headerlink" title="如何实现读写分离"></a>如何实现读写分离</h3><ol><li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主数据库和从数据库之间的数据是实时同步的，即主从复制。</li><li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><p>基于项目层面有两种方案：</p><ol><li>代理方式<br>可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。</li><li>组件方式<br>可以通过引入第三方组件来实现读写分离，例如使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</li></ol><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>MySQL 主从复制是依赖于 <code>binlog</code> 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 <code>canal</code>)的底层一般也是依赖 <code>binlog</code>。具体如下：</p><ol><li>主库将数据库中数据的变化写入到 <code>binlog</code></li><li>从库连接主库</li><li>从库创建一个 I&#x2F;O 线程向主库请求更新的 <code>binlog</code></li><li>主库创建一个 <code>binlog dump</code> 线程来发送 <code>binlog</code>，从库中的 I&#x2F;O 线程负责接收</li><li>从库的 I&#x2F;O 线程将接收的 <code>binlog</code> 写入到中继日志<code>relay log</code> 中。</li><li>从库的 SQL 线程读取中继日志<code>relay log</code> 同步数据到本地(也就是再执行一遍 SQL )。</li></ol><blockquote><p><code>binlog</code>主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)<br><code>relay log</code> 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。</p></blockquote><h3 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h3><p>主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。</p><ul><li>强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。</li><li>延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。</li></ul><h3 id="什么情况下会出现主从延迟"><a href="#什么情况下会出现主从延迟" class="headerlink" title="什么情况下会出现主从延迟"></a>什么情况下会出现主从延迟</h3><p>主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：</p><ul><li>从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度跟不上主库写入 <code>binlog</code> 的速度，导致从库 <code>relay log</code> 的数据滞后于主库 <code>binlog</code> 的数据；</li><li>从库 SQL 线程执行 <code>relay log</code> 的速度跟不上从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度，导致从库的数据滞后于从库 <code>relay log</code> 的数据。</li></ul><p>下面是一些可能导致主从延迟的原因及解决方案：</p><ol><li>从库机器性能比主库差：从库接收 <code>binlog</code> 写入 <code>relay log</code> 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 </li><li>从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 <code>binlog</code> 接入到 <code>Hadoop</code>、<code>Elasticsearch</code> 等系统中。</li><li>大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。</li><li>从库太多：主库需要将 <code>binlog</code> 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。</li><li>网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 <code>binlog</code> 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。</li><li>单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。</li><li>复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 <code>semi-sync</code> 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。</li></ol><h3 id="MySQL分库分表✅"><a href="#MySQL分库分表✅" class="headerlink" title="MySQL分库分表✅"></a>MySQL分库分表✅</h3><p>分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。<br><strong>分库</strong><br>分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p><ul><li>垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。<ul><li>如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</li></ul></li><li>水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。<ul><li>订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。</li></ul></li></ul><p><strong>分表</strong><br>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><ul><li>垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。</li><li>水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</li></ul><h3 id="什么情况下需要分库分表"><a href="#什么情况下需要分库分表" class="headerlink" title="什么情况下需要分库分表"></a>什么情况下需要分库分表</h3><ul><li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li><li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li><li>应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。</li></ul><h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p><p>常见的分片算法有：</p><ul><li>范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1<del>299999 的记录分到第一个表， 300000</del>599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。</li><li>哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。</li><li>地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。</li><li>一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</li></ul><h3 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h3><p>分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。</p><h3 id="分库分表会带来什么问题"><a href="#分库分表会带来什么问题" class="headerlink" title="分库分表会带来什么问题"></a>分库分表会带来什么问题</h3><ul><li>事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。</li><li>跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 <code>GROUP BY</code>，<code>ORDER BY</code> 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。</li><li>数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。</li><li>。。。</li></ul><h3 id="分库分表中数据如何迁移"><a href="#分库分表中数据如何迁移" class="headerlink" title="分库分表中数据如何迁移"></a>分库分表中数据如何迁移</h3><ul><li>停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。</li><li>双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。</li></ul><h3 id="MySQL数据冷热分离✅"><a href="#MySQL数据冷热分离✅" class="headerlink" title="MySQL数据冷热分离✅"></a>MySQL数据冷热分离✅</h3><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据存储在高性能存储介质中。</p><p><strong>优缺点</strong></p><ul><li>优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)</li><li>缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。</li></ul><h3 id="冷数据和热数据"><a href="#冷数据和热数据" class="headerlink" title="冷数据和热数据"></a>冷数据和热数据</h3><ul><li>热数据是指经常被访问和修改且需要快速访问的数据。</li><li>冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</li></ul><p><strong>冷热数据如何区分</strong></p><ol><li>时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。<ul><li>例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li></ul></li><li>访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。<ul><li>例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li></ul></li></ol><h3 id="冷数据如何迁移"><a href="#冷数据如何迁移" class="headerlink" title="冷数据如何迁移"></a>冷数据如何迁移</h3><ul><li>任务调度：可以利用 <code>xxl-job</code> 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li><li>监听数据库的变更日志 <code>binlog</code> ：将满足冷数据条件的数据从 <code>binlog</code> 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li></ul><h3 id="冷数据如何存储"><a href="#冷数据如何存储" class="headerlink" title="冷数据如何存储"></a>冷数据如何存储</h3><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：</p><ul><li>中小厂：直接使用 MySQL&#x2F;PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)</li><li>大厂：Hbase(常用)、RocksDB、Doris、Cassandra</li></ul><h3 id="MySQL字符集"><a href="#MySQL字符集" class="headerlink" title="MySQL字符集"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p><h3 id="MySQL字符集层次级别"><a href="#MySQL字符集层次级别" class="headerlink" title="MySQL字符集层次级别"></a>MySQL字符集层次级别</h3><ul><li>MySQL 中的字符集分为四个层次：<ul><li>server(MySQL 实例级别)</li><li>database(库级别)</li><li>table(表级别)</li><li>column(字段级别)</li></ul></li></ul><p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p><ul><li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li><li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server, REDIS)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul><li>Redis 基于内存，内存的访问速度比磁盘快很多；</li><li>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环</strong>和 <strong>IO 多路复用</strong></li><li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li><li>Redis 通信协议实现简单且解析高效。</li></ul><h3 id="Redis-Memcached"><a href="#Redis-Memcached" class="headerlink" title="Redis&#x2F;Memcached"></a>Redis&#x2F;Memcached</h3><p>共同点：</p><ul><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ul><p>区别：</p><ul><li>Redis 支持更丰富的数据结构，如 <code>string</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code> 等，而 Memcached 只支持 <code>key-value</code> 的数据结构。</li><li>Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。</li><li>Redis 支持集群模式，而 Memcached 不支持集群模式。</li><li>Redis 支持事务，而 Memcached 不支持事务。</li><li>Redis 支持发布订阅，而 Memcached 不支持发布订阅。</li><li>Redis 是单线程，而 Memcached 是多线程。</li></ul><h3 id="为什么用Redis"><a href="#为什么用Redis" class="headerlink" title="为什么用Redis"></a>为什么用Redis</h3><ol><li>高性能：Redis 是基于内存的，读写速度非常快。</li><li>高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。</li><li>功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</li></ol><h3 id="三种常用缓存读写策略"><a href="#三种常用缓存读写策略" class="headerlink" title="三种常用缓存读写策略"></a>三种常用缓存读写策略</h3><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。<br>读：</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回</li><li>把 db 中读取到的数据写入 cache 中。</li></ul><p>写：</p><ul><li>先更新 db</li><li>再删除 cache 中的数据</li></ul><p>先更新数据库后再删除缓存，可以确保在数据库更新成功的前提下，缓存中的旧数据才会被清除，避免出现旧数据重新进入缓存的情况。<br><strong>为什么不先删缓存再更新数据库呢？</strong><br>如果你先删除缓存，然后再更新数据库，可能在这两个操作之间出现一个短暂的时间窗口。如果在这个窗口中有其他请求进来，它们可能会读到旧的数据库数据，并将旧数据重新写入缓存，导致数据不一致。</p><p>这种策略有一些缺陷：</p><ul><li>首次请求数据一定不在 <code>cache</code> 的问题<ul><li>解决办法：可以将热点数据可以提前放入 <code>cache</code> 中。</li></ul></li><li>写操作比较频繁的话导致 <code>cache</code> 中的数据会被频繁被删除，这样会影响缓存命中率 。<ul><li>解决办法：可以使用 <code>Write Through</code> 或者 <code>Write Behind</code> 策略。</li></ul></li></ul><p><strong>读写穿透</strong>(<code>Read/Write Through Pattern</code>)<br>服务端把 <code>cache</code> 视为主要数据存储，从中读取数据并将数据写入其中。<code>cache</code> 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p>读：</p><ul><li>从 <code>cache</code> 中读取数据，读取到就直接返回。</li><li>读取不到的话，先从 db 读取数据然后写入到 <code>cache</code> 中，再返回。</li></ul><p>写：</p><ul><li>先查 <code>cache</code>，<code>cache</code> 中不存在，直接更新 db。</li><li><code>cache</code> 中存在，则先更新 <code>cache</code>，然后 <code>cache</code> 服务自己更新 db(同步更新 <code>cache</code> 和 db)</li></ul><blockquote><p>该模式也有首次请求数据不一定在 <code>cache</code> 的问题，对于热点数据可以提前放入缓存中。</p></blockquote><p><strong>异步缓存写入</strong>(<code>Write Behind Pattern</code>)</p><p><code>Write Behind Pattern</code> 和 <code>Read/Write Through Pattern</code> 很相似，两者都是由 <code>cache</code> 服务来负责 <code>cache</code> 和 db 的读写。但是，两个又有很大的不同：<code>Read/Write Through</code> 是同步更新 cache 和 db，而 <code>Write Behind</code> 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 <code>cache</code> 数据可能还没异步更新 db 的话，<code>cache</code> 服务可能就就挂掉了。</p><blockquote><p>应用场景：消息队列中消息的异步写入磁盘、MySQL 的 <code>Innodb Buffer Pool </code>机制都用到了这种策略。</p></blockquote><h3 id="Redis除了做缓存还有哪些应用场景"><a href="#Redis除了做缓存还有哪些应用场景" class="headerlink" title="Redis除了做缓存还有哪些应用场景"></a>Redis除了做缓存还有哪些应用场景</h3><ul><li>分布式锁：基于 <code>Redisson</code> 来实现分布式锁。</li><li>限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 <code>Redisson</code> 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li><li>消息队列：Redis 自带的 <code>List</code> 数据结构可以作为一个简单的队列使用。</li><li>延时队列：<code>Redisson</code> 内置了延时队列(基于 <code>Sorted Set</code> 实现的)。</li><li>分布式 <code>Session</code> ：利用 <code>String</code> 或者 <code>Hash</code> 数据类型保存 <code>Session</code> 数据，所有的服务器都可以访问。</li><li>热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。</li></ul><h3 id="Redis可以做消息队列吗"><a href="#Redis可以做消息队列吗" class="headerlink" title="Redis可以做消息队列吗"></a>Redis可以做消息队列吗</h3><p>可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 <code>List</code> 来实现。Redis 2.0 之后，Redis 提供了 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。</p><p>和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><h3 id="Redis可以做搜索引擎吗"><a href="#Redis可以做搜索引擎吗" class="headerlink" title="Redis可以做搜索引擎吗"></a>Redis可以做搜索引擎吗</h3><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <code>RediSearch</code>，这是一个基于 Redis 的搜索引擎模块。</p><p><code>RediSearch</code> 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 <code>Elasticsearch</code> 来说，<code>RediSearch</code> 有如下优势：</p><ul><li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作(<code>Elasticsearch</code> 基于磁盘)。</li><li>较低内存占用实现快速索引：<code>RediSearch</code> 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li></ul><p><code>RediSearch</code> 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 <code>Elasticsearch</code>。</p><ul><li>数据量限制：<code>RedisSearch</code> 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。</li><li>分布式能力较差：<code>RedisSearch</code> 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。<code>Elasticsearch</code> 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。</li><li><code>RediSearch</code>聚合功能相较于 <code>Elasticsearch</code> 功能较弱。</li><li>生态较差：<code>Elasticsearch</code> 可以轻松和常见的一些系统&#x2F;软件集成比如 <code>Hadoop</code>、<code>Spark</code>、<code>Kibana</code>，而 <code>RedisSearch</code> 则不具备该优势。</li></ul><h3 id="基于Redis实现延时任务✅"><a href="#基于Redis实现延时任务✅" class="headerlink" title="基于Redis实现延时任务✅"></a>基于Redis实现延时任务✅</h3><blockquote><p>类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？</p></blockquote><p>两种方案：</p><ol><li>Redis 过期事件监听 </li><li><code>Redisson</code> 内置的延时队列</li></ol><p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。<br><code>Redisson</code> 内置的延时队列具备下面这些优势：</p><ul><li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li><li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li></ul><h3 id="Redis过期事件监听实现延时任务的原理"><a href="#Redis过期事件监听实现延时任务的原理" class="headerlink" title="Redis过期事件监听实现延时任务的原理"></a>Redis过期事件监听实现延时任务的原理</h3><p>Redis 2.0 引入了发布订阅 (<code>pub/sub</code>) 功能(其中有一个叫做 <code>channel</code>的概念)，涉及发布者(<code>publisher</code>)和订阅者(<code>subscriber</code>，也叫消费者)两个角色：</p><ul><li>发布者通过 <code>PUBLISH</code> 投递消息给指定 <code>channel</code>。</li><li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 <code>channel</code>。并且，订阅者可以订阅一个或者多个 <code>channel</code>。</li></ul><p>在 <code>pub/sub</code> 模式下，生产者需要指定消息发送到哪个 <code>channel</code> 中，而消费者则订阅对应的 <code>channel</code> 以获取消息。</p><p>Redis 中有很多默认的 <code>channel</code>，Redis 本身向它们发送一些消息，比如 <code>__keyevent@0__:expired</code>，这个 <code>channel</code> 用来监听 Redis 中的 key 过期事件。</p><p>实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 <code>key</code> 过期时，Redis 会向 <code>__keyevent@0__:expired</code> 这个<code>channel</code>发送一条消息，这时候就可以在这个 <code>channel</code> 上监听到这个消息，从而实现延时任务。</p><h3 id="Redis过期事件监听实现延时任务有什么缺陷"><a href="#Redis过期事件监听实现延时任务有什么缺陷" class="headerlink" title="Redis过期事件监听实现延时任务有什么缺陷"></a>Redis过期事件监听实现延时任务有什么缺陷</h3><ol><li>时效性差：过期事件消息是在 Redis 服务器删除 <code>key</code> 时发布的，而不是一个 <code>key</code> 过期之后就会就会直接发布。Redis 采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>。 因此会存在设置了 <code>key</code> 的过期时间，但到了指定时间 <code>key</code> 还未被删除，进而没有发布过期事件的情况。</li><li>丢消息：Redis 的 <code>pub/sub</code> 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。</li><li>多服务实例下消息重复消费：pub&#x2F;sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。</li></ol><h3 id="Redisson内置的延时队列实现延时任务的原理及优势"><a href="#Redisson内置的延时队列实现延时任务的原理及优势" class="headerlink" title="Redisson内置的延时队列实现延时任务的原理及优势"></a>Redisson内置的延时队列实现延时任务的原理及优势</h3><p>可以借助 <code>Redisson</code> 内置的延时队列 <code>RDelayedQueue</code> 来实现延时任务功能。<code>RDelayedQueue</code> 基于 Redis 的 <code>SortedSet</code> 来实现，<code>SortedSet</code> 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 <code>SortedSet</code> 中，使用<code>zrangebyscore</code> 命令扫描 <code>SortedSet</code> 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 <code>SortedSet</code> 的轮询，提高了执行效率。</p><p><code>Redisson</code> 内置的延时队列具备下面这些优势：</p><ul><li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li><li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li></ul><h3 id="Redis数据类型✅"><a href="#Redis数据类型✅" class="headerlink" title="Redis数据类型✅"></a>Redis数据类型✅</h3><ul><li>5种基本数据类型：<table><thead><tr><th align="left">数据类型</th><th align="left">底层实现</th></tr></thead><tbody><tr><td align="left"><code>String</code>(字符串)</td><td align="left"><code>SDS</code>(简单动态字符串)</td></tr><tr><td align="left"><code>List</code>(列表)</td><td align="left"><code>LinkedList</code>(双向链表)、<code>ZipList</code>(压缩列表)、<code>QuickList</code>(快速列表)</td></tr><tr><td align="left"><code>Hash</code>(哈希)</td><td align="left"><code>Dict</code>(哈希表&#x2F;字典)、<code>ZipList</code>(压缩列表)</td></tr><tr><td align="left"><code>Set</code>(集合)</td><td align="left"><code>Dict</code>(哈希表&#x2F;字典)、<code>Intset</code>(整数集合)</td></tr><tr><td align="left"><code>Zset</code>(有序集合)</td><td align="left"><code>ZipList</code>(压缩列表)、<code>SkipList</code>(跳表)</td></tr></tbody></table></li><li>3种特殊数据类型：<ul><li><code>Bitmap</code>：位图</li><li><code>HyperLogLog</code>：基数统计</li><li><code>Geo</code>：地理位置</li></ul></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><code>String</code> 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(<code>Simple Dynamic String，SDS</code>)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值</td></tr><tr><td>MSET key1 value1 key2 value2 ……</td><td>设置一个或多个指定 key 的值</td></tr><tr><td>MGET key1 key2 …</td><td>获取一个或多个指定 key 的值</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值增一</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值减一</td></tr><tr><td>EXISTS key</td><td>判断指定 key 是否存在</td></tr><tr><td>DEL key(通用)</td><td>删除指定的 key</td></tr><tr><td>EXPIRE key seconds(通用)</td><td>给指定 key 设置过期时间</td></tr></tbody></table><p><strong>应用场景</strong><br><code>String</code> 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 <code>base64</code> 编码或者解码或者图片的路径)、序列化后的对象。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>Redis 的 <code>List</code> 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>RPUSH key value1 value2 …</td><td>在指定列表的尾部(右边)添加一个或多个元素</td></tr><tr><td>LPUSH key value1 value2 …</td><td>在指定列表的头部(左边)添加一个或多个元素</td></tr><tr><td>LSET key index value</td><td>将指定列表索引 index 位置的值设置为 value</td></tr><tr><td>LPOP key</td><td>移除并获取指定列表的第一个元素(最左边)</td></tr><tr><td>RPOP key</td><td>移除并获取指定列表的最后一个元素(最右边)</td></tr><tr><td>LLEN key</td><td>获取列表元素数量</td></tr><tr><td>LRANGE key start end</td><td>获取列表 start 和 end 之间 的元素</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>信息流展示，如最新文章、最新动态。</li><li>消息队列，只是与专业的消息队列相比，<code>List</code> 功能较弱。</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p> <code>Hash</code> 是一个 <code>String</code> 类型的 <code>field-value</code>(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。</p><p><code>Hash</code> 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)，不过做了更多优化。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置指定哈希表中指定字段的值</td></tr><tr><td>HSETNX key field value</td><td>只有指定字段不存在时设置指定字段的值</td></tr><tr><td>HMSET key field1 value1 field2 value2 …</td><td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td></tr><tr><td>HGET key field</td><td>获取指定哈希表中指定字段的值</td></tr><tr><td>HMGET key field1 field2 …</td><td>获取指定哈希表中一个或者多个指定字段的值</td></tr><tr><td>HGETALL key</td><td>获取指定哈希表中所有的键值对</td></tr><tr><td>HEXISTS key field</td><td>查看指定哈希表中指定的字段是否存在</td></tr><tr><td>HDEL key field1 field2 …</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HLEN key</td><td>获取指定哈希表中字段的数量</td></tr><tr><td>HINCRBY key field increment</td><td>对指定哈希中的指定字段做运算操作(正数为加，负数为减)</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>存储对象，如用户信息、商品信息、文章信息、购物车信息.</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 <code>HashSet</code> 。当需要存储无重复列表数据时，<code>Set</code> 是一个很好的选择，且 <code>Set</code> 提供了判断某个元素是否在其内的重要接口，这个也是 <code>List</code> 所不能提供的。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SADD key member1 member2 …</td><td>向指定集合添加一个或多个元素</td></tr><tr><td>SMEMBERS key</td><td>获取指定集合中的所有元素</td></tr><tr><td>SCARD key</td><td>获取指定集合的元素数量</td></tr><tr><td>SISMEMBER key member</td><td>判断指定元素是否在指定集合中</td></tr><tr><td>SINTER key1 key2 …</td><td>获取给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 key2 …</td><td>将给定所有集合的交集存储在 destination 中</td></tr><tr><td>SUNION key1 key2 …</td><td>获取给定所有集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 key2 …</td><td>将给定所有集合的并集存储在 destination 中</td></tr><tr><td>SDIFF key1 key2 …</td><td>获取给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 key2 …</td><td>将给定所有集合的差集存储在 destination 中</td></tr><tr><td>SPOP key count</td><td>随机移除并获取指定集合中一个或多个元素</td></tr><tr><td>SRANDMEMBER key count</td><td>随机获取指定集合中指定数量的元素</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>存放无重复数据：如文章点赞、用户收藏、共同好友等。</li><li>需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。</li><li>随机获取数据源：如抽奖、随机推荐等。</li></ul><h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h4><p><code>Zset</code>相较于<code>Set</code>增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>ZADD key score1 member1 score2 member2 …</td><td>向指定有序集合添加一个或多个元素</td></tr><tr><td>ZCARD KEY</td><td>获取指定有序集合的元素数量</td></tr><tr><td>ZSCORE key member</td><td>获取指定有序集合中指定元素的 score 值</td></tr><tr><td>ZINTERSTORE destination numkeys key1 key2 …</td><td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td></tr><tr><td>ZUNIONSTORE destination numkeys key1 key2 …</td><td>求并集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZDIFFSTORE destination numkeys key1 key2 …</td><td>求差集，其它和 ZINTERSTORE 类似</td></tr><tr><td>ZRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素(score 从低到高)</td></tr><tr><td>ZREVRANGE key start end</td><td>获取指定有序集合 start 和 end 之间的元素(score 从高到底)</td></tr><tr><td>ZREVRANK key member</td><td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。</li></ul><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p><code>Bitmap</code>存储的是连续的二进制数据(1&#x2F;0)，只需要一个 <code>bit</code> 位来表示某个元素对应的值或者状态，非常节省内存。可以将<code>Bitmap</code> 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 <code>offset</code>(偏移量)。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>SETBIT key offset value</td><td>设置指定 offset 位置的值</td></tr><tr><td>GETBIT key offset</td><td>获取指定 offset 位置的值</td></tr><tr><td>BITCOUNT key start end</td><td>获取 start 和 end 之前值为 1 的元素个数</td></tr><tr><td>BITOP operation destkey key1 key2 …</td><td>对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>用户签到：每天签到的用户用一个 <code>bit</code> 位来表示，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为签到状态(1&#x2F;0)。</li><li>用户在线状态：用一个 <code>bit</code> 位来表示用户的在线状态，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为在线状态(1&#x2F;0)。</li></ul><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p><code>HyperLogLog</code> 是一种基数统计算法，用于估计一个集合中不重复元素的个数。<code>HyperLogLog</code> 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>PFADD key element1 element2 …</td><td>添加一个或多个元素到 HyperLogLog 中</td></tr><tr><td>PFCOUNT key1 key2</td><td>获取一个或者多个 HyperLogLog 的唯一计数。</td></tr><tr><td>PFMERGE destkey sourcekey1 sourcekey2 …</td><td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。</li></ul><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h4><p><code>Geospatial index</code>(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 <code>Sorted Set</code> 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>GEOADD key longitude1 latitude1 member1 …</td><td>添加一个或多个元素对应的经纬度信息到 GEO 中</td></tr><tr><td>GEOPOS key member1 member2 …</td><td>返回给定元素的经纬度信息</td></tr><tr><td>GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI</td><td>返回两个给定元素之间的距离</td></tr><tr><td>GEORADIUS key longitude latitude radius distance</td><td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数</td></tr><tr><td>GEORADIUSBYMEMBER key member radius distance</td><td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>附近的人：根据用户的经纬度信息，获取附近的人。</li><li>附近的商家：根据用户的经纬度信息，获取附近的商家。</li><li>附近的车辆：根据用户的经纬度信息，获取附近的车辆。</li></ul><h3 id="Set和Zset区别"><a href="#Set和Zset区别" class="headerlink" title="Set和Zset区别"></a>Set和Zset区别</h3><ul><li>数据存储：Set是一种无序且不重复的数据结构。Zset是一种有序且不重复的数据结构，每个元素关联一个浮点数分数(score)，元素根据分数进行排序。</li><li>功能：Set支持添加、删除和查找元素等基本操作。Zset在Set基础上，还支持根据分数范围进行区间检索。</li><li>内部实现：Set内部使用Hash表来实现。Zset根据存储情况使用ZipList或者SkipList实现。</li><li>应用场景：Set适用于存储不需要排序和索引的数据集，如用户的标签、兴趣爱好等。Zset适用于需要根据分数进行排序或检索的场景，如排行榜、商品价格排序等。</li></ul><h3 id="Zset底层实现"><a href="#Zset底层实现" class="headerlink" title="Zset底层实现"></a>Zset底层实现</h3><p><a href="https://www.cnblogs.com/hld123/p/18074778">https://www.cnblogs.com/hld123/p/18074778</a></p><p>Zset根据实际情况动态使用ZipList或者SkipList存储元素，以在内存和性能中找到平衡。</p><p>ZipList或者SkipList的切换依赖于两个配置参数：zset-max-ziplist-entries(默认值为128 单位：个)和 zset-max-ziplist-value(默认值为64，单位：字节)。</p><ul><li><p>当 zset 存储的元素数量小于 128，且所有元素的最大长度小于 64kb时，Redis会选择使用压缩列表作为底层实现。压缩列表占用的内存较少，但是在需要修改数据时，可能需要对整个压缩列表进行重写，性能较低。</p></li><li><p>当 zset 存储的元素数量超过 128，或者任何元素的长度超过 64kb时，Redis 会将底层结构从压缩列表转换为跳跃表。跳跃表的查找和修改数据的性能较高，但是占用的内存也较多。</p></li><li><p>压缩表ziplist：一种为节省内存而设计的特殊编码结构，它将所有的元素和分数紧凑地存储在一起。这种方式的优点是占用内存少，但是在需要修改数据时，可能需要对整个压缩列表进行重写，性能较低。当 Zset 存储的元素数量较少，且元素的字符串长度较短时，Redis 会选择使用压缩列表作为底层实现。</p></li><li><p>跳跃表skiplist：一种可以进行快速查找的有序数据结构，它通过维护多级索引来实现快速查找。这种方式的优点是查找和修改数据的性能较高，但是占用的内存也较多。当 zset 存储的元素数量较多，或者元素的字符串长度较长时，Redis 会选择使用跳跃表作为底层实现。</p></li></ul><p>一个zset结构同时包含一个字典和一个跳跃表。跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。</p><h3 id="跳表SkipList"><a href="#跳表SkipList" class="headerlink" title="跳表SkipList"></a>跳表SkipList</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&mid=2247495510&idx=1&sn=7a9f174b2a5facd92ee0efccf712eecc&chksm=fb427c76cc35f560d0ce02d6b7ff2f3e28c0349434734a428b20dfa2c3366d6266b15eacb588&scene=27">https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&amp;mid=2247495510&amp;idx=1&amp;sn=7a9f174b2a5facd92ee0efccf712eecc&amp;chksm=fb427c76cc35f560d0ce02d6b7ff2f3e28c0349434734a428b20dfa2c3366d6266b15eacb588&amp;scene=27</a><br><a href="https://javaguide.cn/database/redis/redis-skiplist.html#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2">https://javaguide.cn/database/redis/redis-skiplist.html#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2</a><br>跳表是一种可以进行二分查找的有序链表，其在有序链表的的基础上添加了多级索引，将增删改查的时间复杂度变为O(logn)。跳表的节点跟一般的链表不同，有<code>val</code>、<code>next</code>、<code>down</code>三个属性，多级索引其实就是多级链表，最下层的链表包含所有元素，上一层元素是下一层的一半，第k层的元素是2^k个。假设跳表元素最大为65536个，则其最大层数为16。</p><p>特性：</p><ul><li>一个跳表有若干层链表组成；</li><li>每一层链表都是有序的；</li><li>跳表最下面一层的链表包含所有数据；</li><li>如果一个元素出现在某一次层，那么该层下面的所有层都必须包含该元素；</li><li>上一层的元素指向下层的元素必须是相同的；</li><li>头指针 head 指向最上面一层的第一个元素；</li></ul><p>CRUD：</p><ul><li>插入：每次插入新元素或者增添新索引的时候，进行一次随机运算，随机数值范围为 0-1 之间，如果随机值 &gt; 0.5，则为当前元素添加更高一级的索引，这样可以保证生成一级索引的概率为50%，二级索引的概率为25%…</li><li>删除：删除时必须定位到当前跳表各层元素小于 要删除元素 的最大值，然后右移(next)，看元素是否为要删除的元素，如果是的话删除，然后下沉(down)，执行同样操作。</li><li>查询：查询从最顶层索引开始，每层定位到当前跳表各层元素小于 要查询的元素的最大值，然后下沉，右移，继续比较。</li></ul><h3 id="Zset为什么要用跳表"><a href="#Zset为什么要用跳表" class="headerlink" title="Zset为什么要用跳表"></a>Zset为什么要用跳表</h3><ul><li>跳表 vs 平衡树<ul><li>跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。</li></ul></li><li>跳表 vs 红黑树<ul><li>跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li></ul></li><li>跳表 vs B+ 树<ul><li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。</li></ul></li></ul><h3 id="使用String存储对象还是Hash"><a href="#使用String存储对象还是Hash" class="headerlink" title="使用String存储对象还是Hash"></a>使用String存储对象还是Hash</h3><ul><li><code>String</code> 存储的是序列化后的对象数据，存放的是整个对象。<code>Hash</code> 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 <code>Hash</code>。</li><li><code>String</code> 存储相对来说更加节省内存，缓存相同数量的对象数据，<code>String</code> 消耗的内存约是 <code>Hash</code> 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用<code>String</code>。</li></ul><h3 id="购物车信息用String还是Hash存储"><a href="#购物车信息用String还是Hash存储" class="headerlink" title="购物车信息用String还是Hash存储"></a>购物车信息用String还是Hash存储</h3><p>购物车中的商品频繁修改和变动，建议使用 <code>Hash</code>储存。</p><ul><li>用户 id 为 <code>key</code></li><li>商品 id 为 <code>field</code>，商品数量为 <code>value</code></li></ul><p>具体维护：</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul><h3 id="用Set实现抽奖系统"><a href="#用Set实现抽奖系统" class="headerlink" title="用Set实现抽奖系统"></a>用Set实现抽奖系统</h3><ul><li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li><li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code>： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h3 id="Bitmap统计活跃用户"><a href="#Bitmap统计活跃用户" class="headerlink" title="Bitmap统计活跃用户"></a>Bitmap统计活跃用户</h3><p>用日期(精确到天)作为 <code>key</code>，用户 ID 为 <code>offset</code>，如果当日活跃过就设置为 1，否则为 0。通过 <code>BITCOUNT</code> 命令统计某个时间段内的活跃用户数。</p><h3 id="统计网站UV、PV"><a href="#统计网站UV、PV" class="headerlink" title="统计网站UV、PV"></a>统计网站UV、PV</h3><p>PV(Page Views)页面浏览量</p><ul><li>定义：PV指的是页面浏览量，即网页被访问的总次数。每次用户加载一个网页，PV就增加一次。即使是同一个用户多次刷新页面，每刷新一次，PV就会增加一次。</li><li>用途：PV用于衡量网页内容的受欢迎程度和用户对网页的互动频率。PV越高，说明该页面被访问的次数越多。</li></ul><p>UV(Unique Visitors)独立访客</p><ul><li>定义：UV指的是独立访客量，即访问某个网站的不同用户数量。UV通常以天为单位计算，即一天内访问网站的不同用户数量。同一个用户在一天内多次访问，只会被计为1个UV。</li><li>用途：UV用于衡量网站的访问人数。UV越高，说明网站吸引了更多的不同用户。</li></ul><p>使用Jedis：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PV统计直接使用String，每次访问页面对PV计数器进行累加。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pageKey</span> <span class="operator">=</span> <span class="string">&quot;page:home&quot;</span>; <span class="comment">// 可用不同的页面设置不同的key</span></span><br><span class="line">jedis.incr(pageKey + <span class="string">&quot;:pv&quot;</span>);</span><br><span class="line"><span class="comment">// UV统计使用HyperLogLog</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uvKey</span> <span class="operator">=</span> <span class="string">&quot;page:home:uv&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;user123&quot;</span>; <span class="comment">// 这是用户的唯一标识，可以是用户ID、IP等</span></span><br><span class="line">jedis.pfadd(uvKey, userId);</span><br><span class="line"><span class="comment">// 获取PV</span></span><br><span class="line"><span class="type">long</span> <span class="variable">pv</span> <span class="operator">=</span> jedis.get(pageKey + <span class="string">&quot;:pv&quot;</span>);</span><br><span class="line"><span class="comment">// 获取UV</span></span><br><span class="line"><span class="type">long</span> <span class="variable">uv</span> <span class="operator">=</span> jedis.pfcount(uvKey);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>PFADD PAGE_1:UV USER1 USER2 ...... USERn</code>：将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</li><li><code>PFCOUNT PAGE_1:UV</code>：统计指定页面的 UV。</li></ul><h3 id="Redis持久化机制✅"><a href="#Redis持久化机制✅" class="headerlink" title="Redis持久化机制✅"></a>Redis持久化机制✅</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。</p><h3 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h3><ul><li>重用数据(比如重启机器、机器故障之后恢复数据)</li><li>数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。</li></ul><h3 id="三种持久化方式"><a href="#三种持久化方式" class="headerlink" title="三种持久化方式"></a>三种持久化方式</h3><ul><li>快照(<code>snapshotting</code>, RDB)</li><li>只追加文件(<code>append-only file</code>, AOF)</li><li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li></ul><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis通过创建快照获取存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。</p><h3 id="RDB创建时会阻塞主线程吗"><a href="#RDB创建时会阻塞主线程吗" class="headerlink" title="RDB创建时会阻塞主线程吗"></a>RDB创建时会阻塞主线程吗</h3><p>有两个命令生成 RDB 快照文件</p><ul><li><code>save</code>：同步保存操作，会阻塞 Redis 主线程； </li><li><code>bgsave</code>：<code>fork</code> 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(<code>fsync</code>策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。</p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。</p><h3 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h3><ol><li>命令追加(<code>append</code>)：所有的写命令会追加到 AOF 缓冲区中。</li><li>文件写入(<code>write</code>)：将 AOF 缓冲区的数据写入到<strong>系统内核缓冲区</strong>中。这一步系统调用<code>write</code>函数，将数据写入到了<strong>系统内核缓冲区</strong>之后直接返回(延迟写)。</li><li>文件同步(<code>fsync</code>)：<strong>系统内核缓冲区</strong>根据对应的持久化方式(<code>fsync</code>策略)向硬盘做同步操作。这一步系统调用 <code>fsync</code> 函数， <code>fsync</code> 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。</li><li>文件重写(<code>rewrite</code>)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li>重启加载(<code>load</code>)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ol><p><img src="/./image/Database-Interview/aof-work-process.png" alt="AOF工作流程"></p><h3 id="AOF持久化的三种同步策略"><a href="#AOF持久化的三种同步策略" class="headerlink" title="AOF持久化的三种同步策略"></a>AOF持久化的三种同步策略</h3><p>即 <code>fsync</code> 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。</p><ul><li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程( <code>aof_fsync</code> 线程)立即会调用 <code>fsync</code> 函数同步 AOF 文件(刷盘)，<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能(<code>write + fsync</code>)。</li><li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程( <code>aof_fsync</code> 线程)每秒钟调用 <code>fsync</code> 函数同步一次 AOF 文件(<code>write+fsync</code>，<code>fsync</code>间隔为 1 秒)</li><li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定)。</li></ul><blockquote><p>刷盘：将内存中的数据写入到磁盘中。</p></blockquote><h3 id="AOF为什么是执行完命令后记录日志"><a href="#AOF为什么是执行完命令后记录日志" class="headerlink" title="AOF为什么是执行完命令后记录日志"></a>AOF为什么是执行完命令后记录日志</h3><p>不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。</p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>但也存在风险：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； </li><li>可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。</li></ul><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>重写期间，AOF维护一个<strong>AOF重写缓冲区</strong>，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将<strong>AOF重写缓冲区</strong>内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。</p><p>可以配置如下参数：<br><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;<br><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小(<code>aof_current_size</code>)和上一次重写时 AOF 大小(<code>aof_base_size</code>)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</p><h3 id="AOF校验机制"><a href="#AOF校验机制" class="headerlink" title="AOF校验机制"></a>AOF校验机制</h3><p>Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 <code>CRC64</code> 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。</p><p>Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。</p><h3 id="Redis4-0对持久化的优化"><a href="#Redis4-0对持久化的优化" class="headerlink" title="Redis4.0对持久化的优化"></a>Redis4.0对持久化的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h3 id="如何选择RDB和AOF"><a href="#如何选择RDB和AOF" class="headerlink" title="如何选择RDB和AOF"></a>如何选择RDB和AOF</h3><p>RDB优势：</p><ul><li>RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。</li><li>RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。</li></ul><p>AOF优势：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。</li></ul><p>综上：</p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li></ul><h3 id="Redis单线程模型✅"><a href="#Redis单线程模型✅" class="headerlink" title="Redis单线程模型✅"></a>Redis单线程模型✅</h3><p>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(<code>file event handler</code>)，是单线程方式运行的，所以说 Redis 是单线程模型。</p><h3 id="如何监听大量客户端链接"><a href="#如何监听大量客户端链接" class="headerlink" title="如何监听大量客户端链接"></a>如何监听大量客户端链接</h3><p>通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接(或者说是监听多个 <code>socket</code>)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。</p><p>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p><p>文件事件处理器主要是包含 4 个部分：</p><ul><li>多个 socket(客户端连接)</li><li>IO 多路复用程序(支持多个客户端连接的关键)</li><li>文件事件分派器(将 <code>socket</code> 关联到相应的事件处理器)</li><li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li></ul><p><img src="/./image/Database-Interview/redis-event-handler.png" alt="文件事件处理器"></p><h3 id="Redis4-0多线程"><a href="#Redis4-0多线程" class="headerlink" title="Redis4.0多线程"></a>Redis4.0多线程</h3><p>在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p><p>异步命令：</p><ul><li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li><li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li><li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li></ul><p>总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p><h3 id="Redis6-0之前为什么不用多线程"><a href="#Redis6-0之前为什么不用多线程" class="headerlink" title="Redis6.0之前为什么不用多线程"></a>Redis6.0之前为什么不用多线程</h3><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><h3 id="Redis6-0之后为何引入多线程"><a href="#Redis6-0之后为何引入多线程" class="headerlink" title="Redis6.0之后为何引入多线程"></a>Redis6.0之后为何引入多线程</h3><p>Redis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p><h3 id="Redis后台线程"><a href="#Redis后台线程" class="headerlink" title="Redis后台线程"></a>Redis后台线程</h3><p>Redis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：</p><ul><li>通过 <code>bio_close_file</code> 后台线程来释放 AOF&#x2F;RDB 等过程中产生的临时文件资源。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。</li><li>通过 <code>bio_lazy_free</code>后台线程释放大对象(已删除)占用的内存空间.</li></ul><h3 id="lua脚本如何确保原子操作"><a href="#lua脚本如何确保原子操作" class="headerlink" title="lua脚本如何确保原子操作"></a>lua脚本如何确保原子操作</h3><ul><li>单线程：Redis是单线程模型，其在同一时间只能执行一个命令。Lua脚本是在Redis的主线程上执行的，且Redis在执行Lua脚本时会阻塞其他命令的执行。这种机制确保了在执行Lua脚本的过程中，不会有其他Redis命令插入或打断脚本的执行。因此，整个Lua脚本中的所有操作(包括读取和写入)是连续执行的，不会被其他命令中断，从而实现了原子性。</li><li>事务：Lua脚本中，所有的Redis命令都是作为一个整体执行的。即使脚本中包含多个Redis命令，这些命令在逻辑上也是作为一个不可分割的单元来执行的。如果脚本执行过程中发生错误，整个脚本会回滚，没有部分操作会生效。这进一步确保了脚本执行的原子性。</li><li></li></ul><h3 id="Redis内存管理✅"><a href="#Redis内存管理✅" class="headerlink" title="Redis内存管理✅"></a>Redis内存管理✅</h3><h3 id="Redis给缓存数据设置过期时间有啥用"><a href="#Redis给缓存数据设置过期时间有啥用" class="headerlink" title="Redis给缓存数据设置过期时间有啥用"></a>Redis给缓存数据设置过期时间有啥用</h3><ul><li>因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。</li><li>某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。</li></ul><h3 id="Redis如何判断数据过期"><a href="#Redis如何判断数据过期" class="headerlink" title="Redis如何判断数据过期"></a>Redis如何判断数据过期</h3><p>Redis 通过一个叫做<strong>过期字典</strong>(可以看作是 <code>hash</code> 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 <code>key</code>(键)，过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了 <code>key</code> 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。</p><p>在查询一个 <code>key</code> 的时候，Redis 首先检查该 <code>key</code> 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 <code>key</code> 是否过期，过期直接删除 <code>key</code> 然后返回 <code>null</code>。</p><h3 id="Redis过期key删除策略"><a href="#Redis过期key删除策略" class="headerlink" title="Redis过期key删除策略"></a>Redis过期key删除策略</h3><ul><li>惰性删除：只会在取出&#x2F;查询 <code>key</code> 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 <code>key</code> 没有删除。</li><li>定期删除：周期性地随机从设置了过期时间的 <code>key</code> 中抽查一批，然后逐个检查这些 <code>key</code> 是否过期，过期就删除 <code>key</code>。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li><li>延迟队列：把设置过期时间的 <code>key</code> 放到一个延迟队列里，到期之后就删除 <code>key</code>。这样可保证每个过期 <code>key</code> 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li><li>定时删除：每个设置了过期时间的 <code>key</code> 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。</li></ul><p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。</p><h3 id="定期删除策略详细细节"><a href="#定期删除策略详细细节" class="headerlink" title="定期删除策略详细细节"></a>定期删除策略详细细节</h3><ul><li>Redis 默认每 100ms 检查 20 个随机的过期 <code>key</code>，如果有过期的 <code>key</code> 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 <code>key</code> 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li></ul><h3 id="大量key集中过期如何处理"><a href="#大量key集中过期如何处理" class="headerlink" title="大量key集中过期如何处理"></a>大量key集中过期如何处理</h3><p>如果大量 <code>key</code> 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：</p><ul><li>尽量避免 <code>key</code> 集中过期，在设置键的过期时间时尽量随机一点。</li><li>对过期的 <code>key</code> 开启 <code>lazyfree</code> 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。</li></ul><h3 id="Redis内存淘汰策略✅"><a href="#Redis内存淘汰策略✅" class="headerlink" title="Redis内存淘汰策略✅"></a>Redis内存淘汰策略✅</h3><p>当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：</p><ul><li><code>volatile-lru</code>(least recently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最近最少使用的数据淘汰。</li><li><code>volatile-ttl</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选将要过期的数据淘汰。</li><li><code>volatile-random</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中任意选择数据淘汰。</li><li><code>allkeys-lru</code>(least recently used)：从数据集(<code>server.db[i].dict</code>)中移除最近最少使用的数据淘汰。</li><li><code>allkeys-random</code>：从数据集(<code>server.db[i].dict</code>)中任意选择数据淘汰。</li><li><code>no-eviction</code>(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul><p>4.0 版本后增加以下两种：</p><ul><li><code>volatile-lfu</code>(least frequently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰。</li><li><code>allkeys-lfu</code>(least frequently used)：从数据集(<code>server.db[i].dict</code>)中移除最不经常使用的数据淘汰。</li></ul><p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p><h3 id="如何解决Redis事务的缺陷"><a href="#如何解决Redis事务的缺陷" class="headerlink" title="如何解决Redis事务的缺陷"></a>如何解决Redis事务的缺陷</h3><p>可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</p><h3 id="Redis性能优化✅"><a href="#Redis性能优化✅" class="headerlink" title="Redis性能优化✅"></a>Redis性能优化✅</h3><h3 id="批量操作减少网络传输"><a href="#批量操作减少网络传输" class="headerlink" title="批量操作减少网络传输"></a>批量操作减少网络传输</h3><p>Redis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。</p><p>批量操作的三种方式</p><ul><li>原生批量操作：Redis 提供了一些原生的批量操作命令，如 <code>MSET</code>、<code>MGET</code>、<code>DEL</code> 等。</li><li>Pipeline：通过 <code>pipeline</code> 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。</li><li>Lua脚本：</li></ul><h3 id="大量key集中过期"><a href="#大量key集中过期" class="headerlink" title="大量key集中过期"></a>大量key集中过期</h3><p>Redis采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>清理过期<code>key</code>。如果大量 <code>key</code> 集中过期的问题，客户端请求必须等待定期清理过期 <code>key</code> 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：</p><ul><li>给 <code>key</code> 设置随机过期时间。</li><li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)，让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将删除<code>key</code>的操作该操作交给单独的子线程处理，避免阻塞主线程。</li></ul><h3 id="bigkey-大key"><a href="#bigkey-大key" class="headerlink" title="bigkey(大key)"></a>bigkey(大key)</h3><p>如果一个 <code>key</code> 对应的 <code>value</code> 所占用的内存比较大，那这个 <code>key</code> 就可以看作是 <code>bigkey</code>。<code>bigkey</code>的标准：</p><ul><li><code>String</code> 类型的 <code>value</code> 超过 1MB</li><li>复合类型(<code>List</code>、<code>Hash</code>、<code>Set</code>、<code>Sorted Set</code> 等)的 <code>value</code> 包含的元素超过 5000 个(不过，对于复合类型的 <code>value</code> 来说，不一定包含的元素越多，占用的内存就越多)。</li></ul><p><strong>产生原因</strong></p><ul><li>程序设计不当，比如直接使用 <code>String</code> 类型存储较大的文件对应的二进制数据。</li><li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li><li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li></ul><p><strong>危害</strong></p><ul><li>单线程的Redis 在操作<code>bigkey</code> 时候比较耗时，造成客户端超时阻塞。</li><li>网络拥塞：获取<code>bigkey</code>需要较多的流量。</li><li>工作线程阻塞：如果使用 <code>del</code> 删除大 <code>key</code> 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><code>bigkey</code>会进一步影响主从同步。</li></ul><p><strong>bigkey发现</strong></p><ul><li><code>--bigkeys</code>：执行<code>redis-cli -p 6379 --bigkeys</code>扫描所有key，只能找到<code>top 1 bigkey</code>(占用内存最大的 <code>String</code> 数据类型，包含元素最多的复合数据类型)。</li><li><code>SCAN+STRLEN/HLEN/LLEN</code>：Redis 自带的 <code>SCAN</code> 命令按指定模式扫描匹配的<code>key</code>，然后结合<code>STRLEN/HLEN/LLEN</code>返回<code>key</code>的长度或者成员数量。</li><li>集合类型可以使用<code>MEMORY USAGE</code></li><li>借助开源工具分析 RDB 文件。如<code>redis-rdb-tools</code>、<code>rdb_bigkeys</code></li><li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li></ul><p><strong>处理bigkey</strong></p><ul><li>分割 <code>bigkey</code>：将<code>bigkey</code>分割为多个小 <code>key</code>。例如，将一个含有上万字段数量的 <code>Hash</code> 按照一定策略(比如二次哈希)拆分为多个 <code>Hash</code>。</li><li>手动清理：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 <code>key</code>。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li><li>采用合适的数据结构：例如，文件二进制数据不使用 <code>String</code> 保存、使用 <code>HyperLogLog</code> 统计页面 <code>UV</code>、<code>Bitmap</code> 保存状态信息(0&#x2F;1)。</li><li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)：<code>lazy-free</code> 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ul><p>也可以配合使用上述方法</p><h3 id="hotkey-热key"><a href="#hotkey-热key" class="headerlink" title="hotkey(热key)"></a>hotkey(热key)</h3><p>如果一个 <code>key</code> 的访问次数比较多且明显多于其他 <code>key</code>，就可以看作是 <code>hotkey</code>。</p><p><strong>产生原因</strong><br>某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p><p><strong>危害</strong></p><ul><li><code>hotkey</code> 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</li><li>如果突然访问 <code>hotkey</code> 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</li></ul><p><code>hotkey</code> 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><p><strong>发现hotkey</strong></p><ul><li><code>--hotkeys</code>：执行<code>redis-cli -p 6379 --hotkeys</code>命令</li><li><code>MONITOR</code>： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。<ul><li>可在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 <code>hotkey</code>。</li></ul></li><li>根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 <code>hotkey</code>，比如突发的热点新闻事件等。</li><li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li></ul><p><strong>处理hotkey</strong></p><ul><li>读写分离：主节点处理写请求，从节点处理读请求。</li><li>使用 <code>Redis Cluster</code>：将热点数据分散存储在多个 Redis 节点上。</li><li>二级缓存：<code>hotkey</code> 采用二级缓存的方式进行处理，将 <code>hotkey</code> 存放一份到 JVM 本地内存中(可以用 Caffeine)。</li><li>使用公有云的 Redis 服务中的解决方案。</li></ul><p>也可以配合使用上述方法。</p><h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如<code>KEYS *</code>、<code>HGETALL</code>等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</p><h3 id="Redis内存碎片✅"><a href="#Redis内存碎片✅" class="headerlink" title="Redis内存碎片✅"></a>Redis内存碎片✅</h3><p>Redis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。</p><h3 id="内存碎片产生原因"><a href="#内存碎片产生原因" class="headerlink" title="内存碎片产生原因"></a>内存碎片产生原因</h3><ol><li>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。<ul><li>Redis 采用多种内存分配器分配内存，默认采用 <code>jemalloc</code>，其按照 2 的幂次方分配内存，可能会导致内存浪费。</li></ul></li><li>频繁修改 Redis 中的数据也会产生内存碎片。</li></ol><h3 id="查看内存碎片率"><a href="#查看内存碎片率" class="headerlink" title="查看内存碎片率"></a>查看内存碎片率</h3><p>使用 <code>info memory</code> 命令查看 Redis 内存碎片率。</p><p><code>mem_fragmentation_ratio</code> (内存碎片率)&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p><p>内粗碎片率越大，说明 Redis 中的内存碎片越多。<code>used_memory_rss</code> 减去 <code>used_memory</code> 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p><p>通常内存碎片率<code>mem_fragmentation_ratio</code> &gt; 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了</p><h3 id="Redis内存碎片清理"><a href="#Redis内存碎片清理" class="headerlink" title="Redis内存碎片清理"></a>Redis内存碎片清理</h3><ol><li>重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</li><li>Redis4.0-RC3可以通过<code>config set activedefrag yes</code>开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span> <span class="comment"># 开启主动碎片整理功能</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb <span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50 <span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-min 20 <span class="comment"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-max 50 <span class="comment"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Redis生产问题✅"><a href="#Redis生产问题✅" class="headerlink" title="Redis生产问题✅"></a>Redis生产问题✅</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是大量请求的 <code>key</code> 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>举例</strong><br>某个黑客故意制造一些非法的 <code>key</code> 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方案</strong></p><ol><li>做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</li><li>缓存无效 <code>key</code>。短暂地缓存无效<code>key</code>，并设置一个较短的过期时间，这样就可以防止缓存穿透。</li><li>布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 <code>hash</code> 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。</li><li>接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>举例</strong><br>秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方案</strong></p><ol><li>永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。</li><li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是缓存在同一时间大面积的失效或者是Redis宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><strong>举例</strong><br>数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方案</strong><br>针对大量缓存同时失效的情况：</p><ol><li>设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li><li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li><li>多级缓存(推荐)：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li><li>使用Redis集群(推荐)：使用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li></ol><p>针对 Redis 服务不可用的情况：</p><ol><li>Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li><li>多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li></ol><h3 id="缓存穿透-缓存击穿区别"><a href="#缓存穿透-缓存击穿区别" class="headerlink" title="缓存穿透&#x2F;缓存击穿区别"></a>缓存穿透&#x2F;缓存击穿区别</h3><ul><li>缓存穿透中，请求的 <code>key</code> 既不存在于缓存中，也不存在于数据库中。</li><li>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。</li></ul><h3 id="缓存预热如何实现"><a href="#缓存预热如何实现" class="headerlink" title="缓存预热如何实现"></a>缓存预热如何实现</h3><ol><li>使用定时任务，比如 <code>xxl-job</code>，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li><li>使用消息队列，比如 <code>Kafka</code>，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li></ol><h3 id="缓存击穿-缓存雪崩区别"><a href="#缓存击穿-缓存雪崩区别" class="headerlink" title="缓存击穿&#x2F;缓存雪崩区别"></a>缓存击穿&#x2F;缓存雪崩区别</h3><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。</p><h3 id="Redis常见阻塞原因"><a href="#Redis常见阻塞原因" class="headerlink" title="Redis常见阻塞原因"></a>Redis常见阻塞原因</h3><ol><li>O(n)命令：如<code>KEYS *</code>(返回所有符合规则的 <code>key</code>)、<code>HGETALL</code>(会返回一个 <code>Hash</code> 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</li><li><code>Save</code>创建RDB快照：<code>save</code> 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。</li><li>AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。</li><li>AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会<code>append</code>到AOF缓冲区，然后<code>write</code> 到系统内核缓冲区，最后 <code>fsync</code> 刷到磁盘。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。</li><li>AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。</li><li>查找和删除<code>bigkey</code>：查找<code>bigkey</code>时，Redis 会遍历所有的 <code>key</code>，这个操作是阻塞的。删除<code>bigkey</code>时，会先释放<code>bigkey</code>内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的<code>bigkey</code>，空闲内存块插入链表的操作就会阻塞主线程。</li><li>清空数据库：<code>flushall</code> 和 <code>flushdb</code> 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。</li><li>CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</li><li>网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</li></ol><h3 id="Redis如何容灾"><a href="#Redis如何容灾" class="headerlink" title="Redis如何容灾"></a>Redis如何容灾</h3><p>Redis容灾是指在Redis服务出现故障时，确保数据的高可用性和一致性。常见的Redis容灾策略包括：</p><ul><li>集群模式(Cluster)：Redis Cluster是Redis内置的分布式实现，可以在多个节点间自动分片存储数据，并且支持自动故障转移。当某个节点失效时，集群中的其他节点会接管其数据和请求，确保服务的持续运行。<ul><li>优点：数据分片，支持大规模数据存储和高可用性。</li><li>缺点：配置复杂，数据一致性要求较高。</li></ul></li><li>主从复制(Master-Slave Replication)：Redis支持主从复制，即在一台主服务器(Master)上写入的数据会自动复制到一台或多台从服务器(Slave)。当主服务器出现故障时，可以手动或自动将从服务器提升为主服务器，继续提供服务。<ul><li>优点：配置简单，可以实现读写分离。</li><li>缺点：在主服务器故障后需要手动切换，数据可能会有短暂的丢失(未同步到从服务器的数据)。</li></ul></li><li>哨兵模式(Sentinel)：哨兵模式是在主从复制的基础上增加了监控、通知和自动故障转移功能。Redis Sentinel会监控主从节点的状态，如果发现主节点故障，会自动将某个从节点提升为主节点，并通知其他从节点和应用程序。<ul><li>优点：自动故障转移，提高高可用性。</li><li>缺点：需要额外的哨兵实例，占用资源。</li></ul></li><li>持久化机制(Persistence)：Redis提供了RDB和AOF两种持久化机制，可以将内存中的数据定期保存到磁盘上，防止数据丢失。在灾难发生后，可以通过持久化文件恢复数据。<ul><li>RDB：定期将内存中的数据快照保存到磁盘上，适合备份。</li><li>AOF：将每次写操作记录到日志文件中，可以实现更高的持久性。</li><li>优点：数据恢复能力强。</li><li>缺点：需要权衡持久化频率与性能的关系。</li></ul></li><li>异地多活和冷备方案：为应对更大范围的灾难(如机房故障)，可以采用异地多活或冷备方案，将Redis集群部署在多个地理位置，并进行实时同步或定期备份。在某个机房发生故障时，可以快速切换到异地的数据中心。<ul><li>异地多活：多个数据中心同时提供服务，数据同步较为复杂。</li><li>冷备：异地数据中心仅作为备份，在主数据中心故障时启动。</li></ul></li><li>数据备份与恢复：定期对Redis数据进行备份(如导出RDB文件)，并存储到安全的位置(如异地存储、云存储)。在出现不可恢复的灾难时，可以通过备份文件进行数据恢复。<ul><li>优点：备份灵活，支持灾难恢复。</li><li>缺点：备份频率和恢复速度影响可用性。</li></ul></li></ul><h3 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h3><p>Redis 高可用主要涉及通过不同的技术和部署架构来保证 Redis 在发生故障时仍然能够继续提供服务，避免单点故障。以下是 Redis 高可用的几种实现方式：</p><h4 id="主从复制-Master-Slave-Replication"><a href="#主从复制-Master-Slave-Replication" class="headerlink" title="主从复制(Master-Slave Replication)"></a>主从复制(Master-Slave Replication)</h4><ul><li><strong>架构</strong>：Redis 支持一主多从的架构，即一个主节点 (Master) 负责写入数据，多个从节点 (Slave) 负责同步主节点的数据，以提供读取服务。</li><li><strong>实现</strong>：<ul><li>从节点会主动向主节点发送同步请求，主节点会把当前的数据集发送给从节点，从节点收到后会加载数据并保存。</li><li>主节点会将写操作日志发送给从节点，从节点再执行这些操作，从而实现数据同步。</li></ul></li><li><strong>优点</strong>：读写分离，可以通过增加从节点来提高读的性能。</li><li><strong>缺点</strong>：如果主节点故障，需要手动或者通过其他机制进行故障转移。</li></ul><h4 id="哨兵模式-Sentinel"><a href="#哨兵模式-Sentinel" class="headerlink" title="哨兵模式(Sentinel)"></a>哨兵模式(Sentinel)</h4><ul><li><strong>架构</strong>：Redis Sentinel 是一种监控和管理主从复制集群的机制。它能在主节点故障时自动进行故障转移。</li><li><strong>实现</strong>：<ul><li>哨兵节点会定期检查主从节点的状态，一旦发现主节点不可用，会通过选举机制选出一个新的主节点，并让其他从节点与新的主节点进行同步。</li><li>哨兵也负责通知客户端新的主节点地址，使客户端能够无缝切换。</li></ul></li><li><strong>优点</strong>：实现了高可用性和自动故障恢复，减少了人工干预。</li><li><strong>缺点</strong>：哨兵本身需要高可用性部署，多个哨兵节点协同工作才能避免单点故障。</li></ul><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><ul><li><strong>架构</strong>：Redis Cluster 是 Redis 官方提供的分布式解决方案，支持数据分片和自动故障转移。</li><li><strong>实现</strong>：<ul><li>Redis Cluster 将数据分为多个槽 (slot)，每个节点负责一部分槽的数据。集群节点之间会通过 Gossip 协议交换状态信息。</li><li>当一个节点不可用时，集群中的其他节点会自动将其替换为从节点，并重新分配数据槽。</li><li>数据在多个节点上自动分片存储，从而实现横向扩展和高可用。</li></ul></li><li><strong>优点</strong>：原生支持分布式，自动分片和故障转移，适合大规模部署。</li><li><strong>缺点</strong>：集群管理复杂，要求客户端支持 Redis Cluster 协议，且不支持多键事务。</li></ul><h4 id="Keepalived-Redis"><a href="#Keepalived-Redis" class="headerlink" title="Keepalived+Redis"></a>Keepalived+Redis</h4><ul><li><strong>架构</strong>：使用 Keepalived 和 Redis 进行高可用部署，通常是在主从复制的基础上，通过虚拟 IP(VIP)的漂移来实现高可用。</li><li><strong>实现</strong>：<ul><li>Keepalived 监控 Redis 主节点的状态，当主节点不可用时，会将 VIP 切换到从节点，确保客户端可以继续通过同一 IP 地址访问 Redis。</li></ul></li><li><strong>优点</strong>：配置简单，客户端无需感知主从切换。</li><li><strong>缺点</strong>：故障转移时间较长，容易出现短时间内的不可用状态。</li></ul><h4 id="其他高可用技术的结合"><a href="#其他高可用技术的结合" class="headerlink" title="其他高可用技术的结合"></a>其他高可用技术的结合</h4><ul><li><strong>Proxy 层</strong>：如 Twemproxy 或 Codis，可以作为 Redis 前端的代理，管理多个 Redis 实例，实现请求路由和故障转移。</li><li><strong>高可用框架</strong>：可以将 Redis 作为后端缓存服务，与 Kubernetes 等容器编排系统结合，实现自动扩展、自动重启和健康检查等功能。</li></ul><h3 id="Redis集群如何横向扩展数据存储量"><a href="#Redis集群如何横向扩展数据存储量" class="headerlink" title="Redis集群如何横向扩展数据存储量"></a>Redis集群如何横向扩展数据存储量</h3><p>在Redis集群中，横向扩展数据存储量主要通过增加节点(即分片)的方式实现。以下是具体步骤和方法：</p><ol><li>添加新节点：<ul><li>向现有Redis集群中添加新的Redis节点。每个节点都是一个独立的Redis实例，负责处理集群中一部分数据的存储和请求。</li><li>新增节点后，Redis集群将重新平衡数据，将部分数据从现有节点迁移到新节点，以分散存储压力。</li></ul></li><li>重新分配数据槽：<ul><li>Redis集群使用哈希槽(hash slots)机制将数据分片分布在不同的节点上。Redis集群中的每个键都根据CRC16算法映射到一个哈希槽(共16384个槽位)，每个节点管理一部分槽位。</li><li>当添加新的节点时，集群会重新分配槽位，将一部分槽位从现有节点转移到新节点，数据也会相应地迁移。这一过程可以通过<code>reshard</code>命令手动完成，也可以使用Redis的自动分片功能。</li></ul></li><li>数据迁移：<ul><li>Redis提供了工具(如<code>redis-trib</code>或<code>redis-cli</code>中的<code>CLUSTER</code>命令)来帮助将数据从旧节点迁移到新节点。这一过程是在后台进行的，确保集群在迁移过程中仍然可用。</li></ul></li><li>水平扩展的注意事项：<ul><li>数据均衡性：随着节点的增加，需确保数据均匀分布在所有节点上，以避免某些节点成为瓶颈。</li><li>网络带宽：数据迁移过程会消耗网络带宽，因此在扩展期间需要注意网络的负载情况。</li><li>应用兼容性：确保应用程序能够处理数据分布在多个节点上的情况。大部分客户端库(如Jedis、Lettuce等)已经支持Redis集群模式。</li></ul></li></ol><p>通过以上方法，Redis集群能够在不影响服务可用性的情况下，实现数据存储量的横向扩展。</p><h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供<strong>面向文档</strong>的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong>。</p><p>在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点&#x2F;实例，以保证服务性能和可用性。</p><h3 id="mongodb的存储结构是什么"><a href="#mongodb的存储结构是什么" class="headerlink" title="mongodb的存储结构是什么"></a>mongodb的存储结构是什么</h3><p>主要由三个单元组成：</p><ul><li>数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。</li><li>集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(<code>Table</code>)。</li><li>文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(<code>key-value</code>)组成，类似于关系型数据库中的行(<code>Row</code>)。</li></ul><p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p><table><thead><tr><th>SQL</th><th>MongoDB</th></tr></thead><tbody><tr><td>表(Table)</td><td>集合(Collection)</td></tr><tr><td>行(Row)</td><td>文档(Document)</td></tr><tr><td>列(Col)</td><td>字段(Field)</td></tr><tr><td>主键(Primary Key)</td><td>对象 ID(Objectid)</td></tr><tr><td>索引(Index)</td><td>索引(Index)</td></tr><tr><td>嵌套表(Embedded Table)</td><td>嵌入式文档(Embedded Document)</td></tr><tr><td>数组(Array)</td><td>数组(Array)</td></tr></tbody></table><p><strong>集合</strong><br>集合存储于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。</p><p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p><p><strong>文档</strong><br>BSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。</p><h3 id="mongodb特点"><a href="#mongodb特点" class="headerlink" title="mongodb特点"></a>mongodb特点</h3><ul><li>数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。</li><li>数据模型自由：不需要设计表结构，可以存储不同结构的文档。</li><li>支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li><li>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</li><li>高效的二进制存储：文档以键值对的形式存储在集合中，键(<code>ObjectId</code>类型)唯一标识文件，值是以 BSON 形式存在。</li><li>自带数据压缩功能：MongoDB 3.0 版本开始支持 <code>WiredTiger</code> 存储引擎，支持数据压缩，减少磁盘空间占用。</li><li>支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。</li><li>支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li><li>支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。</li><li>支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 <code>GridFS</code> 存储。</li></ul><h3 id="mongodb适合什么场景"><a href="#mongodb适合什么场景" class="headerlink" title="mongodb适合什么场景"></a>mongodb适合什么场景</h3><p>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。</p><h3 id="mongodb存储引擎"><a href="#mongodb存储引擎" class="headerlink" title="mongodb存储引擎"></a>mongodb存储引擎</h3><p>MongoDB 采用的是 <strong>插件式的存储引擎架构</strong>，现在主要使用两种存储引擎：</p><ul><li><code>MMAPv1</code> 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。</li><li><code>WiredTiger</code> 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 <code>WiredTiger</code> 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。</li><li><code>In-Memory</code> 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。</li></ul><h3 id="WiredTiger存储引擎"><a href="#WiredTiger存储引擎" class="headerlink" title="WiredTiger存储引擎"></a>WiredTiger存储引擎</h3><p><code>WiredTiger</code> 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。</p><p>使用 B+ 树时，<code>WiredTiger</code> 以 <code>page</code> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 <code>page</code>，共有三种类型的 <code>page</code>：</p><ul><li><code>root page</code>(根节点)：B+ 树的根节点。</li><li><code>internal page</code>(内部节点)：不实际存储数据的中间索引节点。</li><li><code>leaf page</code>(叶子节点)：真正存储数据的叶子节点，包含一个页头(<code>page header</code>)、块头(<code>block header</code>)和真正的数据(<code>key/value</code>)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 <code>checksum</code>、块在磁盘上的寻址位置等信息。</li></ul><h3 id="mongodb聚合"><a href="#mongodb聚合" class="headerlink" title="mongodb聚合"></a>mongodb聚合</h3><p>将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：</p><ul><li>将来自多个文档的值组合在一起。 </li><li>对集合中的数据进行的一系列运算。 </li><li>分析数据随时间的变化。</li></ul><p>两种聚合方法：</p><ul><li>聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。</li><li>单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li></ul><p>聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：</p><ul><li>接受一系列原始数据文档</li><li>对这些文档进行一系列运算</li><li>结果文档输出给下一个阶段</li></ul><h3 id="mongodb事务"><a href="#mongodb事务" class="headerlink" title="mongodb事务"></a>mongodb事务</h3><p>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</p><h3 id="mongodb数据压缩"><a href="#mongodb数据压缩" class="headerlink" title="mongodb数据压缩"></a>mongodb数据压缩</h3><p>借助 <code>WiredTiger</code> 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。<code>WiredTiger</code> 存储引擎支持以下压缩算法：</p><ul><li><code>snappy</code>：快速压缩算法，压缩比(3～5倍)较低，但速度快。</li><li><code>zlib</code>：压缩比(5～7倍)较高，但速度较慢。</li><li><code>Zstandard</code>：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li></ul><p><code>WiredTiger</code> 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。</p><h3 id="mongodb索引"><a href="#mongodb索引" class="headerlink" title="mongodb索引"></a>mongodb索引</h3><p>索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。</p><p>索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。</p><p><strong>索引类型</strong></p><ul><li>单字段索引：建立在单个字段上的索引。</li><li>复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li><li>多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li><li>哈希索引：按数据的哈希值索引，用在哈希分片集群上。</li><li>文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li><li>地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。</li><li>唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li><li>TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.</li></ul><h3 id="复合索引中字段顺序"><a href="#复合索引中字段顺序" class="headerlink" title="复合索引中字段顺序"></a>复合索引中字段顺序</h3><p>复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。</p><p>复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。</p><blockquote><p>有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p></blockquote><h3 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h3><p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code>，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p><p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p><p><strong>原理</strong></p><ul><li>MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li><li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 <code>oplog</code> 做同步。</li></ul><p><strong>TTL索引限制</strong></p><ul><li>TTL 索引是单字段索引。复合索引不支持 TTL</li><li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> NoSQL </tag>
            
            <tag> MySQL </tag>
            
            <tag> mongodb </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/posts/17770.html"/>
      <url>/posts/17770.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考 <a href="https://javaguide.cn/">JavaGuide</a></p></blockquote><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="常见网络模型"><a href="#常见网络模型" class="headerlink" title="常见网络模型"></a>常见网络模型</h3><ul><li>OSI七层模型：如下。</li><li>TCP&#x2F;IP四层模型：如下。</li><li>混合模型：混合模型结合了OSI模型和TCP&#x2F;IP模型的优点，以更好地解释和实现网络通信。<ul><li>五层模型： 物理层、数据链路层、网络层、传输层和应用层。 去除了OSI模型中的会话层和表示层，将它们的功能合并到应用层中。</li></ul></li><li>IEEE 802模型：主要用于局域网(LAN)和城域网(MAN)。包含物理层和数据链路层，进一步细分为介质访问控制(MAC)层和逻辑链路控制(LLC)层。</li></ul><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><ul><li>应用层：为计算机提供服务</li><li>表示层：数据处理(编码、解码、加密解密、压缩解压缩)</li><li>会话层：管理(建立、维护、重连)应用程序之间的会话</li><li>传输层：为两台主机进程之间的通信提供通用的数据传输服务</li><li>网络层：转发、路由和寻址(决定数据在网络中的游走路径)</li><li>数据链路层：帧编码和误差纠正控制</li><li>物理层：透明地传送比特流传输</li></ul><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><ul><li>应用层(应用层、表示层、会话层)</li><li>传输层</li><li>网络层</li><li>网络接口层(数据链路层、物理层)</li></ul><h3 id="为什么网络要分层"><a href="#为什么网络要分层" class="headerlink" title="为什么网络要分层"></a>为什么网络要分层</h3><p>复杂系统需要分层，每层专注于一类事情。主要有三个原因：</p><ul><li>各层之间相互独立，不需要关注其他层如何实现的，只需知道如何调用下层的接口。</li><li>提高了灵活性和可替换性。每层可使用最合适的技术实现，只需保证提供的功能及接口没改变就行。这也与平时系统开发高内聚、低耦合的原则契合。</li><li>将复杂的网络问题分解为较小的、清晰的小问题来处理解决，使得计算机网络系统易于设计和维护。</li></ul><h3 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h3><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><ul><li>HTTP(Hypertext Transfer Protocol，超文本传输协议)：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</li><li>SMTP(Simple Mail Transfer Protocol，简单邮件发送协议)：基于 TCP 协议，是一种用于发送电子邮件的协议。</li><li>POP3&#x2F;IMAP(邮件接收协议)：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。</li><li>FTP(File Transfer Protocol，文件传输协议): 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。(不安全，更安全可以用SFTP)</li><li>Telnet(远程登陆协议)：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据(包括用户名和密码)均以明文形式发送，这有潜在的安全风险。</li><li>SSH(Secure Shell Protocol，安全的网络传输协议)：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</li><li>RTP(Real-time Transport Protocol，实时传输协议)：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li>DNS(Domain Name System，域名管理系统): 基于 UDP 协议，用于解决域名和 IP 地址的映射问题，端口为 53。</li></ul><h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><ul><li>TCP(Transmission Control Protocol，传输控制协议 )：提供 面向连接 的，可靠 的数据传输服务。</li><li>UDP(User Datagram Protocol，用户数据协议)：提供 无连接 的，尽最大努力 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li></ul><h4 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h4><ul><li>IP(Internet Protocol，网际协议)：TCP&#x2F;IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。(IPv4、IPv6)</li><li>ARP(Address Resolution Protocol，地址解析协议)：ARP 协议解决的是网络层地址和链路层地址之间的转换问题(IP 地址转 MAC 地址)。</li><li>ICMP(Internet Control Message Protocol，互联网控制报文协议)：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。</li><li>NAT(Network Address Translation，网络地址转换协议)：用于内部网到外部网的地址转换过程中。</li><li>OSPF(Open Shortest Path First，开放式最短路径优先)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li>RIP(Routing Information Protocol，路由信息协议)：一种内部网关协议(Interior Gateway Protocol，IGP)，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li>BGP(Border Gateway Protocol，边界网关协议)：一种用来在路由选择域之间交换网络层可达性信息(Network Layer Reachability Information，NLRI)的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h3 id="浏览器输入URL到页面展示的过程"><a href="#浏览器输入URL到页面展示的过程" class="headerlink" title="浏览器输入URL到页面展示的过程"></a>浏览器输入URL到页面展示的过程</h3><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>连接建立后，浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL(如图片、CSS、JS 等)，再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。<ul><li>在解析HTML的过程中，浏览器会遇到外部资源如CSS、JavaScript、图像等，会再次发送请求获取这些资源。</li><li>浏览器解析CSS文件，构建CSSOM(CSS Object Model)，并与DOM树合并形成渲染树(Render Tree)。</li><li>如果有JavaScript代码，浏览器会暂停渲染，先执行JS代码，这可能改变DOM结构和样式。</li><li>浏览器计算每个元素的位置和尺寸，进行布局，然后将渲染树绘制到屏幕上。</li><li>事件监听与用户交互：直到页面变得可交互，浏览器开始监听用户的动作，如点击、滚动等。</li></ul></li><li>浏览器在页面加载完成后或不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li><li>后续操作：浏览器可能继续监听用户事件，执行异步JS代码，处理AJAX请求等。</li></ol><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>URL(Uniform Resource Locators)，即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。</p><p><img src="/./image/Computer-Basic/URL-parts.png" alt="URL的组成"></p><ul><li>协议：用于指定访问资源的协议，如 http、https、ftp(文件传输)、file(本地文件)、mailto(邮件)、telnet(远程登录)等。</li><li>域名&#x2F;IP：用于指定资源所在的主机名或 IP 地址。</li><li>端口号：用于指定访问资源的端口号，HTTP默认端口号是 80，HTTPS默认端口号是 443。</li><li>资源路径：从第一个&#x2F;开始，表示从服务器上根目录开始进行索引到的文件路径。</li><li>参数：浏览器在向服务器提交请求时，在 URL 中附带着参数会提取这些参数。参数采用键值对的形式<code>key=value</code>，每一个键值对使用<code>&amp;</code>隔开。</li><li>锚点：锚点就是在要访问的页面上的一个锚点，可以直接跳转到指定的位置。在 URL 中，锚点以<code>#</code>开头，并且不会作为请求的一部分发送给服务端。</li></ul><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>DNS(Domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议，解决的是域名和 IP 地址的映射问题。</p><p><img src="/./image/Computer-Basic/dns-overview.png" alt="DNS解析过程"></p><p>浏览器在本地维护一个<code>hosts</code>列表，用户访问网址时，先查看要访问的域名是否在<code>hosts</code>列表中，如果有就直接提取对应的 IP 地址记录，如果没有就使用 DNS 服务器获取域名和 IP 地址的映射。</p><p><strong>DNS服务器</strong><br>DNS 服务器自底向上几个层级：</p><ul><li>根域名服务器：负责管理顶级域名服务器的 IP 地址。世界上有 600多个根服务器，但只有 13 个 IP 地址。为了提高 DNS 的可靠性、安全性和性能，每个IP地址对应多个服务器。</li><li>顶级域 DNS 服务器(TLD 服务器)：负责管理各个顶级域名服务器的 IP 地址。如 <code>.com</code>、<code>.cn</code>、<code>.org</code>、<code>.net</code> 等。</li><li>权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，如baidu.com 的 DNS 服务器，负责管理该域名下的所有子域名。</li><li>本地 DNS 服务器：每个 ISP(互联网服务提供商)都有一个自己的本地 DNS 服务器。</li></ul><p><strong>DNS工作流程</strong><br>主机<code>cis.poly.edu</code>想知道<code>gaia.cs.umass.edu</code>的 IP 地址。<br><img src="/./image/Computer-Basic/DNS-process.png" alt="迭代式查询"><br><img src="/./image/Computer-Basic/DNS-process2.png" alt="递归式查询"></p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error(<strong><em>客户端错误状态码</em></strong>)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(<strong><em>服务器错误状态码</em></strong>)</td><td>服务器处理请求出错</td></tr></tbody></table><ul><li><p><code>200 OK</code>：请求被成功处理。如发送查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。</p></li><li><p><code>201 Created</code>：请求被成功处理并且在服务端创建了一个新的资源。如通过 POST 请求创建一个新的用户。</p></li><li><p><code>202 Accepted</code>：服务端已接收到了请求，但还未处理。</p></li><li><p><code>204 No Content</code>：服务端已经成功处理了请求，但是没有返回任何内容。</p></li><li><p><code>206 Partial Content</code>：服务端成功处理了部分请求。如请求一个大文件，服务端只返回了部分内容。</p></li><li><p><code>301 Moved Permanently</code>：资源被永久重定向了。如网站的网址更换了。</p></li><li><p><code>302 Found</code>：资源被临时重定向了。如网站暂时关闭，重定向到一个临时的页面。</p></li><li><p><code>304 Not Modified</code>：客户端发送了一个条件式请求，服务端告诉客户端资源未被修改，可以使用缓存的资源。</p></li><li><p><code>400 Bad Request</code>：发送的 HTTP 请求存在问题。如请求参数不合法、请求方法错误。</p></li><li><p><code>401 Unauthorized</code>：未认证却请求需要认证之后才能访问的资源。</p></li><li><p><code>403 Forbidden</code>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p></li><li><p><code>404 Not Found</code>：请求的资源未在服务端找到。如请求某个用户的信息，服务端并没有找到指定的用户。</p></li><li><p><code>409 Conflict</code>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p></li><li><p><code>500 Internal Server Error</code>：服务端出问题了(通常是服务端出 Bug 了)。如服务端处理请求的时候突然抛出异常，但异常并未在服务端被正确处理。</p></li><li><p><code>502 Bad Gateway</code>：网关将请求转发到服务端，但服务端返回的却是一个错误的响应。</p></li></ul><h3 id="HTTP-HTTPS区别"><a href="#HTTP-HTTPS区别" class="headerlink" title="HTTP&#x2F;HTTPS区别"></a>HTTP&#x2F;HTTPS区别</h3><p><strong>基本概念</strong></p><ul><li>HTTP协议：用来规范超文本的传输，主要用来是规范浏览器和服务器端的行为。扩展性强、速度快、跨平台支持性好。</li><li>HTTPS协议：HTTPS基于HTTP协议，并使用 SSL&#x2F;TLS 协议用作加密和安全认证，其更安全可靠。保密性好、信任度高。</li></ul><blockquote><p>HTTP和HTTPS协议都需要三次握手建立连接、四次挥手断开连接。</p></blockquote><p><strong>HTTP和HTTPS的区别</strong></p><ul><li>HTTP是明文传输，HTTPS使用SSL进行加密加密传输，更安全可靠。</li><li>HTTP默认端口是80，HTTPS默认端口是443。</li><li>HTTP连接简单，无状态，HTTPS握手阶段比较费时，所以HTTP比HTTPS快。</li></ul><p><strong>HTTP通信过程</strong><br>HTTP 是应用层协议，它以 TCP(传输层)作为底层协议，通信过程主要如下：</p><ul><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接(创建套接字 Socket)。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ul><h3 id="SSL-TSL协议加密原理"><a href="#SSL-TSL协议加密原理" class="headerlink" title="SSL&#x2F;TSL协议加密原理"></a>SSL&#x2F;TSL协议加密原理</h3><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><p>SSL&#x2F;TLS 的加密的原理是非对称加密和对称加密的配合使用。对称加密用来加密数据，并生成唯一私有密钥 k，非对称加密用来加密k。通信双方(Client、Server)只需要一次非对称加密，交换对称加密的密钥k，在之后的信息通信中，使用绝对安全的密钥k，对信息进行对称加密，即可保证传输消息的保密性。</p><ul><li>非对称加密采用两个密钥：公钥、私钥。在通信时，私钥仅由Server保存，公钥由Client所知晓。公钥用于加密数据，私钥用于解密数据。</li><li>对称加密中双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密。</li></ul><p><strong>公钥传输隐患</strong><br>假设存在攻击者 A，其对应服务器为AServer，A发送给Client一个假包，假装是Server公钥，其实是诱饵服务器 AServer的公钥，Client收到后误以为是 Server的公钥，Client后续使用AServer公钥加密密钥k，然后在公开信道传输，那么攻击者 A可以捕获加密的包，然后用AServer的私钥解密，得到密钥k，这样攻击者 A 就可以解密Client和Server之间的通信。</p><p><strong>数字证书</strong><br>为了解决这个问题，需要使用数字证书，数字证书是由权威机构(CA，Certificate Authority)颁发的，用于证明公钥的合法性。具体流程如下：<br>假设有服务器 Server，CA 机构，客户端 Client。</p><ol><li>Server信任 CA，CA也知道 Server公钥，CA首先为 Server颁发证书(包含 Server公钥)，采用散列技术为证书生成一个摘要，然后使用 CA私钥对摘要进行加密，生成数字签名。</li><li>Server获得 CA颁发的证书和数字签名，并在 Client请求时，将证书和数字签名一并发送给 Client。</li><li>Client信任 CA并知晓 CA公钥。Client在收到 Server的证书和数字签名时，使用 CA公钥解密数字签名，得到摘要，然后使用相同的散列技术为证书生成摘要。</li><li>Client对比两个摘要是否一致，如果一致则证明证书(包含 Server公钥)是真实的，可以使用 Server公钥加密密钥k，然后在公开信道传输。</li></ol><h3 id="HTTP无状态如何保存用户状态"><a href="#HTTP无状态如何保存用户状态" class="headerlink" title="HTTP无状态如何保存用户状态"></a>HTTP无状态如何保存用户状态</h3><p>可以使用 Session 机制来保存用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了(一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)。</p><p>服务端可以使用内存和数据库保存Session，Session 跟踪是通过在客户端的 Cookie 中存放 Session ID 来实现的。如果 Cookie被禁用可以利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h3 id="URI-URL区别"><a href="#URI-URL区别" class="headerlink" title="URI&#x2F;URL区别"></a>URI&#x2F;URL区别</h3><ul><li>URI(Uniform Resource Identifier)是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator)是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h3 id="Session-Cookie区别"><a href="#Session-Cookie区别" class="headerlink" title="Session&#x2F;Cookie区别"></a>Session&#x2F;Cookie区别</h3><ul><li>存储位置不同：Cookie 存储在客户端，Session 存储在服务端。</li><li>存储容量不同：单个Cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie。Session 存储在服务端，一般没有存储容量限制，但考虑服务器性能，一般会设置 Session 的有效期和存储容量。</li><li>安全性不同：Cookie 存储在客户端，容易被篡改，不安全。Session 存储在服务端，相对安全。</li><li>生命周期不同：Cookie 有过期时间，可以设置长期有效的 Cookie。Session 一般保存在内存中，会话结束后会被销毁。</li><li>作用范围不同：Cookie 的作用范围是整个域名，Session 的作用范围是当前会话。</li><li>传输方式不同：Cookie 会随着 HTTP 请求一起发送到服务端，Session 保存在服务端，客户端只会收到 Session ID。</li></ul><h3 id="GET-POST区别"><a href="#GET-POST区别" class="headerlink" title="GET&#x2F;POST区别"></a>GET&#x2F;POST区别</h3><ul><li>GET 用于获取或查询资源，POST 用于创建或修改资源。</li><li>GET 请求是幂等的，即多次重复执行不会改变资源的状态，POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li><li>GET 请求参数会附加在 URL 后面，POST 请求参数会放在请求体(<code>body</code>)中。</li><li>GET 请求的URL长度受到浏览器和服务器的限制，POST 请求的 <code>body</code>大小则没有明确的限制。</li><li>由于 GET 请求是幂等的，可以被缓存，而POST 请求是不幂等的，不适合被缓存。</li><li>GET 请求的安全性较差，参数会暴露在 URL 中，POST 请求的安全性较好，参数在请求体中，不会暴露在 URL 中。</li></ul><blockquote><p>幂等：一个操作、方法或函数被调用多次，其结果与仅调用一次相同。</p></blockquote><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p><p>WebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。</p><h3 id="WebSocket-HTTP区别"><a href="#WebSocket-HTTP区别" class="headerlink" title="WebSocket&#x2F;HTTP区别"></a>WebSocket&#x2F;HTTP区别</h3><ul><li>WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。</li><li>WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。</li><li>WebSocket 使用 <code>ws://</code> 或 <code>wss://</code>作为协议前缀，HTTP 使用 <code>http://</code> 或 <code>https://</code>作为协议前缀。</li><li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。</li><li>WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。</li></ul><h3 id="WebSocket工作流程"><a href="#WebSocket工作流程" class="headerlink" title="WebSocket工作流程"></a>WebSocket工作流程</h3><ol><li>客户端向服务器发起一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code>等字段，表示要求升级协议为 WebSocket。</li><li>服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复<code>HTTP 101</code>状态码，响应头中包含<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Accept:xxx</code>等字段，表示升级成功。</li><li>现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。</li><li>关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。</li></ol><h3 id="PING命令原理"><a href="#PING命令原理" class="headerlink" title="PING命令原理"></a>PING命令原理</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 www.baidu.com</span><br><span class="line">PING www.baidu.com(36.155.132.3): 56 data bytes</span><br><span class="line">64 bytes from 36.155.132.3: icmp_seq=0 ttl=49 time=8.890 ms</span><br><span class="line">64 bytes from 36.155.132.3: icmp_seq=1 ttl=49 time=8.874 ms</span><br><span class="line">64 bytes from 36.155.132.3: icmp_seq=2 ttl=49 time=9.136 ms</span><br><span class="line">64 bytes from 36.155.132.3: icmp_seq=3 ttl=49 time=9.400 ms</span><br><span class="line"></span><br><span class="line">--- www.baidu.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 8.874/9.075/9.400/0.214 ms</span><br></pre></td></tr></table></figure><p>输出由以下几部分组成：</p><ul><li>ICMP Echo Request(请求报文)信息：序列号、TTL(Time to Live)值。</li><li>目标主机的域名或 IP 地址：输出结果的第一行。</li><li>往返时间(RTT，Round-Trip Time)：从发送 ICMP Echo Request(请求报文)到接收到 ICMP Echo Reply(响应报文)的总时间，用来衡量网络连接的延迟。</li><li>统计结果(Statistics)：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间(RTT)的最小、平均、最大和标准偏差值。</li></ul><p>如果PING目标主机无法正确响应，则说明网络连通性出现问题。</p><p>PING命令的原理是基于 ICMP 协议，通过发送 ICMP Echo Request(请求报文)到目标主机，目标主机收到请求后，会返回 ICMP Echo Reply(响应报文)给发送方，从而实现网络连通性的测试。</p><h3 id="HTTP-TCP区别"><a href="#HTTP-TCP区别" class="headerlink" title="HTTP&#x2F;TCP区别"></a>HTTP&#x2F;TCP区别</h3><ul><li><strong>TCP</strong> 是一种底层的传输协议，提供可靠的数据传输。</li><li><strong>HTTP</strong> 是一种应用层协议，使用 TCP 作为其传输层协议，专门用于 web 数据的传输。</li></ul><ol><li><strong>层次</strong>：TCP 位于传输层，HTTP 位于应用层。</li><li><strong>功能</strong>：TCP 提供可靠的、面向连接的通信。HTTP 用于在客户端和服务器之间传输超文本数据(如 HTML 文档、图片、视频等)。</li><li><strong>连接方式</strong>：TCP 通过三次握手建立连接，确保通信双方准备就绪。HTTP 基于请求-响应模型，客户端发送请求，服务器返回响应。</li><li><strong>数据传输</strong>：TCP 是流式传输数据，没有消息边界。HTTP 是面向消息，每个请求和响应都是独立的。</li><li><strong>错误检测和恢复</strong>：TCP 具有错误检测和恢复机制，保证数据完整性。HTTP 没有错误检测和恢复机制，需要依赖 TCP 来保证数据传输的可靠性。且 HTTP 无状态，依赖于 Cookie 和 Session 来保存用户状态。</li><li><strong>用途</strong>：TCP 适用于需要高可靠性的数据传输，如文件传输、电子邮件等。HTTP 主要用于万维网(WWW)上的数据通信，如浏览网页、提交表单等。</li></ol><p>HTTP 是建立在 TCP 之上的，它利用 TCP 提供的可靠连接来传输数据，但它们在网络模型中的层次和具体功能上有所不同。</p><h3 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h3><p>二者都是常见的传输层协议。</p><ul><li>TCP(Transmission Control Protocol，传输控制协议 )：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li><li>UDP(User Datagram Protocol，用户数据协议)：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务(不保证数据传输的可靠性)，简单高效。</li></ul><p>区别总结：</p><ol><li>TCP面向连接(三次握手四次挥手)，UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如实时视频会议)</li><li>TCP只支持点对点通信，UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节，UDP的首部开销小，只有8个字节</li><li>TCP通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><p>原文链接：<a href="https://blog.csdn.net/Li_Ning_/article/details/52117463">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p><h3 id="TCP-UDP应用场景"><a href="#TCP-UDP应用场景" class="headerlink" title="TCP&#x2F;UDP应用场景"></a>TCP&#x2F;UDP应用场景</h3><p><a href="https://blog.csdn.net/qq_44273429/article/details/131375961">https://blog.csdn.net/qq_44273429/article/details/131375961</a></p><p>由于TCP提供了可靠的、有序的数据传输，它适用于以下场景：</p><ul><li>文件传输：TCP的可靠性和有序性确保了文件在传输过程中不会丢失和损坏，并按正确的顺序接收。</li><li>网页浏览：TCP可靠地传输网页内容，确保网页的准确显示。</li><li>电子邮件传输：TCP保证电子邮件的传输不会出现丢失或乱序的情况。</li><li>远程登录：TCP提供了稳定的连接，适合远程登录操作。</li><li>数据库管理系统：TCP确保了数据库的一致性和完整性，防止数据丢失和损坏。</li></ul><p>由于UDP具有低延迟和高效性的特点，它适用于以下场景：</p><ul><li>视频流和音频流传输：由于UDP的低延迟，它常用于视频流和音频流的实时传输，如在线直播、视频会议等。</li><li>实时游戏：UDP的快速传输和低延迟使其成为在线游戏中常用的协议，可以实现实时的游戏数据传输。</li><li>DNS(域名系统)：UDP广泛用于域名系统中，用于域名解析和查询。</li><li>实时传感器数据：UDP适用于需要快速传输实时传感器数据的场景，如工业自动化、物联网等</li></ul><h3 id="UDP的广播和多播"><a href="#UDP的广播和多播" class="headerlink" title="UDP的广播和多播"></a>UDP的广播和多播</h3><ul><li>UDP广播是指将数据包发送到同一子网内的所有设备。广播消息使用了一个特殊的IP地址，该地址的子网内主机标志部分的二进制全部为1(即点分十进制IP的最后一部分是255)。例如，在子网192.168.1.x中，广播地址是192.168.1.255。<ul><li>特点：<ul><li>广播消息可以被子网内的所有设备接收，无需设备事先注册或加入特定的组。</li><li>广播只能在局域网内使用，广域网中无法使用UDP进行广播。</li><li>广播的开销较小，因为发送者只需发送一个数据包，而该数据包会被子网内的所有设备接收。</li></ul></li><li>应用场景：<ul><li>局域网内的通知或广播消息，如DHCP(动态主机配置协议)服务器向局域网内的设备发送IP地址分配信息。</li><li>局域网内的设备发现或同步操作，如打印机共享或文件同步服务。</li></ul></li></ul></li><li>UDP多播(也称为组播)是一种将数据包发送到一组特定接收者的网络通信模式。多播使用特定的多播地址(在IPv4中为224.0.0.0到239.255.255.255范围内的地址)，该地址标识了一组接收数据的接口。<ul><li>特点：<ul><li>多播比广播具有更高的可控性，只有加入多播组的接收者才能接收数据。</li><li>多播不仅限于局域网，也可以用于广域网环境，适用于在大型网络中分发数据。</li><li>多播地址由IANA(互联网号码分配机构)进行全球分配和管理。</li></ul></li><li>应用场景：<ul><li>视频直播：将视频数据同时分发给大量观众。 </li><li>文件分发：向大量客户端分发相同文件。 </li><li>在线游戏：实现游戏房间的快速组建和对手匹配。 </li><li>监控系统：将视频数据同时分发给多个监控终端。 </li><li>分布式计算：将计算任务分发给多个节点。</li></ul></li></ul></li></ul><p>多播工作工程：</p><ol><li>发送者创建一个UDP套接字，并设置多播属性。</li><li>发送者使用sendto()函数向多播地址发送数据。</li><li>网络设备(如路由器)根据多播路由协议(如IGMP、PIM等)将数据包转发到需要接收该数据的各个网段。</li><li>接收者通过加入多播组来接收数据，使用setsockopt()函数设置套接字加入多播组。</li></ol><h3 id="如何将UDP变为将TCP那样可靠"><a href="#如何将UDP变为将TCP那样可靠" class="headerlink" title="如何将UDP变为将TCP那样可靠"></a>如何将UDP变为将TCP那样可靠</h3><p>要使 UDP 像 TCP 那样可靠，需要在应用层实现类似 TCP 的功能。以下是一些常见的方法和步骤：</p><ol><li>数据包确认机制(<code>ACK</code>)：每当接收方收到一个数据包时，它会发送一个确认(<code>ACK</code>)回给发送方。发送方在发送数据包后会等待 <code>ACK</code>，如果在一定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li><li>序列号：在每个数据包中添加一个序列号，以便接收方可以按顺序重组数据包，并检测丢失或重复的数据包。</li><li>超时和重传：发送方在发送每个数据包后启动一个定时器。如果在规定时间内没有收到 <code>ACK</code>，则会重传该数据包。</li><li>滑动窗口：使用滑动窗口协议来控制数据包的流动。发送方可以在等待 <code>ACK</code> 的同时继续发送多个数据包，从而提高传输效率。</li><li>校验和：在数据包中包含校验和，以检测数据包在传输过程中是否被损坏。接收方会检查校验和，并丢弃任何损坏的数据包。</li><li>流量控制：发送方和接收方协商一个窗口大小，以确保发送方不会超过接收方的处理能力。</li></ol><h3 id="三次握手四次挥手✅"><a href="#三次握手四次挥手✅" class="headerlink" title="三次握手四次挥手✅"></a>三次握手四次挥手✅</h3><p>建立 TCP 连接需要“三次握手”，缺一不可：</p><ul><li>一次握手:客户端发送带有 <code>SYN</code>(SEQ&#x3D;x)标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入 <code>SYN_SEND</code> 状态，等待服务端的确认；</li><li>二次握手:服务端发送带有 <code>SYN+ACK</code>(SEQ&#x3D;y,ACK&#x3D;x+1)标志的数据包 <code>–&gt;</code> 客户端，然后服务端进入 <code>SYN_RECV</code> 状态；</li><li>三次握手:客户端发送带有 <code>ACK</code>(ACK&#x3D;y+1)标志的数据包 <code>–&gt;</code> 服务端，然后客户端和服务端都进入<code>ESTABLISHED</code>状态，完成 TCP 三次握手。</li></ul><p>注意，连接建立后，客户端和服务端都可以发送数据。</p><p>断开 TCP 连接则需要“四次挥手”，缺一不可：</p><ul><li>第一次挥手：客户端发送一个 <code>FIN</code>(SEQ&#x3D;x)标志的数据包 <code>-&gt;</code> 服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 <code>FIN-WAIT-1</code> 状态。</li><li>第二次挥手：服务端收到<code>FIN</code>标志的数据包，它发送一个 <code>ACK</code>(ACK&#x3D;x+1)标志的数据包 <code>-&gt;</code> 客户端。然后服务端进入 <code>CLOSE-WAIT</code> 状态，客户端进入 <code>FIN-WAIT-2</code>状态。</li><li>第三次挥手：服务端发送一个 <code>FIN</code>(SEQ&#x3D;y)标志的数据包 <code>-&gt;</code> 客户端，请求关闭连接，然后服务端进入 <code>LAST-ACK</code> 状态。</li><li>第四次挥手：客户端发送 <code>ACK</code>(ACK&#x3D;y+1)标志的数据包 <code>-&gt;</code> 服务端，然后客户端进入<code>TIME-WAIT</code>状态，服务端在收到 <code>ACK</code>(ACK&#x3D;y+1)标志的数据包后进入 <code>CLOSE</code> 状态。此时如果客户端等待 <code>2MSL</code> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ul><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p><blockquote><p>2MSL, Maximum Segment Lifetime，即最长报文段寿命的两倍。</p></blockquote><p><img src="/./image/Computer-Basic/tcp-shakes-hands-three-times.png" alt="三次握手"></p><p><img src="/./image/Computer-Basic/tcp-waves-four-times.png" alt="四次挥手"></p><h3 id="TIME-WAIT-CLOSE-WAIT是什么"><a href="#TIME-WAIT-CLOSE-WAIT是什么" class="headerlink" title="TIME_WAIT&#x2F;CLOSE_WAIT是什么"></a>TIME_WAIT&#x2F;CLOSE_WAIT是什么</h3><p><code>TIME_WAIT/CLOSE_WAIT</code>是TCP关闭连接过程中出现的两种状态。</p><ul><li><code>CLOSE_WAIT</code>是被动关闭连接的一方(通常是服务器)出现的一种状态，当TCP连接的一端(被动关闭方)收到对方发送的FIN报文时，会发送一个<code>ACK</code>报文作为响应，并进入<code>CLOSE_WAIT</code>状态。</li><li><code>TIME_WAIT</code>是主动关闭连接的一方(通常是客户端)出现的一种状态，当主动关闭连接的一方收到对方发送的<code>FIN</code>报文并发送自己的<code>ACK</code>报文后，就会进入<code>TIME_WAIT</code>状态。这个状态会持续<code>2MSL</code>(两倍的报文最大生存时间)。</li></ul><h3 id="半连接队列-全连接队列"><a href="#半连接队列-全连接队列" class="headerlink" title="半连接队列&#x2F;全连接队列"></a>半连接队列&#x2F;全连接队列</h3><p>在三次握手中，Linux 内核会维护两个队列管理连接请求：</p><ul><li>半连接队列(也称 SYN Queue)：当服务端收到客户端的 <code>SYN</code> 请求时，此时双方还没有完全建立连接，服务端会把半连接状态的连接放在半连接队列。</li><li>全连接队列(也称 Accept Queue)：当服务端收到客户端的 <code>ACK</code> 请求时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。若未收到 <code>ACK</code> 请求，会进行重传，若超过最大重传次数，系统将从半连接队列中删除该连接信息。</li></ul><p>两队列的存在是为了处理并发请求，确保服务端能够有效地管理新的连接请求。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手为的是确认双方收发功能都正常，缺一不可。</p><ul><li>第一次握手：Client 无法确认任何信息；Server 确认了：对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ul><h3 id="第二次握手为何传回ACK和SYN"><a href="#第二次握手为何传回ACK和SYN" class="headerlink" title="第二次握手为何传回ACK和SYN"></a>第二次握手为何传回ACK和SYN</h3><p><strong>为什么传回ACK</strong><br>第二次握手中，服务端传回 <code>ACK</code> 是为了确认接收到客户端的 <code>SYN</code> 报文。<br><strong>为什么传回SYN</strong><br>在第一次握手中，客户端发送 <code>SYN</code>包 是为了建立客户端到服务端的连接，然而 TCP 连接是双向的，服务端到客户端也需要建立连接，所以服务端在第二次握手中向客户端发送 <code>SYN</code>包，以建立服务端到客户端的连接。</p><p>同时发送 <code>SYN</code> 包和 <code>ACK</code>包，服务器能够在一个报文中同时完成这两个操作，从而减少报文的数量，加快连接建立的效率。</p><h3 id="三次握手中可以携带数据吗"><a href="#三次握手中可以携带数据吗" class="headerlink" title="三次握手中可以携带数据吗"></a>三次握手中可以携带数据吗</h3><p>允许在第三次发送 <code>ACK</code> 的时候携带数据，但是不建议这样做，因为在第三次握手时，服务端还没有确认客户端的 <code>ACK</code> 包，可能会导致数据丢失。</p><h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><ul><li>确保数据传输的完整性和可靠性：在任何一方关闭连接之前，确保所有数据都已正确接收和处理。</li><li>保证双向关闭的确认：TCP 是全双工通信，每一方都需要确认对方的关闭请求，以避免数据丢失和连接的不正常终止。</li><li>避免半开连接：确保在关闭过程中，没有未完成的数据传输或者遗留的数据包。</li><li>保证连接的有序终止：TCP 是全双工的，每一方都需要单独关闭自己的发送和接收通道，因此需要四步来完成这一过程。</li></ul><p>四次挥手虽然复杂，但却能够确保连接的稳定、可靠和有序终止。</p><h3 id="为何不能把服务端发送的ACK和FIN合并变成三次挥手"><a href="#为何不能把服务端发送的ACK和FIN合并变成三次挥手" class="headerlink" title="为何不能把服务端发送的ACK和FIN合并变成三次挥手"></a>为何不能把服务端发送的ACK和FIN合并变成三次挥手</h3><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 <code>ACK</code>，表示接收到了断开连接的请求。等到数据发完之后再发 <code>FIN</code>，断开服务端到客户端的数据传送。</p><h3 id="如果第二次挥手客户端未收到服务端发送的ACK会怎样"><a href="#如果第二次挥手客户端未收到服务端发送的ACK会怎样" class="headerlink" title="如果第二次挥手客户端未收到服务端发送的ACK会怎样"></a>如果第二次挥手客户端未收到服务端发送的ACK会怎样</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h3 id="为什么第四次握手客户端需等待2-MSL"><a href="#为什么第四次握手客户端需等待2-MSL" class="headerlink" title="为什么第四次握手客户端需等待2*MSL"></a>为什么第四次握手客户端需等待2*MSL</h3><p>第四次挥手时，客户端发送服务端的 <code>ACK</code> 有可能丢失，如果服务端没收到 <code>ACK</code> 的话，服务端就会重发 <code>FIN</code>，如果客户端在 <code>2*MSL</code> 的时间内收到了 <code>FIN</code>，就会重新发送 <code>ACK</code> 并再次等待 <code>2MSL</code>，防止 Server 没有收到 <code>ACK</code> 而不断重发 <code>FIN</code>。</p><blockquote><p><code>MSL</code>(Maximum Segment Lifetime): 一个片段在网络中最大的存活时间，<code>2MSL</code> 就是一个发送和一个回复所需的最大时间。如果直到 <code>2MSL</code>，Client 都没有再次收到 <code>FIN</code>，那么 Client 推断 <code>ACK</code> 已经被成功接收，则结束 <code>TCP</code> 连接。</p></blockquote><h3 id="TCP如何保证连接可靠性"><a href="#TCP如何保证连接可靠性" class="headerlink" title="TCP如何保证连接可靠性"></a>TCP如何保证连接可靠性</h3><ol><li>基于数据块传输：数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li>对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，给每个包一个序列号，这使得能够将接收到的数据根据序列号排序，去掉重复序列号的数据就可以实现数据包去重。</li><li>校验和：TCP 有端到端的校验和机制，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃此报文段和不确认收到此报文段。</li><li>重传机制：在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答(ACK)。<ul><li>超时重传：当发送方发送数据后，如果超时重传计时器超时，仍没有收到接收方的确认应答，就会重传数据包。</li><li>快速重传：当发送方连续收到三个重复的 ACK 时，立即重传相应的数据包，而不必等待超时。</li></ul></li><li>TCP 连接每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 利用滑动窗口实现流量控制。</li><li>拥塞控制：当网络拥塞时，减少数据的发送。TCP 在发送数据的时候会考虑网络的拥塞程度，由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li></ol><h3 id="如何实现快速重传"><a href="#如何实现快速重传" class="headerlink" title="如何实现快速重传"></a>如何实现快速重传</h3><p>快速重传(Fast Retransmit)：当发送方连续收到三个重复的ACK时，立即重传相应的数据包，而不必等待超时。</p><ul><li>快速重传就是要发送方尽快重传，而不是等待超时重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时捎带<code>ACK</code>，而是立即发送<code>ACK</code>。</li><li>即使收到了失序的报文段，也要立即发送对自己收到的报文段的重复确认<code>ACK</code>。</li><li>发送方一旦收到三个连续的<code>ACK</code>，就立即重传对应的报文段，而不必等待超时重传计时器超时。</li><li>使用快速重传可以将网络吞吐量提高 20%~30%。</li></ul></li></ul><h3 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="为什么需要流量控制"><a href="#为什么需要流量控制" class="headerlink" title="为什么需要流量控制"></a>为什么需要流量控制</h3><p>因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果处理不过来，会先将数据放入接收缓冲区(Receiving Buffers)里。如果接收缓冲区满了，就只能把再收到的数据包丢掉。而丢包会浪费网络资源。因此要让接收方与发送方处于一种动态平衡。</p><h3 id="为什么要进行拥塞控制"><a href="#为什么要进行拥塞控制" class="headerlink" title="为什么要进行拥塞控制"></a>为什么要进行拥塞控制</h3><p>拥塞控制是为了避免网络拥塞，确保网络的稳定性和可靠性。当网络中的数据包过多，超过网络的处理能力时，就会发生拥塞，导致数据包丢失、延迟增加、吞吐量下降等问题。拥塞控制的目的是通过限制发送方的发送速率，避免过多的数据包注入到网络中，从而保持网络的正常运行。</p><h3 id="TCP拥塞控制的四种算法"><a href="#TCP拥塞控制的四种算法" class="headerlink" title="TCP拥塞控制的四种算法"></a>TCP拥塞控制的四种算法</h3><p><a href="https://blog.csdn.net/love_668/article/details/116913790">https://blog.csdn.net/love_668/article/details/116913790</a></p><ul><li>慢开始(Slow Start)：初始阶段发送方以指数增长的方式增加拥塞窗口(Congestion Window, cwnd)，逐渐探测网络的可用带宽。</li><li>拥塞避免(Congestion Avoidance)：当<code>cwnd</code>达到慢启动阈值(Slow Start Threshold, ssthresh)时，<code>cwnd</code>以线性增长方式增加。<ul><li>发送方维护一个拥塞窗口(<code>cwnd</code>)，用于控制发送数据的速率，其值取决于网络的拥塞程度，并且动态变化。<ul><li><code>cwnd</code>的维护原则：只要网络没有拥塞，就增大<code>cwnd</code>，以提高发送速率；一旦网络出现拥塞，就减小<code>cwnd</code>。</li><li>判断拥塞依据：没有按时收到应当到达的报文(即发生超时重传)。</li></ul></li><li>发送方将拥塞窗口作为发送窗口<code>swnd</code>，即<code>swnd=cwnd</code>。</li><li>维护一个慢开始门限<code>ssthresh</code>状态变量：<ul><li>当<code>cwnd &lt; ssthresh</code>时，使用慢开始算法；</li><li>当<code>cwnd &gt; ssthresh</code>时，停止使用慢开始算法而改用拥塞避免算法；</li><li>当<code>cwnd = ssthresh</code>时，既可以使用慢开始算法，也可以使用拥塞避免算法；</li></ul></li><li>在TCP双方建立逻辑连接关系时，<code>cwnd</code>的值被设置为1，慢开始门限ssthresh值进行设置(假设为 16)。</li></ul><ol><li>慢开始阶段：<code>cwnd</code>从1开始，每收到一个<code>ACK</code>，<code>cwnd</code>加倍，即<code>cwnd = cwnd * 2</code>，直到<code>cwnd &gt;= ssthresh</code>。</li><li>当<code>cwnd &gt;= ssthresh</code>，开始执行拥塞避免算法，<code>cwnd</code>每次只增加1，即<code>cwnd = cwnd + 1</code>。</li><li>如果此时部分数据报文段丢失,那么发送方会对这些丢失的数据报文段进行超时重传。发送方以此判断可能发生了网络拥塞，进行调整：将慢开始门限值<code>ssthresh</code>值更新为发生拥塞时<code>cwnd</code>值的一半；将<code>cwnd</code>的值减少为1，并重新开始执行慢开始算法。</li><li>当<code>cwnd</code>重新达到新的<code>ssthresh</code>时，再次执行拥塞避免算法。</li></ol></li><li>快速重传(Fast Retransmit)：当发送方连续收到三个重复的ACK时，立即重传相应的数据包，而不必等待超时。</li><li>快速恢复(Fast Recovery)：在快速重传后，<code>cwnd</code>减半，但不重新进入慢启动，而是进入快速恢复阶段，通过继续发送数据来尽快恢复网络的正常传输。<ul><li>有时候个别报文丢失，但实际上并没有网络拥塞。这导致发送发超时重传，误认为发生了网络拥塞，错误地使用慢开始算法，降低了网络的传输效率。为了解决这个问题，TCP引入了快速重传机制、快速恢复机制。</li><li>快速重传就是要发送方尽快重传，而不是等待超时重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时捎带<code>ACK</code>，而是立即发送<code>ACK</code>。</li><li>即使收到了失序的报文段，也要立即发送对自己收到的报文段的重复确认<code>ACK</code>。</li><li>发送方一旦收到三个连续的<code>ACK</code>，就立即重传对应的报文段，而不必等待超时重传计时器超时。</li><li>使用快速重传可以将网络吞吐量提高 20%~30%。</li></ul></li><li>发送方收到三个重复的<code>ACK</code>，就知道只是丢失了个别报文，所以不使用慢开始算法，而是使用快恢复算法。<ul><li>发送方将慢开始门限<code>ssthresh</code>和拥塞窗口<code>cwnd</code>设置为原来<code>cwnd</code>的一半，然后执行拥塞避免算法。</li><li>有的快恢复算法实现是将新的拥塞窗口设置的大一点，即<code>cwnd = ssthresh(cwnd/2) + 3</code>，然后执行拥塞避免算法。</li></ul></li></ul></li></ul><p><img src="/./image/Computer-Basic/20210517113954737.png" alt="TCP拥塞控制"></p><blockquote><p>注意：<br>慢开始是指一开始向网络中注入的报文少，并不是指<code>cwnd</code>的增长速度慢；<br>拥塞避免并非不能完全避免拥塞，而是在网络出现拥塞时使用线性增长方式控制<code>cwnd</code>，使网络不容易出现拥塞。</p></blockquote><h3 id="TCP如何实现拥塞控制"><a href="#TCP如何实现拥塞控制" class="headerlink" title="TCP如何实现拥塞控制"></a>TCP如何实现拥塞控制</h3><p>TCP 发送发维持一个 拥塞窗口(<code>cwnd</code>)的状态变量。采用了四种算法，即 <code>慢开始</code>、 <code>拥塞避免</code>、<code>快重传</code> 和 <code>快恢复</code>。</p><ul><li>发送方维护一个拥塞窗口(<code>cwnd</code>)，用于控制发送数据的速率，其值取决于网络的拥塞程度，并且动态变化。<ul><li><code>cwnd</code>的维护原则：只要网络没有拥塞，就增大<code>cwnd</code>，以提高发送速率；一旦网络出现拥塞，就减小<code>cwnd</code>。</li><li>判断拥塞依据：没有按时收到应当到达的报文(即发生超时重传)。</li></ul></li><li>发送方将拥塞窗口作为发送窗口<code>swnd</code>，即<code>swnd=cwnd</code>。</li><li>维护一个慢开始门限<code>ssthresh</code>状态变量：<ul><li>当<code>cwnd &lt; ssthresh</code>时，使用慢开始算法；</li><li>当<code>cwnd &gt; ssthresh</code>时，停止使用慢开始算法而改用拥塞避免算法；</li><li>当<code>cwnd = ssthresh</code>时，既可以使用慢开始算法，也可以使用拥塞避免算法；</li></ul></li><li>在TCP双方建立逻辑连接关系时，<code>cwnd</code>的值被设置为1，慢开始门限ssthresh值进行设置(假设为 16)。</li></ul><ol><li>慢开始阶段：<code>cwnd</code>从1开始，每收到一个<code>ACK</code>，<code>cwnd</code>加倍，即<code>cwnd = cwnd * 2</code>，直到<code>cwnd &gt;= ssthresh</code>。</li><li>当<code>cwnd &gt;= ssthresh</code>，开始执行拥塞避免算法，<code>cwnd</code>每次只增加1，即<code>cwnd = cwnd + 1</code>。</li><li>如果此时部分数据报文段丢失,那么发送方会对这些丢失的数据报文段进行超时重传。发送方以此判断可能发生了网络拥塞，进行调整：将慢开始门限值<code>ssthresh</code>值更新为发生拥塞时<code>cwnd</code>值的一半；将<code>cwnd</code>的值减少为1，并重新开始执行慢开始算法。</li><li>当<code>cwnd</code>重新达到新的<code>ssthresh</code>时，再次执行拥塞避免算法。</li></ol><ul><li>有时候个别报文丢失，但实际上并没有网络拥塞。这导致发送发超时重传，误认为发生了网络拥塞，错误地使用慢开始算法，降低了网络的传输效率。为了解决这个问题，TCP引入了快速重传机制、快速恢复机制。</li><li>快速重传就是要发送方尽快重传，而不是等待超时重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时捎带<code>ACK</code>，而是立即发送<code>ACK</code>。</li><li>即使收到了失序的报文段，也要立即发送对自己收到的报文段的重复确认<code>ACK</code>。</li><li>发送方一旦收到三个连续的<code>ACK</code>，就立即重传对应的报文段，而不必等待超时重传计时器超时。</li><li>使用快速重传可以将网络吞吐量提高 20%~30%。</li></ul></li><li>发送方收到三个重复的<code>ACK</code>，就知道只是丢失了个别报文，所以不使用慢开始算法，而是使用快恢复算法。<ul><li>发送方将慢开始门限<code>ssthresh</code>和拥塞窗口<code>cwnd</code>设置为原来<code>cwnd</code>的一半，然后执行拥塞避免算法。</li><li>有的快恢复算法实现是将新的拥塞窗口设置的大一点，即<code>cwnd = ssthresh(cwnd/2) + 3</code>，然后执行拥塞避免算法。</li></ul></li></ul><h3 id="TCP解决丢包问题"><a href="#TCP解决丢包问题" class="headerlink" title="TCP解决丢包问题"></a>TCP解决丢包问题</h3><ul><li>重传机制<ul><li>超时重传(Retransmission TimeOut, RTO)：当发送方没有在预期时间内收到确认应答(<code>ACK</code>)时，认为数据包丢失，重新发送该数据包。</li><li>快速重传(Fast Retransmit)：当发送方连续收到三个重复的ACK时，立即重传相应的数据包，而不必等待超时。</li></ul></li><li>拥塞控制<ul><li>慢启动(Slow Start)：初始阶段发送方以指数增长的方式增加拥塞窗口(Congestion Window, CWND)，逐渐探测网络的可用带宽。</li><li>拥塞避免(Congestion Avoidance)：当CWND达到慢启动阈值(Slow Start Threshold, SSTHRESH)时，CWND以线性增长方式增加。</li><li>快速恢复(Fast Recovery)：在快速重传后，CWND减半，但不重新进入慢启动，而是进入快速恢复阶段，通过继续发送数据来尽快恢复网络的正常传输。</li><li>快速重传(Fast Retransmit)：当发送方连续收到三个重复的ACK时，立即重传相应的数据包，而不必等待超时。</li></ul></li><li>选择性确认(Selective Acknowledgement, SACK)：允许接收方通知发送方已接收的非连续数据块，发送方可以只重传丢失的部分数据，而不是所有后续数据包。</li><li>冗余传输(Redundant Transmission)：使用前向纠错码(Forward Error Correction, FEC)或者额外的冗余数据，以便在接收方能够自行修复部分丢失的数据包。</li><li>流量控制(Flow Control)：通过调整接收窗口(Receiver Window, RWND)的大小，确保发送方不会发送超过接收方处理能力的数据量，减少因拥塞而导致的丢包。</li><li>网络层优化<ul><li>质量服务(Quality of Service, QoS)：在路由器和交换机上设置优先级规则，确保关键数据包优先传输。</li><li>负载均衡(Load Balancing)：将流量分布到多个路径或链路上，避免某一路径过载导致丢包。</li></ul></li><li>物理层优化：改善物理连接质量，如使用更好的网络电缆、优化无线信号强度等，以减少物理层的丢包率。</li><li>网络协议的改进：Quick UDP Internet Connections(QUIC)，谷歌开发的一种基于UDP的协议，具有更快速的连接建立和恢复能力。</li></ul><p>通过结合以上各种方法，可以更有效地应对TCP丢包问题，提高网络传输的稳定性和效率。</p><h3 id="TCP粘包拆包问题"><a href="#TCP粘包拆包问题" class="headerlink" title="TCP粘包拆包问题"></a>TCP粘包拆包问题</h3><p><a href="https://blog.csdn.net/u010429831/article/details/119932832">https://blog.csdn.net/u010429831/article/details/119932832</a><br>TCP 是一个面向字节流的传输层协议。发送方无法保证对方每次收到的都是一个完整的数据包。于是就有了粘包、拆包问题的出现。粘包、拆包问题只发生在TCP协议中。</p><ul><li>接收端只收到一个TCP报文段，去掉首部后，报文段中包含发送端发送来的两个数据包的信息，即为粘包。由于接收端不知道两数据包的界限，所以对于接收端来说很难处理。</li><li>接收端收到了两个TCP报文段，但是去掉首部后，两个数据包要么是不完整的，要么就是多出来一部分，这种现象即为粘包、拆包问题。<ul><li>粘包问题分两种：一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的数据包。</li><li>拆包：应用程序的数据包被拆分成若干部分发送出去，从接收缓存看，接收方收到的只是数据包的一部分内容。</li></ul></li></ul><h3 id="粘包产生原因"><a href="#粘包产生原因" class="headerlink" title="粘包产生原因"></a>粘包产生原因</h3><ul><li>应用程序(发送方)进程写入的数据量大于TCP发送缓冲区的大小，这将会发生拆包。此时数据包需要进行拆包处理，分多次进行发送。</li><li>应用进程写入的数据量小于TCP发送缓冲区的大小，这将会发生粘包。由于TCP发送缓存空间足够，它会等到有多个数据包时，再组装成一个TCP报文段，然后通过网卡发送到网络中去。</li><li>当应用进程发送的数据包大于 MSS(最大报文段长度： TCP报文段的长度 - TCP首部长度)时，将会发生拆包。TCP 协议会将大的数据包拆分成 MSS 大小的数据包进行发送。</li><li>接收方不及时读取接收缓冲区中的数据，将会发生粘包。接收方先把接收到的数据存放在内核接收缓冲区中，用户进程从接收缓冲区读取数据，若下一个数据包到达时前一个数据包尚未被用户进程取走，则下一个数据包放到内核接收缓冲区时就和前一数据包粘在一起，而用户进程根据预先设定的缓冲区大小从内核接收缓冲区读取数据，这样就一次性读取到了多个数据包。</li></ul><p><strong>什么时候需要考虑粘包问题</strong><br>TCP是长连接，并且传输的是结构化数据时，如：传送的是一个结构体类型的数据，由于不知道结构化数据的边界，容易导致粘包问题的出现。这时需要考虑粘包问题的影响。</p><p><strong>什么时候不需要考虑粘包问题</strong></p><ul><li>如果 TCP 是短连接，即只进行一次数据通信过程，通信完成就关闭连接，这样就不会出现粘包问题。</li><li>如果传输的是字符串、文件等无结构化数据时，也不会出现粘包问题。因为发送方只管发送，接收方只管接收存储就行了</li></ul><h3 id="粘包问题解决方案"><a href="#粘包问题解决方案" class="headerlink" title="粘包问题解决方案"></a>粘包问题解决方案</h3><ol><li>发送定长包。即发送端将每个数据包封装为固定长度(长度不够的可以通过补0填充)，这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。(适合定长结构的数据)</li><li>包头加上包体长度。发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便可以知道每一个数据包的实际长度了。(适合不定长结构的数据)</li><li>在包尾部设置边界标记。发送端在每个数据包尾部添加边界标记，可以使用特殊符号作为边界标记。如此，接收端通过这个边界标记就可以将不同的数据包拆分开来。但这可能会存在一个问题：如果数据包内容中也包含有边界标记，则会被误判为消息的边界，导致出错。这样方法要视具体情况而定。例如，FTP协议就是采用 “\r\n” 来识别一个消息的边界的。</li></ol><h3 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h3><p>自动重传请求(Automatic Repeat-reQuest，ARQ)是数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息<code>ACK</code>，就会重新发送，直到收到确认或者重试超过一定的次数。</p><h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复 <code>ACK</code>)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><ul><li>优点：信道利用率高，容易实现。</li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。</li></ul><h3 id="超时重传机制如何实现"><a href="#超时重传机制如何实现" class="headerlink" title="超时重传机制如何实现"></a>超时重传机制如何实现</h3><p>发送方发送完数据后，会启动一个定时器，等待接收端确认收到这个报文段。接收端成功收到报文段的话会发送会 <code>ACK</code>包，如果发送端在合理的往返时延(RTT)内未收到确认信息，那数据包就被标记为已丢失并进行重传。</p><p>超时重传时间 RTO(Retransmission Time Out)直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此 RTO 应根据网络的实际状况，动态地进行调整。</p><p>超时重传时间不能直接使用往返时延RTT，因为其值会随着网络波动而变化。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是每个连入互联网的设备或域(如计算机、服务器、路由器等)都被分配的一个唯一标识符。</p><h3 id="IP地址过滤"><a href="#IP地址过滤" class="headerlink" title="IP地址过滤"></a>IP地址过滤</h3><p>IP 地址过滤(IP Address Filtering)就是限制或阻止特定 IP 地址或 IP 地址范围的访问。如：有一个图片服务突然被某一个 IP 地址攻击，那就可以禁止这个 IP 地址访问图片服务。</p><h3 id="IPv4-IPv6区别"><a href="#IPv4-IPv6区别" class="headerlink" title="IPv4&#x2F;IPv6区别"></a>IPv4&#x2F;IPv6区别</h3><p>IPv4(Internet Protocol version 4)是四组由点分隔的数字，例如：<code>123.89.46.72</code>。IPv4 使用 4Bytes 32 位(bits)地址作为其 Internet 地址，共有约 42 亿(2^32)个可用 IP 地址。不够用。</p><p>为了解决 IP 地址耗尽的问题，采用具有更大地址空间的新版本 IP 协议 - IPv6(Internet Protocol version 6)。该格式使用由单或双冒号分隔的一组数字和字母，如：<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>。IPv6 使用 128 位互联网地址，有 2^128个可用 IP 地址。</p><ul><li>IPv4采用DHCP(动态主机配置协议)来自动分配IP地址。IPv6支持自动配置(SLAAC)和DHCPv6，自动化程度更高。</li><li>IPv4路由表较大，互联网的快速增长导致路由表膨胀，路由效率受到一定影响。IPv6有更高效的路由聚合(aggregation)，路由表规模更小，有助于提高路由效率。</li></ul><h3 id="断点续传在浏览器如何实现"><a href="#断点续传在浏览器如何实现" class="headerlink" title="断点续传在浏览器如何实现"></a>断点续传在浏览器如何实现</h3><p>断点续传是一种在网络传输中恢复中断数据的技术，常用于下载文件时继续未完成的部分。浏览器中实现断点续传主要依赖HTTP的<code>Range</code>头和状态码<code>206 Partial Content</code>。</p><ul><li><code>Range</code>头：客户端在请求资源时，通过<code>Range</code>头指定请求的范围，如<code>Range: bytes=500-</code>表示请求资源的 500 字节之后的部分。</li><li><code>206 Partial Content</code>：服务器收到带有<code>Range</code>头的请求后，会返回状态码<code>206 Partial Content</code>，并在响应头中包含<code>Content-Range</code>字段，指示返回的数据范围。</li><li>实现细节：<ol><li>发送初始请求：浏览器首先发送一个普通的GET请求，下载文件的起始部分。</li><li>检测中断：如果下载中断或用户暂停下载，记录下已下载的字节数。</li><li>发送带<code>Range</code>头的请求：重新开始下载时，浏览器发送一个带有<code>Range</code>头的请求，从上次中断的地方继续。</li><li>处理服务器响应：服务器返回<code>206 Partial Content</code>状态码和请求范围的内容，浏览器继续下载剩余部分。</li></ol></li></ul><p><strong>如何判断浏览器是否支持断点续传</strong><br>要检测浏览器是否支持断点续传，可以通过发送一个带有<code>Range</code>头的请求，并检查服务器的响应。如果服务器返回状态码<code>206 Partial Content</code>，则表示支持断点续传。</p><p><strong>处理不支持断点续传的情况</strong><br>如果浏览器或服务器不支持断点续传，可以采取以下几种策略：</p><ul><li>完整下载：直接进行完整下载，而不是尝试断点续传。</li><li>分块下载：将文件分成多个小块，分别下载并在客户端合并。这种方法需要服务器支持多部分下载，但不依赖于HTTP的断点续传功能。</li></ul><p><strong>在项目中处理断点续传的支持性</strong><br>在实际项目中，通常会有以下步骤来处理断点续传的支持性：</p><ul><li>检测支持性：如上所示，首先检测浏览器是否支持断点续传。</li><li>优先使用断点续传：如果支持，使用断点续传来提高下载效率和用户体验。</li><li>回退方案：如果不支持，使用完整下载或其他替代方案。</li><li>用户提示：在用户界面上显示相关提示，例如告诉用户当前浏览器不支持断点续传，可能需要更长时间下载。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><ul><li>用户态是指应用程序运行时所处的模式。在用户态下，程序执行受到严格的限制，不能直接访问硬件或内存中的关键部分。任何试图进行这些操作的指令都会导致异常，并且操作系统会终止该程序。这种限制可以防止用户程序破坏系统的稳定性和安全性。<ul><li>受限的指令集：只能执行非特权指令。</li><li>受限的资源访问：不能直接访问硬件设备和内核内存空间。</li><li>需要通过系统调用(System Call)与内核进行交互。</li></ul></li><li>内核态是指操作系统内核运行时所处的模式。在内核态下，系统具有完全的访问权限，可以执行任何指令，并且可以访问所有的硬件设备和内存。这种模式下，操作系统能够管理系统资源和控制硬件。<ul><li>完全的指令集：可以执行所有的指令，包括特权指令。</li><li>完全的资源访问：可以直接访问硬件设备和内存。</li><li>执行关键任务：处理系统调用、中断处理、设备管理等。</li></ul></li></ul><p><strong>切换</strong></p><ul><li>系统调用：当用户态的应用程序需要执行特权操作(如读写文件、分配内存、访问硬件设备)时，它会发出一个系统调用请求，触发从用户态到内核态的切换。内核处理完系统调用后，会返回用户态继续执行应用程序。</li><li>中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。这种从用户态到内核态的切换是由硬件中断控制器完成的。</li><li>异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li></ul><p><strong>示例</strong></p><ul><li>用户态：运行中的应用程序，如文本编辑器、浏览器等。它们通过系统调用请求操作系统提供的服务。</li><li>内核态：操作系统内核在处理系统调用、硬件中断或其他低级别任务时的运行状态。</li></ul><p><strong>安全性和稳定性</strong><br>用户态和内核态的分离是现代操作系统安全性和稳定性的关键。通过将用户程序与操作系统核心隔离，防止用户程序直接操作硬件或内存，减少了系统崩溃和安全漏洞的风险。</p><p><strong>总结</strong><br>用户态和内核态的划分使得计算机系统能够有效地管理资源，提供安全的运行环境，同时允许用户程序执行。用户态用于执行普通应用程序，而内核态用于执行操作系统核心任务，保证了系统的稳定性和安全性。</p><h3 id="只有内核态不行吗？"><a href="#只有内核态不行吗？" class="headerlink" title="只有内核态不行吗？"></a>只有内核态不行吗？</h3><ul><li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。</li><li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p><p>系统调用(System Call)是操作系统提供给应用程序的接口，用于访问操作系统内核的服务和功能。在用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内存管理等)，必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>系统调用分下面几类：</p><ul><li>设备管理：完成设备(输入输出设备和外部存储设备等)的请求或释放，以及设备启动等功能。</li><li>文件管理：完成文件的读、写、创建及删除等功能。</li><li>进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li><li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一种内存管理技术，它为每个进程提供了一个统一的地址空间，使得进程认为它独占一个大的连续内存空间。然而，实际的物理内存可能是零散的或不足的，操作系统通过虚拟内存技术将虚拟地址转换为物理地址，从而透明地管理内存。</p><p>主要作用：</p><ul><li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页(通常大小为 4 KB)保存到磁盘文件(会影响读写速度)，数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><h3 id="没有虚拟内存会存在什么问题？"><a href="#没有虚拟内存会存在什么问题？" class="headerlink" title="没有虚拟内存会存在什么问题？"></a>没有虚拟内存会存在什么问题？</h3><ul><li>程序之间的内存隔离性差：没有虚拟内存，不同程序的内存空间可能会重叠，一个程序可以访问另一个程序的内存空间，导致数据泄露或者程序崩溃。</li><li>物理内存利用率低：没有虚拟内存，每个程序都需要占用一定的物理内存，如果物理内存不足，就会导致程序无法运行。</li><li>程序的内存管理复杂：没有虚拟内存，程序需要直接管理物理内存，需要考虑内存的分配、释放、回收等问题，增加了程序的复杂性。</li><li>程序的安全性差：没有虚拟内存，程序可以直接访问物理内存，可能会导致程序的安全漏洞，如缓冲区溢出等。</li></ul><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>内存池(Memory Pool)是一种内存管理技术，旨在提高内存分配和释放的效率，同时减少内存碎片化的问题。内存池主要用于那些需要频繁进行内存分配和释放的场景，比如游戏开发、实时系统、嵌入式系统等。</p><p>内存池可以在应用程序级别实现，也可以在操作系统内核中实现。例如，操作系统内核中的一些子系统(如文件系统、网络堆栈等)可能会使用内存池来提高内存管理的效率。在用户态，应用程序可以自行实现内存池，或者使用一些第三方库来管理内存池。而在内核态，操作系统可能会提供类似的机制来优化内存管理。</p><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><ul><li>外部碎片化(External Fragmentation)：内存中存在许多小的、非连续的空闲块，导致大块内存请求无法满足，即使总的空闲内存量足够。</li><li>内部碎片化(Internal Fragmentation)：分配的内存块内部有未被使用的空间，因为分配的块大于实际需要的内存。</li></ul><h3 id="内存池如何解决内存碎片问题"><a href="#内存池如何解决内存碎片问题" class="headerlink" title="内存池如何解决内存碎片问题"></a>内存池如何解决内存碎片问题</h3><ul><li>预先分配固定大小的内存块：内存池通常在初始化时预先分配一大块连续的内存，然后将这块内存划分成许多大小相等的内存块。这样做可以避免外部碎片化，因为所有的内存分配都是从预先划分好的内存块中进行的。</li><li>减少分配和释放次数：通过预先分配和重用内存块，内存池减少了系统进行内存分配和释放的次数。这不仅提高了性能，还减少了产生碎片的机会。</li><li>分层内存池：有些内存池会根据不同大小的内存请求划分成多个子池，每个子池管理一种特定大小的内存块。这样可以有效减少内部碎片化，因为每个内存块的大小都是根据需求精细划分的。</li></ul><h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程&#x2F;线程&#x2F;协程"></a>进程&#x2F;线程&#x2F;协程</h3><p><a href="https://blog.csdn.net/m0_60505735/article/details/131047046">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href="https://blog.csdn.net/weixin_49199646/article/details/109210547">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p><ul><li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li><li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li><li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li></ul><p><strong>进程与线程的区别</strong></p><ul><li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ul><p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p><p><strong>进程与线程的选择</strong></p><ul><li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li><li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li><li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li><li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li></ul><p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p>进程间通信(Inter-Process Communication, IPC)是指在操作系统中不同进程之间传递数据或信息的机制。常见的进程间通信方式有多种，每种方式都有其独特的应用场景和优缺点。以下是一些主要的进程间通信方式：</p><ol><li>管道(Pipes)：<ul><li>匿名管道(Anonymous Pipes)：主要用于有亲缘关系的进程之间的通信，如父子进程。数据以字节流的形式在进程间传递。</li><li>命名管道(Named Pipes)：支持在无亲缘关系的进程之间进行通信。命名管道存在于文件系统中，可以被不同的进程打开和使用。</li></ul></li><li>消息队列(Message Queues)：<ul><li>允许进程通过发送和接收消息进行通信。消息队列提供了一种在进程间传递数据的有序方式，可以实现异步通信。</li></ul></li><li>共享内存(Shared Memory)：<ul><li>进程共享一段内存空间，进程可以直接读写这段共享内存中的数据。共享内存是最快的一种通信方式，因为数据不需要在进程间复制，但需要额外的同步机制来避免并发访问问题。</li></ul></li><li>信号量(Semaphores)：<ul><li>用于控制多个进程对共享资源的访问，通过信号量可以实现进程间的同步和互斥。</li></ul></li><li>信号(Signals)：<ul><li>信号是一种有限的异步通知机制，用于通知进程某个事件的发生。进程可以捕捉和处理信号，从而实现简单的通信和控制。</li></ul></li><li>套接字(Sockets)：<ul><li>套接字不仅支持同一台计算机上进程间的通信，也支持分布式网络中不同计算机上的进程间通信。常用于网络编程中。</li></ul></li><li>文件系统(File System)：<ul><li>进程可以通过读写共享的文件进行通信。这种方式简单但效率较低，适用于需要持久化存储的场景。</li></ul></li><li>内存映射文件(Memory-Mapped Files)：<ul><li>通过将文件映射到进程的地址空间，实现文件内容的共享和通信。与共享内存类似，但数据的持久化由文件系统提供。</li></ul></li></ol><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>线程间的通信是指在同一个进程内，不同线程之间交换数据或信号的机制。常见的线程间通信方式包括以下几种：</p><ol><li>共享内存：<ul><li>全局变量：所有线程都可以访问和修改同一个全局变量。</li><li>静态变量：静态变量在进程的生命周期内只初始化一次，所有线程共享。</li></ul></li><li>互斥锁(Mutex)：<ul><li>用于防止多个线程同时访问共享资源，从而避免数据竞争。</li></ul></li><li>读写锁(RWLock)：<ul><li>允许多个线程同时读数据，但在写数据时需要独占锁，确保写操作的安全性。</li></ul></li><li>信号量(Semaphore)：<ul><li>主要用于限制对共享资源的访问数量，可以控制同时访问资源的线程数。</li></ul></li><li>条件变量(Condition Variable)：<ul><li>用于线程之间的等待通知机制，一个线程可以等待一个条件变量，而另一个线程可以通知该条件变量改变状态，从而唤醒等待的线程。</li></ul></li><li>事件(Event)：<ul><li>线程可以等待一个事件，直到另一个线程设置该事件，从而实现线程之间的同步。</li></ul></li><li>队列(Queue)：<ul><li>线程安全的队列，常用于生产者-消费者模型，一个线程放入数据，另一个线程取出数据。</li></ul></li><li>管道(Pipe)：<ul><li>用于线程之间的数据传输，常见于一些操作系统提供的进程间通信机制中。</li></ul></li><li>消息队列(Message Queue)：<ul><li>一种线程安全的队列，专门用于在多个线程之间传递消息。</li></ul></li><li>信号(Signal)：</li></ol><ul><li>一种用于通知线程某个事件发生的机制，通常用在异步事件处理。</li></ul><h3 id="CPU满载如何排查问题"><a href="#CPU满载如何排查问题" class="headerlink" title="CPU满载如何排查问题"></a>CPU满载如何排查问题</h3><p>当CPU满载时，排查问题通常需要系统地检查多个方面，以确定导致高负载的具体原因。以下是一些详细的排查步骤：</p><ol><li>使用系统监控工具<br>查看系统负载：首先，使用系统监控工具（如Windows的任务管理器、Linux的top或htop命令）来查看系统的整体负载情况，包括CPU、内存、磁盘和网络等资源的使用情况。<br>确定高占用进程：在监控工具中查找哪个进程或应用程序的CPU占用率很高。这通常是导致CPU满载的直接原因。</li><li>分析进程和资源使用情况<br>查看进程详细信息：在任务管理器或相应的系统监控工具中，查看高占用进程的详细信息，包括其启动时间、占用资源量、关联的模块或服务等。<br>检查进程行为：分析进程的行为，看是否有异常操作或不必要的资源占用。例如，某些进程可能因为死循环、内存泄漏或低效的算法而持续占用大量CPU资源。</li><li>检查系统配置和设置<br>查看启动项和服务：检查系统启动时自动运行的程序和服务，看是否有不必要的程序或服务在后台运行并占用CPU资源。<br>优化系统设置：关闭不必要的后台程序、禁用不必要的系统服务、降低屏幕分辨率或减少同时打开的窗口数量等，以降低CPU的使用率。</li><li>检查硬件和驱动程序<br>检查硬件状态：确保CPU、内存、硬盘等硬件设备工作正常，没有过热、损坏或性能瓶颈等问题。<br>更新驱动程序：确保所有硬件设备的驱动程序都是最新的，以避免因驱动程序问题导致的CPU高占用。</li><li>排查病毒和恶意软件<br>运行杀毒软件：使用可靠的杀毒软件对系统进行全面扫描，以排除病毒或恶意软件导致的CPU高占用。<br>检查系统日志：查看系统日志文件，查找是否有与病毒或恶意软件相关的异常记录。</li><li>使用性能分析工具<br>使用专业工具：对于复杂的问题，可以使用专业的性能分析工具（如VisualVM、Arthas等）来进一步分析CPU使用情况，并确定具体的性能瓶颈。</li><li>咨询专业人员<br>如果以上步骤都无法解决问题，或者您对系统配置和性能分析不熟悉，建议咨询专业的技术人员或计算机维修人员。<br>通过以上步骤，您可以系统地排查CPU满载的问题，并找到导致高负载的具体原因。在排查过程中，请保持耐心和细心，以便准确地定位问题并采取相应的解决措施。</li></ol><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>在操作系统中，孤儿进程（Orphan Process）和僵尸进程（Zombie Process）是两种特殊的进程状态，它们各自具有特定的行为和影响。</p><p>孤儿进程（Orphan Process）定义：孤儿进程是指在其父进程执行完毕或被终止后，该进程仍然运行着的进程。这些进程会被操作系统中的“进程收养所”（通常是init进程，其PID为1）收养，成为init进程的子进程。</p><p>特点：</p><ul><li>孤儿进程不再是任何有效进程的子进程。</li><li>孤儿进程的结束处理由收养它的进程（如init进程）负责。</li><li>孤儿进程本身对系统没有直接的负面影响，因为操作系统能够正确处理它们。</li></ul><p>孤儿进程是系统能够自动处理的，</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>僵尸进程（Zombie Process）定义：僵尸进程是指已经结束（即已经完成了执行）但是其父进程尚未通过调用wait()或waitpid()等系统调用来获取其终止状态的进程。</p><p>特点：</p><ul><li>僵尸进程已经释放了除进程描述符以外的所有资源，但仍在进程表中占有一个表项，这意味着它们的PID仍然被占用。</li><li>如果系统中有大量僵尸进程，可能会导致PID耗尽，从而影响新进程的创建。</li><li>僵尸进程的存在是为了让父进程能够查询子进程的退出状态。如果父进程不调用wait()或waitpid()，子进程就会一直处于僵尸状态。</li></ul><p>解决方法：</p><ul><li>确保父进程在适当的时候调用wait()或waitpid()来回收子进程的终止状态，从而避免僵尸进程的产生。</li><li>如果父进程已经结束，而子进程成为僵尸进程，那么这些僵尸进程最终会被init进程收养，并由init进程调用wait()来回收。</li><li>在某些情况下，如果父进程确实不需要知道子进程的退出状态，可以考虑在子进程中调用_exit()而不是exit()，这样可以在子进程结束时立即释放资源，但这种方法并不推荐，因为它可能掩盖了潜在的错误。</li></ul><p>僵尸进程则需要程序员通过编程来避免其产生或及时回收。</p><h3 id="动态链接和静态链接的区别"><a href="#动态链接和静态链接的区别" class="headerlink" title="动态链接和静态链接的区别"></a>动态链接和静态链接的区别</h3><p>动态链接和静态链接是计算机科学中两种重要的程序链接方式。</p><ul><li>静态链接：在程序编译时，将所有外部库文件（如DLL文件在Windows系统中，或.so文件在Linux系统中）直接嵌入到可执行文件中，形成一个独立的可执行文件。当程序运行时，就不需要再加载这些外部库文件。</li><li>动态链接：在程序编译时，只生成程序的可执行文件和一些必要的资源文件，而将外部库文件放在一个单独的目录下（如系统的PATH环境变量所指定的目录）。当程序运行时，系统会在这些目录下查找所需的外部库文件，并将其加载到内存中。</li></ul><p><strong>优缺点</strong><br>静态链接</p><ul><li><p>优点：</p><ul><li>程序运行时不依赖于外部库文件，减少了程序的依赖性，提高了程序的独立性和安全性。</li><li>避免了因外部库文件版本不匹配导致的兼容性问题。</li><li>在某些情况下，可以提高程序的运行速度（尽管这取决于具体情况，如硬盘读写速度等）。</li></ul></li><li><p>缺点：</p><ul><li>程序体积较大，因为包含了所有外部库文件的代码。</li><li>升级程序时需要替换所有的外部库文件，增加了维护成本。</li><li>灵活性较差，无法实现模块化编程。<br>动态链接</li></ul></li><li><p>优点：</p><ul><li>程序体积较小，因为不包含外部库文件的代码，只包含对外部库文件的引用。</li><li>便于升级和维护，只需替换外部库文件即可，无需重新编译整个程序。</li><li>灵活性高，可以根据需要加载不同的库或模块，实现模块化编程。</li><li>节省内存和磁盘空间，因为多个程序可以共享同一个外部库文件。</li></ul></li><li><p>缺点：</p><ul><li>程序运行时需要依赖于外部库文件，可能导致安全性问题和兼容性问题。</li><li>性能开销较大，因为程序运行时需要不断地检查外部库或模块是否已经加载。</li><li>可能导致内存泄漏等问题，需要开发者更加关注内存管理。</li></ul></li><li><p>应用场景</p><ul><li>静态链接：适用于需要将程序打包成一个独立的可执行文件，并且不需要频繁更新外部库文件的场景。例如，嵌入式系统、游戏等对性能和安全性要求较高的应用程序。</li><li>动态链接：适用于项目规模较大、模块化程度较高的项目，以及需要频繁更新外部库文件的场景。例如，操作系统、数据库等需要不断更新的软件。</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常见Linux线程间的通信方式"><a href="#常见Linux线程间的通信方式" class="headerlink" title="常见Linux线程间的通信方式"></a>常见Linux线程间的通信方式</h3><h3 id="如何查询内存大小"><a href="#如何查询内存大小" class="headerlink" title="如何查询内存大小"></a>如何查询内存大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -h选项表示以人类可读的格式(如KB、MB、GB)显示内存大小。</span></span><br><span class="line">free -h</span><br><span class="line"><span class="comment"># /proc/meminfo文件包含了详细的内存使用信息。可以在这个文件中搜索与内存大小相关的信息，比如MemTotal项显示了总的物理内存大小。</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo </span><br></pre></td></tr></table></figure><h3 id="如何查询系统日志文件"><a href="#如何查询系统日志文件" class="headerlink" title="如何查询系统日志文件"></a>如何查询系统日志文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于使用systemd的Linux系统，journalctl命令是查看系统日志的强大工具。</span></span><br><span class="line"><span class="comment"># 查看所有系统日志</span></span><br><span class="line">journalctl</span><br><span class="line"><span class="comment"># 查看nginx服务器的日志</span></span><br><span class="line">journalctl -u nginx.service</span><br><span class="line"><span class="comment"># 查看系统启动时的日志</span></span><br><span class="line">journalctl -b</span><br><span class="line"><span class="comment"># 查看系统上一次启动时的日志</span></span><br><span class="line">journalctl -b -1</span><br><span class="line"><span class="comment"># 搜索包含特定文本的日志</span></span><br><span class="line">journalctl | grep <span class="string">&quot;特定文本&quot;</span></span><br><span class="line"><span class="comment"># 对于不直接使用systemd日志或需要查看传统日志文件的情况，可以直接查看/var/log目录下的日志文件。</span></span><br><span class="line"><span class="comment"># 查看系统消息日志(通常是系统级别的警告和错误信息)：</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/syslog  </span><br><span class="line"><span class="comment"># 或者在某些系统中可能是  </span></span><br><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br><span class="line"><span class="comment"># 查看认证和授权相关的日志(如SSH登录尝试)：</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/auth.log  </span><br><span class="line"><span class="comment"># 或者  </span></span><br><span class="line"><span class="built_in">cat</span> /var/log/secure</span><br><span class="line"><span class="comment"># 查看Web服务器(如Apache或Nginx)的日志(通常位于/var/log/apache2或/var/log/nginx目录)：</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/apache2/access.log  </span><br><span class="line"><span class="built_in">cat</span> /var/log/nginx/access.log</span><br></pre></td></tr></table></figure><p>使用<code>logrotate</code>管理日志文件。<code>/var/log</code>目录下的日志文件可能会随着时间增长而变得非常大。为了管理这些日志文件的大小和数量，大多数Linux系统使用<code>logrotate</code>工具定期轮转、压缩、删除或邮寄旧日志文件。<code>logrotate</code>的配置文件通常位于<code>/etc/logrotate.conf</code>以及<code>/etc/logrotate.d/</code>目录下的文件中。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道(Pipes)使用竖线|)符号表示。它的作用是将一个命令的输出作为另一个命令的输入。这样，用户可以将多个命令串联起来，形成一个命令管道，从而执行复杂的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下所有.txt文件，并显示这些文件的内容行数：</span></span><br><span class="line"><span class="built_in">ls</span> *.txt | xargs <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>这里，ls *.txt命令列出所有.txt文件，然后通过管道|将这些文件名传递给xargs命令，xargs命令再将这些文件名作为wc -l命令的参数，wc -l命令计算并显示每个文件的行数。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向(Redirection)允许用户将命令的输出(标准输出或标准错误输出)重定向到文件或其他命令中，或者将文件的内容作为命令的输入。重定向使用大于号(&gt;)和小于号(&lt;)等符号表示。</p><ul><li>标准输出重定向(&gt;)：将命令的输出重定向到文件中。如果文件已存在，则覆盖原有内容；如果文件不存在，则创建新文件。</li><li>标准输出追加重定向(&gt;&gt;)：将命令的输出追加到文件的末尾，而不是覆盖原有内容。</li><li>标准输入重定向(&lt;)：将文件的内容作为命令的输入。</li><li>标准错误输出重定向(2&gt;)：将命令的错误输出重定向到文件中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将ls命令的输出(即当前目录下的文件和目录列表)重定向到files.txt文件中。</span></span><br><span class="line"><span class="built_in">ls</span> &gt; files.txt</span><br><span class="line"><span class="comment"># 将文本&quot;Hello, World!&quot;追加到greeting.txt文件的末尾。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> &gt;&gt; greeting.txt</span><br><span class="line"><span class="comment"># 将files.txt文件的内容作为wc -l命令的输入，计算并显示文件的行数。</span></span><br><span class="line"><span class="built_in">wc</span> -l &lt; files.txt</span><br><span class="line"><span class="comment"># 如果non_existent_file文件不存在，ls命令的错误输出(通常是“No such file or directory”消息)将被重定向到errors.txt文件中。</span></span><br><span class="line"><span class="built_in">ls</span> non_existent_file 2&gt; errors.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="Linux如何查看文件前5行"><a href="#Linux如何查看文件前5行" class="headerlink" title="Linux如何查看文件前5行"></a>Linux如何查看文件前5行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 5 filename</span><br></pre></td></tr></table></figure><h3 id="Linux怎么看进程占用多少内存"><a href="#Linux怎么看进程占用多少内存" class="headerlink" title="Linux怎么看进程占用多少内存"></a>Linux怎么看进程占用多少内存</h3><p>在Linux系统中，查看进程占用多少内存可以通过多种方法实现。以下是一些常用的方法和命令：</p><ol><li>使用top命令<br>top命令是Linux系统中一个实时监控系统资源使用情况的工具，包括CPU、内存等。通过top命令，你可以看到系统中各个进程的内存占用情况。</li></ol><p>运行top命令后，你可以看到类似以下的输出（输出内容会根据实际系统情况有所不同）：<br>top - 11:15:16 up 1 day,  1:23,  2 users,  load average: 0.00, 0.01, 0.05<br>Tasks: 123 total,   1 running, 122 sleeping,   0 stopped,   0 zombie<br>%Cpu(s):  0.3 us,  0.7 sy,  0.0 ni, 98.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st<br>MiB Mem :   7815.1 total,   1234.1 free,   2345.6 used,   4235.4 buff&#x2F;cache<br>MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   4977.8 avail Mem</p><p>PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND<br>1234 user1     20   0  1024m  200m  50m S   0.0   2.6   0:01.23 myprocess<br>在上面的输出中，%MEM列表示进程占用的内存比例，RES列表示进程实际使用的物理内存大小（以KB或MB为单位，具体取决于你的系统配置和top命令的显示设置）。</p><ol start="2"><li>使用ps命令<br>ps命令用于显示当前进程的快照。结合适当的选项，你可以查看进程的内存使用情况。</li></ol><p>例如，使用ps aux –sort&#x3D;-%mem命令可以按照内存使用率从高到低的顺序列出所有进程及其内存使用情况：<br>bash<br>ps aux –sort&#x3D;-%mem<br>输出将包含进程的PID、用户、CPU和内存使用率等信息。</p><ol start="3"><li>使用grep和&#x2F;proc文件系统<br>每个Linux进程都有一个对应的&#x2F;proc&#x2F;[pid]&#x2F;status文件，其中包含了该进程的状态信息，包括内存使用情况。</li></ol><p>你可以使用grep命令从该文件中提取特定的内存信息，如VmRSS（表示进程实际占用的物理内存大小）：<br>bash<br>grep VmRSS &#x2F;proc&#x2F;1234&#x2F;status<br>将1234替换为你想要查看的进程PID。</p><ol start="4"><li>使用高级工具<br>除了上述基本命令外，还有一些高级工具可以帮助你更详细地分析进程的内存使用情况，如htop、atop、smem等。</li></ol><p>htop是top命令的增强版本，提供了更丰富的信息和更友好的用户界面。<br>atop是一个性能监控工具，可以显示系统资源（包括内存）的综合使用情况。<br>smem是一个用于统计进程和用户内存使用的命令行工具，它可以提供更详细的内存统计信息。<br>这些工具通常不是Linux系统的默认安装部分，但你可以通过包管理器（如apt、yum等）轻松安装它们。</p><p>总之，Linux提供了多种方法来查看进程的内存占用情况，你可以根据自己的需求和喜好选择合适的方法。</p><h3 id="Linux抓包"><a href="#Linux抓包" class="headerlink" title="Linux抓包"></a>Linux抓包</h3><p>Linux抓包是Linux系统下进行网络流量分析、故障诊断和安全审计等任务的重要手段。以下是对Linux抓包的详细介绍：</p><ul><li>tcpdump<br>功能：tcpdump是一个强大的命令行抓包工具，可以捕获经过网络接口的数据包，并将其显示或保存到文件中。它支持复杂的过滤器和表达式，能够灵活地筛选和捕获所需的数据包。<br>特点：tcpdump是Linux系统自带的抓包工具之一，使用起来非常方便。它提供了丰富的选项和参数，可以精确控制抓包过程，包括指定网络接口、设置抓包数量、保存抓包数据等。<br>使用场景：适用于需要深入分析网络流量、诊断网络问题或进行安全审计的场景。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ] [ -i 网络接口 ] [ -r 文件名] [ -s snaplen ] [ -T 类型 ] [ -w 文件名] [表达式 ]</span><br></pre></td></tr></table></figure><p>二、常用选项说明<br>-a：将网络地址和广播地址转变成名字。<br>-c 数量：指定要抓取的包的数量。<br>-d：将匹配信息包的代码以人们能够理解的汇编格式给出。<br>-e：在输出行打印出数据链路层的头部信息，例如源MAC和目标MAC。<br>-f：将外部的Internet地址以数字的形式打印出来。<br>-i 网络接口：指定tcpdump需要监听的接口。<br>-n：对地址以数字方式显式，不进行主机名解析。<br>-nn：除了-n的作用外，还把端口显示为数值，不进行端口名解析。<br>-P：指定要抓取的包是流入还是流出的包，可以给定的值为”in”、”out”和”inout”，默认为”inout”。<br>-q：快速打印输出，即打印很少的协议相关信息，输出行简短。<br>-s snaplen：设置tcpdump的数据包抓取长度为snaplen，如果不设置默认将会是65535字节。<br>-t：在输出的每一行不打印时间戳。<br>-v、-vv、-vvv：分别产生详细程度递增的输出信息。<br>-w 文件名：将抓包数据输出到文件中而不是标准输出。<br>-r 文件名：从给定的数据包文件中读取数据。<br>-X：输出包的头部数据，以16进制和ASCII两种方式同时输出。<br>-XX：输出包的头部数据，以16进制和ASCII两种方式同时输出，更详细。<br>-D：列出可用于抓包的接口。<br>-F：从文件中读取抓包的表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认启动</span></span><br><span class="line">tcpdump</span><br><span class="line"><span class="comment"># 默认情况下，tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包。</span></span><br><span class="line"><span class="comment"># 监视指定网络接口的数据包</span></span><br><span class="line">tcpdump -i eth1</span><br><span class="line"><span class="comment"># 如果不指定网卡，默认tcpdump只会监视第一个网络接口，如eth0。</span></span><br><span class="line"><span class="comment"># 截获主机hostname发送的所有数据</span></span><br><span class="line">tcpdump src host hostname</span><br><span class="line"><span class="comment"># 监视所有发送到主机hostname的数据包</span></span><br><span class="line">tcpdump dst host hostname</span><br><span class="line"><span class="comment"># 监视指定主机和端口的数据包</span></span><br><span class="line">tcpdump tcp port 22 and host hostname</span><br><span class="line"><span class="comment"># 抓取包含特定IP的数据包</span></span><br><span class="line">tcpdump -i eth0 -vnn host 10.84.10.217</span><br><span class="line"><span class="comment"># 抓取包含特定端口的数据包</span></span><br><span class="line">tcpdump -i eth0 -vnn port 22</span><br><span class="line"><span class="comment"># 抓取特定协议的数据包</span></span><br><span class="line">tcpdump -i eth0 -vnn udp</span><br><span class="line"><span class="comment"># 将抓取的数据包记录存到文件中</span></span><br><span class="line">tcpdump -i eth0 -vnn -w /tmp/fil1 -c 100</span><br><span class="line"><span class="comment"># 从文件中读取数据包进行分析</span></span><br><span class="line">tcpdump -i eth0 -vnn -r /tmp/fil1 tcp</span><br></pre></td></tr></table></figure><p>tcpdump只能抓取流经本机的数据包。<br>在使用复杂的表达式时，建议使用单引号将表达式括起来，以防止shell对特殊字符进行错误解析。抓取长度(snaplen)的设置需要根据实际需求进行调整，以避免包截断或处理时间过长。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测开面经</title>
      <link href="/posts/17768.html"/>
      <url>/posts/17768.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：下面内容一部分来自于我舍友的博客</p></blockquote><h3 id="测开自我介绍"><a href="#测开自我介绍" class="headerlink" title="测开自我介绍"></a>测开自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 测试开发岗位。</p><p>我呢，研一的时候积极参加开源社区建设，先参加了Casbin社区一个线上实习，担任社区维护者，日常工作会解决社区 issue，跟踪解决用户需求，修bug以及完善相关文档；然后在研一暑假三个月时间中了一个中科院和 casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国家电网经济研究院的一个项目。 这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p><p>其实在开源项目也做过关于测试相关的工作，也激发了我对测试开发的兴趣，所以就应聘了测试开发这个岗位。</p><p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 最后感谢 饿了么 给我这次面试机会，我也十分希望能进入 饿了么 ，与公司共同成长进步！</p><h3 id="为什么选择测开"><a href="#为什么选择测开" class="headerlink" title="为什么选择测开"></a>为什么选择测开</h3><p>之前在社区的一个开发经历让我对软件质量和稳定性产生了兴趣，认为测试开发是保证软件质量的重要环节。我认为测试开发不仅仅是为了找到软件中的bug，更是为了确保软件在各种场景下都能稳定运行，从而提升用户体验。这其实是软件开发中非常重要的一环。</p><blockquote><p>需要与开发人员紧密合作，及时沟通和反馈，确保开发进度和质量。</p></blockquote><h3 id="做过哪些关于测开的工作"><a href="#做过哪些关于测开的工作" class="headerlink" title="做过哪些关于测开的工作"></a>做过哪些关于测开的工作</h3><p>之前负责给社区写一个适配器。</p><p>Casbin是一个灵活强大的权限访问控制库，PyCasbin 是 Python 版本的，广泛用于管理应用程序中的权限。为了更好地集成数据库操作，PyCasbin 提供了一些适配器，其中包括异步 <code>SQLAlchemy</code> 适配器。这种适配器允许在异步环境中使用 <code>SQLAlchemy</code> 作为持久化层，管理 Casbin 的策略存储。</p><p>主要工作：</p><ul><li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li><li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li></ul><p>技术细节</p><ul><li>测试框架：使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。 </li><li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul><li>测试添加一个策略，添加多个策略</li><li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li><li>测试更新一个策略，测试更新多个策略。</li></ul></li></ul><p>还有就是我在社区中自己做的每个 sdk，其中都使用 Github workflow进行持续集成和部署，然后也可以编写一些这种自动化脚本。</p><h3 id="测试类型分类"><a href="#测试类型分类" class="headerlink" title="测试类型分类"></a>测试类型分类</h3><ul><li>单元测试(Unit Testing)<ul><li>定义：对软件中的最小可测试单元进行验证，通常是函数或方法。</li><li>目的：确保每个单元独立工作正确。</li></ul></li><li>集成测试(Integration Testing)<ul><li>定义：在单元测试的基础上，测试多个单元组合在一起后的功能。</li><li>目的：确保模块之间的交互正确。</li></ul></li><li>系统测试(System Testing)<ul><li>定义：在一个完整的系统环境中进行测试。</li><li>目的：验证整个系统是否满足需求。</li></ul></li><li>验收测试(Acceptance Testing)<ul><li>定义：由客户或终端用户进行，确认系统满足业务需求。</li><li>目的：确保软件的最终产品符合预期用途。</li></ul></li></ul><h3 id="测试方法分类"><a href="#测试方法分类" class="headerlink" title="测试方法分类"></a>测试方法分类</h3><ul><li>黑盒测试：测试者不需要了解内部代码结构，只测试输入和输出。<ul><li>技术：等价类划分、边界值分析、决策表。</li><li>优点：基于功能需求，容易理解和实施。</li><li>缺点：无法覆盖内部实现细节。</li></ul></li><li>白盒测试：测试者需要了解内部代码结构，根据代码逻辑进行测试。软件代码改变，测试用例也需要改变。<ul><li>技术：语句覆盖、分支覆盖、路径覆盖。</li><li>优点：可以发现代码中的隐含错误和缺陷。</li><li>缺点：需要较高的技术知识，测试维护成本高。</li></ul></li><li>灰盒测试：结合黑盒和白盒测试，测试者了解部分内部结构。<ul><li>技术：使用部分代码知识进行测试，如数据库图表。</li><li>优点：平衡内部和外部测试，能够发现更多缺陷。</li><li>缺点：复杂度高，需要更多的时间和资源。</li></ul></li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>描述输入实际值和预期输出行为或者结果的文档，同时也标识了测试过程结果与约束</p><h3 id="测试用例的设计方法"><a href="#测试用例的设计方法" class="headerlink" title="测试用例的设计方法"></a>测试用例的设计方法</h3><p>测试用例设计方法是软件测试中的关键环节，旨在确保全面覆盖软件的各个功能和可能的缺陷。以下是一些常见的测试用例设计方法：</p><ol><li>等价类划分(Equivalence Partitioning)<ul><li>定义：将输入域划分为若干等价类，每个等价类中的数据被认为是等价的，选取一个代表进行测试。</li><li>目的：减少测试用例数量，同时覆盖所有可能的输入。</li><li>应用：输入字段长度、有效值范围。</li><li>例子：如果输入年龄在1-100之间有效，可以划分为有效等价类(1-100)和无效等价类(小于1，大于100)。</li></ul></li><li>边界值分析(Boundary Value Analysis)<ul><li>定义：关注输入值的边界，选择边界值及其附近的值进行测试。</li><li>目的：发现边界值上的缺陷，因为边界往往是错误集中发生的地方。</li><li>应用：最大值、最小值、边界值上下的值。</li><li>例子：对于输入年龄在1-100之间的情况，测试值可以是0、1、2、99、100、101。</li></ul></li><li>决策表(Decision Table)<ul><li>定义：列出所有可能的输入条件及其对应的输出，形成一个表格，用于逻辑分析。</li><li>目的：确保所有逻辑路径都得到测试。</li><li>应用：复杂的业务逻辑、多条件判断。</li><li>例子：银行贷款审批系统，可以根据申请人的收入、信用评分、贷款金额等条件，生成决策表来测试不同组合的结果。</li></ul></li><li>状态转换图(State Transition Diagram)<ul><li>定义：根据系统状态和事件，描述状态之间的转换关系。</li><li>目的：验证系统在不同状态下的行为，确保状态转换正确。</li><li>应用：工作流系统、状态机。</li><li>例子：在线购物系统的订单状态，可以从“新订单”到“处理中”，再到“已发货”或“已取消”。</li></ul></li><li>因果图(Cause-Effect Graphing)<ul><li>定义：根据输入条件(原因)和系统响应(结果)，绘制因果关系图，生成测试用例。</li><li>目的：确保所有可能的输入组合都被测试。</li><li>应用：复杂系统的逻辑测试。</li><li>例子：电梯控制系统的输入条件如楼层选择、开关门按钮，可以使用因果图设计测试用例。</li></ul></li><li>场景测试(Scenario Testing)<ul><li>定义：基于用户的实际使用场景，设计真实的操作流程来进行测试。</li><li>目的：确保系统在实际使用中的正确性和用户体验。</li><li>应用：用户故事、用例。</li><li>例子：在线银行系统中，用户从登录到转账的整个操作流程。</li></ul></li><li>探索性测试(Exploratory Testing)<ul><li>定义：没有预先定义的测试用例，测试人员在探索系统过程中，根据发现动态设计和执行测试。</li><li>目的：发现意外的缺陷和问题，特别是那些传统测试用例未覆盖的部分。</li><li>应用：新功能、快速反馈。</li><li>例子：新上线的功能模块，通过不同用户角色和操作路径进行随机测试。</li></ul></li><li>使用基于模型的测试(Model-Based Testing)<ul><li>定义：利用系统的模型(如状态机、流程图)来生成测试用例。</li><li>目的：自动生成测试用例，确保系统行为符合模型。</li><li>应用：复杂系统的行为测试。</li><li>例子：ATM机操作流程模型，用于生成取款、查询余额等操作的测试用例。</li></ul></li></ol><p>这些测试用例设计方法可以帮助测试人员全面和系统地覆盖被测试软件的功能和可能的缺陷，从而提高测试效率和测试质量。</p><h3 id="测试生命周期"><a href="#测试生命周期" class="headerlink" title="测试生命周期"></a>测试生命周期</h3><ol><li>测试计划(Test Planning)<ul><li>定义：制定测试策略、范围、资源和时间表。</li><li>输出：测试计划文档。</li></ul></li><li>测试设计(Test Design)<ul><li>定义：设计测试用例和测试脚本。</li><li>输出：测试用例文档、测试脚本。</li></ul></li><li>测试执行(Test Execution)<ul><li>定义：执行测试用例，记录测试结果和缺陷。</li><li>输出：测试执行记录、缺陷报告。</li></ul></li><li>测试评估(Test Evaluation) <ul><li>定义：评估测试结果，确保所有缺陷已修复和验证。</li><li>输出：测试报告、缺陷状态报告。</li></ul></li><li>测试闭合(Test Closure)<ul><li>定义：结束测试活动，归档测试文档和数据。</li><li>输出：测试总结报告、测试文档归档。</li></ul></li></ol><h3 id="如何理解测试开发中的开发"><a href="#如何理解测试开发中的开发" class="headerlink" title="如何理解测试开发中的开发"></a>如何理解测试开发中的开发</h3><ul><li>编写测试用例： 测试开发人员编写测试用例来验证软件系统的不同功能。这些测试用例可以是单元测试、集成测试、端到端测试等，覆盖不同层次和方面的功能和行为。</li><li>编写自动化测试脚本： 测试开发人员使用编程语言(如Java、Python、JavaScript等)编写自动化测试脚本，用于执行测试用例并检查系统的响应和行为。这些脚本通常使用测试框架(如<code>JUnit</code>、<code>TestNG</code>、<code>Selenium</code>等)来组织和运行测试。</li><li>开发测试工具和框架： 测试开发人员开发测试工具和框架，用于简化测试过程、提高测试效率和覆盖率。这些工具和框架可以包括测试数据生成工具、模拟器、Mock对象、测试管理系统等。</li><li>维护测试代码： 随着软件系统的演变和变化，测试代码也需要不断更新和维护。测试开发人员负责确保测试代码的可靠性、稳定性和可维护性，以及及时更新测试代码以反映系统的变化。</li><li>参与持续集成和持续部署： 测试开发人员参与持续集成和持续部署流程，确保每次代码提交或部署后都运行自动化测试，并及时发现和解决问题。</li></ul><h3 id="如何使用测试保证一个模块的质量"><a href="#如何使用测试保证一个模块的质量" class="headerlink" title="如何使用测试保证一个模块的质量"></a>如何使用测试保证一个模块的质量</h3><p>为了保证一个模块的质量，需要制定全面的测试策略，覆盖不同类型的测试，从多个方面验证模块的功能、性能、安全性和可靠性。以下是具体步骤和方法：</p><ol><li>需求分析<ul><li>目标：明确模块的功能、性能和安全需求。</li><li>方法：与产品经理、开发人员和相关利益方沟通，阅读需求文档。</li></ul></li><li>制定测试计划<ul><li>内容：定义测试范围、测试目标、测试资源、测试环境、测试时间表。</li><li>文档：编写测试计划文档，列出测试策略和测试用例。</li></ul></li><li>测试用例设计<ul><li>功能测试用例<ul><li>等价类划分：将输入域划分为若干等价类，选取代表进行测试。</li><li>边界值分析：选择输入值的边界和附近值进行测试。</li><li>决策表：列出所有可能的输入条件及其对应的输出。</li><li>状态转换图：描述系统状态和事件之间的转换关系。</li></ul></li><li>非功能测试用例<ul><li>性能测试：设计负载测试和压力测试用例，验证模块在不同负载下的响应时间和吞吐量。</li><li>安全测试：设计安全漏洞测试用例，如SQL注入、XSS、CSRF等。</li><li>兼容性测试：设计跨平台和跨浏览器测试用例，验证模块在不同环境下的表现。</li></ul></li></ul></li><li>搭建测试环境<ul><li>硬件和软件环境：配置与生产环境类似的测试环境。</li><li>测试数据：准备多样化的测试数据，覆盖正常、异常和边界情况。</li></ul></li><li>执行测试用例<ul><li>手动测试：按照测试用例手动执行测试，记录测试结果。</li><li>自动化测试：使用自动化测试工具执行回归测试、性能测试等。</li></ul></li><li>缺陷报告和跟踪<ul><li>报告缺陷：使用缺陷跟踪工具(如JIRA)记录发现的缺陷，描述缺陷的复现步骤、严重性和优先级。</li><li>跟踪缺陷：与开发团队合作，确保缺陷得到及时修复和验证。</li></ul></li><li>测试评估和报告<ul><li>分析测试结果<ul><li>测试覆盖率：分析测试用例覆盖率，确保关键功能和边界情况得到充分测试。</li><li>缺陷分析：分析缺陷分布和严重性，评估模块质量。</li></ul></li><li>编写测试报告<ul><li>内容：包括测试摘要、测试结果、缺陷统计、测试评估和改进建议。</li><li>分享报告：与团队和相关利益方分享测试报告，讨论测试结果和改进措施。</li></ul></li></ul></li><li>执行回归测试<ul><li>目的：在缺陷修复后，重新测试相关功能，确保修复不影响其他部分。</li><li>工具：使用自动化测试工具，如Selenium、JUnit、pytest，快速执行回归测试。</li></ul></li><li>验收测试<ul><li>定义：根据需求文档和测试计划，定义模块验收标准。</li><li>执行：与客户或终端用户一起进行验收测试，确认模块满足业务需求。</li></ul></li><li>测试闭合<ul><li>总结测试过程：分析测试的成功和失败，提炼经验教训。</li><li>归档测试文档：保存测试计划、测试用例、测试报告、缺陷报告等文档，以备将来参考。</li></ul></li></ol><p>通过上述步骤，全面和系统地进行测试，可以有效保证模块的质量，确保其功能正确、性能优良、安全可靠。</p><h3 id="针对优酷视频-从系统层面如何进行测试"><a href="#针对优酷视频-从系统层面如何进行测试" class="headerlink" title="针对优酷视频 从系统层面如何进行测试"></a>针对优酷视频 从系统层面如何进行测试</h3><p>对优酷视频(或其他视频播放应用)进行系统层面的测试可以从多个方面入手，包括功能测试、性能测试、兼容性测试、安全测试等。以下是每个测试类型的详细说明：</p><ul><li>功能测试<ul><li>基础功能测试：<ul><li>播放功能：检查视频的播放、暂停、快进、快退、音量控制、全屏切换等功能是否正常。</li><li>搜索功能：测试搜索栏输入关键词后是否能准确返回相关视频。</li><li>下载功能：检查视频下载功能，确保下载后的视频可以正常播放。</li><li>账户管理：注册、登录、修改密码、找回密码等功能的测试。</li></ul></li><li>高级功能测试：<ul><li>推荐系统：测试推荐的视频是否符合用户的观看历史和偏好。</li><li>字幕和语言选择：检查是否能正常选择和切换字幕及语言。</li></ul></li></ul></li><li>性能测试<ul><li>加载时间测试：<ul><li>启动时间：测试应用从启动到首页加载完成所需的时间。</li><li>视频加载时间：测试点击播放视频后视频开始播放所需的时间。</li></ul></li><li>流畅度测试：<ul><li>播放流畅度：测试视频播放过程中是否有卡顿、缓冲等现象。</li><li>响应速度：测试用户操作(如暂停、快进等)后的响应时间。</li></ul></li><li>资源占用测试：<ul><li>CPU和内存使用率：测试播放不同分辨率的视频时CPU和内存的使用情况。</li><li>网络带宽占用：测试视频播放过程中网络带宽的占用情况。</li></ul></li></ul></li><li>兼容性测试<ul><li>操作系统兼容性：在不同版本的操作系统(如Windows、macOS、iOS、Android)上测试应用的运行情况。</li><li>设备兼容性：在不同型号的手机、平板、电脑等设备上测试应用的表现。</li><li>浏览器兼容性：优酷视频有网页版，需要在不同浏览器(如Chrome、Firefox、Safari、Edge)上测试。</li></ul></li><li>安全测试<ul><li>数据传输安全：检查视频播放、账户登录等过程中是否使用了安全的传输协议(如HTTPS)。</li><li>隐私保护：确保用户的个人信息(如账号、密码、观看历史等)不会被泄露或滥用。</li><li>漏洞扫描：使用自动化工具扫描应用的安全漏洞，并进行人工验证。</li></ul></li><li>自动化测试<ul><li>脚本编写：编写自动化测试脚本，对上述功能进行自动化测试，减少人工操作的工作量。</li><li>持续集成：将自动化测试脚本集成到CI&#x2F;CD流水线中，确保每次代码变更后都能进行全面的测试。</li></ul></li><li>用户体验测试<ul><li>界面设计：检查界面的布局、按钮的位置、字体的大小等是否符合用户习惯和视觉美学。</li><li>交互体验：测试用户在使用过程中是否能顺畅地完成各项操作，是否有困惑或不便之处。</li></ul></li></ul><p>通过以上多个方面的测试，可以全面保障优酷视频在各个层面的质量和用户体验。</p><h3 id="如何测试一个Java项目？"><a href="#如何测试一个Java项目？" class="headerlink" title="如何测试一个Java项目？"></a>如何测试一个Java项目？</h3><ul><li>单元测试： 编写单元测试来测试项目中的各个模块、类和方法。使用 JUnit 或 TestNG 等单元测试框架来编写测试用例，并确保覆盖尽可能多的代码路径和边界情况。</li><li>集成测试： 编写集成测试来测试项目中不同模块之间的交互。这可以包括测试数据库访问、外部 API 调用、消息队列等。使用 JUnit、Mockito 等工具来模拟外部依赖，并编写集成测试用例。</li><li>性能测试： 对项目进行性能测试，评估其在不同负载下的性能表现。使用 JMeter、Gatling 等性能测试工具来模拟大量用户请求，并监控系统的响应时间、吞吐量等指标。</li><li>持续集成和持续部署： 将测试集成到持续集成和持续部署流程中，确保每次代码提交或部署后都运行测试，并及时发现和修复问题。</li></ul><h3 id="如何判断所写接口功能正常？"><a href="#如何判断所写接口功能正常？" class="headerlink" title="如何判断所写接口功能正常？"></a>如何判断所写接口功能正常？</h3><ul><li>功能测试： 确保接口按照预期工作。这包括发送各种有效和无效的输入数据，并验证接口的响应是否符合预期。例如，如果接口是一个登录接口，你可以测试使用正确的用户名和密码进行登录是否成功，以及使用错误的凭据时是否会得到适当的错误消息。</li><li>性能测试： 检查接口的性能，包括响应时间、吞吐量等指标。确保接口在负载增加时仍然能够正常工作，并且性能不会严重下降。</li><li>安全测试： 确保接口受到适当的安全保护，例如输入验证、防止SQL注入、XSS攻击等。</li><li>兼容性测试： 确保接口在不同的浏览器、操作系统和设备上都能正常工作。</li></ul><h3 id="怎么构造无用测试用例？"><a href="#怎么构造无用测试用例？" class="headerlink" title="怎么构造无用测试用例？"></a>怎么构造无用测试用例？</h3><ul><li>随机数据： 使用随机生成的数据作为输入。这些数据可能不符合业务逻辑或实际情况，从而导致测试用例的无用性。</li><li>非法输入： 提供完全不合法的输入数据。例如，如果一个字段要求输入数字，你可以提供字母字符或特殊字符。</li><li>重复数据： 重复使用相同的数据进行测试，而不关注不同数据情况下的行为。这样做可能会错过一些潜在的问题。</li></ul><h3 id="如何感知线上项目出现问题"><a href="#如何感知线上项目出现问题" class="headerlink" title="如何感知线上项目出现问题"></a>如何感知线上项目出现问题</h3><p>日志监控： 实时监控系统的日志以捕获异常情况和错误信息。通过设置适当的日志级别和使用日志聚合工具，可以帮助发现潜在的问题。<br>性能监控： 监控系统的性能指标，如响应时间、吞吐量、CPU 使用率、内存使用率等。突然的性能下降可能是系统出现问题的迹象。<br>自动化测试： 编写自动化测试用例，定期运行以确保系统的功能和性能符合预期。自动化测试可以在每次部署后运行，帮助发现新的问题。</p><h3 id="小红书购物搜索框设计测试用例"><a href="#小红书购物搜索框设计测试用例" class="headerlink" title="小红书购物搜索框设计测试用例"></a>小红书购物搜索框设计测试用例</h3><p>测试用例名称：搜索框输入有效关键词</p><ul><li>输入：在搜索框中输入有效的商品关键词，例如“连衣裙”。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面显示与输入关键词相关的商品列表。</li></ul><p>测试用例名称：搜索框输入无效关键词</p><ul><li>输入：在搜索框中输入无效的商品关键词，例如“@@@”。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面提示“未找到相关商品”。</li></ul><p>测试用例名称：搜索框输入空关键词</p><ul><li>输入：在搜索框中不输入任何内容。</li><li>操作：点击搜索按钮或按下回车键。</li><li>预期结果：搜索结果页面显示全部商品列表。</li></ul><p>测试用例名称：搜索框联想功能</p><ul><li>输入：在搜索框中输入部分关键词，例如“连衣”。</li><li>操作：等待几秒钟，观察搜索框下方是否出现联想词。</li><li>预期结果：搜索框下方显示与输入关键词相关的联想词列表。</li></ul><p>测试用例名称：搜索框输入并选择联想词</p><ul><li>输入：在搜索框中输入部分关键词，例如“连衣”。</li><li>操作：从联想词列表中选择一个词，例如“连衣裙”。</li><li>预期结果：搜索框中显示选择的联想词，并跳转到与该词相关的搜索结果页面。</li></ul><p>测试用例名称：搜索框清空功能</p><ul><li>输入：在搜索框中输入关键词，例如“连衣裙”。</li><li>操作：点击搜索框右侧的清空按钮。</li><li>预期结果：搜索框中的文本被清空，搜索框恢复为空状态。</li></ul><h3 id="登录设计测试样例"><a href="#登录设计测试样例" class="headerlink" title="登录设计测试样例"></a>登录设计测试样例</h3><p>测试用例名称：输入有效的用户名和密码登录</p><ul><li>输入：有效的用户名和密码。</li><li>操作：在登录页面输入用户名和密码，点击登录按钮。</li><li>预期结果：成功登录，跳转到用户的个人资料页面或首页。</li></ul><p>测试用例名称：输入无效的用户名和密码登录</p><ul><li>输入：无效的用户名和密码。</li><li>操作：在登录页面输入错误的用户名和密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名或密码错误的错误信息。</li></ul><p>测试用例名称：输入不存在的用户名登录</p><ul><li>输入：不存在的用户名和有效密码。</li><li>操作：在登录页面输入不存在的用户名和有效密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名不存在的错误信息。</li></ul><p>测试用例名称：输入正确的用户名和空密码登录</p><ul><li>输入：有效的用户名和空密码。</li><li>操作：在登录页面输入正确的用户名和空密码，点击登录按钮。</li><li>预期结果：登录失败，提示密码不能为空的错误信息。</li></ul><p>测试用例名称：输入空用户名和正确密码登录</p><ul><li>输入：空用户名和有效的密码。</li><li>操作：在登录页面输入空用户名和正确的密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名不能为空的错误信息。</li></ul><p>测试用例名称：输入特殊字符的用户名和密码登录</p><ul><li>输入：包含特殊字符的用户名和密码。</li><li>操作：在登录页面输入包含特殊字符的用户名和密码，点击登录按钮。</li><li>预期结果：登录失败，提示用户名或密码格式不正确的错误信息。</li></ul><p>测试用例名称：记住登录状态</p><ul><li>输入：有效的用户名和密码。</li><li>操作：在登录页面勾选“记住我”选项后登录。</li><li>预期结果：成功登录后，关闭浏览器再次打开时，应自动保持登录状态，无需重新输入用户名和密码。</li></ul><p>测试用例名称：登录页链接验证</p><ul><li>输入：无。</li><li>操作：检查登录页面上的链接。</li><li>预期结果：登录页面应包含“忘记密码”、“注册账号”等相关链接，确保用户可以方便地进行其他操作。</li></ul><p>测试用例名称：跳转到登录页面</p><ul><li>输入：未登录状态。</li><li>操作：尝试访问需要登录权限的页面。</li><li>预期结果：跳转到登录页面，并在登录成功后自动跳回原页面。</li></ul><p>测试用例名称：登录界面的响应速度</p><ul><li>输入：无。</li><li>操作：在不同网络环境下打开登录页面。</li><li>预期结果：登录页面应该在合理的时间内加载完成，不应该出现过长的加载时间。</li></ul><h3 id="微信发送文件的测试用例"><a href="#微信发送文件的测试用例" class="headerlink" title="微信发送文件的测试用例"></a>微信发送文件的测试用例</h3><p>功能测试</p><ul><li>正常发送文件</li><li>发送支持的文件类型</li></ul><p>边界值测试</p><ul><li>发送最大允许大小的文件</li><li>发送超过最大允许大小的文件</li></ul><p>异常情况测试</p><ul><li>发送空文件</li><li>发送损坏文件</li><li>网络中断后重新发送</li></ul><p>性能测试</p><ul><li>同时发送多个文件</li><li>选择一个接近最大允许大小的文件</li></ul><p>用户体验测试</p><ul><li>发送文件时的用户提示</li><li>文件发送记录</li></ul><p>安全性测试</p><ul><li>发送包含敏感信息的文件</li><li>病毒文件检测</li></ul><p>跨平台测试</p><h3 id="微信发送红包的测试用例"><a href="#微信发送红包的测试用例" class="headerlink" title="微信发送红包的测试用例"></a>微信发送红包的测试用例</h3><ul><li><p>功能测试<br>正常发送红包<br>发送拼手气红包<br>发送定向红包</p></li><li><p>边界值测试<br>发送最低和最高金额的红包<br>发送超过最高金额的红包</p></li><li><p>异常情况测试<br>余额不足时发送红包<br>网络中断后重新发送<br>取消发送红包</p></li><li><p>安全性测试<br>多测领取红包<br>红包过期<br>未实名验证用户发送红包<br>单方删除好友后发送红包</p></li></ul><p>用户体验测试</p><p>跨平台测试</p><p>性能测试</p><ul><li>高频发送红包</li><li>大规模红包领取(拼手气红包)</li></ul><h3 id="电影订票功能的测试样例"><a href="#电影订票功能的测试样例" class="headerlink" title="电影订票功能的测试样例"></a>电影订票功能的测试样例</h3><p>功能测试</p><ul><li>检查电影本身的信息和电影院(不同的电影院)、场次(不同的场次)、座位信息(已售出和可售状态)是否显示正确</li><li>验证不同支付方式是否可用</li><li>验证电子票是否包含必要信息、是否能通过扫描进入影院</li></ul><p>边界和异常情况测试</p><ul><li>无效的账户或者账户余额不足进行支付</li><li>用户选择座位但未完成支付，座位在一定时间后能否自动释放</li></ul><p>性能测试</p><ul><li>系统负载测试：高并发访问</li><li>正常负载和高负载下的响应时间是否正常</li></ul><p>兼容性测试</p><h3 id="电商满减优惠券测试用例设计"><a href="#电商满减优惠券测试用例设计" class="headerlink" title="电商满减优惠券测试用例设计"></a>电商满减优惠券测试用例设计</h3><p>设计电商满减优惠券的测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p><ul><li><p>正常情况</p><ul><li>优惠券满减条件满足<ul><li>用例描述：用户购物车金额为150元，使用满100减20元优惠券。</li><li>预期结果：最终支付金额为130元。</li></ul></li><li>优惠券满减条件满足多张<ul><li>用例描述：用户购物车金额为250元，使用两张满100减20元优惠券。</li><li>预期结果：最终支付金额为210元。</li></ul></li></ul></li><li><p>边界情况 </p><ul><li>刚好满足满减条件<ul><li>用例描述：用户购物车金额为100元，使用满100减20元优惠券。</li><li>预期结果：最终支付金额为80元。</li></ul></li><li>差一分钱满足满减条件<ul><li>用例描述：用户购物车金额为99.99元，使用满100减20元优惠券。</li><li>预期结果：不能使用优惠券，最终支付金额为99.99元。</li></ul></li><li>超过满减条件1分钱<ul><li>用例描述：用户购物车金额为100.01元，使用满100减20元优惠券。</li><li>预期结果：最终支付金额为80.01元。</li></ul></li></ul></li><li><p>异常情况</p><ul><li>优惠券已过期<ul><li>用例描述：用户尝试使用一张已过期的满100减20元优惠券。</li><li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li></ul></li><li>优惠券不适用商品<ul><li>用例描述：用户购物车内商品不在优惠券适用范围，购物车金额为150元，使用满100减20元优惠券。</li><li>预期结果：提示优惠券不适用，不能使用，最终支付金额为150元。</li></ul></li><li>优惠券已被使用<ul><li>用例描述：用户尝试使用一张已被使用过的满100减20元优惠券。</li><li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li></ul></li></ul></li><li><p>多重优惠情况</p><ul><li>叠加优惠券<ul><li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张满100减20元优惠券。</li><li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用满100减20元优惠券，最终支付金额为230元。</li></ul></li><li>不同优惠券叠加使用规则<ul><li>用例描述：用户购物车金额为300元，使用一张满200减50元优惠券和一张全场9折优惠券。</li><li>预期结果：先使用满200减50元优惠券，金额变为250元，再使用9折优惠券，最终支付金额为225元。</li></ul></li></ul></li><li><p>优惠券优先级情况</p><ul><li>有多张优惠券可用<ul><li>用例描述：用户购物车金额为200元，有满100减20元优惠券和满150减30元优惠券。</li><li>预期结果：系统自动选择满150减30元优惠券，最终支付金额为170元。</li></ul></li></ul></li><li><p>无法使用优惠券的情况</p><ul><li>购物车金额不足<ul><li>用例描述：用户购物车金额为50元，使用满100减20元优惠券。</li><li>预期结果：不能使用优惠券，最终支付金额为50元。</li></ul></li><li>优惠券被取消<ul><li>用例描述：用户尝试使用被商家取消的优惠券。</li><li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li></ul></li></ul></li></ul><p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试电商平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p><h3 id="外卖优惠券测试用例设计"><a href="#外卖优惠券测试用例设计" class="headerlink" title="外卖优惠券测试用例设计"></a>外卖优惠券测试用例设计</h3><p>设计外卖平台的满减优惠券测试用例需要考虑各种场景，包括正常情况、边界情况和异常情况。以下是一些详细的测试用例设计：</p><ul><li><p>正常情况</p><ul><li>优惠券满减条件满足<ul><li>用例描述：用户订单金额为60元，使用满50减10元优惠券。</li><li>预期结果：最终支付金额为50元。</li></ul></li><li>优惠券满减条件满足多张<ul><li>用例描述：用户订单金额为120元，使用两张满50减10元优惠券。</li><li>预期结果：最终支付金额为100元。</li></ul></li></ul></li><li><p>边界情况</p><ul><li>刚好满足满减条件<ul><li>用例描述：用户订单金额为50元，使用满50减10元优惠券。</li><li>预期结果：最终支付金额为40元。</li></ul></li><li>差一分钱满足满减条件<ul><li>用例描述：用户订单金额为49.99元，使用满50减10元优惠券。</li><li>预期结果：不能使用优惠券，最终支付金额为49.99元。</li></ul></li><li>超过满减条件1分钱<ul><li>用例描述：用户订单金额为50.01元，使用满50减10元优惠券。</li><li>预期结果：最终支付金额为40.01元。</li></ul></li></ul></li><li><p>异常情况</p><ul><li>优惠券已过期<ul><li>用例描述：用户尝试使用一张已过期的满50减10元优惠券。</li><li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li></ul></li><li>优惠券不适用餐厅<ul><li>用例描述：用户订单来自不适用优惠券的餐厅，订单金额为60元，使用满50减10元优惠券。</li><li>预期结果：提示优惠券不适用，不能使用，最终支付金额为60元。</li></ul></li><li>优惠券已被使用<ul><li>用例描述：用户尝试使用一张已被使用过的满50减10元优惠券。</li><li>预期结果：提示优惠券已被使用，不能再次使用，最终支付金额为原金额。</li></ul></li></ul></li><li><p>多重优惠情况</p><ul><li>叠加优惠券<ul><li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张满50减10元优惠券。</li><li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用满50减10元优惠券，最终支付金额为70元。</li></ul></li><li>不同优惠券叠加使用规则<ul><li>用例描述：用户订单金额为100元，使用一张满80减20元优惠券和一张全场9折优惠券。</li><li>预期结果：先使用满80减20元优惠券，金额变为80元，再使用9折优惠券，最终支付金额为72元。</li></ul></li></ul></li><li><p>优惠券优先级情况</p><ul><li>有多张优惠券可用<ul><li>用例描述：用户订单金额为100元，有满50减10元优惠券和满80减20元优惠券。</li><li>预期结果：系统自动选择满80减20元优惠券，最终支付金额为80元。</li></ul></li></ul></li><li><p>无法使用优惠券的情况</p><ul><li>订单金额不足<ul><li>用例描述：用户订单金额为30元，使用满50减10元优惠券。</li><li>预期结果：不能使用优惠券，最终支付金额为30元。</li></ul></li><li>优惠券被取消<ul><li>用例描述：用户尝试使用被商家取消的优惠券。</li><li>预期结果：提示优惠券无效，不能使用，最终支付金额为原金额。</li></ul></li></ul></li><li><p>特殊情况</p><ul><li>优惠券部分使用<ul><li>用例描述：用户订单金额为55元，使用满50减10元优惠券，同时使用余额支付(5元)。</li><li>预期结果：订单金额55元，使用优惠券后支付45元，再用余额支付5元，最终支付金额为40元。</li></ul></li></ul></li></ul><p>这些测试用例涵盖了常见的优惠券使用场景，可以帮助全面测试外卖平台的满减优惠券功能，确保系统能够正确处理各种情况下的优惠券使用。</p><h3 id="Github-Workflow自动化测试"><a href="#Github-Workflow自动化测试" class="headerlink" title="Github Workflow自动化测试"></a>Github Workflow自动化测试</h3><p>GitHub Workflow 是指 GitHub Actions 的一种自动化流程管理功能。它可以用于多种用途，包括但不限于测试。具体来说，GitHub Workflow 可以用来：</p><ol><li>持续集成(CI)： 自动运行测试用例，以确保代码在合并之前是正常工作的。这是最常见的用例之一。</li><li>持续部署(CD)： 自动将代码部署到生产环境或其他目标环境。</li><li>代码分析和质量检查： 运行静态代码分析工具，以检查代码质量和一致性。</li><li>构建和发布： 自动构建应用程序并发布构建产物，比如发布到包管理工具(如npm、PyPI)或者生成文档。</li><li>自动化任务： 自动执行脚本或命令，如自动关闭已解决的GitHub Issues、定时执行任务等。</li></ol><p>在 GitHub Actions 中，workflow 文件是通过 <code>.yml</code> 或 <code>.yaml</code> 文件定义的，通常放在 <code>.github/workflows/</code> 目录下。每个 workflow 文件定义了一个或多个 jobs，这些 jobs 可以并行或串行地执行。</p><p>示例：</p><p>以下是一个简单的 GitHub Workflow 文件示例，用于在每次推送时运行测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;14&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><h3 id="支付宝-微信转账功能测试用例"><a href="#支付宝-微信转账功能测试用例" class="headerlink" title="支付宝&#x2F;微信转账功能测试用例"></a>支付宝&#x2F;微信转账功能测试用例</h3><p>在设计支付宝转账功能的测试用例时，应该覆盖各种正常情况、边界情况和异常情况，以确保转账功能的健壮性和可靠性。以下是详细的测试用例设计：</p><ul><li><p>正常情况</p><ul><li>成功转账<ul><li>用例描述：用户A向用户B成功转账100元。</li><li>前置条件：用户A账户余额大于等于100元，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额100元。</li><li>输入用户B的账户信息。</li><li>确认转账。</li></ol></li><li>预期结果：转账成功，用户A账户余额减少100元，用户B账户余额增加100元。</li></ul></li><li>转账金额包含小数<ul><li>用例描述：用户A向用户B转账50.75元。</li><li>前置条件：用户A账户余额大于等于50.75元，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额50.75元。</li><li>输入用户B的账户信息。</li><li>确认转账。</li></ol></li><li>预期结果：转账成功，用户A账户余额减少50.75元，用户B账户余额增加50.75元。</li></ul></li></ul></li><li><p>边界情况</p><ul><li>转账金额为0<ul><li>用例描述：用户A向用户B转账0元。</li><li>前置条件：用户A账户有效，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额0元。</li><li>输入用户B的账户信息。</li><li>尝试确认转账。</li></ol></li><li>预期结果：系统提示转账金额无效，转账失败。</li></ul></li><li>转账金额为账户余额<ul><li>用例描述：用户A向用户B转账用户A的全部余额。</li><li>前置条件：用户A账户余额为200元，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额200元。</li><li>输入用户B的账户信息。</li><li>确认转账。</li></ol></li><li>预期结果：转账成功，用户A账户余额减少200元，用户B账户余额增加200元。</li></ul></li></ul></li><li><p>异常情况</p><ul><li>转账金额超过账户余额<ul><li>用例描述：用户A尝试向用户B转账300元，而用户A账户余额只有100元。</li><li>前置条件：用户A账户余额100元，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额300元。</li><li>输入用户B的账户信息。</li><li>尝试确认转账。</li></ol></li><li>预期结果：系统提示余额不足，转账失败。</li></ul></li><li>用户B账户无效<ul><li>用例描述：用户A尝试向一个无效的用户B账户转账100元。</li><li>前置条件：用户A账户余额大于等于100元，用户B账户无效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额100元。</li><li>输入无效的用户B的账户信息。</li><li>尝试确认转账。</li></ol></li><li>预期结果：系统提示用户B账户无效，转账失败。</li></ul></li><li>网络连接中断<ul><li>用例描述：用户A在转账过程中网络连接中断。</li><li>前置条件：用户A账户有效，用户B账户有效，网络连接不稳定。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额100元。</li><li>输入用户B的账户信息。</li><li>确认转账时网络中断。</li></ol></li><li>预期结果：系统提示网络连接问题，转账未完成。</li></ul></li></ul></li><li><p>安全测试</p><ul><li>防止重复提交<ul><li>用例描述：用户A在确认转账后多次点击确认按钮。</li><li>前置条件：用户A账户有效，用户B账户有效，转账金额为100元。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额100元。</li><li>输入用户B的账户信息。</li><li>多次点击确认转账按钮。</li></ol></li><li>预期结果：系统只执行一次转账操作，用户A账户减少100元，用户B账户增加100元。</li></ul></li><li>转账金额非法字符<ul><li>用例描述：用户A尝试输入非法字符作为转账金额。</li><li>前置条件：用户A账户有效，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入非法字符(如”abc”)作为转账金额。</li><li>输入用户B的账户信息。</li><li>尝试确认转账。</li></ol></li><li>预期结果：系统提示金额无效，转账失败。</li></ul></li></ul></li><li><p>其他情况</p><ul><li>跨境转账<ul><li>用例描述：用户A向国外的用户B转账100美元。</li><li>前置条件：用户A账户有效且支持跨境转账，用户B账户有效，用户A有足够的美元余额。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择跨境转账功能。</li><li>输入转账金额100美元。</li><li>输入用户B的账户信息。</li><li>确认转账。</li></ol></li><li>预期结果：转账成功，用户A美元余额减少100美元，用户B账户美元余额增加100美元。</li></ul></li><li>转账备注<ul><li>用例描述：用户A向用户B转账100元，并添加备注信息。</li><li>前置条件：用户A账户有效，用户B账户有效。</li><li>操作步骤：<ol><li>用户A登录支付宝账户。</li><li>用户A选择转账功能。</li><li>输入转账金额100元。</li><li>输入用户B的账户信息。</li><li>添加转账备注信息(如“生日礼物”)。</li><li>确认转账。</li></ol></li><li>预期结果：转账成功，备注信息正确保存，用户A账户减少100元，用户B账户增加100元。</li></ul></li></ul></li></ul><p>这些测试用例覆盖了支付宝转账功能的主要场景，可以帮助全面测试转账功能，确保系统能够正确处理各种情况下的转账操作。</p><p>在这个示例中，workflow 文件名为 <code>ci.yml</code>，它定义了一个名为 <code>build</code> 的 job，该 job 在 <code>ubuntu-latest</code> 的环境上运行。整个过程包括以下步骤：</p><ol><li>Checkout code：检出代码仓库。</li><li>Set up Node.js：设置 Node.js 环境。</li><li>Install dependencies：安装依赖。</li><li>Run tests：运行测试。</li></ol><p>所以，GitHub Workflow 可以用于测试，但它的应用范围远不止于此。</p><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul><li>JUnit：JUnit是Java中最流行的单元测试框架之一，用于编写和运行单元测试。它提供了一组注解和断言方法，使得编写测试用例变得简单易懂。</li><li>TestNG：TestNG是另一个流行的Java测试框架，提供了比JUnit更丰富的功能，例如参数化测试、测试组、依赖测试等。它也可以用于编写单元测试和集成测试。</li><li>Selenium：Selenium是用于自动化Web应用程序测试的工具，它支持多种浏览器，并提供了Java API，使得测试脚本的编写和执行变得简单。Selenium可以用于执行功能测试、回归测试等。</li><li>JMeter：JMeter是一个用于性能测试的工具，它可以模拟大量用户并测量应用程序的性能和稳定性。JMeter也可以用于功能测试和接口测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 测试开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端&amp;移动端面经</title>
      <link href="/posts/17767.html"/>
      <url>/posts/17767.html</url>
      
        <content type="html"><![CDATA[<h3 id="虚拟列表实现原理"><a href="#虚拟列表实现原理" class="headerlink" title="虚拟列表实现原理"></a>虚拟列表实现原理</h3><p>虚拟列表（Virtual List）是一种在数据量较大时，优化显示性能和用户体验的技术。其核心思想是在渲染和显示过程中只加载和显示当前视窗内的部分数据，而不是一次性加载和渲染全部数据。这样可以显著减少内存消耗和提高渲染速度。虚拟列表通常用于长列表或表格组件中，特别是在Web应用和移动应用中。</p><ul><li>实现原理</li></ul><ol><li>可视区域（Viewport）：虚拟列表只渲染用户当前可见区域内的列表项。用户滚动时，更新可视区域内的列表项。</li><li>缓冲区（Buffer）：为了防止滚动时的卡顿，虚拟列表通常会在可视区域上下增加一定数量的缓冲区列表项。这些缓冲区项可以在用户快速滚动时提前加载，保证平滑滚动。</li><li>位置计算（Position Calculation）：通过计算每个列表项在整个列表中的位置，只渲染可视区域和缓冲区内的项。使用绝对定位或CSS变换属性将这些项放置在正确的位置。</li><li>事件监听（Event Listener）：监听滚动事件，根据滚动位置更新可视区域和缓冲区内的列表项。</li></ol><ul><li>具体实现步骤</li></ul><ol><li>初始设置：确定列表项的高度（或宽度），以及可视区域的高度（或宽度）。如果列表项高度不一致，需要预估一个平均值或进行动态调整。</li><li>渲染可视区域内的项：根据当前滚动位置和可视区域大小，计算需要渲染的列表项的起始和结束索引。</li><li>更新DOM：只将计算得到的列表项添加到DOM中，并更新其位置。未在可视区域和缓冲区内的项应从DOM中移除。</li><li>滚动事件处理：监听滚动事件，当滚动位置发生变化时，重新计算需要渲染的列表项，并更新DOM。</li></ol><h3 id="JavaScript✅"><a href="#JavaScript✅" class="headerlink" title="JavaScript✅"></a>JavaScript✅</h3><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><ul><li><p>原始类型：<code>undefined</code>, <code>null</code>, <code>boolean</code>, <code>number</code>, <code>bigint</code>, <code>string</code>, <code>symbol</code></p></li><li><p>引用类型：<code>object</code>, <code>array</code>, <code>function</code>, <code>date</code>, <code>regexp</code></p></li><li><p>原始类型：这些类型直接包含值，比较时是值的比较。</p><ul><li><code>Undefined</code>: 一个变量声明了，但没有赋值时，它的值就是<code>undefined</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><code>Null</code>: 表示一个空的或不存在的对象。与<code>undefined</code>不同，<code>null</code>是一个赋值对象，表示变量没有值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li><li><code>Boolean</code>: 只有两个值：<code>true</code>和<code>false</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isActive); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><code>Number</code>: 包括整数和浮点数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> price = <span class="number">9.99</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 42</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(price); <span class="comment">// 9.99</span></span><br></pre></td></tr></table></figure></li><li><code>BigInt</code>: 可以表示大于<code>Number</code>类型范围的整数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigIntNum = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bigIntNum); <span class="comment">// 1234567890123456789012345678901234567890n</span></span><br></pre></td></tr></table></figure></li><li><code>String</code>: 用于表示文本数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;Alice&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>Symbol</code>: 是一种唯一且不可变的数据类型，通常用于对象属性的唯一标识符。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sym); <span class="comment">// Symbol(description)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>引用类型：引用类型的值是对象，比较时是引用的比较。</p><ul><li><code>Object</code>: 用于存储集合数据或更复杂的实体。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Bob&#x27;, age: 30 &#125;</span></span><br></pre></td></tr></table></figure></li><li><code>Array</code>: 一种特殊类型的对象，用于存储有序集合。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><code>Function</code>: 一种可调用的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure></li><li><code>Date</code>: 用于表示日期和时间。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now); <span class="comment">// 当前日期和时间</span></span><br></pre></td></tr></table></figure></li><li><code>RegExp</code>: 正则表达式，用于模式匹配字符串。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern); <span class="comment">// /ab+c/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>JavaScript中的数据类型可以通过<code>typeof</code>操作符来检查：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">42</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;hello&quot;</span>); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// &quot;object&quot; (这是一个历史遗留问题)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><h3 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h3><p>在JavaScript中，堆和栈是两种不同的内存区域，它们各自负责不同类型数据的存储和管理。</p><ul><li>栈（Stack）<ul><li>存储内容：栈主要存储基本类型数据，如<code>undefined</code>, <code>string</code>, <code>boolean</code>, <code>number</code>等，以及函数调用的上下文和局部变量。</li><li>内存分配与回收：栈内存是由系统自动管理的，当一个函数被调用时，其参数和局部变量会被压入栈中；当函数返回时，这些数据会被弹出并释放。</li><li>访问方式：栈中的基本类型数据是按值访问的，这意味着你直接访问的是实际的值。</li><li>优点：内存分配和释放快速，管理简单，不需要额外的垃圾回收。</li><li>缺点：缺乏灵活性，数据的大小和生命周期需要在编译时确定。</li></ul></li><li>堆（Heap）<ul><li>存储内容：堆主要用于存储复杂类型或引用类型数据，如对象、数组和函数。这些数据的大小在创建时未知且可变。</li><li>内存分配与回收：堆内存的分配是动态的，由程序员（或更准确地说，由JavaScript引擎的垃圾回收器）控制。当一个对象不再被引用时，垃圾回收器会自动回收这块内存。</li><li>访问方式：堆中的引用类型数据是按引用访问的，即在栈中存储的是指向堆中实际对象的引用。</li><li>优点：提供了更大的灵活性，可以在运行时动态地分配和调整内存。</li><li>缺点：内存分配和访问相对缓慢，由于垃圾回收机制的介入，可能会导致不可预测的性能影响。</li></ul></li><li>总结<ul><li>栈内存适合于那些生命周期短、大小固定的变量，如函数内的局部变量。</li><li>堆内存适合于那些大小未知或可变的数据结构，如对象和数组。</li></ul></li></ul><p>在JavaScript中，函数调用和基本类型的变量通常使用栈内存，而对象、数组和函数体则存储在堆内存中。垃圾回收机制负责监控堆内存中的对象，并在适当时候释放不再使用的内存，以防止内存泄漏。</p><h3 id="JS是单线程还是多线程，什么情况下会新开一个线程"><a href="#JS是单线程还是多线程，什么情况下会新开一个线程" class="headerlink" title="JS是单线程还是多线程，什么情况下会新开一个线程"></a>JS是单线程还是多线程，什么情况下会新开一个线程</h3><p>JavaScript 在设计上是单线程的，这意味着在任何给定的时间点，JavaScript 引擎只能执行一个任务。这种设计的主要原因在于JavaScript最初是为了在浏览器环境中操作DOM（文档对象模型）而设计的，而DOM必须保持一致性，避免多个线程同时修改DOM导致的潜在冲突和复杂性。</p><p>现代的JavaScript环境提供了几种机制来模拟多线程行为或并行处理能力：</p><ol><li>Web Workers：<br>Web Workers允许JavaScript代码在后台线程中运行，从而不会阻塞UI线程。Web Workers提供了一种将计算密集型任务放到单独的线程中运行的方式，而不会影响到网页的响应速度。Web Workers和主线程之间通过消息传递进行通信。</li><li>Service Workers：<br>Service Workers是运行在浏览器后台的特殊类型的Worker，它们可以拦截网络请求，缓存资源，甚至在没有网络连接的情况下提供离线服务。Service Workers完全独立于主线程运行，可以处理推送通知和背景同步等功能。</li><li>Shared Workers：<br>Shared Workers类似于Web Workers，但它们可以被多个窗口、标签页或框架共享，允许这些上下文共享状态和数据。</li><li>Worker Threads in Node.js：<br>在Node.js环境中，虽然V8引擎本身是单线程的，但Node.js利用事件循环和异步I&#x2F;O来处理并发。从Node.js v10开始，引入了Worker Threads模块，允许创建在独立线程中运行的JavaScript代码片段，可以用于CPU密集型任务。</li></ol><h3 id="web-worker有哪些限制，与主线程怎么通信"><a href="#web-worker有哪些限制，与主线程怎么通信" class="headerlink" title="web worker有哪些限制，与主线程怎么通信"></a>web worker有哪些限制，与主线程怎么通信</h3><ul><li>限制<ul><li>DOM 访问限制：<ul><li>Web Workers 不能直接访问或操作 DOM。这意味着它们不能修改页面的内容或样式，也不能监听或触发 UI 事件。</li></ul></li><li>脚本限制：<ul><li>Web Workers 不能调用 <code>alert()</code>、<code>confirm()</code> 或 <code>prompt()</code> 函数，因为它们通常用于与用户交互，而 Web Workers 应用于后台任务。</li><li>也不能使用 <code>window</code>、<code>document</code> 或 <code>location</code> 等全局对象，因为它们与 UI 相关。</li></ul></li><li>同源策略：<ul><li>Web Workers 只能加载与创建它们的脚本同源的资源。这意味着如果 Web Worker 的脚本来自于不同的源，则会引发安全错误。</li></ul></li><li>资源限制：<ul><li>Web Workers 的使用可能会受到资源限制，例如每个页面可以创建的 Web Workers 数量，以及每个 Worker 可以使用的内存量。</li></ul></li><li>网络请求：<ul><li>尽管 Web Workers 可以使用 <code>XMLHttpRequest</code> 或 <code>fetch</code> API 发起网络请求，但它们不能接收 <code>onload</code> 或 <code>onerror</code> 等 UI 相关的事件回调。</li></ul></li></ul></li><li>与主线程的通信：主要依赖于 <code>postMessage</code> 方法和 <code>message</code> 事件处理器<ul><li>主线程向 Worker 发送消息：<ul><li>主线程可以通过调用 Worker 对象上的 <code>postMessage()</code> 方法来向 Worker 发送消息。这个方法接受一个参数，可以是任意可序列化的 JavaScript 数据类型（如字符串、数字、数组、对象等）。</li></ul></li><li>Worker 向主线程发送消息：<ul><li>Worker 线程同样可以使用 <code>self.postMessage()</code> 方法（<code>self</code> 指的是 Worker 线程的全局作用域）向主线程发送消息。</li></ul></li><li>监听消息：<ul><li>在主线程和 Worker 中，都可以通过添加事件监听器来处理接收到的消息。在主线程中，这个事件监听器添加到 Worker 对象上；在 Worker 中，事件监听器添加到 <code>self</code> 上。</li><li>事件处理器通常包含一个 <code>event</code> 参数，其中 <code>event.data</code> 包含了发送方通过 <code>postMessage</code> 发送的数据。</li></ul></li></ul></li></ul><h3 id="事件循环Event-Loop"><a href="#事件循环Event-Loop" class="headerlink" title="事件循环Event Loop"></a>事件循环Event Loop</h3><ul><li>任务队列：在 JS中存在不同类型的任务队列，其中包括：</li><li>同步任务队列（Synchronous Task Queue）：包含同步执行的任务，例如代码块、函数调用等。在执行完一个同步任务后，才会去处理下一个任务。</li><li>异步任务队列（Asynchronous Task Queue）：包含异步执行的任务，例如事件回调、定时器回调等。这些任务不会立即执行，而是在满足一定条件时被推入执行队列。<ul><li>异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code>，宏任务的话就是<code>setImmediate setTimeout setInterval</code></li></ul></li><li>Event Loop 是一个持续运行的循环，负责处理任务队列中的任务。它的基本工作流程如下：<ol><li>从同步任务队列中取出一个任务，执行该任务。</li><li>如果在执行同步任务的过程中产生了异步任务（例如定时器、事件回调等），则将这些异步任务添加到异步任务队列中，等待执行。</li><li>当同步任务队列为空时，Event Loop 会检查异步任务队列。</li><li>如果异步任务队列不为空，则按照一定的优先级顺序（通常是 FIFO）从队列中取出一个任务，执行该任务。</li><li>重复步骤 1 至步骤 4。</li></ol></li><li>举例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1. 同步任务开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2. 异步任务A&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3. 异步任务B&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4. 同步任务结束&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设没有其他操作，输出顺序应该是：</span></span><br><span class="line"><span class="comment">// 1. 同步任务开始</span></span><br><span class="line"><span class="comment">// 4. 同步任务结束</span></span><br><span class="line"><span class="comment">// 3. 异步任务B</span></span><br><span class="line"><span class="comment">// 2. 异步任务A</span></span><br></pre></td></tr></table></figure><ol><li>首先，<code>console.log(&#39;1. 同步任务开始&#39;);</code> 执行并打印 “1. 同步任务开始”。</li><li><code>setTimeout</code> 函数被调用，但是其回调函数不会立即执行，而是会被添加到微任务队列中（实际上，<code>setTimeout</code> 是宏任务，但在现代浏览器中，它的延迟可以非常短，这里我们假设它为0）。</li><li>接下来，<code>Promise.resolve().then()</code> 被调用，这是一个微任务，它会在当前宏任务结束时立即执行。</li><li><code>console.log(&#39;4. 同步任务结束&#39;);</code> 执行并打印 “4. 同步任务结束”。</li><li>当前宏任务执行完毕，所有的微任务（这里是<code>Promise</code>的回调）将被执行。因此，<code>console.log(&#39;3. 异步任务B&#39;);</code> 将会被执行并打印 “3. 异步任务B”。</li><li>最后，事件循环检查宏任务队列，发现有<code>setTimeout</code>的回调，所以它将被取出并执行，打印 “2. 异步任务A”。</li></ol></li></ul><p>需要注意的是，微任务（如Promise）在每个宏任务执行完后会立即执行，而宏任务（如setTimeout）则会等待所有微任务执行完后才执行下一个。这就是为什么在上述示例中，尽管<code>setTimeout</code>的延迟为0，但<code>Promise</code>的回调却先于<code>setTimeout</code>的回调执行的原因。</p><h3 id="Promise函数"><a href="#Promise函数" class="headerlink" title="Promise函数"></a>Promise函数</h3><p>Promise 提供了一种更优雅的方式来处理异步操作，使得代码更易读、更易维护。通过链式调用、Promise.all 和 Promise.race 等方法，可以更灵活地组织和处理异步操作的结果。</p><ul><li>原理：Promise 是 JavaScript 中处理异步操作的一种机制，其内部原理涉及到状态、回调函数队列等概念。 </li><li>Promise 内部有三种状态：<ul><li>Pending（进行中）：初始状态，表示异步操作尚未完成。</li><li>Fulfilled（已成功）：表示异步操作成功完成。</li><li>Rejected（已失败）：表示异步操作失败。</li><li>状态一旦发生变化，就不会再变化。例如，当 Promise 对象从 Pending 状态变为 Fulfilled 状态时，它就不能再变为 Rejected 状态，反之亦然。</li></ul></li><li>回调函数队列：Promise 内部有两个队列，分别用于存储成功态和失败态时的回调函数。<ul><li>成功态回调函数队列：存储 then 方法中的成功回调函数。</li><li>失败态回调函数队列：存储 then 方法中的失败回调函数。</li></ul></li><li>then 方法：Promise 提供了 then 方法用于注册对异步操作结果的处理逻辑。then 方法接受两个参数：成功回调函数和失败回调函数，它们分别在异步操作成功和失败时被调用。<ul><li>当 Promise 的状态为 Fulfilled 时，会调用成功态回调函数队列中的回调函数；当 Promise 的状态为 Rejected 时，会调用失败态回调函数队列中的回调函数。</li></ul></li><li>异步操作的触发和状态改变：异步操作完成后，调用 resolve 方法将 Promise 的状态从 Pending 变为 Fulfilled，并将结果传递给成功态回调函数队列中的回调函数；调用 reject 方法将 Promise 的状态从 Pending 变为 Rejected，并将错误信息传递给失败态回调函数队列中的回调函数。</li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><code>Promise.all</code> 是一个静态方法，用于将多个 Promise 实例包装成一个新的 Promise 实例。当使用<code>Promise.all</code>时，通常会传入一个包含多个<code>Promise</code>对象的数组。<code>Promise.all</code>会返回一个新的<code>Promise</code>，这个新的<code>Promise</code>会在所有输入的<code>Promise</code>都成功（resolved）后解析，或者如果任何一个<code>Promise</code>失败（rejected），则立即失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>); <span class="comment">// 如果在Node.js环境中使用fetch API，需要引入node-fetch</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchGoogle</span> = (<span class="params"></span>) =&gt; <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.google.com&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>());</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchBing</span> = (<span class="params"></span>) =&gt; <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.bing.com&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>());</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">fetchGoogle</span>(), <span class="title function_">fetchBing</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Google:&#x27;</span>, values[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Bing:&#x27;</span>, values[<span class="number">1</span>]);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>例子中创建了两个函数<code>fetchGoogle</code>和<code>fetchBing</code>，它们各自返回一个Promise。然后我们使用<code>Promise.all</code>来等待这两个请求同时完成。当所有的请求都成功完成时，<code>Promise.all</code>返回的Promise将被解析，并将所有解析值组成的数组传递给<code>.then</code>方法中的回调函数。 如果任何请求失败，<code>Promise.all</code>返回的Promise将被拒绝，并跳过<code>.then</code>方法直接调用<code>.catch</code>方法中的错误处理器。</p><h3 id="ES6新特性有哪些"><a href="#ES6新特性有哪些" class="headerlink" title="ES6新特性有哪些"></a>ES6新特性有哪些</h3><p>ES6（ECMAScript 2015）是 JavaScript 的一个重要版本，引入了许多新特性和语法糖，使得 JavaScript 更加现代化、功能强大和易用。以下是 ES6 中一些常见的新特性：</p><ul><li>let 和 const：<code>let</code> 和 <code>const</code> 用于声明变量，相比 <code>var</code> 具有块级作用域。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure></li><li>箭头函数：箭头函数是一种更简洁的函数声明方式，省略了 <code>function</code> 关键字和 <code>return</code> 关键字。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure></li><li>解构赋值：解构赋值允许从数组或对象中提取数据，并赋值给变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure></li><li>默认参数值：函数参数可以设置默认值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>模板字符串：模板字符串允许使用反引号（&#96;）定义多行字符串，并在字符串中插入变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure></li><li>扩展运算符：扩展运算符（<code>...</code>）可以将数组展开成逗号分隔的参数序列，或将对象展开成键值对。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure></li><li>类和模块：ES6 引入了类和模块的概念，使得 JavaScript 更像一种传统的面向对象语言。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></table></figure></li><li>Promise：Promise 是一种用于处理异步操作的对象，使得异步编程更加优雅和易读。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Map 和 Set：ES6 引入了新的数据结构 Map 和 Set，用于存储键值对和唯一值集合。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">myMap.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li>Symbol：Symbol 是一种新的原始数据类型，表示唯一标识符。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量作用域和作用域链"><a href="#变量作用域和作用域链" class="headerlink" title="变量作用域和作用域链"></a>变量作用域和作用域链</h3><ul><li>作用域（Scope）是指变量和函数在代码中可访问的范围。在 JavaScript 中，作用域分为以下几种类型：<ol><li>全局作用域（Global Scope）：<ul><li>在整个程序中都可以访问的变量。</li><li>一般在函数外部定义。</li></ul></li><li>局部作用域（Local Scope）：<ul><li>变量仅在其定义的代码块或函数内部可见。</li><li>函数参数和在函数内声明的变量都是局部变量。</li></ul></li><li>块级作用域（Block Scope）：<ul><li>在某些语言中（如JavaScript ES6+），在特定的代码块（如if语句、for循环）中定义的变量只在该块内可见。</li><li>这有助于避免命名冲突和提升代码可读性。</li></ul></li><li>函数作用域（Function Scope）：<ul><li>在函数内部定义的所有变量都具有函数作用域，在函数调用时创建，调用结束时销毁。</li></ul></li><li>闭包作用域（Closure Scope）：<ul><li>当一个函数被另一个函数内部定义时，它可以访问其外部函数的变量，即使外部函数已经返回。这种现象称为闭包。</li></ul></li></ol></li><li>作用链（Scope Chain）是解释器或编译器在查找变量时遵循的一系列作用域。当在一个函数中引用一个变量时，解释器首先在当前函数的作用域中查找，如果没有找到，则会向上一级作用域查找，直到全局作用域。如果仍然没有找到，那么就认为变量未定义。这个查找的过程形成了作用链。</li></ul><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><ul><li>原型关系：<ul><li>每个 class都有显式原型 prototype</li><li>每个实例都有隐式原型 _ proto_</li><li>实例的_ proto_指向对应 class 的 prototype</li></ul></li><li>原型（Prototype）<ul><li>在 JavaScript 中，每个对象都有一个关联的原型对象。原型对象是一个普通的对象，它包含共享的属性和方法。当你创建一个对象时，JavaScript 引擎会自动为该对象关联一个原型对象。</li></ul></li><li>原型链（Prototype Chain）<ul><li>原型链是 JavaScript 中对象之间的一种链接方式，它是由对象的原型组成的链式结构。 </li><li>函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ &#x3D; null表示原型链顶端。如此形成了js的原型链继承。 </li><li>当访问对象的属性或方法时，JavaScript 引擎会首先在对象本身查找，如果没有找到，则会继续在对象的原型上查找，直到找到相应的属性或方法或者到达原型链的顶端（即 <code>Object.prototype</code>）。 </li><li>特点: <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</li></ul></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p><ul><li>闭包的特性：<ol><li>内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。<br>  1.1. 闭包是密闭的容器，，类似于set、map容器，存储数据的<br>  1.2. 闭包是一个对象，存放数据的格式为 key-value 形式</li><li>函数嵌套函数</li><li>本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</li></ol></li><li>闭包形成的条件：<ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li>闭包的用途：<ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li>闭包应用场景<br>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</li><li>闭包的优点：延长局部变量的生命周期</li><li>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li><li>闭包的作用：<ul><li>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</li><li>保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</li></ul></li></ul><h3 id="this指针的5种情况"><a href="#this指针的5种情况" class="headerlink" title="this指针的5种情况"></a>this指针的5种情况</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>基于Function.prototype上的 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，<code>bind</code>方法通过传入一个对象，返回一个<code>this</code>绑定了传入对象的新函数。这个函数的 <code>this</code>指向除了使用<code>new </code>时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ol><h3 id="new运算符实现机制"><a href="#new运算符实现机制" class="headerlink" title="new运算符实现机制"></a>new运算符实现机制</h3><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h3 id="浏览器✅"><a href="#浏览器✅" class="headerlink" title="浏览器✅"></a>浏览器✅</h3><h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><p>浏览器采用同源策略(Same-Origin Policy, SOP)来防止跨域访问，SOP限制了一个源（由协议、域名和端口号组成）上的网页脚本与另一个源上的网页进行交互的能力。同源策略要求以下三个部分完全相同：</p><ul><li>协议(如HTTP与HTTPS)</li><li>域名(如<a href="http://www.example.com与api.example.com/">www.example.com与api.example.com</a>)</li><li>端口(如80与8080)</li></ul><h3 id="跨域是什么及是为了防止什么"><a href="#跨域是什么及是为了防止什么" class="headerlink" title="跨域是什么及是为了防止什么"></a>跨域是什么及是为了防止什么</h3><p>防止恶意网站从不同的源获取或者操作敏感数据。</p><p>跨域是指一种网页或应用程序通过浏览器访问不同域名、协议或端口上的资源或服务的行为。由于安全原因，浏览器通常会限制这种跨域访问，这是为了防止某些类型的安全威胁，如跨站脚本攻击(Cross-Site Scripting, XSS)和跨站请求伪造(Cross-Site Request Forgery, CSRF)。<br>跨域是为了防止如下安全威胁：</p><ol><li>跨站脚本攻击(XSS)：<ul><li>恶意脚本被注入到可信网站中，攻击者利用这些脚本来窃取用户信息、劫持用户会话等。</li><li>通过限制跨域访问，可以防止恶意网站从可信网站中窃取敏感数据。</li></ul></li><li>跨站请求伪造(CSRF)：<ul><li>攻击者诱导用户在登录状态下访问攻击者构造的恶意网站，从而以用户的身份执行未授权的操作。</li><li>跨域访问限制可以减少这种攻击的风险，因为恶意网站不能直接向受保护的资源发出请求。</li></ul></li></ol><h3 id="解决跨域问题的方法"><a href="#解决跨域问题的方法" class="headerlink" title="解决跨域问题的方法"></a>解决跨域问题的方法</h3><p>虽然跨域访问受到限制，但在某些情况下需要进行跨域请求，比如在前后端分离的应用中。以下是一些常见的解决跨域问题的方法：</p><ol><li>CORS (Cross-Origin Resource Sharing)：最常见且推荐的解决方式，它允许服务器通过响应头中的特定字段来指定哪些源可以访问其资源。<ul><li>服务器在响应头中设置特定的CORS头信息，允许指定的跨域请求。</li><li><code>Access-Control-Allow-Origin</code>：指定哪些源可以访问资源，可以是一个具体的域名，或通配符*表示允许所有源。<ul><li><code>Access-Control-Allow-Origin: *</code> 或 <code>Access-Control-Allow-Origin: http://example.com</code></li></ul></li><li><code>Access-Control-Allow-Methods</code>: 允许的HTTP方法列表，如<code>GET</code>, <code>POST</code>, <code>PUT</code>等。</li><li><code>Access-Control-Allow-Headers</code>: 允许的请求头列表，这对于预检请求（preflight requests）非常重要。</li><li><code>Access-Control-Max-Age</code>: 预检请求的有效期，单位是秒，在此期间，对于同样的请求，浏览器不会再次发送预检请求。</li><li><code>Access-Control-Allow-Credentials</code>: 如果设置为<code>true</code>，则表示服务器允许包含身份验证信息（如cookies和HTTP认证）的跨域请求。</li><li><code>Access-Control-Expose-Headers</code>: 指定客户端可以从响应中访问的额外头部信息。</li><li>通常可以在服务端通过框架或中间件来配置这些头部。例如，在Node.js的Express框架中，可以使用<code>cors</code>中间件来轻松配置CORS。</li><li>前端通常不需要直接处理CORS配置，因为它主要是在服务器端完成的。但需要确保API调用正确地设置<code>credentials</code>属性，以便在需要<code>cookies</code>或其他认证信息时正确处理请求。</li></ul></li><li>JSONP (JSON with Padding)：一种古老的技巧，利用<code>&lt;script&gt;</code>标签没有同源策略限制的特点，但只适用于GET请求。<ul><li>通过动态生成<code>&lt;script&gt;</code>标签进行跨域请求，因为<code>&lt;script&gt;</code>标签不受同源策略限制。</li><li>主要用于GET请求，但现代应用中使用较少。</li></ul></li><li>服务器代理 (Proxy)：在服务器端设置代理，让所有跨域请求先通过同一源的服务器转发，这样浏览器就不会视为跨域请求。<ul><li>在同源服务器上设置一个代理，通过代理服务器转发请求到不同的域。</li><li>客户端只与代理服务器通信，代理服务器与目标服务器通信。</li></ul></li><li>WebSocket<ul><li>WebSocket协议允许跨域通信，适用于需要实时双向通信的应用。</li></ul></li></ol><h3 id="浏览器缓存-强制缓存-协商缓存"><a href="#浏览器缓存-强制缓存-协商缓存" class="headerlink" title="浏览器缓存-强制缓存&#x2F;协商缓存"></a>浏览器缓存-强制缓存&#x2F;协商缓存</h3><p>浏览器缓存是一种用于存储和重复利用资源的机制，它可以减少网络请求次数，提高网页加载速度。浏览器的缓存机制主要分为两种类型：强制缓存和协商缓存。</p><ul><li><p>强制缓存</p><ul><li>强缓存是指客户端在接收到响应后，响应中的缓存控制指示允许，客户端可以无条件地使用缓存的副本，而不必再次询问服务器。这通常意味着在给定的时间内，资源不会改变，所以不需要再次验证资源的有效性。常见的响应头有<code>Cache-Control</code>和<code>Expires</code>。</li><li><code>Cache-Control</code> 字段中的常见值包括：<ul><li><code>max-age=&lt;seconds&gt;</code>：指示响应可以被缓存的最大时间（以秒为单位），在此期间可以被重复使用而无需向服务器验证。</li><li><code>no-store</code>：指示响应不能被存储在任何缓存中。</li><li><code>no-cache</code>：这可能有些令人困惑，因为名字暗示不允许缓存，但实际上它可以与其他指令结合使用，如 <code>no-cache=Set-Cookie</code>，意味着可以缓存响应，但每次使用前需要先验证。</li><li><code>must-revalidate</code>：指示缓存必须在过期后向服务器验证，即使在网络中断的情况下也不可使用过期的缓存。</li><li><code>proxy-revalidate</code>：类似于 <code>must-revalidate</code>，但只适用于代理服务器，终端用户浏览器可以使用过期的缓存直到收到新的响应。</li><li><code>public</code>：指示响应可以被任何缓存存储，包括共享缓存。</li><li><code>private</code>：指示响应只能被单个用户的缓存存储，不能在代理服务器上共享。</li></ul></li><li><code>Expires</code>：指定缓存过期时间，是一个绝对的时间点，直到过期前都可以直接使用缓存。</li></ul></li><li><p>协商缓存<br>协商缓存是指客户端在使用缓存副本之前，需要先向服务器确认资源是否已经改变。可以通过比较客户端缓存的版本和服务器上的版本完成，通常使用 <code>ETag</code> 或 <code>Last-Modified</code> 和 <code>If-Modified-Since</code> 这样的头部。</p></li><li><p>在协商缓存中，服务器会在响应头中包含：</p><ul><li><code>ETag</code>：一个代表资源版本的唯一标识符。</li><li><code>Last-Modified</code>：资源最后修改的日期和时间。</li></ul></li><li><p>客户端在后续请求中可以通过以下头部进行验证：</p><ul><li><code>If-None-Match</code>：与服务器返回的 ETag 对比，以确定资源是否相同。</li><li><code>If-Modified-Since</code>：与服务器的 <code>Last-Modified</code> 时间对比，以判断资源是否已更新。</li></ul></li></ul><p>当服务器收到这些请求头时，如果资源没有变化，它会返回一个<code>304</code>状态码，表示“未修改”，这样客户端就可以继续使用缓存中的副本，从而避免了完整资源的下载。</p><h3 id="介绍一下304过程"><a href="#介绍一下304过程" class="headerlink" title="介绍一下304过程"></a>介绍一下304过程</h3><p>在HTTP协议中，状态码“304 Not Modified”是在客户端缓存和服务器之间进行缓存验证时使用的一种响应状态。这个过程涉及到了强制缓存和协商缓存的概念，以及HTTP头部如<code>If-Modified-Since</code>和<code>ETag</code>的使用。</p><ul><li>当客户端首次请求一个资源时，服务器会返回该资源，并可能包含以下头部之一：<ul><li><code>Last-Modified</code> - 表示资源最后一次修改的时间。</li><li><code>ETag</code> - 一个代表资源版本的唯一标识符。</li><li>假设服务器返回了资源和<code>Last-Modified</code>头部，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified: Wed, 01 Jul 2020 01:23:45 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li>当客户端需要再次获取同一资源时，它会检查是否有缓存版本，并在请求中包含<code>If-Modified-Since</code>头部。<ul><li>其值为上次请求时服务器返回的<code>Last-Modified</code>时间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /resource HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">If-Modified-Since: Wed, 01 Jul 2020 01:23:45 GMT</span><br></pre></td></tr></table></figure></li></ul></li><li>服务器接收到请求后，会检查资源是否自上次修改以来有变化：<ul><li>如果资源没有变化，服务器将返回一个304状态码，表示“Not Modified”。这意味着客户端可以继续使用其缓存的副本，无需接收新的数据。</li><li>如果资源有变化，服务器将返回一个新的200状态码，包含更新后的资源和新的<code>Last-Modified</code>或<code>ETag</code>头部。</li></ul></li></ul><p>304过程对于提高Web性能至关重要，因为它减少了不必要的网络传输。如果资源没有变化，服务器不需要发送完整的资源内容，客户端可以立即使用缓存版本，这显著加快了页面加载速度，同时也减轻了服务器的负载。</p><p>总之，304过程是HTTP缓存机制的核心部分，它优化了客户端与服务器之间的通信，提高了用户体验，同时降低了网络带宽消耗和服务器资源的使用。</p><h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3><p>“重排”（Reflow）和“重绘”（Repaint）是浏览器渲染网页时发生的两个重要过程，它们对于页面性能有着直接的影响。</p><ul><li><p>重排发生在浏览器需要重新计算元素的几何属性时，比如位置、大小或形状。以下情况可能会触发重排：</p><ul><li>添加或删除可见的DOM元素。</li><li>元素的尺寸发生变化（如通过JavaScript修改CSS样式）。</li><li>触发布局依赖的属性变化，如<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>border</code>等。</li><li>文档流中的内容变化，如文本内容的更改。</li><li>影响：重排会导致浏览器重新计算页面布局，这是一个比较耗时的操作，因为它涉及到复杂的计算，并且可能涉及整个文档流中多个元素的重新定位。</li></ul></li><li><p>重绘则是在元素的外观发生变化，但不涉及尺寸或位置改变时发生的过程。例如：</p><ul><li>改变元素的颜色或背景。</li><li>应用或移除透明度变化。</li><li>更改元素的<code>z-index</code>值（只要不影响布局）。 </li><li>影响：重绘比重排要快一些，因为它不需要重新计算布局，仅需要更新像素颜色。然而，频繁的重绘也会对性能造成影响。</li></ul></li><li><p>性能优化，为了减少重排和重绘对性能的影响，开发者可以采取以下策略：</p><ul><li>减少布局依赖的样式更改，尽量使用不影响布局的属性。</li><li>使用<code>requestAnimationFrame</code>来批量处理动画和DOM操作，减少浏览器的重排&#x2F;重绘次数。</li><li>避免使用<code>window.getComputedStyle</code>或<code>element.offsetHeight</code>等会触发重排的方法在循环中。</li><li>尽量减少DOM树的深度和复杂性。</li><li>利用CSS层叠上下文和独立容器，比如<code>position: fixed</code>或<code>transform</code>，可以让某些元素的改变只影响自身而不影响其他元素。</li><li>使用硬件加速的CSS属性，让浏览器尽可能利用GPU进行渲染。</li></ul></li></ul><h3 id="React✅"><a href="#React✅" class="headerlink" title="React✅"></a>React✅</h3><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>React中受控组件和非受控组件主要用于描述如何处理表单元素（如<code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>等）中的用户输入。两者的主要区别在于状态管理和数据流的方向。</p><ul><li>受控组件（Controlled Components）<ul><li>定义：在受控组件中，表单的值（<code>value</code>属性）是由React组件的状态（state）或属性（props）控制的。这意味着React组件负责维护表单元素的状态，并通过事件处理器（如<code>onChange</code>）更新状态，进而更新显示的值。</li><li>数据流：数据流是单向的，从React组件的state或props流向表单元素。用户交互会触发事件处理器，导致state更新，然后state的变化会导致组件重新渲染，更新表单的值。</li></ul></li><li>非受控组件（Uncontrolled Components）<ul><li>定义：非受控组件的值不由React组件直接控制，而是由DOM元素自身管理。React不会通过<code>value</code>属性来设置表单元素的值，而是通过<code>defaultValue</code>属性设置初始值，之后的值变化由DOM自行处理。</li><li>数据读取：由于React不直接控制表单元素的值，它通常使用<code>ref</code>来访问DOM节点，以便读取和设置值。</li></ul></li><li>选择使用哪种组件<ul><li>受控组件通常用于需要实时响应用户输入并执行某些逻辑（如验证）的情况，或是需要将表单值作为应用程序状态的一部分的情况。</li><li>非受控组件可能在性能敏感或复杂的表单中更有效率，因为它们减少了状态更新的次数，特别是在大型应用中，这可能会带来性能优势。</li><li>某些情况下可能需要混合使用两种类型，或使用“受控与非受控”的组合组件，这种组件可以在没有提供<code>value</code>属性时作为非受控组件工作，在提供了<code>value</code>时作为受控组件工作。这在一些库组件中比较常见，比如Ant Design的一些组件就支持这种模式。</li></ul></li></ul><h3 id="useLayoutEffect和useEffect区别"><a href="#useLayoutEffect和useEffect区别" class="headerlink" title="useLayoutEffect和useEffect区别"></a>useLayoutEffect和useEffect区别</h3><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 都是 React Hooks 中用于处理副作用（例如数据获取、订阅或者手动修改 DOM）的钩子函数。它们的主要区别在于执行时机和对渲染的影响。</p><ol><li>执行时机:<ul><li><code>useEffect</code>: 这个 Hook 是在 DOM 更新后异步执行的，即它不会阻塞浏览器的渲染。这意味着在执行 <code>useEffect</code> 的回调函数时，屏幕上的元素已经完成渲染，因此任何在 <code>useEffect</code> 中的操作都不会影响当前屏幕上的渲染输出。这使得 <code>useEffect</code> 更适合处理那些不需要立即反映到用户界面上的副作用，如网络请求、事件监听器的设置或清除等。</li><li><code>useLayoutEffect</code>: 相比之下，<code>useLayoutEffect</code> 是同步执行的，它的回调函数会在所有 DOM 变更完成后但在浏览器绘制更新前执行。这意味着 <code>useLayoutEffect</code> 中的代码可以改变布局，并且这种变化会立即反映到用户界面上，不会造成视觉上的闪烁或抖动。这使得 <code>useLayoutEffect</code> 更适合处理那些需要立即反映到布局中的副作用，如测量 DOM 节点的尺寸或位置，或直接修改 DOM。</li></ul></li><li>性能影响:<ul><li>因为 <code>useEffect</code> 是异步执行的，所以它通常对性能的影响较小，特别是在涉及到复杂的计算或大量的 DOM 操作时。这是因为浏览器可以优先完成渲染，然后再处理副作用，从而保持流畅的用户体验。</li><li><code>useLayoutEffect</code> 的同步执行特性意味着如果它包含的逻辑过于复杂，可能会阻塞浏览器的渲染线程，导致页面卡顿。因此，在性能敏感的场景下，应当谨慎使用 <code>useLayoutEffect</code>。</li></ul></li><li>兼容性:<ul><li><code>useEffect</code> 在所有现代浏览器中都有良好的兼容性。</li><li><code>useLayoutEffect</code> 在某些旧版浏览器中可能不被支持，尤其是那些不支持异步渲染的浏览器。</li></ul></li></ol><p>推荐首先尝试使用 <code>useEffect</code>，因为它的异步执行方式更加符合现代 Web 应用程序的性能要求。只有在特定场景下，比如需要在渲染之前进行精确的 DOM 测量或修改，才应该使用 <code>useLayoutEffect</code>。</p><h3 id="hooks为什么不能在if中使用"><a href="#hooks为什么不能在if中使用" class="headerlink" title="hooks为什么不能在if中使用"></a>hooks为什么不能在if中使用</h3><p>React Hooks（如 <code>useState</code>, <code>useEffect</code> 等）设计时有一些关键的规则需要遵守，以确保组件的正确渲染和生命周期的一致性。其中一条规则是，Hooks 必须在函数组件或自定义 Hook 的顶层调用，而不能在循环、条件或嵌套函数中调用。</p><p>不建议在 if 条件语句中调用 Hooks 的原因如下：</p><ol><li>可预测性：<br>React 需要知道何时调用 Hooks，以便能够追踪状态更新和副作用。如果在 if 语句中调用，React 将无法确定每次渲染时是否应该调用这些 Hooks，这会导致状态和副作用的混乱。</li><li>一致性和确定性：<br>Hooks 被设计成在每次组件渲染时按照相同的顺序调用，这保证了状态和副作用的一致性。如果将 Hooks 放入条件逻辑中，那么每次渲染调用的 Hooks 可能不同，这违反了 Hooks 的这一核心原则。</li><li>避免内存泄漏：<br>如果你在条件语句中使用了 <code>useEffect</code>，并且该条件不再满足，你可能忘记清理之前的副作用，从而导致内存泄漏。</li></ol><p>为了遵循这些规则，应该在函数组件的主体内始终调用你的 Hooks，而不是在 if 语句中。如果需要根据条件执行某些操作，可以考虑使用 <code>useState</code> 或 <code>useEffect</code> 的依赖数组来控制这些操作的发生，或者在组件内部创建逻辑分支来处理不同的情况，但要确保所有的 Hooks 调用都在组件的顶层。</p><h3 id="memorizedState"><a href="#memorizedState" class="headerlink" title="memorizedState"></a>memorizedState</h3><p>在React中，<code>memorizedState</code>这个术语通常与React的Hooks机制相关联，尤其是<code>useState</code>和<code>useReducer</code>等Hooks。当使用这些Hooks时，React内部会维护一个叫做“memorized state”的值，这是Hook当前状态的最新版本。</p><p><code>memorizedState</code>并不是直接暴露给开发者的一个属性或API，而是React为了实现状态管理和更新逻辑的一部分。当组件重新渲染时，React会检查新的props或state是否与前一次渲染的不同。如果<code>memorizedState</code>发生变化，React将执行必要的更新逻辑，否则可能直接使用之前计算的输出，以优化性能。</p><p>对于<code>React.memo</code>来说，它是一个高阶组件（HOC），用于包装函数组件，提供类似于<code>shouldComponentUpdate</code>生命周期方法的功能，即它会比较传递给组件的新旧props，如果它们是浅相等的（即引用相等或值相等，取决于props的数据类型），那么<code>React.memo</code>会告诉React不要重新渲染组件，而是使用上一次渲染的结果。</p><p>需要注意的是，<code>React.memo</code>只比较props，并不会比较组件内部的状态（state）。如果需要根据组件内部状态的变化来决定是否重新渲染，将需要使用React的Hooks，如<code>useState</code>或<code>useReducer</code>，以及可能的<code>useCallback</code>或<code>useMemo</code>来确保某些函数或对象的引用保持不变，从而避免不必要的重新渲染。</p><h3 id="setState是同步还是异步"><a href="#setState是同步还是异步" class="headerlink" title="setState是同步还是异步"></a>setState是同步还是异步</h3><p><code>React</code> 中的 <code>setState</code> 方法的行为在不同情况下有所不同，它通常被视为异步的，但这种异步行为不是传统意义上的异步（如使用 <code>Promise</code> 或 <code>async/await</code>），而是基于 React 的批处理更新机制。</p><ul><li>在大多数情况下：当在组件的生命周期方法（如 <code>componentDidMount</code>, <code>componentDidUpdate</code>）或 React 合成事件处理器中调用 <code>setState</code> 时，React 会将状态更新放入一个队列中，并在当前工作循环结束或在下一次重绘之前的一段时间内进行批处理。这意味着状态更新可能不会立即反映在组件的状态上，而是等待 React 完成当前的工作或等到下一次渲染周期。</li><li>特殊情况：当在 <code>setTimeout</code> 或原生 DOM 事件（非 React 合成事件）中调用 <code>setState</code> 时，React 的批处理机制可能不会生效，导致 <code>setState</code> 表现得更像同步行为。这是因为这些环境下的调用通常不在 React 的控制流中，所以 React 可能会立即执行状态更新。</li><li>如何确保访问最新状态：如果需要确保在 <code>setState</code> 后访问到最新的状态，你可以传递一个回调函数作为 <code>setState</code> 的第二个参数。这个回调函数将在状态更新并且组件完成重新渲染后被调用。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">someState</span>: newValue &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里可以安全地访问最新的状态</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">someState</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue✅"><a href="#Vue✅" class="headerlink" title="Vue✅"></a>Vue✅</h3><h3 id="npm✅"><a href="#npm✅" class="headerlink" title="npm✅"></a>npm✅</h3><h3 id="npm包有哪些license，哪些允许商用"><a href="#npm包有哪些license，哪些允许商用" class="headerlink" title="npm包有哪些license，哪些允许商用"></a>npm包有哪些license，哪些允许商用</h3><ol><li>MIT License</li><li>Apache License 2.0</li><li>BSD License (2-clause or 3-clause)</li><li>GPL (General Public License)</li><li>LGPL (Lesser General Public License)</li><li>MPL (Mozilla Public License)</li><li>ISC License</li><li>Unlicense</li><li>Creative Commons (CC0)</li></ol><p>其中，允许商用的许可证包括：</p><ol><li>MIT License: 允许几乎任何用途，包括商用。</li><li>Apache License 2.0: 允许商用，要求附带版权声明和免责条款。</li><li>BSD License: 允许商用，要求附带版权声明和免责条款。</li><li>ISC License: 类似于BSD许可证，允许商用。</li><li>MPL (Mozilla Public License): 允许商用，但对分发源代码有一定的要求。</li><li>Unlicense: 放弃版权，允许任何用途，包括商用。</li><li>Creative Commons (CC0): 类似于公有领域，允许任何用途，包括商用。</li></ol><p>需要注意的是，GPL和LGPL虽然也是开源许可证，但对商业用途有严格的规定。GPL要求衍生作品也必须遵循GPL许可证（即所谓的“传染性”），这对于商业软件可能不太适用。LGPL则允许在商业软件中使用，但如果修改了LGPL库，修改后的部分仍需要开源。</p><h3 id="CSS✅"><a href="#CSS✅" class="headerlink" title="CSS✅"></a>CSS✅</h3><h3 id="HTML✅"><a href="#HTML✅" class="headerlink" title="HTML✅"></a>HTML✅</h3><h3 id="script标签如何加载js文件"><a href="#script标签如何加载js文件" class="headerlink" title="script标签如何加载js文件"></a>script标签如何加载js文件</h3><p>在HTML中，可以通过<code>&lt;script&gt;</code>标签来加载JavaScript文件。</p><ul><li>内联脚本：直接在<code>&lt;script&gt;</code>标签中编写JavaScript代码。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>外部脚本：通过<code>src</code>属性指定要加载的JavaScript文件的URL。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/my/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>异步加载：<code>&lt;script&gt;</code> 标签的 <code>async</code> 属性用于指定脚本的异步加载。当指定了 <code>async</code> 属性时，脚本将会在加载时不阻塞 HTML 解析，并在加载完成后立即执行。多个异步脚本的执行顺序是不确定的。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/my/script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>延迟加载：<code>&lt;script&gt;</code> 标签的 <code>defer</code> 属性用于指定脚本的延迟加载。当指定了 <code>defer</code> 属性时，脚本将会在 HTML 解析完成后再执行，但在 <code>DOMContentLoaded</code> 事件之前执行。多个延迟脚本的执行顺序是按照它们在文档中出现的顺序执行的。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/my/script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>动态加载脚本：通过 JavaScript 动态创建 <code>&lt;script&gt;</code> 标签，然后将其插入到文档中。动态加载脚本可以在任何时候进行，例如在页面加载后、用户操作后或其他事件触发时。这种方式可以控制脚本的加载时机。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;script.js&#x27;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure><blockquote><p>注意，JavaScript 脚本默认是同步加载的，即阻塞 HTML 解析并立即执行。async、defer、动态加载脚本方法可以调整脚本的加载方式，使其异步或延迟加载，提高页面加载性能或控制脚本执行时机。</p></blockquote></li></ul><h3 id="Flutter✅"><a href="#Flutter✅" class="headerlink" title="Flutter✅"></a>Flutter✅</h3><h3 id="Flutter原理"><a href="#Flutter原理" class="headerlink" title="Flutter原理"></a>Flutter原理</h3><p>Flutter 是一个由 Google 开发的开源框架，用于构建高性能、高保真度的跨平台移动应用。其核心原理如下：</p><ol><li>Dart 编程语言:<ul><li>Flutter 使用 Dart 语言作为开发应用的主要语言。Dart 是一种现代化的、面向对象的语言，具有即时编译特性，可以直接编译为本地代码。</li></ul></li><li>Skia 渲染引擎:<ul><li>Flutter 使用 Skia 作为其渲染引擎，Skia 是一个跨平台的2D图形库，由 C++ 编写，能够提供高性能的绘图能力。</li></ul></li><li>Widget 树:<ul><li>Flutter 的核心概念是 Widget。在 Flutter 中，一切都是 Widget，包括布局、样式、动画等。Flutter 使用基于组合的方式构建用户界面，每个 Widget 都是不可变的。</li><li>Widget 树描述了应用界面的结构，从根部的 Widget 开始，逐级构建出整个应用的 UI。</li></ul></li><li>Hot Reload:<ul><li>Flutter 提供了热重载(Hot Reload)功能，这是一个非常强大的开发工具，可以在保持应用状态的同时快速更新代码和界面，大大加快开发迭代速度。</li></ul></li><li>自绘:<ul><li>Flutter 不依赖平台的原生控件，而是通过 Skia 直接绘制界面。这种方式使得 Flutter 的 UI 高度定制化，并且能够实现完全一致的跨平台体验。</li></ul></li><li>平台通道:<ul><li>Flutter 提供了平台通道(Platform Channels)，用于在 Dart 代码和原生代码之间进行通信。通过平台通道，Flutter 可以调用平台特定的 API 和功能。</li></ul></li><li>性能优化:<ul><li>Flutter 通过使用 Skia 渲染引擎和自带的动画库来实现流畅的动画效果和高性能的绘制。它还利用 Dart 的优化能力，如快速的 JIT(即时编译)和 AOT(预编译)技术来提升运行时性能。<br>通过这些原理和机制，Flutter 实现了高效、美观且跨平台的移动应用开发，为开发者提供了灵活且强大的工具集来构建现代应用。</li></ul></li></ol><h3 id="React-Native✅"><a href="#React-Native✅" class="headerlink" title="React-Native✅"></a>React-Native✅</h3><h3 id="ReactNative原理"><a href="#ReactNative原理" class="headerlink" title="ReactNative原理"></a>ReactNative原理</h3><p>React Native是一种用于构建跨平台移动应用的框架，其核心原理包括以下几个方面：</p><ol><li>JavaScriptCore:<ul><li>React Native使用JavaScriptCore引擎来运行JavaScript代码。对于iOS，React Native使用系统自带的JavaScriptCore；对于Android，它会嵌入一个独立的JavaScriptCore实例。</li></ul></li><li>Bridge:<ul><li>React Native的核心是一个称为“Bridge”的机制。这个桥接机制在JavaScript和原生代码之间建立了通信渠道。JavaScript线程和原生线程通过JSON消息进行通信。</li><li>当JavaScript代码需要调用原生模块时，它会通过Bridge发送消息到原生线程。原生代码执行相应的操作后，可能会将结果返回给JavaScript线程。</li></ul></li><li>Shadow Tree和布局引擎:<ul><li>React Native使用一个虚拟的Shadow Tree来描述UI结构。这个Shadow Tree类似于React中的虚拟DOM，但它并不直接渲染UI，而是用于计算布局。</li><li>布局计算完成后，React Native会将布局信息传递给原生线程，由原生视图系统来实际渲染UI。</li></ul></li><li>UI组件:<ul><li>React Native提供了一系列跨平台的UI组件，如<code>View</code>, <code>Text</code>, <code>Image</code>等。这些组件在JavaScript中定义，但会映射到原生的视图组件。</li><li>通过这种方式，React Native可以利用原生平台的高性能和丰富功能，同时保留React的声明式编程风格。</li></ul></li><li>原生模块和第三方库:<ul><li>开发者可以编写自己的原生模块并通过Bridge与JavaScript代码进行交互。这样可以扩展React Native的功能，使用平台特定的API。</li><li>还有很多第三方库提供了常用功能，如相机、地理位置、推送通知等，它们也通过类似的方式与React Native集成。</li></ul></li><li>性能优化:<ul><li>React Native通过批量更新和异步渲染来提升性能。例如，批量将多次状态更新合并为一次操作，减少与原生线程的通信次数。</li><li>使用虚拟DOM和高效的diff算法来最小化UI更新的开销。<br>通过这些核心机制，React Native能够实现一次编码，跨平台运行的目标，同时保留接近原生应用的性能和体验。</li></ul></li></ol><h3 id="ReactNative和Flutter的区别"><a href="#ReactNative和Flutter的区别" class="headerlink" title="ReactNative和Flutter的区别"></a>ReactNative和Flutter的区别</h3><p><a href="https://blog.csdn.net/BTTBHT/article/details/131046656">https://blog.csdn.net/BTTBHT/article/details/131046656</a><br>Flutter和ReactNative是目前最流行的跨平台移动应用开发框架。它们分别由谷歌和Facebook开发。</p><ul><li>性能：Flutter在性能方面具有明显的优势，可以提供更接近原生的用户体验。<ul><li>Flutter使用Dart语言编写，可以直接编译成本地代码，避免性能损耗和内存泄漏的风险，提高应用的稳定性和流畅度。Flutter还使用了自己的渲染引擎Skia，可以直接绘制像素到屏幕上，实现高质量的UI效果。</li><li>ReactNative使用JavaScript语言编写，需要通过JavaScript桥接层与本地代码进行通信。这样会增加性能开销和延迟，降低应用的响应速度和运行效率。ReactNative使用了本地的渲染引擎，可以利用本地的UI组件，但也会受到本地平台的限制和差异。</li></ul></li><li>代码书写：<ul><li>Flutter使用Dart语言编写，这是一种静态类型、面向对象、支持多范式的语言。Dart语言相对于JavaScript来说更加严格和规范，可以避免一些常见的错误和异常，提高代码的可读性和可维护性。Dart语言还支持热重载和热重启功能，可以实时查看代码修改后的效果，提高开发效率。</li><li>ReactNative使用JavaScript语言编写，这是一种动态类型、基于原型、支持多范式的语言。JavaScript语言相对于Dart来说更加灵活和简洁，可以实现更多的功能和逻辑，提高代码的表达力和创造力。JavaScript语言也支持热重载和热重启功能，可以实时查看代码修改后的效果，提高开发效率。</li></ul></li><li>学习难度：ReactNative在学习方面具有一定的优势，可以降低开发者的入门难度<ul><li>Flutter使用Dart语言编写，这是一种相对较新的语言，目前还没有太多的使用者和教程。开发者需要花费一定的时间和精力来学习Dart语言的语法和特性，以及Flutter框架的原理和组件。</li><li>ReactNative使用JavaScript语言编写，这是一种相对较老的语言，目前有着广泛的使用者和教程。开发者如果已经熟悉JavaScript语言和React框架，可以很快地上手ReactNative框架。</li></ul></li><li>运行速度：Flutter在运行速度方面具有明显的优势，可以提供更快速和流畅的用户体验。<ul><li>Flutter使用Dart语言编写，可以直接编译成本地代码，无需通过JavaScript桥接层。这样可以提高应用的启动速度和运行速度</li><li>ReactNative使用JavaScript语言编写，需要通过JavaScript桥接层与本地代码进行通信。这样会降低应用的启动速度和运行速度，增加卡顿和闪退的可能性。</li></ul></li></ul><h3 id="移动端✅"><a href="#移动端✅" class="headerlink" title="移动端✅"></a>移动端✅</h3><h3 id="对移动端开发的认识？"><a href="#对移动端开发的认识？" class="headerlink" title="对移动端开发的认识？"></a>对移动端开发的认识？</h3><p>移动端开发是指开发用于移动设备(如智能手机、平板电脑)的应用程序或网站。随着移动设备的普及和使用量的增加，移动端开发已成为软件开发领域中的重要方向之一。以下是关于移动端开发的一些认识：</p><ol><li>平台多样性：<ul><li>移动设备的操作系统多样性是移动端开发的一个显著特点。主要的移动操作系统包括 Android、iOS 和可能还有 Windows Phone(已停止开发支持)。因此，移动端开发需要考虑多种操作系统和平台之间的兼容性。</li></ul></li><li>开发工具：<ul><li>为了开发移动应用程序，开发人员可以使用各种工具和技术栈。比较常见的移动端开发工具包括 Android Studio(用于 Android 开发)、Xcode(用于 iOS 开发)、React Native、Flutter、Ionic 等跨平台框架，以及 Web 技术(如 HTML、CSS、JavaScript)开发的移动网页应用。</li></ul></li><li>用户体验：<ul><li>移动端开发需要特别关注用户体验(UX)，因为移动设备的屏幕较小，用户交互方式也有所不同。因此，设计和开发移动应用需要考虑到触摸操作、屏幕尺寸适配、响应式设计等方面，以提供良好的用户体验。</li></ul></li><li>性能优化：<ul><li>移动端应用的性能优化是非常重要的，因为移动设备的资源相对有限。开发人员需要注意减少应用的内存占用、优化加载速度、减少功耗等方面，以确保应用在移动设备上的流畅运行。</li></ul></li><li>发布和更新：<ul><li>发布移动应用需要遵循各个应用商店的规定和流程。对于 Android 应用，通常使用 Google Play Store 进行发布；而 iOS 应用则需要通过苹果的 App Store 发布。此外，定期更新应用以修复 bug、增加新功能也是移动端开发的常规工作之一。<br>总的来说，移动端开发涉及多种技术和方面，包括平台选择、开发工具、用户体验、性能优化、发布和更新等。随着移动技术的不断发展和创新，移动端开发也在不断演进和壮大，为用户提供更便捷、高效、丰富的移动应用体验。</li></ul></li></ol><h3 id="场景题✅"><a href="#场景题✅" class="headerlink" title="场景题✅"></a>场景题✅</h3><h3 id="有一张1GB的图片需要加载到手机屏幕上，但是手机内存不够怎么办？"><a href="#有一张1GB的图片需要加载到手机屏幕上，但是手机内存不够怎么办？" class="headerlink" title="有一张1GB的图片需要加载到手机屏幕上，但是手机内存不够怎么办？"></a>有一张1GB的图片需要加载到手机屏幕上，但是手机内存不够怎么办？</h3><ul><li>懒加载(lazy loading)：在内存不足的情况下，可以分步加载图片以避免一次性占用大量内存。懒加载的基本思路是按需加载图片的部分数据，直到整个图片被完全加载。<ul><li>实现：</li></ul><ol><li>分块加载：将图片分割成多个小块，每次只加载一部分数据，这样可以有效降低每次加载时的内存占用。</li><li>使用缩略图：在用户需要查看图片之前，先加载较小的缩略图，等用户需要查看详细内容时，再加载高清图像。</li><li>图片压缩：在加载之前，将图片压缩成较小的尺寸和质量，然后在需要时加载完整的图片。</li><li>文件流处理：使用文件流处理方式，一边读取一边显示，不需要一次性加载整个图片。</li></ol></li><li>图片压缩：通过压缩图片的分辨率、质量等方式来减小图片的体积，从而减少内存占用。</li><li>缓存管理：实现一个智能缓存系统，只缓存当前屏幕上需要显示的图片数据，释放掉那些暂时不需要显示的图片数据。这样可以有效管理内存占用。</li><li>调整图片分辨率：加载合适分辨率的图片，既能保证显示效果，又能减少内存使用。</li><li>使用外部存储：将大图片存储在外部存储设备(如SD卡)中，而不是手机的内存中。通过读取外部存储中的图片数据来显示。</li><li>内存优化：对应用程序进行内存优化，释放不必要的内存占用，以便为大图片的加载腾出空间。这包括清理缓存、减少后台运行的进程等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 移动端 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端面经</title>
      <link href="/posts/17766.html"/>
      <url>/posts/17766.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>准备在这篇文章中，先详细分析简历中可能会被问到的问题，然后总结一下 Java基础的精简答案，最后再回顾一下每次面试的面经。<br>本文参考 <a href="https://javaguide.cn/">JavaGuide</a></p></blockquote><h2 id="简历相关"><a href="#简历相关" class="headerlink" title="简历相关"></a>简历相关</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>面试官您好，我叫陈温鹏，就读于南京理工大学软件工程专业，学位是学硕，这次应聘的是 <strong>Java后端开发岗位</strong>。</p><p>我呢，研一的时候有过一段开源经历(Casbin社区一个线上实习)，担任社区维护者，日常工作会负责处理社区日常issue，跟踪解决用户需求，修复bug及完善文档等；然后在研一暑假期间中选了中科院和 Casbin 社区联合举办的一个开源项目，主要的工作是完善社区整个大前端系统，包括 web，移动端功能完善，以及为社区开发了一款支持通用2FA的移动端app。除此之外，我还参与过国网经济研究院的一个项目，以及自己做过两个Java前后端项目。这几段项目实习经历锻炼了我文档阅读、编写的能力，并在代码规范、开发流程等技能上获得提升。</p><p>然后我呢，我评价觉得自己是一个学习能力很强的人，可以比较快速的学习并适应新的环境和技术栈。 </p><p>最后感谢 xxx 给我这次面试机会，我也十分希望能进入 xxx ，与公司共同成长进步！</p><h3 id="开源经历"><a href="#开源经历" class="headerlink" title="开源经历"></a>开源经历</h3><blockquote><p>Casbin&#x2F;Casdoor社区明日之星预选生培养计划<br>2023&#x2F;02 - 2023&#x2F;09<br>社区简介：Casbin是一个开源访问控制框架，Casdoor是一个身份认证和权限管理的解决方案，其无缝集成Casbin，专注于SSO。<br>工作内容：负责处理社区日常issue，修复bug及完善文档等。在7-9月期间中选并顺利完成中科院和Casbin社区联合举办的开源之夏项目。<br>工作成果：</p><ol><li>代码 commit 数百次，Pull Request 被 merge 50余次，多次跟进用户需求，积极与社区成员及导师讨论，努力和贡献被广泛认可，并最终被提名为 pycasbin 组织的 member 之一。</li><li>独立完成casdoor-react-native-sdk&#x2F;example、async-sqlalchemy-adapter、casdoor-unity-example的测试、开发及发布，完善casdoor-flutter-sdk的功能，使其支持ios移动端微信第三方原生登录。</li><li>独立开发Casdoor Authenticator App，这是一款⽀持通⽤2FA的iOS&#x2F;Android移动应⽤程序，通过生成基于时间的一次性密码(TOTP)来帮助保护用户账户。app基于React Native框架开发，认证过程使用了PKCE协议扩展，极大地增强了OAuth 2.0授权流程的安全性。</li></ol></blockquote><h4 id="你在开源活动中主要做了什么？"><a href="#你在开源活动中主要做了什么？" class="headerlink" title="你在开源活动中主要做了什么？"></a>你在开源活动中主要做了什么？</h4><p>社区简介：Casbin是一个开源访问控制框架，Casdoor是一个身份认证和权限管理的解决方案，其无缝集成Casbin，专注于SSO。<br>我的开源经历主要分为两部分：</p><ul><li>Casbin社区的明日之星预选生培养计划，相当于一个线上实习。<ul><li>担任社区维护者，处理日常issue，跟踪用户需求，修复bug。由于Casbin的核心访问控制功能已经比较完善，所以我在社区的主要工作是围绕开发完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查。</li><li>我在这个期间主要是完成了与微信支付SDK对接实现微信支付功能、以及设计开发一个异步的权限管理持久化适配器<code>async-sqlalchemy-adapter</code>。其他可能就跟后端关系不太大了。</li></ul></li><li>中科院和Casbin社区联合举办的开源之夏项目。<ul><li>作为项目负责人，主要实现casdoor-react-native-sdk&#x2F;example、casdoor-unity-example的测试、开发及发布，完善casdoor-flutter-sdk的功能，使其支持ios移动端微信第三方原生登录。</li><li>独立开发Casdoor Authenticator App，这是一款⽀持通⽤2FA的iOS&#x2F;Android移动应⽤程序，通过生成基于时间的一次性密码(TOTP)来帮助保护用户账户。app基于React Native框架开发，认证过程使用了PKCE协议扩展，极大地增强了OAuth 2.0授权流程的安全性。</li></ul></li></ul><h4 id="casdoor-unity-example"><a href="#casdoor-unity-example" class="headerlink" title="casdoor-unity-example"></a>casdoor-unity-example</h4><ul><li>在github上开源的一个小游戏ValleyOfCubes_Unity3D (方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li><li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li><li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li><li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li></ul><h4 id="casdoor-react-native-sdk-example"><a href="#casdoor-react-native-sdk-example" class="headerlink" title="casdoor-react-native-sdk&#x2F;example"></a>casdoor-react-native-sdk&#x2F;example</h4><ul><li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li><li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li><li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li></ul><h4 id="Casdoor-Authenticator-App"><a href="#Casdoor-Authenticator-App" class="headerlink" title="Casdoor Authenticator App"></a>Casdoor Authenticator App</h4><ul><li>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。</li><li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li><li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li></ul><h4 id="async-sqlalchemy-adapter"><a href="#async-sqlalchemy-adapter" class="headerlink" title="async-sqlalchemy-adapter"></a>async-sqlalchemy-adapter</h4><p>异步的权限管理持久化适配器 <code>async-sqlalchemy-adapter</code>，是PyCasbin的<code>SQLAlchemy</code>适配器。通过这个库，Casbin 可以从 <code>SQLAlchemy</code> 支持的数据库加载策略或将策略保存到其中。</p><blockquote><p><code>SQLAlchemy</code> 是 Python SQL 工具包和对象关系映射器，为应用程序开发人员提供 SQL 的全部功能和灵活性。</p></blockquote><p><strong>亮点</strong></p><ol><li>异步支持：<ul><li>亮点：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li><li>回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li></ul></li><li>灵活的过滤机制：<ul><li>亮点：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li><li>回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li></ul></li><li>可扩展性：<ul><li>亮点：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li><li>回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li></ul></li><li>事务处理：<ul><li>亮点：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li><li>回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li></ul></li></ol><p><strong>难点</strong></p><ol><li>异步编程的复杂性：<ul><li>难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li><li>回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li></ul></li><li>数据库模型的灵活性与一致性：<ul><li>难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li><li>回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li></ul></li><li>复杂的策略更新逻辑：<ul><li>难点：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li><li>回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li></ul></li><li>高效的批量操作：<ul><li>难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li><li>回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li></ul></li></ol><p>测试方面</p><ul><li>适配器实现：编写了<code>SQLAlchemy</code>适配器，使得Casbin可以使用<code>SQLAlchemy</code>进行权限管理存储。</li><li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括策略的添加、删除、更新和过滤。</li></ul><p>技术细节</p><ul><li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li><li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul><li>测试添加一个策略，添加多个策略</li><li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li><li>测试更新一个策略，测试更新多个策略。</li></ul></li></ul><h4 id="微信支付对接-无"><a href="#微信支付对接-无" class="headerlink" title="微信支付对接(无)"></a>微信支付对接(无)</h4><h4 id="单点登录SSO原理"><a href="#单点登录SSO原理" class="headerlink" title="单点登录SSO原理"></a>单点登录SSO原理</h4><p>单点登录(Single Sign-On, SSO)是一种身份验证的解决方案，它允许用户在多个应用间共享身份信息，也就是说，用户只需要登录一次，就可以在多个系统或者应用之间无缝访问。这大大提高了用户体验和安全性。</p><p>每种需要SSO的app需要先在SSO系统中进行注册。注册流程：</p><ol><li>注册应用：app和app2作为客户端应用程序，需要提供应用的名称、回调URL(用于接收SSO系统的重定向)、以及其他必要的配置信息。</li><li>获取<code>clientID</code>和<code>clientSecret</code>：注册成功后，SSO系统会为每个应用生成一个唯一的<code>clientID</code>(客户端标识)和<code>clientSecret</code>(客户端密钥)。<code>clientID</code>用来标识应用，而<code>clientSecret</code>则用于确保请求的合法性和安全性。</li></ol><p>SSO流程：</p><ol><li>用户第一次访问app，系统会触发一个302的重定向请求，转到SSO登录系统。SSO系统发现当前用户没用登录app，就弹出用户登录页面，用户在这个页面填写用户名和密码，那么SSO系统就会进行一个验证，验证成功以后，把登录状态写入到SSO的<code>session</code>里面，浏览器也会写入SSO域下的<code>cookie</code>。 SSO系统登录完成以后，系统会生成一个ST(Service Ticket)，然后跳转到app系统，同时把ST作为参数传递给app系统。app系统拿到ST以后，从后台向SSO发送请求，验证ST是否有效。验证通过以后，app系统把登录状态写入到<code>session</code>中，并设置app域下的<code>cookie</code>，这样，跨域的单点登录就完成了。后面在访问app系统的时候，app就是一个登录状态。</li><li>当用户访问app2系统，app2没有登录会跳转到SSO，但此时SSO在访问app的时候已经是登录态了(SSO系统通过检查SSO域下的<code>cookie</code>，识别出该用户已经有了有效的登录会话)，所以不用重新输入账号密码。此时SSO也会生成一个ST，浏览器会跳转到app2系统，把ST作为参数传递给app2。 app2拿到ST以后，后台访问SSO验证ST是否有效，如果验证成功，那么app2会把登录状态写入到<code>session</code>，并在app2的域下写入一个<code>cookie</code>。这样，app2系统不需要再走登录流程，就已经是一个登录状态了。SSO、app、app2不同域，它们之间的<code>session</code>不共享，也没有任何问题。</li></ol><p>SSO的具体实现因为技术栈不同会有所不同，比如OAuth2.0和OpenID Connect经常被用作于实现SSO的标准协议，</p><h4 id="OAuth-2-0原理"><a href="#OAuth-2-0原理" class="headerlink" title="OAuth 2.0原理"></a>OAuth 2.0原理</h4><p><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></p><p>OAuth2.0是一个授权框架，使应用程序(如Github)能够获得对 HTTP 服务上的用户帐户的有限访问权限。它的工作原理是将用户身份验证委托给托管用户帐户的服务，并授权第三方应用程序访问该用户帐户。OAuth2.0 为 Web 和桌面应用程序以及移动设备提供授权流程。</p><p>定义了4种角色：</p><ul><li>用户(资源所有者)：资源所有者是授权应用程序访问其帐户的用户。应用程序对用户帐户的访问仅限于授予的授权范围。</li><li>应用程序(客户端)：客户端是想要访问用户帐户信息的应用程序。在执行此操作之前，必须获得用户的授权，并且该授权必须由授权服务器进行验证。</li><li>资源服务器：资源服务器托管受保护的用户帐户的资源。</li><li>授权服务器：授权服务器验证用户的身份，然后向应用程序颁发访问令牌。</li></ul><p>步骤：</p><ol><li>应用程序(可以是Casdoor)向用户请求访问服务器资源的授权。应用程序请求参数如下：<ul><li><code>client_id</code>：客户端应用的<code>clientID</code>。</li><li><code>redirect_uri</code>：授权成功后的重定向URI。</li><li><code>response_type</code>：通常为<code>code</code>，表示请求一个授权码。</li><li><code>scope</code>：请求的权限范围(可选)。</li><li><code>state</code>：防止CSRF攻击的随机字符串(可选)。</li></ul></li><li>如果用户授权该请求，授权服务器会生成授权准许(<code>Authorization Grant</code>)，并重定向到重定向URI(重定向URI包含<code>Authorization Grant</code>)。应用程序通过重定向URI获取授权准许(<code>Authorization Grant</code>)。</li><li>应用程序通过提供其自身的身份验证(包含<code>clientID</code>和<code>clientSecret</code>)和授权准许(<code>Authorization Grant</code>)来向授权服务器请求访问令牌(<code>access_token</code>)。应用程序请求参数如下：<ul><li><code>grant_type</code>：通常为<code>authorization_code</code>。</li><li><code>code</code>：在前一步收到的授权准许(<code>Authorization Grant</code>)</li><li><code>redirect_uri</code>：与授权请求中使用的<code>redirect_uri</code>相同。</li><li><code>client_id</code>：客户端的<code>clientID</code>。</li><li><code>client_secret</code>：客户端的<code>clientSecret</code>。</li></ul></li><li>授权服务器验证应用程序的<code>Authorization Grant</code>、<code>clientID</code>、<code>clientSecret</code>和<code>redirect_uri</code>。如果应用程序通过验证且授权准许(<code>Authorization Grant</code>)有效，则授权服务器向应用程序颁发访问令牌(<code>access_token</code>)。授权完成。</li><li>应用程序从资源服务器请求资源并提供访问令牌(<code>access_token</code>)进行身份验证。</li><li>如果访问令牌(<code>access_token</code>)有效，则资源服务器向应用程序提供资源。</li></ol><p>授权准许(<code>Authorization Grant</code>)的类型取决于应用程序请求授权所使用的方法以及 API 支持的授权类型。 OAuth2.0 定义了三种主要准许(grant)类型，每种类型在不同情况下都有用：</p><ol><li>授权码(<code>Authorization Code</code>)：与服务器端应用程序一起使用。</li><li>客户端凭证(<code>Client Credentials</code>)：与具有 API 访问权限的应用程序一起使用。</li><li>设备代码(<code>Device Code</code>)：用于缺少浏览器或有输入限制的设备。</li></ol><h4 id="PKCE"><a href="#PKCE" class="headerlink" title="PKCE"></a>PKCE</h4><p>PKCE(<code>Proof Key for Code Exchange, PKCE</code>)是一种用于保护OAuth 2.0授权码授权流程的机制，主要目的是防止授权码拦截攻击(Authorization Code Interception Attack)。</p><p>原理：<br>PKCE通过在OAuth 2.0授权码请求和令牌交换过程中引入一个随机生成的<code>code_challenge</code>和<code>code_verifier</code>来增强安全性。具体来说，PKCE引入了两个新参数：</p><ul><li><code>code_verifier</code>：一个高熵的随机字符串，客户端在请求<code>code</code>(授权码)时生成并保存。</li><li><code>code_challenge</code>：由<code>code_verifier</code>生成的一个变体，发送给授权服务器。可以是<code>code_verifier</code>本身，或者是<code>code_verifier</code>的SHA256哈希值。</li></ul><p>流程：</p><ol><li>客户端生成一个随机的<code>code_challenge</code>和<code>code_verifier</code>，<code>code_verifier</code>可以是明文(<code>plain</code>)SHA256哈希值(<code>s256</code>)。</li><li>客户端将<code>code_challenge</code>和<code>code_challenge_method</code>(<code>plain</code>或<code>s256</code>)发送给授权服务器。<ul><li>如：<code>GET /authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;scope=SCOPE&amp;state=STATE&amp;code_challenge=CODE_CHALLENGE&amp;code_challenge_method=S256</code></li></ul></li><li>用户在授权服务器进行身份验证，同意授权，授权服务器通过重定向URI将<code>code</code>(授权码)返回给客户端。</li><li>客户端将<code>code</code>(授权码)和<code>code_verifier</code>发送给授权服务器，以获取<code>access_token</code>(访问令牌)。<ul><li>如：<code>POST /token?grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=REDIRECT_URI&amp;client_id=CLIENT_ID&amp;code_verifier=CODE_VERIFIER</code></li></ul></li><li>授权服务器收到客户端发送的<code>code</code>(授权码)和<code>code_verifier</code>后，使用之前保存的<code>code_challenge</code>进行验证。<ul><li>如果<code>code_challenge_method</code>是<code>plain</code>，则直接比较<code>code_verifier</code>和<code>code_challenge</code>。</li><li>如果<code>code_challenge_method</code>是<code>s256</code>，则比较<code>code_verifier</code>的SHA256哈希值和<code>code_challenge</code>。</li></ul></li><li>如果验证通过，授权服务器返回<code>access_token</code>(访问令牌)给客户端。</li></ol><p>这样，即使<code>code</code>(授权码)在传输过程中被拦截，攻击者也无法使用该<code>code</code>(授权码)，因为缺少正确的<code>code_verifier</code>。</p><h4 id="2FA"><a href="#2FA" class="headerlink" title="2FA"></a>2FA</h4><p>两因素认证(<code>Two-Factor Authentication, 2FA)</code>是一种安全系统，用于确保用户登录到账户或访问资源时，需要通过两种不同类型的验证方式。这种方法比仅依靠密码更安全，因为它增加了额外的验证层，使得即使密码被泄露，攻击者仍然难以访问用户账户。</p><p>身份验证因素：2FA通常结合两种不同的验证因素，分三类：</p><ul><li>知识因素(Something you know)：用户知道的东西，例如密码、PIN码、回答安全问题等。</li><li>持有因素(Something you have)：用户拥有的物品，例如手机、硬件令牌、智能卡等。</li><li>固有因素(Something you are)：用户自身的特征，例如指纹、面部识别、声音识别等生物特征。</li></ul><p>验证过程：</p><ul><li>第一步：输入用户名和密码：用户首先输入他们的用户名和密码(知识因素)。</li><li>第二步：额外验证：系统会要求用户进行第二步验证。这可以是：  <ul><li>一次性密码(OTP)：通过短信、电子邮件或专用应用程序(如Google Authenticator、Authy)生成并发送给用户的随机密码。</li><li>硬件令牌：用户插入或展示硬件令牌生成的代码。</li><li>生物特征识别：用户通过指纹、面部识别等方式进行验证。</li></ul></li></ul><p>验证成功：如果两步验证都通过，用户将获得访问权限。<br>验证失败：如果任何一步失败，访问将被拒绝。</p><h4 id="OTP-TOTP-HOTP"><a href="#OTP-TOTP-HOTP" class="headerlink" title="OTP&#x2F;TOTP&#x2F;HOTP"></a>OTP&#x2F;TOTP&#x2F;HOTP</h4><p>OTP (One-Time Password) 是一种一次性有效的密码，通常用于两因素身份验证(2FA)。每次使用 OTP 进行身份验证后，这个密码便失效，无法再使用。OTP 提高了安全性，因为即使密码被截获或暴力破解，也不能再次使用。OTP 生成和使用的方式有很多种，包括基于时间的(TOTP)和基于事件的(HOTP)。</p><p><strong>TOTP(基于时间的一次性密码)</strong><br>TOTP (Time-Based One-Time Password) 是 OTP 的一种，它基于当前时间生成密码。TOTP 是 HOTP 的扩展，结合了时间元素来提高安全性。TOTP 的工作原理如下：</p><ol><li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 TOTP。</li><li>时间段：TOTP 使用当前时间的一个窗口(通常是 30 秒)来生成密码。每个时间段内生成的密码是唯一的。</li><li>算法：TOTP 使用 HMAC-SHA1 算法和共享密钥以及当前时间戳来生成密码。</li></ol><p><strong>生成和验证</strong></p><ul><li>生成 TOTP：用户的设备(如手机上的 Google Authenticator 应用)使用共享密钥和当前时间生成 TOTP。</li><li>验证 TOTP：服务器使用同样的共享密钥和当前时间计算 TOTP，并与用户提供的 TOTP 进行对比。如果匹配，则验证成功。</li></ul><p><strong>优点</strong></p><ul><li>安全性高：每个密码只能使用一次，有效时间短，降低了被攻击的风险。</li><li>易于使用：用户只需要输入一次性密码，而不需要记住复杂的密码。</li><li>灵活性：适用于各种应用场景，如登录、交易验证等。</li></ul><p><strong>缺点</strong></p><ul><li>时间同步：TOTP 依赖于设备和服务器时间的同步，如果时间不同步，可能会导致验证失败。</li><li>设备依赖：需要用户拥有生成 OTP 或 TOTP 的设备，如智能手机。</li></ul><p><strong>HOTP(基于事件的一次性密码)</strong><br>HOTP (HMAC-Based One-Time Password) 是一种基于事件的 OTP(一次性密码)生成方法。HOTP 的生成与验证基于 HMAC-SHA1 算法及一个计数器，确保每次生成的密码都是唯一的。HOTP 的工作原理如下：</p><ol><li>共享密钥：用户和服务器共享一个密钥，这个密钥用于生成和验证 HOTP。</li><li>计数器：用户和服务器都维护一个计数器，计数器初始值相同，每次生成或验证 OTP 时都会增加计数器的值。</li><li>HMAC-SHA1 算法：HOTP 使用 HMAC-SHA1 算法，将共享密钥和计数器作为输入，生成一个哈希值。</li><li>生成 OTP：从哈希值中提取部分数据(通常是取哈希值的后几位)，将其转换为一个短数字串，即 OTP。</li></ol><p><strong>生成和验证</strong></p><ul><li>生成 HOTP：用户的设备使用共享密钥和计数器生成 HOTP。</li><li>验证 HOTP：服务器使用同样的共享密钥和计数器计算 HOTP，并与用户提供的 OTP 进行对比。如果匹配，则验证成功，并增加计数器的值。</li></ul><p><strong>优点</strong></p><ul><li>无时间依赖：HOTP 不依赖于设备和服务器时间的同步，避免了时间不同步带来的问题。</li><li>安全性高：每个密码只能使用一次，降低了密码被截获或重复使用的风险。</li><li>灵活性：适用于各种应用场景，如登录、交易验证等。</li></ul><p><strong>缺点</strong></p><ul><li>计数器同步：用户和服务器必须保持计数器的同步，否则会导致验证失败。如果计数器不同步，需要有机制进行重新同步。</li><li>复杂性：相较于静态密码，HOTP 的实现和维护相对复杂。</li></ul><p><strong>使用场景</strong></p><ul><li>银行和金融服务：TOTP&#x2F;HOTP 经常用于网上银行和金融交易中，以确保只有授权用户才能进行操作。</li><li>企业安全：企业系统常使用 TOTP&#x2F;HOTP 进行多因素身份验证，以保护敏感数据和资源。</li><li>社交媒体和电子邮件：为了防止账户被黑客入侵，许多社交媒体和电子邮件服务提供商都提供 TOTP&#x2F;HOTP 作为额外的安全措施。</li></ul><h4 id="TOTP中如果用户与服务器时间不同步怎么办？"><a href="#TOTP中如果用户与服务器时间不同步怎么办？" class="headerlink" title="TOTP中如果用户与服务器时间不同步怎么办？"></a>TOTP中如果用户与服务器时间不同步怎么办？</h4><p>如果用户端和服务器端的时间不同步，TOTP 会出现以下问题：</p><ul><li>验证失败：TOTP算法依赖于当前时间来生成密码，如果用户端和服务器端的时间不一致，生成的密码就会不同。即使用户输入正确的密码，服务器端由于时间不同步，会生成和用户端不同的密码，从而导致验证失败。</li><li>用户体验问题：用户可能会反复输入密码，但由于时间不同步，导致总是验证失败，进而影响用户体验，甚至导致用户无法完成登录或其他需要验证的操作。</li></ul><p>解决方案：</p><ol><li>时间容差窗口：允许服务器在验证 TOTP 时，检查当前时间前后一定范围内的密码。通常，这个时间窗口设置为 30 秒到 1 分钟。这意味着服务器会验证多个时间点的密码，而不仅仅是当前时间对应的密码。这种方法能够解决小范围的时间偏差。</li><li>自动时间同步：定期使用网络时间协议(NTP)等方式同步用户设备和服务器的时间，确保两者的时间保持一致。这可以大大减少时间不同步的问题。</li><li>用户手动时间同步：如果用户的设备时间与标准时间偏差较大，应用程序可以提醒用户手动调整时间，或者提供一键同步时间的功能。</li><li>使用服务器端生成并发送 TOTP：由服务器生成 TOTP 并通过短信或电子邮件发送给用户。这样即使用户设备时间不准确，用户仍然可以收到正确的 TOTP。</li></ol><h4 id="开源经历中遇到的困难及解决方案"><a href="#开源经历中遇到的困难及解决方案" class="headerlink" title="开源经历中遇到的困难及解决方案"></a>开源经历中遇到的困难及解决方案</h4><p>开发Casdoor Authenticator App过程中遇到一些困难。这包括以下几个方面的困难：</p><ol><li>跨平台兼容性：由于应用需要同时支持iOS和Android平台，需要确保代码能够在这两个平台上顺畅运行，如何处理不同平台的差异成为一个重要问题。</li><li>登录：需要登录到Casdoor这个SSO系统。如何登录是一个问题。</li><li>安全性挑战：2FA的核心是生成基于时间的一次性密码(TOTP)，这些密码的生成过程必须足够安全，防止被破解或伪造。同时，在认证流程中使用PKCE协议扩展以增强OAuth 2.0的安全性，也带来了实现上的复杂性。</li><li>要实现扫码生成TOTP码，该如何实现。</li><li>用户与服务器时间不同步怎么办：该app是需要用户安装到自己的设备上的，基于用户自己的移动设备上的时间生成TOTP码。</li><li><code>clientSecret</code>泄露问题。授权码劫持攻击。</li></ol><p>解决方法：</p><ol><li>跨平台开发：为了解决跨平台兼容性问题，采用facebook开发的expo框架，这是一个基于React Native 的开发框架，旨在简化移动端跨平台开发。无需设置复杂的开发环境，也不需要直接接触原生代码，就能快速构建和部署 iOS 和 Android 应用。</li><li>登录过程采用了casdoor-react-native-sdk，这可以非常方便地接入SSO系统。首先需要在SSO系统中生成一个应用，记录其<code>clientId</code>和<code>clientSecret</code>，然后在<code>casdoor-react-native-sdk</code>中绑定好<code>clientId</code>和<code>clientSecret</code>，就可以使用SSO功能了。</li><li>安全性实现：在TOTP的生成过程中，我选择了开源的totp-generator库，默认使用SHA-256哈希算法，并通过严格的密钥管理策略来保证密钥的安全性。在实现PKCE协议扩展时，我结合了社区的最佳实践，并通过定期的代码审查和测试，确保了OAuth 2.0授权流程的安全性。</li><li>一旦在SSO系统中选择开启2FA功能，就会给用户发一个密钥或者二维码，二维码中隐含app以及密钥信息。此时输入密钥或者扫码就可以绑定app，在用户的应用上生成TOTP码。这里使用<code>expo-camera</code>库，调用移动设备的相机，扫码识别二维码中的关键信息，拿到密钥后即可生成TOTP码。</li><li>见上一个问题。</li><li>采用PKCE协议拓展进行授权认证。</li></ol><p>最终，Casdoor Authenticator App不仅实现了2FA功能，还在安全性和用户体验上达到了较高的标准。这个过程中的挑战让我对跨平台开发、安全协议实现以及第三方登录集成有了更深入的理解，并且我学会了如何通过社区合作和资源整合来解决复杂的技术问题。</p><h4 id="假如一个用户需要接入Casdoor-SSO系统该怎么办？"><a href="#假如一个用户需要接入Casdoor-SSO系统该怎么办？" class="headerlink" title="假如一个用户需要接入Casdoor SSO系统该怎么办？"></a>假如一个用户需要接入Casdoor SSO系统该怎么办？</h4><ol><li>注册应用：首先需要在Casdoor管理平台上注册应用。需要提供应用名称、标识符、回调URL等信息。Casdoor将为应用生成一个<code>clientId</code>和<code>clientSecret</code>，用于后续的认证流程。</li><li>配置Casdoor客户端：在应用中，集成Casdoor客户端库。对于不同的技术栈，Casdoor提供了相应的SDK，例如<code>casdoor-react-native-sdk</code>适用于React Native应用。选择适合开发环境的SDK进行集成。</li><li>设置OAuth 2.0协议：Casdoor使用OAuth 2.0进行认证。需要配置<code>clientId</code>、<code>clientSecret</code>、授权服务器的URL以及回调URL。对于更高的安全性，建议使用PKCE(Proof Key for Code Exchange)来避免<code>clientSecret</code>泄露问题。</li><li>实现登录功能：<ul><li>在应用中实现登录按钮，点击按钮后用户将被重定向到Casdoor的授权页面进行登录认证。认证成功后，Casdoor会将用户重定向回应用，并附带一个授权码(authorization code)。</li><li>在应用中，通过这个授权码向Casdoor请求访问令牌(<code>access_token</code>)。通过访问令牌，你可以获取用户的基本信息并管理用户会话。</li></ul></li><li>处理回调与会话管理：实现回调处理逻辑，接收从Casdoor返回的授权码，并交换访问令牌。随后可以使用访问令牌从Casdoor API中获取用户信息，并在应用中创建或更新用户会话。</li><li>安全性措施：在实际应用中，确保<code>clientSecret</code>的安全性，避免泄露。使用HTTPS传输数据，并遵循Casdoor官方推荐的最佳安全实践，例如设置时间容差窗口来应对服务器与客户端时间不同步的问题。</li><li>测试与调试：完成集成后，进行全面的测试，确保从Casdoor的认证流程顺畅无误。模拟各种用户场景，验证登录、登出、授权失败等情况的处理逻辑。</li><li>文档与用户支持：为应用提供详细的文档，说明如何使用Casdoor SSO进行登录。如果可能，为用户提供FAQ和支持渠道，解决他们在使用过程中遇到的问题。</li></ol><h4 id="如果是你要接入SSO系统的话，session存储到哪里，那个中间件？"><a href="#如果是你要接入SSO系统的话，session存储到哪里，那个中间件？" class="headerlink" title="如果是你要接入SSO系统的话，session存储到哪里，那个中间件？"></a>如果是你要接入SSO系统的话，session存储到哪里，那个中间件？</h4><ol><li>Redis<ul><li>适合场景: 适合分布式部署、大规模应用环境。</li><li>配置方法: 使用Redis作为Session存储，支持高并发和数据持久化。</li><li>优点: 高性能，支持持久化和分布式会话共享。</li><li>缺点: 需要额外配置Redis服务。</li></ul></li><li>数据库(MySQL、PostgreSQL等)<ul><li>适合场景: 需要持久化Session数据，并且希望与现有数据库集成的场景。</li><li>配置方法: 使用数据库来存储Session数据，需提供数据库连接字符串。</li><li>优点: 数据持久化，易于备份和管理。</li><li>缺点: 读写速度相对Redis较慢，配置相对复杂。</li></ul></li><li>其他分布式存储(如Memcached)<ul><li>适合场景: 在高可用、分布式系统中使用。</li><li>配置方法: 配置Beego使用Memcached等分布式缓存系统。</li><li>优点: 高性能，支持分布式架构。</li><li>缺点: 配置和管理复杂度较高。</li></ul></li><li>云服务<ul><li>适合场景: 采用云服务构建的系统，使用云提供的Session存储解决方案(如AWS ElastiCache)。</li><li>配置方法: 类似于Redis或Memcached，根据云服务提供商的指南进行配置。</li></ul></li><li>内存(Memory)<ul><li>适合场景: 适合开发和测试环境。</li><li>配置方法: 使用Beego自带的内存Session存储。</li><li>优点: 配置简单，速度快。</li><li>缺点: Session数据存储在内存中，不适合生产环境，服务器重启或宕机会导致Session丢失。</li></ul></li><li>文件系统(File System)<ul><li>适合场景: 适合小型应用或简单的生产环境。</li><li>配置方法: 将Session数据存储在文件系统中，设置存储路径。</li><li>优点: 简单易用，持久化Session数据。</li><li>缺点: 读写速度相对较慢，不适合分布式部署。</li></ul></li></ol><p>如果是生产环境且需要分布式支持，Redis通常是最佳选择。如果只是开发环境或小规模应用，内存或文件存储可能就足够了。</p><h4 id="expo框架"><a href="#expo框架" class="headerlink" title="expo框架"></a>expo框架</h4><p>Expo 是一个基于 React Native 的开发框架，它提供了一整套开发工具和服务，旨在简化跨平台移动应用的开发过程。Expo 让开发者无需设置复杂的开发环境，也不需要直接接触原生代码，就能快速构建和部署 iOS 和 Android 应用。</p><p>以下是 Expo 的一些关键特点：</p><ol><li>零配置开发环境：Expo 提供了一个即开即用的开发环境，开发者无需设置 Android Studio 或 Xcode 这样的原生开发工具，就能直接在浏览器或命令行中启动项目。这个特性特别适合初学者或希望快速原型设计的开发者。</li><li>跨平台支持：Expo 支持同时构建 iOS 和 Android 应用，开发者只需编写一份代码，Expo 会处理平台差异。通过 Expo 的 API，你可以轻松调用相机、位置、推送通知等设备功能，而不必担心底层实现的差异。</li><li>丰富的组件库和 API：Expo 提供了大量的内置组件和 API，涵盖媒体处理、传感器、文件系统等常见的移动应用需求。这些工具可以帮助开发者快速实现应用的核心功能，而无需编写复杂的原生代码。</li><li>Expo Go 应用：Expo Go 是一个预配置的应用程序，开发者可以将代码推送到 Expo 服务器，然后直接在手机上通过 Expo Go 实时查看应用的效果。这个过程大大加快了开发和调试的效率。</li><li>OTA(Over-the-Air)更新：Expo 支持应用的 OTA 更新功能，这意味着开发者可以在不经过 App Store 或 Google Play 审核的情况下，直接向用户推送更新。用户只需打开应用，就能自动获取最新版本。</li><li>Eject 到 Bare Workflow：虽然 Expo 提供了很多便利的工具，但它也有一定的局限性。当开发者需要实现一些复杂的原生功能时，可以选择从 Expo 的托管环境中“弹出”(eject)，进入 Bare Workflow 模式，从而获得对原生代码的完全控制权。</li><li>社区与生态系统：Expo 有一个活跃的社区和生态系统，提供了丰富的文档、插件和第三方库，帮助开发者解决各种问题。</li></ol><h4 id="Casbin-Casdoor介绍"><a href="#Casbin-Casdoor介绍" class="headerlink" title="Casbin&amp;Casdoor介绍"></a>Casbin&amp;Casdoor介绍</h4><p>Casbin是一个强大的访问控制库，用于实现权限管理和访问控制的功能。它使用基于策略(Policy-Based)的访问控制模型，支持各种访问控制模型(如 ACL、RBAC、ABAC 等)，并提供了丰富的功能和灵活的配置选项，使开发者可以轻松地实现精细化的权限管理。<br>Casbin 的主要特点包括：</p><ol><li>多种访问控制模型支持：包括基于角色的访问控制(RBAC)、基于属性的访问控制(ABAC)、访问控制列表(ACL)等，满足不同场景的权限管理需求。</li><li>灵活的策略管理：通过策略文件进行权限管理，支持多种格式(如 CSV、JSON、数据库等)，方便管理和配置访问策略。</li><li>细粒度的权限控制：支持精细到 API 级别的权限控制，可以根据需求对用户和资源进行精确控制。</li><li>跨语言支持：Casbin 提供了多种语言的实现，如 Go、Java、Node.js、Python 等，方便开发者在不同的技术栈中使用 Casbin 进行权限管理。</li></ol><p>Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。</p><ol><li>单点登录(SSO)：支持统一身份验证，用户只需登录一次即可访问多个应用系统。</li><li>用户管理：提供用户注册、登录、密码找回等功能，支持用户角色和权限的管理。</li><li>权限控制：与 Casbin 集成，实现灵活的权限控制和策略管理，可以根据用户角色和权限设置不同的访问策略。</li><li>开源社区：Casdoor 是开源项目，提供了完整的文档和示例代码，同时也有活跃的社区支持，方便开发者使用和定制。</li></ol><h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h4><p>RESTful API(<code>Representational State Transfer API</code>)是一种基于REST架构风格的Web服务接口。REST是一种架构风格，用于设计网络应用，使其更轻量、性能更高且更易于扩展。RESTful API利用HTTP协议作为通信标准，并遵循REST架构原则。<br>REST架构原则：</p><ul><li>无状态性：每个请求从客户端到服务器必须包含足够的信息以使服务器理解请求。服务器不存储客户端的上下文，所有状态信息由客户端维护。</li><li>统一接口： 资源：通过URL定位资源(通常是名词，如 <code>/users</code> 表示用户资源)。 操作：使用标准HTTP方法对资源进行操作： <code>GET</code>：获取资源 <code>POST</code>：创建资源 <code>PUT</code>：更新资源 <code>DELETE</code>：删除资源</li><li>可缓存性：服务器的响应可以被标记为可缓存或不可缓存，以提高性能。</li><li>分层系统：客户端不需要直接与服务器交互，可能会通过中间服务器(如代理、负载均衡器等)来提升系统的可扩展性和安全性。</li><li>按需代码：在某些情况下，服务器可以返回可执行代码(如JavaScript)，使客户端能够执行。</li></ul><p><strong>特点</strong></p><ul><li>资源导向：一切皆资源，每个资源使用唯一的URL表示。 </li><li>标准化操作：利用HTTP动词来描述对资源的操作。 </li><li>状态表示：服务器在每次请求中发送所需的状态信息，以便客户端理解和使用。 </li><li>客户端-服务器架构：客户端和服务器职责分离，提升了系统的可维护性和可扩展性。 </li><li>无状态交互：每个请求独立，不依赖于之前的请求。</li></ul><p><strong>优点</strong></p><ul><li>简单易懂：遵循标准的HTTP协议和方法，便于理解和使用。 </li><li>性能高：无状态和可缓存性提高了性能。 </li><li>可扩展性：分层系统和明确的资源导向使得系统易于扩展。 </li><li>灵活性：支持多种数据格式(如JSON、XML)，适应不同客户端需求。</li></ul><p><strong>缺点</strong></p><ul><li>无状态：每个请求都需要携带所有信息，可能会导致开销增加。</li><li>缺乏标准化：虽然REST原则明确，但实际实现可能会有差异，导致互操作性问题。 </li><li>适用于简单操作：对于复杂事务处理，REST可能不如其他协议(如GraphQL)高效。</li></ul><p>RESTful API因其简单、灵活和高效，已经成为现代Web服务开发的主流选择。</p><h4 id="Casbin明日之星实习"><a href="#Casbin明日之星实习" class="headerlink" title="Casbin明日之星实习"></a>Casbin明日之星实习</h4><ol><li>在实习期间负责处理社区中导师分配的issue。由于Casbin的核心访问控制功能已经比较完善，且有很多仓库及sdk，所以issue的提交并不单单围绕主仓库，我的职责更多的是放在完善sdk上面。具体就是使用Casdoor的RESTful API接口，然后使用其他语言如JS、Java、Python来调用接口实现登录登出、对相关用户信息、资源等进行增删改查，这就是其他语言的sdk。当然，随着主仓库的相关接口或者功能更新，sdk也要做出相应的调整。</li><li>有时候我也负责Casdoor中的issue或者bug修复，Casdoor 是基于 Casbin 的单点登录(SSO)和权限管理系统，用于管理用户身份验证和访问权限。它提供了用户注册、登录、角色管理、权限控制等功能，可以与 Casbin 搭配使用，实现全面的身份验证和权限管理解决方案。这个系统使用react作为前端，beego作为后端，实现相关功能。</li><li>另外就是负责编写演示文档了，社区中某些开发文档不够完善，需要自己测试使用某些功能后，写出教程文档。</li></ol><h4 id="中科院开源之夏项目"><a href="#中科院开源之夏项目" class="headerlink" title="中科院开源之夏项目"></a>中科院开源之夏项目</h4><p><strong>简介</strong><br>Casdoor单点登录系统⼤前端项⽬包括ios、flutter、uinapp、⼩程序等sdk的开发、功能的增强， 对微信等第三⽅登录的移动端⽅式的⽀持。开发⼤前端应⽤的主要⽬的是为了提⾼⽤户体验和增加应⽤的可访问性，可以让⽤户在不同的设备和应⽤中都能够⽅便地使⽤应⽤，提⾼⽤户的满意度和使⽤率。同时，⼤前端应⽤也可以为开发者提供更多的开发选项和⼯具，提⾼开发效率和应⽤的可维护性。</p><p><strong>项目诉求</strong></p><ol><li>对微信第三方登录的移动端支持<ul><li>在casdoor移动网页端，点击微信第三方登录按钮，弹出的却是扫二维码登录，这在移动端显然是不合理的，需要的是点击微信第三方登录后，跳转到微信app进行认证授权登录，用户确认后返回移动网页端。</li></ul></li><li>对flutter、react-native、unity等sdk的开发及功能的增强<ul><li>对flutter-sdk的增强如第一点</li></ul></li><li>临时加上的开发casdoor-app诉求，对标Google Authenticator</li></ol><p><strong>技术细节</strong></p><ol><li><p>在flutter-sdk中通过截取<code>session</code>中的<code>url</code>和<code>callbackURLscheme</code>判断其中是否有”weixin”字段，如果有，则进行微信第三方原生授权登录；</p><ul><li>使用<code>WKWebView</code>替换原本的<code>ASWebAuthenticationSession</code>，对ios认证部分进行重写，以支持对每个跳转的链接进行监听；</li><li>使用rb脚本文件自动化配置微信SDK导入后xcode中<code>xcodeproj</code>文件的相关配置；</li><li>接入<code>xcframework</code>的微信SDK，使用obj-c重写原本的swift代码，以使用微信SDK；</li></ul><p>接下来根据微信SDK开发文档进行配置即可。由于配置微信SDK需要苹果开发者账号以配置<code>universal Link</code>，需付费几百美元，所以最终代码并未实际测试。</p></li><li><p>分为两部分</p><ol><li>casdoor-unity-example<ul><li>在github上开源的一个小游戏ValleyOfCubes_Unity3D(方块之谷)的基础上，演示如何使用casdoor RESTful API进行web SSO(Single Sign On) 登录；</li><li>以C#为开发语言，调用casdoor-dotnet-sdk进行web SSO 登录；</li><li>在casdoor服务端配置好应用的<code>clientCode</code>和<code>clientSecret</code>后，在Unity3D中向服务端发送认证请求(<code>cilentCode</code>等)，解析返回的<code>token</code>，就可以得到用户信息，也可以使用<code>session</code>保存<code>token</code>等信息。</li><li>认证过程中还使用到了unity-webview这个由格力公司一个团队开发的小组件，因为它是开源免费的。</li></ul></li><li>casdoor-react-native-sdk、example<ul><li>以react-native作为框架，使用casdoor RESTful API进行web SSO 登录；</li><li>react-native与JS不同的点在于在JS中，使用sessionStorage保存临时的session，主要是针对web端的，是同步的；react-native中与之类似的一个组件叫AsyncStorage，虽然功能大致相同，但却是异步的，导致不能共用一个sdk，所以就着手写了一个react-native sdk。</li><li>sdk采用PKCE(Proof Key for Code Exchange, 代码交换的证明密钥)这种更安全的方式获取token。PKCE是⼀种⽤于增强OAuth 2.0授权码流程安全性的协议扩展。这种协议使得在客户端不需要 clientSecret 就能获取到 token ，它依赖的是 <code>code_challenge</code> 和 <code>code_verifier</code> 。</li></ul></li></ol></li><li><p>casdoor-app 采用react-native框架，在授权登录功能上使用了react-native-sdk。</p><ul><li>casdoor-app使用开源的totp-generator作为TOTP(Time-based One Time Passwords)码生成器，默认使用SHA-256(Secure Hash Algorithm-256)哈希算法，也可以支持SHA384、SHA512等其他多种哈希算法。</li><li>casdoor-app支持输入密钥和扫码生成OTP，目前已完成核心功能开发。</li></ul></li></ol><blockquote><p>SHA(Secure Hash Algorithm，安全哈希算法)是一系列的哈希算法，它们用于将数据转换成固定长度的唯一标识符，通常用于数据完整性验证、数字签名、密码学安全等领域。SHA 算法属于密码学中的哈希函数，而不是加密算法。</p></blockquote><p><strong>总结</strong><br>参加开源活动对我的锻炼是非常大的，我觉得虽然每个小例子和sdk涉及相关知识都没那么难，但是他难就难在你从没接触过，要在短时间内学习，并将之应用。在短时间内学习掌握一种领域的知识，我觉得这才是我参与开源项目收获最大的经验。</p><h3 id="点评项目"><a href="#点评项目" class="headerlink" title="点评项目"></a>点评项目</h3><blockquote><p>项目经历：<br>优点评 - 不只点评<br>2024&#x2F;06 - 2024&#x2F;07<br>技术栈：SpringBoot、Mybatis-plus、Redis、MySQL<br>项目介绍：一个仿大众点评的项目，使用Redis解决各种应用场景问题，实现了短信登录、商户查询缓存、优惠券秒杀、每日签到等功能。<br>技术亮点：</p><ol><li>用Redis存储token、验证码，解决集群的session共享问题；通过ThreadLocal配合拦截器进行token校验，优化鉴权逻辑。</li><li>针对商铺查询，采用旁路缓存模式解决缓存与数据库双写一致性问题，并解决缓存查询中出现的缓存穿透、缓存雪崩、缓存击穿问题。</li><li>在秒杀业务中，采用乐观锁解决库存超卖问题；使用Redisson分布式锁解决集群模式下的一人一单问题；使用Stream消息队列实现异步秒杀优化，将业务接口的平均响应时间由250ms优化至110ms。</li><li>使用Redis各种数据结构实现点赞排行榜(ZSet)、附近商户(GEO)、每日签到(BitMap)等功能。</li></ol></blockquote><ol><li>用Redis存储token、验证码，解决集群的session共享问题；通过ThreadLocal配合拦截器进行token校验，优化鉴权逻辑。<ul><li>在分布式集群环境中，多个服务节点可能处理同一用户的请求。然而多个Tomcat服务器并不共享session存储空间，Redis作为集中式的存储，可以确保各个节点都能访问到相同session数据。在Redis中，将用户token作为key，用户信息作为value存储，实现session共享。前端将token存放入<code>authorization</code>头部，后端通过拦截器校验token，将头部中的token与Redis中的token进行比对，实现用户身份验证。</li><li><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 来修改或者获取默认值，这样可以实现线程之间的信息共享。将用户信息存储在<code>ThreadLocal</code>中，通过拦截器获取用户信息，实现鉴权逻辑。</li></ul></li><li>针对商铺查询，采用旁路缓存模式解决缓存与数据库双写一致性问题，并解决缓存查询中出现的缓存穿透、缓存雪崩、缓存击穿问题。<ul><li>旁路缓存模式适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</li><li>采用缓存空对象的方式来解决缓存穿透问题。</li><li>给不同的key设置的过期时间添加随机值，解决缓存雪崩问题。</li><li>互斥锁&#x2F;分布式锁：使用SETNX命令 + 设置过期时间作为互斥锁来解决缓存击穿问题。确保了数据的一致性，但是性能会收到一定影响。逻辑过期时间：在原有数据基础上添加一个过期时间字段。通过对比当前时间和逻辑过期时间，判断缓存是否过期。当缓存过期时，先使用过期的旧数据，然后再异步更新缓存。</li></ul></li><li><ul><li>在秒杀业务中，采用乐观锁解决库存超卖问题；<ul><li>采用CAS方法实现乐观锁，即将库存本身作为版本号，每次更新库存时，先查询当前版本号，然后更新库存时带上版本号，如果版本号一致，则更新成功，否则更新失败。</li></ul></li><li>使用Redisson分布式锁解决集群模式下的一人一单问题；<ul><li>在单机模式下，使用<code>synchronized</code>锁锁住下单逻辑，可以实现一人一单，但在集群模式下就不行。多个JVM之间的锁无法同步，Redisson分布式锁可以解决这个问题。</li><li>使用Redisson中的分布式锁：1. 创建锁对象<code>getLock()</code> 2. <code>tryLock()</code>方法获取锁 3. <code>unlock()</code>方法释放锁</li></ul></li><li>使用Stream消息队列实现异步秒杀优化，将业务接口的平均响应时间由250ms优化至110ms。<ul><li>异步秒杀的核心是减库存和创建订单这种耗时多的分离出来，单独安排一个线程去执行，这样可以提高接口的响应速度。</li></ul></li></ul></li><li>使用Redis各种数据结构实现点赞排行榜(ZSet)、附近商户(GEO)、每日签到(BitMap)等功能。<ul><li>点赞排行榜：使用ZSet有序集合存储点赞数，将用户id作为key，将点赞时刻的时间戳作为score，根据点赞时间实现排行榜。</li><li>附近商户：使用GEO地理位置数据结构存储商户的经纬度信息，根据用户经纬度，将商户按照距离用户的距离进行排序，实现附近商户功能。</li><li>每日签到：使用BitMap位图存储用户签到信息，将用户id和当前年月作为key，将签到日期作为offset，用户签到时将对应offset位置的bit设置为1，实现每日签到功能。<ul><li>以年月作为key，方便统计每月签到次数。</li></ul></li></ul></li></ol><h4 id="做项目有遇到什么问题吗"><a href="#做项目有遇到什么问题吗" class="headerlink" title="做项目有遇到什么问题吗"></a>做项目有遇到什么问题吗</h4><ol><li>在异步秒杀优化中，刚开始使用阻塞队列存储秒杀请求，但是发现存在问题：<ul><li>JVM内存限制问题 </li><li>数据安全问题，阻塞队列没有持久化机制，如果服务器宕机，数据会丢失。 </li><li>解决：使用Stream消息队列。Stream是Redis 5.0版本引入的新数据结构，是一个有序的消息队列，可以持久化消息，保证数据安全。通过Stream消息队列，将秒杀请求异步处理，提高了系统的并发能力和响应速度。XADD命令将秒杀请求写入Stream，XREAD命令读取Stream中的消息，异步处理秒杀请求。 </li><li>这里的异步指的是：将秒杀请求写入Stream消息队列，然后异步处理秒杀请求，不会阻塞主线程，提高系统的并发能力和响应速度。</li></ul></li><li>实现分布式锁时，刚开始使用SETNX命令实现分布式锁，但是发现存在一些问题：<ul><li>不可重入：同一个线程无法多次获取同一把锁。</li><li>不可重试：获取锁只尝试一次就返回false，没有重试机制。</li><li>超时释放：锁超时释放虽然可以避免死锁，但是如果业务执行时间过长也会导致锁的释放，存在安全隐患。</li><li>主从一致性：线程在主节点获取了锁，在未同步的情况下，主节点就宕机了，从节点没有这把锁，那么其他线程就可以获取到锁，这样就会多个线程获取到锁，而原线程获取到的锁也失效了。 </li><li>后面还是使用现成的更为成熟的Redisson了。</li></ul></li></ol><h4 id="秒杀业务如何实现的？"><a href="#秒杀业务如何实现的？" class="headerlink" title="秒杀业务如何实现的？"></a>秒杀业务如何实现的？</h4><p>当用户下单时，提交优惠券id，根据优惠券id查询优惠券信息，判断是否满足秒杀条件，比如秒杀是否开始，优惠券库存是否充足，用户是否秒杀过等。如果满足条件，生成订单，减少库存，返回订单信息。如果有一个条件不满足，则返回相应的错误信息。</p><ol><li>根据id查询优惠卷信息</li><li>秒杀是否开始</li><li>判断秒杀库存是否足够</li><li>校验是否是一人一单</li><li>扣减库存</li><li>创建订单</li></ol><h4 id="异步秒杀如何实现？"><a href="#异步秒杀如何实现？" class="headerlink" title="异步秒杀如何实现？"></a>异步秒杀如何实现？</h4><p>异步秒杀的核心是减库存和创建订单这种耗时多的分离出来，单独安排一个线程去执行，这样可以提高接口的响应速度。</p><ol><li>根据id查询优惠卷信息</li><li>秒杀是否开始</li><li>判断秒杀库存是否足够(Lua脚本)</li><li>校验是否是一人一单(Lua脚本)</li><li>扣减库存(Lua脚本)，并将当前用户id存入优惠券的set集合中</li><li>将优惠券id、用户id和订单id放入Stream消息队列中，将减库存和创建订单这种耗时多的分离出来，单独安排一个线程去执行，实现异步下单。</li><li>返回给用户订单id，表示秒杀成功</li></ol><h4 id="登录怎么实现的？"><a href="#登录怎么实现的？" class="headerlink" title="登录怎么实现的？"></a>登录怎么实现的？</h4><p>采用手机验证码登录</p><ol><li>用户输入手机号，点击获取验证码</li><li>服务端先校验手机号的格式是否正确，如果正确，生成验证码，并将验证码保存到redis(key为手机号，value为验证码)，然后将验证码发送给用户。</li><li>用户输入验证码后，点击登录</li><li>服务端校验手机号格式，如果正确，从redis中取出验证码进行校验，验证通过，则到数据库中根据手机号查询用户。如果用户不存在，则新建用户保存到数据库。</li><li>随机生成token作为登录令牌，并将用户对象转换为Hash结构，存入redis中(key为token，value为用户Hash)，并设置token有效期为半小时。</li><li>返回token给前端。</li><li>前端将token存放入<code>authorization</code>头部，以后每次请求都携带这个token，便于身份校验。</li></ol><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p><strong>原理</strong><br><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p><blockquote><p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p></blockquote><p><strong>ThreadLocal内存泄漏</strong><br><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><blockquote><p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p></blockquote><h4 id="旁路缓存模式如何解决缓存与数据库双写一致性问题？"><a href="#旁路缓存模式如何解决缓存与数据库双写一致性问题？" class="headerlink" title="旁路缓存模式如何解决缓存与数据库双写一致性问题？"></a>旁路缓存模式如何解决缓存与数据库双写一致性问题？</h4><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>旁路缓存模式是一种缓存写入策略，当有数据写入操作时，数据直接写入数据库，而不更新缓存。在后续的读取操作中，如果发生缓存未命中，则从数据库中读取数据并将其写入缓存，供后续读取操作使用。</p><p>读：</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回，然后把 db 中读取到的数据写入 cache 中。</li></ul><p>写：</p><ul><li>先更新 db</li><li>再删除 cache 中的数据</li></ul><p><strong>为什么不先删缓存再更新数据库呢？</strong><br>如果你先删除缓存，然后再更新数据库，可能在这两个操作之间出现一个短暂的时间窗口。如果在这个窗口中有其他请求进来，它们可能会读到旧的数据库数据，并将旧数据重新写入缓存，导致数据不一致。</p><p><strong>双写一致性问题</strong><br>双写一致性问题是指在同时更新缓存和数据库时，可能出现的数据不一致情况。</p><ul><li>写操作失败：在更新数据库后，更新缓存的操作可能失败，导致缓存和数据库的数据不一致。</li><li>并发问题：多个并发操作可能导致更新顺序混乱，造成数据不一致。</li><li>延迟更新：在采用异步方式更新缓存时，可能存在延迟，导致读取到旧数据。</li></ul><p>旁路缓存模式通过以下方式来解决双写一致性问题：</p><ul><li>消除双写操作：由于写操作只针对数据库，缓存不参与写入过程，避免了在写入阶段更新缓存的复杂性和潜在错误。</li><li>简化一致性维护：读取操作在缓存未命中时从数据库获取最新数据，并更新缓存，确保缓存中的数据始终与数据库一致。</li></ul><p>优点</p><ul><li>提高数据一致性：由于写操作只发生在数据库，减少了缓存与数据库数据不一致的情况。</li><li>降低缓存写入压力：减少了对缓存的写入操作，降低了缓存系统的负载。</li><li>实现简单：实现逻辑相对简单，易于维护和扩展。</li></ul><p>缺点</p><ul><li>首次读取性能较低：由于写操作不更新缓存，首次读取可能会出现缓存未命中，导致读取延迟增加。</li><li>适用于读多写少场景：在写操作频繁的场景下，可能会影响系统整体性能。</li><li>缓存命中率降低：因为只有在读取时才更新缓存，可能导致缓存命中率不高。</li></ul><h4 id="解决双写一致性问题的方法"><a href="#解决双写一致性问题的方法" class="headerlink" title="解决双写一致性问题的方法"></a>解决双写一致性问题的方法</h4><ol><li><p>延时双删策略<br>写操作步骤：</p><ul><li>更新数据库：首先将数据写入数据库。</li><li>删除缓存：更新完数据库后，立即删除缓存中的对应数据。</li><li>延时删除缓存：等待一段时间后，再次删除缓存，防止并发读写导致缓存脏数据。</li><li>解释：延时双删的核心思想是，第一次删除缓存后，如果有并发请求在这段时间内读到缓存中陈旧的数据(缓存没有及时过期)，则可以通过第二次删除来确保缓存与数据库的一致性。</li></ul></li><li><p>异步更新缓存策略<br>写操作步骤：</p><ul><li>更新数据库：首先将数据写入数据库。</li><li>发送消息更新缓存：数据库更新完成后，通过消息队列异步通知缓存更新。</li><li>解释：异步更新缓存策略通过消息队列保证数据库更新成功后，缓存会异步更新，避免强一致性问题，但可能会产生短时间的不一致。</li></ul></li><li><p>读写锁机制<br>写操作步骤：</p><ul><li>在更新数据库前，获取数据库相关记录的写锁。</li><li>更新数据库。</li><li>删除或更新缓存。</li><li>释放写锁。</li></ul><p>读操作步骤：</p><ul><li>在读取数据时，先获取读锁，保证读取时数据与缓存一致。</li><li>解释：通过读写锁控制数据库和缓存的并发操作，确保在写操作期间不会有读请求读取缓存中的陈旧数据，适用于高一致性要求的场景。</li></ul></li><li><p>先删除缓存再更新数据库<br>写操作步骤：</p><ul><li>删除缓存：在数据库更新之前，先删除缓存中的旧数据。</li><li>更新数据库：然后执行数据库更新操作。</li><li>解释：这种策略确保了缓存中不会再出现旧数据。数据库更新的原子性操作会避免数据库和缓存出现长时间的不一致。</li></ul></li><li><p>设置合理的缓存失效时间<br>设置缓存的失效时间(TTL)能够自动让缓存数据在一段时间后过期，从而避免缓存和数据库长时间不一致。结合上述策略，这种方法能够进一步减少不一致的窗口期。</p></li></ol><h4 id="三种常用缓存读写策略"><a href="#三种常用缓存读写策略" class="headerlink" title="三种常用缓存读写策略"></a>三种常用缓存读写策略</h4><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>旁路缓存模式是一种缓存写入策略，当有数据写入操作时，数据直接写入数据库，而不更新缓存。在后续的读取操作中，如果发生缓存未命中，则从数据库中读取数据并将其写入缓存，供后续读取操作使用。适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。<br>读：</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回，然后把 db 中读取到的数据写入 cache 中。</li></ul><p>写：</p><ul><li>先更新 db</li><li>再删除 cache 中的数据</li></ul><p>先更新数据库后再删除缓存，可以确保在数据库更新成功的前提下，缓存中的旧数据才会被清除，避免出现旧数据重新进入缓存的情况。<br><strong>为什么不先删缓存再更新数据库呢？</strong><br>如果你先删除缓存，然后再更新数据库，可能在这两个操作之间出现一个短暂的时间窗口。如果在这个窗口中有其他请求进来，它们可能会读到旧的数据库数据，并将旧数据重新写入缓存，导致数据不一致。</p><p>优点</p><ul><li>提高数据一致性：由于写操作只发生在数据库，减少了缓存与数据库数据不一致的情况。</li><li>降低缓存写入压力：减少了对缓存的写入操作，降低了缓存系统的负载。</li><li>实现简单：实现逻辑相对简单，易于维护和扩展。</li></ul><p>这种策略有一些缺陷：</p><ul><li>首次请求数据一定不在 <code>cache</code> 的问题<ul><li>解决办法：可以将热点数据可以提前放入 <code>cache</code> 中。</li></ul></li><li>写操作比较频繁的话导致 <code>cache</code> 中的数据会被频繁被删除，这样会影响缓存命中率 。<ul><li>解决办法：可以使用 <code>Write Through</code> 或者 <code>Write Behind</code> 策略。</li></ul></li></ul><p><strong>读写穿透</strong>(<code>Read/Write Through Pattern</code>)<br>服务端把 <code>cache</code> 视为主要数据存储，从中读取数据并将数据写入其中。<code>cache</code> 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p>读：</p><ul><li>从 <code>cache</code> 中读取数据，读取到就直接返回。</li><li>读取不到的话，先从 db 读取数据然后写入到 <code>cache</code> 中，再返回。</li></ul><p>写：</p><ul><li>先查 <code>cache</code>，<code>cache</code> 中不存在，直接更新 db。</li><li><code>cache</code> 中存在，则先更新 <code>cache</code>，然后 <code>cache</code> 服务自己更新 db(同步更新 <code>cache</code> 和 db)</li></ul><blockquote><p>该模式也有首次请求数据不一定在 <code>cache</code> 的问题，对于热点数据可以提前放入缓存中。</p></blockquote><p><strong>异步缓存写入</strong>(<code>Write Behind Pattern</code>)</p><p><code>Write Behind Pattern</code> 和 <code>Read/Write Through Pattern</code> 很相似，两者都是由 <code>cache</code> 服务来负责 <code>cache</code> 和 db 的读写。但是，两个又有很大的不同：<code>Read/Write Through</code> 是同步更新 cache 和 db，而 <code>Write Behind</code> 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 <code>cache</code> 数据可能还没异步更新 db 的话，<code>cache</code> 服务可能就就挂掉了。</p><blockquote><p>应用场景：消息队列中消息的异步写入磁盘、MySQL 的 <code>Innodb Buffer Pool </code>机制都用到了这种策略。</p></blockquote><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询一个不存在的数据，导致每次请求都落到数据库上。</p><p>缓存穿透是大量请求的 <code>key</code> 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>解决方案</strong></p><ol><li>做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。可以直接在前端做参数校验。</li><li>缓存无效 <code>key</code>。短暂地缓存无效<code>key</code>，并设置一个较短的过期时间，这样就可以防止缓存穿透。</li><li>布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 <code>hash</code> 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。</li><li>接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指某个热点数据在缓存失效的瞬间有大量请求访问。</p><p>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期)。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><strong>举例</strong><br>秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方案</strong></p><ol><li>永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。</li><li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。 互斥锁：使用SETNX命令 + 设置过期时间作为互斥锁来解决缓存击穿问题。确保了数据的一致性，但是性能会收到一定影响。</li><li>逻辑过期时间：在原有数据基础上添加一个过期时间字段。通过对比当前时间和逻辑过期时间，判断缓存是否过期。当缓存过期时，先使用过期的旧数据，然后再异步更新缓存。性能很好，但是数据一致性不能保证。</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在某一时刻大量缓存失效，导致数据库压力骤增。</p><p>缓存雪崩是缓存在同一时间大面积的失效或者是Redis宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><strong>举例</strong><br>数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方案</strong><br>针对大量缓存同时失效的情况：</p><ol><li>设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li><li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li><li>多级缓存(推荐)：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li><li>使用Redis集群(推荐)：使用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li></ol><p>针对 Redis 服务不可用的情况：</p><ol><li>Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li><li>多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li></ol><h4 id="缓存穿透-缓存击穿区别"><a href="#缓存穿透-缓存击穿区别" class="headerlink" title="缓存穿透&#x2F;缓存击穿区别"></a>缓存穿透&#x2F;缓存击穿区别</h4><ul><li>缓存穿透中，请求的 <code>key</code> 既不存在于缓存中，也不存在于数据库中。</li><li>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。</li></ul><h4 id="缓存击穿-缓存雪崩区别"><a href="#缓存击穿-缓存雪崩区别" class="headerlink" title="缓存击穿&#x2F;缓存雪崩区别"></a>缓存击穿&#x2F;缓存雪崩区别</h4><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。</p><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><ul><li><p>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p><ul><li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li><li>悲观锁可能会存在死锁问题。</li><li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li></ul></li><li><p>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。</p><ul><li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li><li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li><li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul><li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li></ul></li><li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li></ul></li><li><p>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</p></li><li><p>CAS：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。</p><ul><li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li></ul></li></ul><h3 id="外卖项目"><a href="#外卖项目" class="headerlink" title="外卖项目"></a>外卖项目</h3><blockquote><p>餐速达 - 美味速达<br>2024&#x2F;06 - 2024&#x2F;07<br>技术栈：SpringBoot、Mybatis-plus、Redis、MySQL、Vue、Nginx<br>项目介绍：基于SpringBoot实现的前后端分离外卖平台，项目分为商家端和用户端，商家端主要实现了对员工和菜品的CRUD，用户端实现下单和催单。<br>技术亮点：</p><ol><li>JWT实现身份验证，对密码进行MD5加密储存；自定义AOP切面拦截自定义注解，实现公共字段自动填充。</li><li>用Redis缓存高频访问菜品，缓解高并发下数据库压力；采用超时剔除+主动删除保证数据一致性。</li><li>使用Spring Task实现订单状态定时处理、超时自动取消订单；通过WebSocket实现来单提醒和用户催单。</li></ol></blockquote><ul><li>JWT实现身份验证，对密码进行MD5加密储存；<ul><li>JWT是一种用于身份验证的令牌，通过对用户信息生成JWT，然后将JWT存储在客户端，实现无状态的身份验证。对密码进行MD5加密储存，可以提高系统的安全性。</li><li>为什么要加密储存密码：直接存储用户密码存在严重的安全隐患，数据库泄露时会导致用户的密码暴露。因此，必须对密码进行加密处理后再存储，以提高系统的安全性。</li></ul></li><li>自定义AOP切面拦截自定义注解，实现公共字段自动填充。<ul><li>面向切面编程AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</li><li>通过自定义AutoFill注解以及AutoFillAspect切面，拦截添加了AutoFill注解的方法，填充公共字段如创建时间、更新时间等，提高代码的复用性和可维护性。</li></ul></li><li>用Redis缓存高频访问菜品，缓解高并发下数据库压力；采用超时剔除+主动删除保证数据一致性。<ul><li>超时剔除：设置缓存的过期时间，当缓存过期后，自动剔除缓存数据，避免缓存数据过期后仍然被访问。</li><li>主动删除：在数据发生变化时，主动删除缓存数据，保证缓存数据与数据库数据的一致性。</li></ul></li><li>使用Spring Task实现订单状态定时处理、超时自动取消订单；<ul><li>Spring Task是Spring框架提供的任务调度工具，可以实现定时任务、延时任务等功能。通过Spring Task实现订单状态定时处理，可以提高系统的可靠性和稳定性。</li><li>通过定时任务，每天凌晨一点检查订单状态，是否存在派送中的订单，如果有则取消，提高管理端用户体验和系统的效率。</li><li>通过每分钟检查一次是否存在超过15分钟仍未支付的订单，如果有则自动取消订单，避免订单积压和数据混乱。</li></ul></li><li>通过WebSocket实现来单提醒和用户催单。<ul><li>WebSocket是一种在单个TCP连接上进行全双工通信的协议，可以实现服务器主动向客户端推送消息和客户端向服务端主动发消息。通过WebSocket实现来单提醒和用户催单，提高用户体验和系统的实时性。</li></ul></li></ul><h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>自定义注解(Annotation)是 Java 中用于在代码中添加元数据的机制。通过自定义注解，我们可以为代码的特定部分添加附加信息，并通过反射机制在运行时访问这些信息。</p><ol><li><p>定义注解类：使用 <code>@interface</code> 关键字来定义注解。</p></li><li><p>注解的元注解：<code>@Target</code> 和 <code>@Retention</code> 是注解的元注解（Meta-Annotations），它们用于指定注解的适用范围和生命周期。</p><ul><li><code>@Target</code>：指定注解可以应用的程序元素，如方法、类、字段等。常见的值有：<ul><li><code>ElementType.METHOD</code>：表示注解可以应用于方法。</li><li><code>ElementType.FIELD</code>：表示注解可以应用于字段。</li><li><code>ElementType.TYPE</code>：表示注解可以应用于类、接口（包括注解类型）或枚举声明。</li></ul></li><li><code>@Retention</code>：指定注解的保留策略。常见的值有：<ul><li><code>RetentionPolicy.RUNTIME</code>：注解在运行时保留，可以通过反射读取。</li><li><code>RetentionPolicy.CLASS</code>：注解在编译期保留，但在运行时不会保留。</li><li><code>RetentionPolicy.SOURCE</code>：注解仅保留在源代码中，编译时会被丢弃。</li></ul></li></ul></li><li><p>定义注解的属性：通过定义方法来添加注解的属性，属性方法可以有默认值。</p></li></ol><p>用于标识某个方法执行的数据库操作类型，如 <code>UPDATE</code> 或 <code>INSERT</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperationType</span> &#123;</span><br><span class="line">    UPDATE,</span><br><span class="line">    INSERT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 该注解只能应用于方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解在运行时保留，可以通过反射读取它。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">// 定义一个名为 `value` 的属性，类型为 `OperationType`</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>：该注解只能应用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：注解在运行时保留，可以通过反射读取它。</li><li><code>OperationType value()</code>：这是注解的一个属性，返回类型为 <code>OperationType</code>。使用该注解时，必须提供一个 <code>OperationType</code> 的值。</li></ul><p>使用该注解的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoFill(OperationType.UPDATE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行更新操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoFill(OperationType.INSERT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>JWT(JSON Web Token)是一种用于在不同的系统之间安全地传递信息的机制。它的主要优势在于轻量级、跨平台，并且能够携带足够的用户信息，方便无状态的身份验证。以下是JWT的原理与流程。</p><p>JWT由三部分组成，依次为：</p><ol><li>Header(头部)：<ul><li>头部通常包含两部分信息：令牌类型(JWT)和签名算法(如HMAC SHA256)。</li><li>经过Base64Url编码后形成JWT的第一部分。</li></ul></li><li>Payload(载荷)：<ul><li>载荷部分包含了声明(claims)，即存储在令牌中的信息。常见的声明包括用户ID、用户名、令牌的过期时间(exp)等。</li><li>经过Base64Url编码后形成JWT的第二部分。</li></ul></li><li>Signature(签名)：<ul><li>签名部分是由头部、载荷以及一个密钥经过指定的算法(如HS256)生成的，用于验证消息的真实性和完整性。</li><li>签名使得服务器能够确认JWT未被篡改。</li></ul></li></ol><p>完整的JWT令牌由这三部分通过”.”连接构成，形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.payload.signature</span><br></pre></td></tr></table></figure><h4 id="JWT-的工作流程"><a href="#JWT-的工作流程" class="headerlink" title="JWT 的工作流程"></a>JWT 的工作流程</h4><ol><li>用户登录：用户通过输入用户名和密码向服务器发送登录请求。如果信息正确，服务器会根据用户信息生成一个JWT。</li><li>生成JWT：<ul><li>服务器根据用户信息生成JWT。头部指定签名算法，载荷包含用户相关信息(如用户ID、角色等)和过期时间。</li><li>服务器使用签名算法对头部和载荷进行签名，形成完整的JWT。</li><li>服务器将JWT返回给客户端。</li></ul></li><li>客户端保存JWT：<ul><li>客户端通常会将JWT存储在本地(如localStorage或cookie中)，以便在后续请求中使用。</li></ul></li><li>客户端请求受保护资源：<ul><li>客户端在访问受保护的资源时，将JWT放入请求头的<code>Authorization</code>字段中，一般格式为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>服务器验证JWT：<ul><li>服务器接收到请求后，会从请求头中获取JWT，并使用与生成时相同的密钥对JWT进行验证。</li><li>服务器解析JWT，验证其签名、过期时间等，确保令牌未被篡改且在有效期内。</li></ul></li><li>访问授权：<ul><li>如果JWT验证通过，服务器将根据JWT中的信息(如用户ID、角色等)进行权限验证，确定用户是否有权访问请求的资源。</li><li>若权限验证通过，服务器返回相应的资源；否则返回相应的错误信息。</li></ul></li></ol><p><strong>优点</strong>：</p><ul><li><strong>无状态性</strong>：JWT在客户端和服务器之间传递，不需要在服务器端保存会话信息，因此具有无状态性，适合分布式系统。</li><li><strong>安全性</strong>：通过签名验证，JWT可以确保数据未被篡改，且支持多种加密算法。</li><li><strong>携带信息</strong>：JWT可以在载荷中包含用户相关信息，减少数据库查询次数。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>体积较大</strong>：由于JWT携带了不少信息，在网络传输时会增加流量。</li><li><strong>安全性考量</strong>：如果不使用HTTPS加密，JWT容易在传输中被截获。使用弱加密算法(如简单的MD5)也会存在安全隐患。</li><li><strong>难以撤销</strong>：一旦JWT被生成并发出，除非到期或服务器端明确拒绝该令牌(例如改换密钥)，否则很难在中途撤销。</li></ul><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p><p>WebSocket 协议是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>WebSocket 的常见应用场景：视频弹幕、实时消息推送、实时游戏对战、多用户协同编辑、社交聊天等。</p><h4 id="WebSocket-HTTP区别"><a href="#WebSocket-HTTP区别" class="headerlink" title="WebSocket&#x2F;HTTP区别"></a>WebSocket&#x2F;HTTP区别</h4><ul><li>WebSocket 是全双工通信，HTTP 是单向通信。且 HTTP 协议只能由客户端发起，服务器只能响应请求。</li><li>WebSocket 是持久连接，HTTP 是短连接。HTTP 请求结束后，连接就会断开，而 WebSocket 连接会一直保持。</li><li>WebSocket 使用 <code>ws://</code> 或 <code>wss://</code>作为协议前缀，HTTP 使用 <code>http://</code> 或 <code>https://</code>作为协议前缀。</li><li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，而 HTTP 通信每次都要携带完整的头部，网络开销较大。</li><li>WebSocket 支持扩展，可以自定义协议，HTTP 不支持扩展。</li></ul><h4 id="WebSocket工作流程"><a href="#WebSocket工作流程" class="headerlink" title="WebSocket工作流程"></a>WebSocket工作流程</h4><ol><li>客户端向服务器发起一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code>等字段，表示要求升级协议为 WebSocket。</li><li>服务器收到请求后，会进行协议升级，如果支持 WebSocket 协议，将回复<code>HTTP 101</code>状态码，响应头中包含<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Accept:xxx</code>等字段，表示升级成功。</li><li>现在已经建立了 WebSocket 连接，可以进行双向的数据传输。连接建立之后，通过心跳机制保持连接的稳定性和活跃性。数据以帧(frames)的形式传输，WebSocket的发送端将每条消息被切分成多个帧发送，接收端将关联的帧重新组装成完整的消息。</li><li>关闭连接时，双方都可以发送一个关闭帧，表示关闭连接。另一方收到后，会回复一个关闭帧，然后关闭连接。</li></ol><h3 id="国家电网项目"><a href="#国家电网项目" class="headerlink" title="国家电网项目"></a>国家电网项目</h3><blockquote><p>国网经研院 - 电网数据智能诊断分析平台<br>2022&#x2F;08 - 2023&#x2F;02<br>技术栈：Flask、MongoDB、Umi、AntDesign<br>项目介绍：组内横向项目，实现平台页面设计、功能研发，对指标数据进行智能分析及预测，目前项目已部署于电网正式运行。<br>技术亮点：在项目中负责实现文件导入导出、数据存取与前端展示、CRUD等功能。</p><ol><li>完整的前后端分离架构。前端结合Umi和AntDesign，构建美观、友好且响应迅速的用户界面；后端采用Flask框架开发RESTful API，通过MongoEngine简化与MongoDB交互。</li><li>使用OpenPyXL处理Excel文件，将其以字典格式进行对象文档映射存储，确保数据处理的完整准确。</li></ol></blockquote><p><strong>简介</strong></p><p>这是我导师在国家电网南京经济研究院接的一个横向项目，江苏省国家电网智能诊断数据分析平台。具体来说，电网那边会给一些 Excel表格数据，数据是一些电网的指标，比如电压、电流、功率等等，还有一些指标计算公式。</p><p>我的主要工作如下：</p><ol><li>首先将这些 Excel表格数据导入到 mongodb 中，我考虑用 mongodb 存储的原因是，这些数据是一些指标，不需要关系型数据库的关联查询，而且 mongodb 的文档存储模型比较适合这种数据。且得知该系统部署在电网内网中，其实接口 QPS 不高，不需要关系型数据库的高并发处理能力，mongodb足够。而且单个 excel 使用一个文档存储，方便后续的查询。</li><li>将这些表格数据实时展示到前端页面上，并在前端实现数据的增删改查功能，这里用到了 react、Antd等技术。</li><li>实现将表格导出为 excel 表格。</li><li>对指标的智能诊断分析，是根据电网那边给出的公式，进行计算，然后展示到前端页面上。(这块不是我负责)</li></ol><p><strong>技术细节</strong><br>react、Antd、Flask、mongodb</p><p><strong>我的职责</strong><br>在项目中，负责实现各项重要指标的计算、以及对各指标进行灵活的增删改查，实现数据的存取以及前端展示等功能。</p><h4 id="为什么使用mongodb"><a href="#为什么使用mongodb" class="headerlink" title="为什么使用mongodb"></a>为什么使用mongodb</h4><ol><li>mongodb是一个非关系型数据库，采用文档存储模型，数据以BSON格式存储。项目中，需要导入或者导出 Excel 表格，一个 Excel文件正好可以对应mongodb中的一个文档，这样可以方便地将 Excel 中的数据导入到 mongodb 中。</li><li>电网那边给的Excel表格的数据量其实不大，每个表格数据量在几十~几万不等。</li></ol><h3 id="江南布衣实习"><a href="#江南布衣实习" class="headerlink" title="江南布衣实习"></a>江南布衣实习</h3><p>在公司实习期间，我担任网络工程师实习生，主要负责以下工作：</p><ol><li><p>新入职员工设备管理：负责<u>新入职员工的电脑设备接入公司内网，包括网络配置、安装必要软件以及配备相应办公区域的打印机驱动程序。</u>通过有效的网络设备管理，确保新员工能够快速融入公司工作环境，并顺利开始工作。</p></li><li><p>离职员工设备回收和资料销毁：<u>负责处理离职员工设备的回收工作，包括安全地清除设备上的敏感数据并销毁资料，保障公司数据安全和隐私保护。</u></p></li><li><p>订货会期间设备组装和网络连接：<u>在公司订货会期间，负责组装现场所需的大量电脑及相关打印设备，并确保它们在网络上正常连接，打印设备能够顺利工作。</u>通过良好的设备管理和网络连接调试，保证了订货会的顺利进行和信息传输的稳定性。</p></li><li><p>员工设备报修响应与问题解决：<u>及时响应员工设备报修请求，并通过重装系统、更换硬件设备等手段迅速解决问题</u>，确保员工工作不受影响，提高公司办公效率和网络设备的稳定性。</p></li></ol><p>通过这些工作，我积累了丰富的网络设备管理、故障排除和应急响应的经验，对计算机硬件、网络有了更深入的理解和实践。</p><blockquote><p><strong>公司内网</strong>：指的是一个局域网(LAN)，用于连接公司内部各种设备和资源，如电脑、打印机、服务器等，使它们可以相互通信和共享资源。公司内网通常由路由器、交换机等设备组成，通过内部网络连接。<br>要使一台电脑接入公司内网，经过以下步骤：</p><ol><li>网络配置：打开电脑的网络设置，配置IP地址、子网掩码、网关和DNS服务器等网络参数。这些参数通常由网络管理员提供或在公司内部网络设备中配置。</li><li>身份验证：根据公司的网络策略，需要先在管理员处创建账号密码，然后在需要接入的电脑上输入用户名和密码进行身份验证，以获得对公司内部资源的访问权限。</li><li>访问内部资源：一旦电脑成功接入公司内网，就可以通过内部网络访问共享文件夹、打印机、应用程序和其他资源。</li></ol></blockquote><h3 id="印象最深的一个项目"><a href="#印象最深的一个项目" class="headerlink" title="印象最深的一个项目"></a>印象最深的一个项目</h3><p>之前在社区做开源的时候，给社区写过一个异步的权限管理持久化适配器 <code>async-sqlalchemy-adapter</code>，这个项目是我印象最深的一个项目。这个项目是基于 Casbin 的一个持久化适配器，用于将 Casbin 的策略存储到数据库中。在这个项目中，我主要负责了整个项目的设计和开发，包括数据库表结构设计、持久化逻辑实现、单元测试等。这个项目的难点在于异步编程，因为 Casbin 是一个同步的库，而我需要将其适配成异步的，这就需要对异步编程有一定的了解。通过这个项目，我学到了很多关于异步编程的知识，也提升了自己的编码能力和解决问题的能力。</p><p><strong>亮点</strong></p><ol><li><strong>异步支持</strong>：<ul><li>亮点：代码中使用了 <code>AsyncSession</code> 和 <code>async with</code> 语法，使得数据库操作支持异步执行。这在处理大量并发请求时，能够显著提升性能和响应速度。</li><li>回答：这个适配器支持异步操作，可以在高并发场景下提高数据库访问的效率和响应速度，减少阻塞，提高系统的吞吐量。</li></ul></li><li><strong>灵活的过滤机制</strong>：<ul><li>亮点：通过 <code>Filter</code> 类和 <code>filter_query</code> 方法，可以根据多种条件灵活地筛选数据。这种设计使得策略规则的加载和过滤变得非常方便。</li><li>回答：适配器提供了灵活的过滤机制，允许根据多种条件动态筛选和加载策略规则，适应各种复杂的访问控制需求。</li></ul></li><li><strong>可扩展性</strong>：<ul><li>亮点：支持自定义 <code>db_class</code>，可以根据不同的需求定制存储策略。同时，默认的 <code>CasbinRule</code> 类提供了一个通用的实现。</li><li>回答：适配器设计时考虑了可扩展性，允许用户自定义数据库模型类，以适应不同的存储需求。这使得该适配器具有很强的适应性和可扩展性。</li></ul></li><li><strong>事务处理</strong>：<ul><li>亮点：使用了 <code>_session_scope</code> 作为上下文管理器，确保每次数据库操作都在事务中执行，保证数据的一致性和完整性。</li><li>回答：通过使用上下文管理器管理数据库会话，确保每次操作都在事务中执行，保证了数据的一致性和完整性。</li></ul></li></ol><p><strong>难点</strong></p><ol><li><strong>异步编程的复杂性</strong>：<ul><li>难点：异步编程相比同步编程更加复杂，需要处理更多的并发问题，如资源竞争、死锁等。此外，还需要确保每个异步操作都正确处理异常，以防止未捕获的异常导致程序崩溃。</li><li>回答：实现异步编程是一大难点，需要处理并发问题，并确保每个异步操作的异常处理得当，以保证系统的稳定性和可靠性。</li></ul></li><li><strong>数据库模型的灵活性与一致性</strong>：<ul><li>难点：适配器需要支持用户自定义的数据库模型类，这要求对模型的属性进行严格检查，确保其符合 Casbin 的策略存储要求。</li><li>回答：支持自定义数据库模型类是一个挑战，因为需要确保这些自定义模型类具有所有必要的属性，符合 Casbin 的策略存储要求。</li></ul></li><li><strong>复杂的策略更新逻辑</strong>：<ul><li>难点：如 <code>update_policy</code> 和 <code>update_policies</code> 方法，涉及到策略规则的更新，这需要精确定位旧规则并正确替换为新规则，逻辑复杂且容易出错。</li><li>回答：策略更新逻辑较为复杂，需要精确定位并替换旧的规则，确保更新操作的正确性和高效性。</li></ul></li><li><strong>高效的批量操作</strong>：<ul><li>难点：处理批量添加、删除和更新策略规则时，需要确保操作的高效性，同时避免数据库锁定和性能瓶颈。</li><li>回答：批量操作的实现需要确保高效性，并尽量避免数据库锁定和性能瓶颈，这在高并发环境下尤为重要。</li></ul></li></ol><p>测试方面</p><ul><li>适配器实现：编写了SQLAlchemy适配器，使得Casbin可以使用SQLAlchemy进行权限管理存储。</li><li>测试覆盖：编写了全面的测试用例，覆盖了适配器的所有主要功能，包括政策的添加、删除、更新和过滤。</li></ul><p>技术细节</p><ul><li>测试框架：说明使用了<code>unittest</code>库，并扩展了<code>IsolatedAsyncioTestCase</code>来测试异步功能。</li><li>测试用例设计：这个适配器需要在异步环境下持久管理 Casbin 策略，所以需要对策略的增删改查、保存、以及策略过滤查找等进行测试。测试用例保证了覆盖基本功能测试。<ul><li>测试添加一个策略，添加多个策略</li><li>测试删除一个策略，删除多个策略，删除经过过滤的策略</li><li>测试更新一个策略，测试更新多个策略。</li></ul></li></ul><p>通过强调这些亮点和难点，可以展示在该项目中的成就和技术深度，突出在异步编程、高性能数据库访问和复杂逻辑处理方面的经验和能力。</p><h3 id="学生生涯遇到的挫折和应对策略"><a href="#学生生涯遇到的挫折和应对策略" class="headerlink" title="学生生涯遇到的挫折和应对策略"></a>学生生涯遇到的挫折和应对策略</h3><p>高一升高二的时候，当时是从一个普通班进入全校最好的英才班嘛。然后第一次考试，我考了全班倒数第三，当时从普通班的前几名到倒数第三，可谓是很大的打击，我从小到大就没考过这么差的名次，当时很伤心沮丧吧，回家在房间偷偷哭。</p><p>但我也知道，哭是没有用的，我跟别人的差距是确实存在的，从那次后，我比别人更加努力，我花别人更多的时间去学习，去做题，去复习。不会的知识点也请教老师和同学，他们也都很乐意帮助我，我很感谢他们。争取把遇到的每个不会的知识点攻克，我也慢慢的感觉到自己的进步，从才开始的在英才班倒数，到中游 10-20名这样子，到最后高考的时候，考了英才班第四名。</p><p>我觉得吧，从这个经历中，我学到了很多，比如说遇到困难要找对方法才行，其次就是要有毅力，不要轻易放弃，最后就是要有信心，相信自己可以做到。</p><p>最让我有感触的是，让我学会了 任何时候，都要对自己有信心，不要怀疑自己的能力，相信自己可以做到。这点在我后面的大学学习、跨专业保研中起到了很重要的作用。</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java优势"><a href="#Java优势" class="headerlink" title="Java优势"></a>Java优势</h3><ul><li>跨平台性(Write Once, Run Anywhere, WORA)：Java的最大优势之一是它的跨平台性。Java程序可以在任何安装了JVM的平台上运行，无需修改源代码。这种特性极大地简化了应用程序的部署和维护过程。</li><li>面向对象编程(OOP)：Java是一种纯面向对象的语言，支持封装、继承和多态等面向对象的基本特性。这使得Java代码更加模块化、易于理解和维护。</li><li>丰富的库和框架：Java拥有庞大的生态系统，包括大量的库和框架，如Spring、Hibernate、Apache Commons等，这些库和框架极大地简化了开发过程，提高了开发效率。</li><li>强大的安全性：Java平台提供了多种安全机制，如自动垃圾回收、内存管理、访问控制等，这些机制有助于防止常见的编程错误和安全问题。此外，Java还提供了加密、解密、签名等安全功能。</li><li>高性能：尽管Java是一种解释型语言，但通过即时编译器(JIT)技术，Java程序可以获得接近甚至超过本地编译代码的性能。此外，JVM的不断优化也提高了Java程序的执行效率。</li><li>多线程支持：Java内置了对多线程的支持，使得开发并发程序变得简单。Java提供了丰富的线程同步机制，如synchronized关键字、锁等，以确保线程安全。</li><li>广泛的社区支持：Java拥有庞大的开发者社区，这意味着你可以轻松找到关于Java的教程、文档、问题和解决方案。此外，社区还不断推动Java的发展，使其保持与时俱进。</li><li>大型企业支持：许多大型企业都使用Java作为其主要的开发语言，如Google、Amazon、Oracle等。这些企业的支持使得Java在技术和市场上都得到了广泛的认可和应用。</li><li>良好的可扩展性和可维护性：由于Java的面向对象特性和丰富的库支持，Java程序通常具有良好的可扩展性和可维护性。这使得Java成为开发大型、复杂系统的理想选择。</li><li>广泛的应用领域：Java不仅限于Web开发，还广泛应用于企业级应用、移动应用开发、大数据处理(Hadoop)、云计算(如AWS、Azure等)等多个领域。这种广泛的应用领域使得Java成为了一种非常有用的编程语言。</li></ul><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但还是有很多不同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全，C++ 支持指针；</li><li>Java 的类是单继承的，C++ 支持多继承； Java 的接口可以多继承；</li><li>Java 有自动内存管理垃圾回收机制(GC)，而C++ 没有垃圾回收机制，程序员需要手动释放无用内存；</li><li>C++ 支持方法重载和操作符重载，Java 只支持方法重载(操作符重载增加了复杂性，与Java最初的设计思想不符)。</li></ul><blockquote><p>C 是面向过程的语言，C++ 既支持面向对象也支持面向过程，算是半面向对象语言，Java 是面向对象的语言。</p></blockquote><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p><code>&lt;&lt;</code>：左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。<br><code>&gt;&gt;</code>：带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0，负数高位补 1。<code>x &gt;&gt; 1</code> 相当于 x 除以 2。<br><code>&gt;&gt;&gt;</code>：无符号右移，忽略符号位，空位都以 0 补齐。</p><p>使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有 <code>int</code> 和 <code>long</code>，编译器在对 <code>short</code>、<code>byte</code>、<code>char</code> 类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><p>如果移位的位数超过数值所占有的位数会怎样？<br>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先 <strong>求余(%)</strong> 后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作(32%32&#x3D;0)，左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位(42%32&#x3D;10)。当 <code>long</code> 类型进行左移&#x2F;右移操作时，由于 <code>long</code> 对应的二进制是 64 位，因此求余操作的基数也变成了 64。也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x&gt;&gt;&gt;42</code>等同于<code>x&gt;&gt;&gt;10</code>。</p><h3 id="基本数据类型-包装类型-及区别"><a href="#基本数据类型-包装类型-及区别" class="headerlink" title="基本数据类型&#x2F;包装类型 及区别"></a>基本数据类型&#x2F;包装类型 及区别</h3><p><strong>8种基本数据类型</strong></p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code></li></ul><blockquote><p>注意：Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <code>L</code> ，否则将作为整型解析。<br><code>char a = &#39;h&#39;</code>，<code>char</code>： 单引号，<code>String a = &quot;hello&quot;</code>，<code>String</code>： 双引号。</p></blockquote><p><strong>8种包装类型</strong><br><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p><p><strong>区别</strong></p><ul><li>用途：基本类型用来定义常量和局部变量，包装类型可用于泛型，而基本类型不可以。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量(未被 <code>static</code> 修饰 )存放在 Java 虚拟机的堆中。包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li><li>占用空间：相比于包装类型(对象类型)， 基本数据类型占用的空间往往非常小。</li><li>默认值：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>比较方式：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h3 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><p>从字节码来看，装箱调用包装类的 <code>valueOf()</code> 方法，拆箱调用 <code>xxxValue()</code> 方法。</p><h3 id="如何解决浮点数运算的精度丢失问题"><a href="#如何解决浮点数运算的精度丢失问题" class="headerlink" title="如何解决浮点数运算的精度丢失问题"></a>如何解决浮点数运算的精度丢失问题</h3><p>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。<code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 来做的。</p><h3 id="局部变量-成员变量-静态变量"><a href="#局部变量-成员变量-静态变量" class="headerlink" title="局部变量&#x2F;成员变量&#x2F;静态变量"></a>局部变量&#x2F;成员变量&#x2F;静态变量</h3><ul><li>语法形式：成员变量可以被 <code>public</code>、<code>private</code>、<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li>存储方式：如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>生存时间：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值(一种情况例外：被 <code>final</code> 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</li></ul><p>静态变量是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，即使创建多个对象，静态变量只会被分配一次内存，这样可以节省内存。</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><ul><li>重载就是同名的方法能够根据输入数据的不同，做出不同的处理。重载发生在同一个类中(或者父类和子类之间)，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li><li>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ul></li></ul><h3 id="面向对象和面向过程区别"><a href="#面向对象和面向过程区别" class="headerlink" title="面向对象和面向过程区别"></a>面向对象和面向过程区别</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h3 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h3><p>共同点： 都不能被实例化<br><a href="https://learn.skyofit.com/archives/351">https://learn.skyofit.com/archives/351</a><br><strong>区别</strong></p><ul><li>子类使用<code>extends</code>关键字来继承抽象类，只能继承 1 个抽象类；子类使用关键字<code>implements</code>来实现接口，可以实现多个接口。</li><li>抽象类可以有构造方法，接口不能有构造方法。</li><li>抽象类允许有普通方法，接口中的方法默认是<code>public abstract</code>类型(JDK8后允许使用<code>default</code>、<code>static</code>定义非抽象方法)。</li><li>抽象类允许有成员变量，接口中只允许有常量(默认是<code>public static final</code>类型)。</li><li>抽象类中的抽象方法可以有访问修饰符(可以是<code>public</code>、<code>protected</code>、<code>private</code>)，接口中的抽象方法默认是<code>public</code>类型。</li><li>抽象类可以有 <code>main</code> 方法，接口中不能有 <code>main</code> 方法。</li></ul><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p><a href="https://blog.csdn.net/qq_44944221/article/details/126692973">https://blog.csdn.net/qq_44944221/article/details/126692973</a></p><ul><li>栈：是运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；</li><li>堆：是存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；</li></ul><p>区别：</p><ul><li>功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；</li><li>共享性不同：栈是线程私有，而堆是线程共享；</li><li>异常错误不同：当内存不足时；栈抛出的是<code>StackOverFlowError</code>异常，而堆抛出的是<code>OutOfMemoryError</code>；</li><li>空间大小不同：堆空间大小远远大于栈的内存空间。</li></ul><h3 id="深拷贝-浅拷贝-引用拷贝"><a href="#深拷贝-浅拷贝-引用拷贝" class="headerlink" title="深拷贝&#x2F;浅拷贝&#x2F;引用拷贝"></a>深拷贝&#x2F;浅拷贝&#x2F;引用拷贝</h3><ul><li>深拷贝：完全复制整个对象，包括这个对象所包含的内部对象。</li><li>浅拷贝：浅拷贝会在堆上创建一个新的对象(区别于引用拷贝的一点)，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>引用拷贝：引用拷贝是两个不同的引用指向同一个对象。这不就是拷贝了一份引用吗哈哈哈？</li></ul><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p>Object 类是一个特殊的类，是所有类的父类。主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于比较两个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，用于创建并返回当前对象的一份拷贝，默认是浅拷贝，深拷贝需要自己实现。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了 nanos 参数，这个参数表示额外时间(以纳秒为单位，范围是 0-999999)。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>饿汉式：饿汉式单例模式在类加载时就完成实例化，线程安全，简单但可能会造成资源浪费。</li><li>懒汉式：懒汉式单例模式在第一次调用 <code>getInstance</code> 方法时创建实例，线程不安全，需要额外处理同步。</li><li>线程安全的懒汉式<ul><li>同步方法：在 <code>getInstance</code> 方法上加 <code>synchronized</code> 关键字，保证线程安全，但是效率低。</li><li>双重检查锁定：在 <code>getInstance</code> 方法内部进行双重检查，保证只有第一次调用时才会加锁，提高效率。</li></ul></li><li>静态内部类：利用静态内部类来实现懒加载和线程安全。</li><li>枚举：枚举实现单例模式是最简洁、安全的实现方式，可以防止反射和序列化攻击。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全的懒汉式-双重检查锁定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式中用于保存实例的字段，被声明为volatile，确保对该变量的写入操作会立即反映到所有线程中，这样可以防止可能发生的指令重排序问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 私有的构造方法确保该类不能在外部被初始化，只能通过getUniqueInstance()方法获取实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定的机制，实现对外提供的获取单例实例的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一层检查：首先检查 uniqueInstance 是否为 null。如果不是 null，意味着实例已经被创建，则直接返回这个实例。</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁，表示进入同步代码前要获得 Singleton类 的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二层检查：在同步代码块内再次检查 uniqueInstance 是否为 null。</span></span><br><span class="line">                <span class="comment">// 这种双重检查是为了在等待锁的线程获取到锁后再次确认实例是否已经被创建，因为在等待锁的过程中可能有其他线程已经创建了实例。</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 注意 上面不是 class 是 enum</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singelton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        singleton.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参-实参"><a href="#形参-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h3><ul><li>形参(形式参数，Parameters)：用于定义函数&#x2F;方法，接收实参，不需要有确定的值。</li><li>实参(实际参数，Arguments)：用于传递给函数&#x2F;方法的参数，必须有确定的值。</li></ul><h3 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h3><ul><li>值传递：方法接收的是实参值的拷贝，会创建副本。</li><li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>Java 中只有值传递，C++ 中有值传递和引用传递。</p><h3 id="和equals-区别"><a href="#和equals-区别" class="headerlink" title="&#x3D;&#x3D;和equals()区别"></a>&#x3D;&#x3D;和equals()区别</h3><ul><li><code>==</code> 可以用来比较基本数据类型和引用数据类型<ul><li>基本数据类型：比较的是值是否相等</li><li>引用数据类型：比较的是引用地址是否相等</li><li>Java只有值传递，不管是基本数据类型还是引用数据类型，比较的都是值，只是引用类型变量存的值是对象的地址。</li></ul></li><li><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<ul><li>如果没有重写<code>equals()</code>方法， 子类调用<code>Object</code> 类中的<code>equals()</code>方法，等价于通过“&#x3D;&#x3D;”比较这两个对象，即比较的是两个对象的引用地址。</li><li>一般重写<code>equals()</code>方法来比较两个对象中的属性是否相等；若属性相等，则返回 <code>true</code>(即认为这两个对象相等)。</li></ul></li></ul><h3 id="hashCode-和equal"><a href="#hashCode-和equal" class="headerlink" title="hashCode()和equal()"></a>hashCode()和equal()</h3><p><code>hashCode()</code> 的作用是获取哈希码(<code>int</code> 整数)，也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code> 定义在 <code>Object</code> 类中，意味着 Java 中的任何类都有 <code>hashCode()</code>。注意：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。JDK 同时提供这两个方法，<code>hashCode()</code>方法可以大大减少<code>equals()</code>方法的调用次数，从而提高程序的性能。</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等(<strong>哈希碰撞</strong>)。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，可以直接认为这两个对象不相等。</li></ul><p><strong>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</strong><br>因为两个相等对象的 <code>hashCode</code> 值必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><h3 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String&#x2F;StringBuffer&#x2F;StringBuilder"></a>String&#x2F;StringBuffer&#x2F;StringBuilder</h3><ul><li><p><code>String</code> ：字符串常量，不可变，线程安全，适用于少量的字符串操作的情况。</p></li><li><p><code>StringBuffer</code> ：字符串变量(线程安全)，适用于多线程下大量字符串操作的情况。</p></li><li><p><code>StringBuilder</code> ：字符串变量(非线程安全)，适用于单线程下大量字符串操作的情况。</p></li><li><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。</p></li><li><p><code>StringBuffer</code> 改变时会对本身进行操作，而不是生成新的对象并改变对象引用。</p></li><li><p><code>StringBuilder</code> 仅比 <code>StringBuffer</code> 高 10%~15% 左右的性能，但却线程不安全。</p></li></ul><p><strong><code>String</code> 为什么不可变？</strong></p><ul><li><code>String</code>类内保存字符串的<code>char</code>数组被 <code>final</code> 修饰且为私有的，且 <code>String</code> 类没有提供修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ul><h3 id="字符串拼接使用-还是StringBuilder？"><a href="#字符串拼接使用-还是StringBuilder？" class="headerlink" title="字符串拼接使用+还是StringBuilder？"></a>字符串拼接使用+还是StringBuilder？</h3><p>Java中“+”和“+&#x3D;” 实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象。在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象。</p><h3 id="String-equals-Object-equals"><a href="#String-equals-Object-equals" class="headerlink" title="String.equals()&#x2F;Object.equals()"></a>String.equals()&#x2F;Object.equals()</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 <code>String</code> 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串(String 类)专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常的共同祖先是 <code>Throwable</code> 类，其有两个重要的子类：<br><code>Error</code>： 程序无法处理的错误，不建议通过 <code>catch</code> 捕获。一般由 JVM 抛出，线程终止执行。<br><code>Exception</code>： 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</p><h3 id="Checked-Unchecked异常"><a href="#Checked-Unchecked异常" class="headerlink" title="Checked&#x2F;Unchecked异常"></a>Checked&#x2F;Unchecked异常</h3><ul><li>受检查异常(<code>Checked Exception</code>)，在编译过程中，若受检查异常没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没法通过编译。<ul><li>除了 <code>RuntimeException</code> 及其子类以外，其他的 <code>Exception</code> 类及其子类都属于受检查异常。常见的受检查异常有：<code>ClassNotFoundException</code>、<code>FileNotFoundException</code>、<code>SQLException</code> 等。</li></ul></li><li>不受检查异常(<code>Unchecked Exception</code>)，在编译过程中，即使不处理也可以正常通过编译。<ul><li><code>RuntimeException</code> 及其子类属于不受检查异常。常见的不受检查异常有：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code> 等。</li></ul></li></ul><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p><code>try</code>：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。<br><code>catch</code>：用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code>：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p><blockquote><p>注意：不要在 <code>finally</code> 语句块中使用 <code>return</code> ! 当 <code>try</code> 语句和 <code>finally</code> 语句中都有 <code>return</code> 语句时，<code>try</code> 语句块中的 <code>return</code> 语句会被忽略。</p></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>使用泛型参数，可以增强代码的可读性以及稳定性。</li><li>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是框架的灵魂，主要是因为它赋予了在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p><ul><li>优点：可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li><li>缺点：在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查(泛型参数的安全检查发生在编译时)。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="有一个第三方jar包，包里面有个类，类里面有个私有方法，怎么调用这个方法？"><a href="#有一个第三方jar包，包里面有个类，类里面有个私有方法，怎么调用这个方法？" class="headerlink" title="有一个第三方jar包，包里面有个类，类里面有个私有方法，怎么调用这个方法？"></a>有一个第三方jar包，包里面有个类，类里面有个私有方法，怎么调用这个方法？</h3><p>在 Java 中，如果需要调用一个类中的私有方法，可以使用 Java 的反射机制。反射允许在运行时动态访问类的属性和方法，即便它们是私有的。下面是调用私有方法的步骤：</p><ol><li><strong>获取类的 <code>Class</code> 对象</strong>。</li><li><strong>获取私有方法的 <code>Method</code> 对象</strong>。</li><li><strong>将该方法设置为可访问</strong>。</li><li><strong>调用该方法</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectPrivateMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取目标类的Class对象</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.ThirdPartyClass&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 创建该类的实例(假设有无参构造方法)</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            <span class="comment">// 3. 获取私有方法，假设该私有方法叫做 &quot;privateMethod&quot;，并且有一个String参数</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 4. 设置私有方法为可访问</span></span><br><span class="line">            privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 5. 调用私有方法，传递一个参数，假设返回类型是String</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) privateMethod.invoke(instance, <span class="string">&quot;Hello, Reflection!&quot;</span>);</span><br><span class="line">            <span class="comment">// 6. 输出结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射虽然灵活，但通常会破坏封装性，应尽量避免在生产代码中频繁使用，除非在测试或调试中有特殊需求。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解使用了反射，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li>编译期直接扫描：编译器在编译代码的时候扫描对应的注解并处理，如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理：像框架中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h3 id="序列化-反序列化"><a href="#序列化-反序列化" class="headerlink" title="序列化&#x2F;反序列化"></a>序列化&#x2F;反序列化</h3><p>如果需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库(如 Redis)之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>语法糖(Syntactic sugar) 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><p>Java 中最常用的语法糖主要有<strong>switch语句</strong>、<strong>自动拆装箱</strong>、<strong>for-each循环</strong>、<strong>try-with-resources</strong> 语法、<strong>lambda 表达式</strong>等。</p><h3 id="Java设计模式"><a href="#Java设计模式" class="headerlink" title="Java设计模式"></a>Java设计模式</h3><p>Java 设计模式是一种在软件开发中常用的解决特定问题的通用方案。设计模式可以提高代码的可维护性、可重用性和可扩展性。根据目的和使用场景，设计模式通常分为三大类：</p><ul><li>创建型模式<ul><li>工厂模式：工厂模式定义了一个用于创建对象的接口，但由子类决定实例化哪个类。它使得类的实例化延迟到子类。</li><li>单例模式：单例模式确保一个类只有一个实例，并提供一个全局访问点。</li></ul></li><li>结构型模式<ul><li>适配器模式：适配器模式将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>装饰器模式：装饰者模式允许向一个现有的对象添加新的功能，同时又不改变其结构。</li></ul></li><li>行为型模式<ul><li>策略模式：策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化。</li><li>观察者模式：观察者模式定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</li></ul></li></ul><h3 id="JDK中用到哪些设计模式"><a href="#JDK中用到哪些设计模式" class="headerlink" title="JDK中用到哪些设计模式"></a>JDK中用到哪些设计模式</h3><ol><li><strong>单例模式(Singleton Pattern)</strong><ul><li><code>java.lang.Runtime#getRuntime()</code>：<code>Runtime</code>类确保只有一个实例存在，并提供了一个全局访问点。</li><li><code>java.awt.Desktop#getDesktop()</code>：<code>Desktop</code>类也是一个单例模式的实现。</li></ul></li><li><strong>工厂模式(Factory Pattern)</strong><ul><li><code>java.util.Calendar#getInstance()</code>：根据不同的参数，返回不同的<code>Calendar</code>子类实例。</li><li><code>java.sql.DriverManager#getConnection()</code>：根据提供的URL、用户名和密码返回不同类型的数据库连接。</li></ul></li><li><strong>抽象工厂模式(Abstract Factory Pattern)</strong><ul><li><code>javax.xml.parsers.DocumentBuilderFactory</code>：用于创建不同类型的XML解析器。</li><li><code>javax.xml.transform.TransformerFactory</code>：用于创建不同类型的XML转换器。</li></ul></li><li><strong>建造者模式(Builder Pattern)</strong><ul><li><code>java.lang.StringBuilder</code> 和 <code>java.lang.StringBuffer</code>：用于构建字符串。</li><li><code>java.nio.ByteBuffer</code>：用于构建字节缓冲区。</li></ul></li><li><strong>原型模式(Prototype Pattern)</strong><ul><li><code>java.lang.Object#clone()</code>：所有实现了<code>Cloneable</code>接口的类都可以使用<code>clone</code>方法来复制对象。</li></ul></li><li><strong>适配器模式(Adapter Pattern)</strong><ul><li><code>java.util.Arrays#asList()</code>：将数组转换为<code>List</code>。</li><li><code>java.io.InputStreamReader</code> 和 <code>java.io.OutputStreamWriter</code>：将字节流转换为字符流。</li></ul></li><li><strong>装饰器模式(Decorator Pattern)</strong><ul><li><code>java.io.BufferedInputStream</code> 和 <code>java.io.BufferedOutputStream</code>：为现有的输入&#x2F;输出流添加额外的功能。</li><li><code>java.util.Collections#synchronizedList()</code>、<code>#unmodifiableList()</code>：为现有的集合添加额外的行为。</li></ul></li><li><strong>观察者模式(Observer Pattern)</strong><ul><li><code>java.util.Observer</code> 和 <code>java.util.Observable</code>：用于实现观察者模式。</li><li><code>javax.swing.event.EventListenerList</code>：用于管理事件监听器。</li></ul></li><li><strong>策略模式(Strategy Pattern)</strong><ul><li><code>java.util.Comparator</code>：用于定义比较两个对象的策略。</li><li><code>javax.swing.text.Document#insertString()</code>：不同的插入策略。</li></ul></li><li><strong>责任链模式(Chain of Responsibility Pattern)</strong><ul><li><code>java.util.logging.Logger#log()</code>：通过不同的<code>Handler</code>处理日志记录请求。</li></ul></li><li><strong>状态模式(State Pattern)</strong><ul><li><code>javax.swing.JComponent#paint(Graphics)</code>：通过状态模式来管理组件的绘制状态。</li></ul></li><li><strong>模板方法模式(Template Method Pattern)</strong><ul><li><code>java.util.AbstractList</code>、<code>java.util.AbstractSet</code>：这些抽象类定义了集合的一些模板方法，具体的子类来实现具体的方法。</li></ul></li></ol><p>这些设计模式的使用，使得JDK在设计和实现上更加灵活、可扩展且易于维护。这些模式不仅仅是代码结构的规范，它们还体现了面向对象设计的基本原则，如单一职责原则、开闭原则和依赖倒置原则。</p><h3 id="内存溢出-内存泄露区别"><a href="#内存溢出-内存泄露区别" class="headerlink" title="内存溢出&#x2F;内存泄露区别"></a>内存溢出&#x2F;内存泄露区别</h3><ul><li>内存溢出(Memory Overflow)：内存溢出是指程序尝试使用超过其可用内存量的情况。这通常会导致程序崩溃或产生意外行为。内存溢出可以发生在堆栈或堆内存中。<ul><li>常见原因：<ul><li>递归太深：没有终止条件的递归函数调用会导致堆栈溢出。</li><li>内存分配过多：程序请求的内存超过了系统可用的物理内存或虚拟内存。</li></ul></li></ul></li><li>内存泄露(Memory Leak)：内存泄漏是指程序在运行过程中，动态分配了内存但未能正确释放，导致这些内存不可达并且不能再被使用。内存泄漏会导致程序占用的内存越来越多，最终可能导致系统内存耗尽。<ul><li>常见原因：<ul><li>未释放内存：程序分配了内存但没有调用适当的释放函数(如 <code>free</code>)。</li><li>指针丢失：丢失对已分配内存的引用，使得内存无法被释放。</li></ul></li></ul></li></ul><p><strong>区别</strong></p><ul><li>内存溢出是指程序尝试使用超过其可用内存量的情况，而内存泄漏是指程序动态分配的内存未被正确释放，导致内存逐渐耗尽。</li><li>二者成因不同。内存溢出：递归太深、内存分配过多等。内存泄漏：未释放内存、指针丢失等。</li><li>二者影响不同。内存溢出：立即导致程序崩溃或异常。内存泄漏：程序占用的内存越来越多，最终可能导致系统性能下降或内存耗尽而崩溃。</li></ul><h3 id="Java如何排查内存泄露"><a href="#Java如何排查内存泄露" class="headerlink" title="Java如何排查内存泄露"></a>Java如何排查内存泄露</h3><p>在 Java 中，内存泄漏通常是指无用的对象仍然被引用，导致垃圾回收器无法回收这些对象，从而导致内存不断增长，最终可能导致内存耗尽。排查内存泄漏通常涉及以下步骤：</p><ol><li>使用内存分析工具(如 JVM 工具)<ul><li>VisualVM：Java 自带的工具，可以查看应用的堆内存使用情况、线程活动和垃圾回收情况。</li><li>Eclipse Memory Analyzer (MAT)：强大的内存分析工具，用于分析 Java 堆转储，检测内存泄漏。</li><li>JConsole：监控 JVM 的堆内存使用情况，能够实时观察应用的内存变化。</li><li>YourKit：商业内存分析工具，功能强大，用户友好。</li></ul></li><li>生成和分析堆转储：堆转储文件包含应用运行时所有对象的状态信息，是内存泄漏排查的重要依据。生成堆转储的方式有：<ul><li>在 OOM(OutOfMemoryError)时自动生成转储文件。通过 JVM 参数 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 实现。</li><li>手动生成堆转储：可以使用 <code>jmap</code> 命令，如 <code>jmap -dump:live,format=b,file=heap_dump.hprof &lt;pid&gt;</code>。</li><li>通过内存分析工具(如 VisualVM)生成堆转储。生成堆转储后，使用工具如 MAT 或 VisualVM 进行分析，查找哪些对象占用了大量内存，检查是否存在对象的生命周期比预期的长。</li></ul></li><li>分析内存使用模式<ul><li>内存使用率监控：通过 JConsole 或 VisualVM 监控堆内存使用情况，特别关注内存是否在 GC 后没有显著下降。</li><li>GC 日志分析：开启 GC 日志(通过 JVM 参数 <code>-Xlog:gc*</code>)，分析内存回收情况，查看是否有过多的 Full GC 发生，或内存回收效果不佳。</li><li>内存占用趋势分析：在应用运行一段时间后，查看内存占用是否在稳定增长。如果应用的内存使用在没有相应负载增长的情况下持续增加，可能是内存泄漏的迹象。</li></ul></li><li>排查常见的内存泄漏模式：以下是一些常见的内存泄漏场景，排查时可以重点关注：<ul><li>静态集合类：如 <code>HashMap</code>、<code>List</code> 等存储了不再使用的对象，但未能及时清理。</li><li>未关闭的资源：未关闭的 <code>InputStream</code>、<code>OutputStream</code>、数据库连接、文件句柄等资源可能导致内存泄漏。</li><li>监听器和回调：未正确移除的事件监听器或回调函数可能导致对象无法被回收。</li><li>ThreadLocal：使用不当的 <code>ThreadLocal</code> 可能导致线程池中的线程持有大量对象，无法回收。</li></ul></li><li>代码分析：如果通过工具找到了特定的类或对象占用了过多内存，回头查看代码，检查是否有如下问题：<ul><li>对象的生命周期管理不当，导致被长期持有引用。</li><li>缓存(如 LRU Cache)没有及时清理。</li><li>使用 <code>WeakReference</code>、<code>SoftReference</code> 或 <code>PhantomReference</code> 来管理不确定生命周期的对象。</li></ul></li><li>基于工具的内存泄漏检测：有些工具可以直接帮助你分析和检测内存泄漏模式，例如：<ul><li>Eclipse MAT：可以帮助你生成泄漏报告，显示哪些对象可能导致了泄漏，哪些对象的引用链最深。</li><li>YourKit：具有内存泄漏检测功能，能够自动检测潜在的泄漏对象。</li></ul></li><li>模拟压力测试：在实际生产环境中，内存泄漏通常不会很快暴露。因此，可以通过模拟压力测试、长时间运行测试来发现内存泄漏。使用工具如 <code>Apache JMeter</code> 对应用施加压力，观察内存占用随时间的变化。</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>在Java中，<code>final</code>关键字用于定义常量或限制类、方法和变量的修改。</p><ol><li>常量：<code>final</code>可以用于定义常量。一旦为变量赋值后，<code>final</code>修饰的变量值不能再改变。例如：</li><li>类：如果一个类被声明为<code>final</code>，则它不能被继承。这意味着不能创建该类的子类。例如：</li><li>方法：如果一个方法被声明为<code>final</code>，则该方法不能在子类中被重写。这对于防止子类修改父类的行为非常有用。例如：</li><li>局部变量：如果局部变量(在方法内声明的变量)被声明为<code>final</code>，则在初始化后，它的值不能再被修改。例如：</li></ol><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List-Map-Set-Queue区别"><a href="#List-Map-Set-Queue区别" class="headerlink" title="List&#x2F;Map&#x2F;Set&#x2F;Queue区别"></a>List&#x2F;Map&#x2F;Set&#x2F;Queue区别</h3><ul><li>List： 存储的元素是有序的、可重复的。</li><li>Set： 存储的元素不可重复的。</li><li>Queue： 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map： 使用键值对(key-value)存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h3><p>主要根据集合的特点来选择合适的集合。如：</p><ul><li>需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>，不需要排序时就选择 <code>HashMap</code>，需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接口的集合的特点来选用。</li></ul><h3 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h3><p>在实际开发中，存储的数据类型多种多样且数量不确定。相较于数组，Java 集合提供了更灵活、更有效的方法来存储多个数据对象，其优势在于集合的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p><h3 id="List✅"><a href="#List✅" class="headerlink" title="List✅"></a>List✅</h3><h3 id="ArrayList和Array区别"><a href="#ArrayList和Array区别" class="headerlink" title="ArrayList和Array区别"></a>ArrayList和Array区别</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>(静态数组) 更加灵活：</p><ul><li><code>ArrayList</code>可动态扩容&#x2F;缩容，<code>Array</code> 创建后不能改变长度。</li><li><code>ArrayList</code> 可使用泛型确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存对象，存基本类型数据时要用对应包装类(如<code>Integer</code>)。<code>Array</code> 可直接存储基本类型数据，也可存储对象。</li><li><code>ArrayList</code> 提供增删改查等 API 操作方法，如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度数组，只能按照下标访问元素，无动态添加、删除元素能力。</li><li><code>ArrayList</code>创建时不需指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><blockquote><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。之后每次扩容容量变为原来的 1.5 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// Array</span></span><br><span class="line">ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// ArrayList</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="ArrayList可以一直扩容吗？"><a href="#ArrayList可以一直扩容吗？" class="headerlink" title="ArrayList可以一直扩容吗？"></a>ArrayList可以一直扩容吗？</h3><p>会，其会一直扩容，直至达到JVM内存限制。</p><ul><li><code>ArrayList</code>基于数组实现的，数组在内存中需要连续空间，即便有大量内存，也可能无法创建一个非常大的数组。</li></ul><h3 id="for循环里如何对ArrayList又删除又添加"><a href="#for循环里如何对ArrayList又删除又添加" class="headerlink" title="for循环里如何对ArrayList又删除又添加"></a>for循环里如何对ArrayList又删除又添加</h3><p>当在遍历 <code>ArrayList</code> 的同时进行添加或删除操作时，<code>ArrayList</code> 的大小会动态变化，导致迭代过程中出现意外的行为。如果直接使用 <code>for</code> 循环(基于索引的遍历)，一旦删除元素，<code>ArrayList</code> 的大小变化，迭代器或索引会失效。</p><p>解决：</p><ol><li>对于删除，可以使用迭代器 Iterator 的 <code>remove()</code> 方法在遍历过程中安全地删除元素。但 Iterator 只提供删除操作，不能直接添加元素。</li><li>对于添加，可以将待添加的元素存入临时列表，在循环结束后一次性添加到原列表中。</li><li>可以使用<code>CopyOnWriteArrayList</code>。</li></ol><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><ul><li><code>ArrayList</code> 底层基于<code>Object</code>数组实现的，<code>LinkedList</code> 是基于双向链表实现的(JDK1.6之前是循环链表，1.7改为双向链表)。<ul><li><code>ArrayList</code>插入和删除元素的时间复杂度受元素位置的影响。<code>add()</code>方法默认在尾部添加元素为O(1)，在指定位置插入元素或者删除元素时间复杂度为O(n)，因为需要移动元素。</li><li><code>LinkedList</code>插入和删除元素的时间复杂度为O(1)，因为只需要改变指针指向。如果要在指定位置插入或者删除元素，时间复杂度为O(n)，需要先移动到指定位置再插入和删除。</li></ul></li><li>二者都是线程不安全的。</li><li><code>ArrayList</code> 随机访问效率高(实现了<code>RandomAccess()</code>接口)，<code>LinkedList</code> 插入删除效率高。</li><li>占用空间：<code>ArrayList</code> 主要体现在在列表的结尾会留一定的容量空间，<code>LinkedList</code> 每个元素占用空间比前者大(要存放直接后继和直接前驱以及数据)。</li></ul><blockquote><p>项目中一般不会使用 <code>LinkedList</code>。</p></blockquote><h3 id="ArrayList和LinkedList插入-删除效率"><a href="#ArrayList和LinkedList插入-删除效率" class="headerlink" title="ArrayList和LinkedList插入&#x2F;删除效率"></a>ArrayList和LinkedList插入&#x2F;删除效率</h3><p><code>ArrayList</code></p><ul><li>头部插入&#x2F;删除：O(n)，需要移动元素。</li><li>指定位置插入&#x2F;删除：O(n)，需要移动元素。</li><li>尾部插入&#x2F;删除：O(1)，直接在尾部添加或删除元素。尾部插入时，当容量已到极限并需扩容时，需执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul><p><code>LinkedList</code></p><ul><li>头部插入&#x2F;删除：O(1)，只需改变指针指向。</li><li>尾部插入&#x2F;删除：O(1)，只需改变指针指向。</li><li>指定位置插入&#x2F;删除：O(n)，需要先移动到指定位置再插入和删除。</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是一种线程安全的集合类，适用于读操作远多于写操作的场景。它使用了一种叫做 <code>Copy-On-Write(COW)</code>的策略，即每次写操作(如添加、删除、更新元素)都会创建一个新的数组副本。这种策略在以下场景中非常有用：</p><ul><li>读多写少：大部分操作都是读取数据，写操作相对较少。</li><li>不要求实时性：因为写操作需要创建数组副本，可能会有短暂的延迟。</li></ul><p>其与<code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥(只有读读不互斥)。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的，写入操作也不会阻塞读取操作，只有写写才会互斥。</p><p><strong>优点</strong></p><ul><li>线程安全：所有读操作不需要加锁，因为读操作只是读取一个不可变的数组副本。</li><li>简化并发控制：不需要显式的同步块或锁定机制。</li><li>迭代器安全：迭代器不会抛出 <code>ConcurrentModificationException</code>，因为迭代时是基于快照的。</li></ul><p><strong>缺点</strong></p><ul><li>内存开销大：每次写操作都会创建数组副本，可能会占用较多的内存。</li><li>写操作开销大：由于需要复制整个数组，写操作的时间复杂度为 O(n)。</li><li>读取旧数据：在高并发场景下，可能会读取到旧的数据。</li></ul><p><strong>适用场景</strong></p><ul><li>配置类数据：如系统配置参数、常量集合等。</li><li>事件监听器列表：如监听器的添加和删除较少，事件触发较频繁。</li></ul><p><strong>不适用场景</strong></p><ul><li>高并发写操作：如果有大量的写操作，那么 <code>CopyOnWriteArrayList</code> 的性能会变差。</li><li>实时性要求高的场景：在需要读取最新数据的情况下，可能不适合使用。</li></ul><p><strong>结论</strong><br><code>CopyOnWriteArrayList</code> 适合用于读操作远多于写操作且不要求实时性数据更新的场景。对于高并发写操作或需要读取最新数据的场景，建议使用其他更合适的数据结构或并发容器，如 <code>ConcurrentHashMap</code> 或 <code>ConcurrentLinkedQueue</code>。</p><h3 id="跳表SkipList"><a href="#跳表SkipList" class="headerlink" title="跳表SkipList"></a>跳表SkipList</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&mid=2247495510&idx=1&sn=7a9f174b2a5facd92ee0efccf712eecc&chksm=fb427c76cc35f560d0ce02d6b7ff2f3e28c0349434734a428b20dfa2c3366d6266b15eacb588&scene=27">https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&amp;mid=2247495510&amp;idx=1&amp;sn=7a9f174b2a5facd92ee0efccf712eecc&amp;chksm=fb427c76cc35f560d0ce02d6b7ff2f3e28c0349434734a428b20dfa2c3366d6266b15eacb588&amp;scene=27</a><br><a href="https://javaguide.cn/database/redis/redis-skiplist.html#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2">https://javaguide.cn/database/redis/redis-skiplist.html#%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2</a><br>跳表是一种可以进行二分查找的有序链表，其在有序链表的的基础上添加了多级索引，将增删改查的时间复杂度变为O(logn)。跳表的节点跟一般的链表不同，有<code>val</code>、<code>next</code>、<code>down</code>三个属性，多级索引其实就是多级链表，最下层的链表包含所有元素，上一层元素是下一层的一半，第k层的元素是2^k个。假设跳表元素最大为65536个，则其最大层数为16。</p><p>特性：</p><ul><li>一个跳表有若干层链表组成；</li><li>每一层链表都是有序的；</li><li>跳表最下面一层的链表包含所有数据；</li><li>如果一个元素出现在某一次层，那么该层下面的所有层都必须包含该元素；</li><li>上一层的元素指向下层的元素必须是相同的；</li><li>头指针 head 指向最上面一层的第一个元素；</li></ul><p>CRUD：</p><ul><li>插入：每次插入新元素或者增添新索引的时候，进行一次随机运算，随机数值范围为 0-1 之间，如果随机值 &gt; 0.5，则为当前元素添加更高一级的索引，这样可以保证生成一级索引的概率为50%，二级索引的概率为25%…</li><li>删除：删除时必须定位到当前跳表各层元素小于 要删除元素 的最大值，然后右移(next)，看元素是否为要删除的元素，如果是的话删除，然后下沉(down)，执行同样操作。</li><li>查询：查询从最顶层索引开始，每层定位到当前跳表各层元素小于 要查询的元素的最大值，然后下沉，右移，继续比较。</li></ul><h3 id="Map-重要-✅"><a href="#Map-重要-✅" class="headerlink" title="Map(重要)✅"></a>Map(重要)✅</h3><h3 id="HashMap-HashTable区别"><a href="#HashMap-HashTable区别" class="headerlink" title="HashMap&#x2F;HashTable区别"></a>HashMap&#x2F;HashTable区别</h3><ul><li><code>HashMap</code> 是非线程安全的，<code>HashTable</code> 是线程安全的(内部方法经过<code>synchronized</code>修饰)。</li><li>JDK1.8以后 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树)，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li><li><code>HashTable</code>中有锁，所以效率比 <code>HashMap</code> 低。</li><li><code>HashMap</code> 可以有一个 <code>null</code> key和多个<code>null</code> value，而 <code>HashTable</code> 不允许有<code>null</code> key和<code>null</code> value，否则会报错<code>NullPointerException</code>。</li><li>初始容量大小和每次扩充容量大小的不同： <ul><li><code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。</li><li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，<code>Hashtable</code> 会直接使用给定的大小，而 <code>HashMap</code> 总是使用 2 的初始容量的幂作为哈希表的大小。</li></ul></li></ul><blockquote><p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p></blockquote><h3 id="HashMap底层✅"><a href="#HashMap底层✅" class="headerlink" title="HashMap底层✅"></a>HashMap底层✅</h3><p><strong>JDK1.8 之前</strong><br>底层是数组和链表。哈希冲突使用“拉链法”解决。</p><p><code>HashMap</code> 通过 <code>key</code> 的 <code>hashcode</code> 经过扰动函数<code>hash()</code>处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 <code>key</code> 是否相同，如果相同的话，直接覆盖，不相同就通过“拉链法”解决冲突。</p><ul><li>扰动函数 <code>hash()</code> 可以减少碰撞。</li><li>“拉链法”：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就放一个链表的头部。若遇到哈希冲突，则将冲突的值加到链表中。</li><li>“拉链法”中，数组的 index 就是key 的 <code>hashcode</code> 通过扰动函数<code>hash()</code>计算出来的 <code>hash</code> 值，数组中存放的是链表的头结点。而链表中的每个节点中存放的是键值对。</li></ul><p><strong>JDK1.8 之后</strong><br>底层还是数组和链表，当链表长度大于阈值(默认为8)时，调用 <code>treeifyBin()</code>方法，判断是否决定要将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会执行 <code>resize()</code> 方法数组扩容，而不是转换为红黑树)，以减少搜索时间。</p><ul><li>数组扩容后，原本在一个链表上的元素可能会分散到多个链表上，这样就会降低链表的长度，提高查询效率。</li><li>扩容步骤：创建一个长度是原来两倍的新数组，由于扩容前后key经过<code>hash()</code>计算出来的<code>hash</code>值不变，但数组长度 n 变化，将原数组中的元素通过 <code>(n - 1) &amp; hash</code>重新计算 index 放入新数组中。</li></ul><h4 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h4><ol><li>计算<code>key</code>的<code>hash</code>值。通过<code>key</code>的<code>hashCode()</code>方法返回的<code>hashcode</code>经过扰动函数<code>hash()</code>处理后得到<code>hash</code>值。</li><li>确定桶的位置。<code>HashMap</code>内部使用一个桶数组存储键值对。通过<code>hash</code>值与数组的长度n进行取模操作(<code>(n - 1) &amp; hash</code>)找到相应的数组索引。</li><li>检查该位置是否已有元素。如果当前位置为空(<code>table[(n - 1) &amp; hash] == null</code>)，则直接将键值对放入该位置。如果当前位置已经有元素，则需要处理哈希冲突。</li><li>处理哈希冲突。哈希冲突指的是不同的键经过哈希计算后，映射到了同一个数组位置。<ul><li>拉链法：当多个键的哈希值映射到同一位置时，这些键值对以链表的形式存储在同一个桶中。<code>put()</code> 方法会遍历该链表，检查是否已经存在相同的键(通过 <code>equals()</code> 方法比较<code>key</code>的相等性)。如果找到相同的键，则更新其对应的值。如果未找到，则会在链表的末尾添加一个新节点。</li><li>红黑树：当冲突过多，链表长度超过阈值(默认为 8)时，<code>HashMap</code> 会将链表转换为红黑树，以提高查找和插入的效率。红黑树可以在 <code>O(log n)</code> 时间内进行查找和插入。如果桶中的结构是红黑树，<code>put()</code> 方法会按照红黑树的插入规则将新的键值对插入。</li></ul></li><li>扩容检查：每次插入新的键值对时，都会检查负载因子(当前元素数与数组大小的比值)是否超过设定的阈值(默认0.75)，如果超过则会进行扩容操作，将数组的大小扩展为原来的两倍，并重新分配已有的元素到新的桶中。</li><li>若有扩容，则扩容后重新分配元素。此时，再走一下2 3 4流程。</li><li>返回旧值。如果键已存在且值被替换，<code>put()</code> 方法会返回旧值。如果是插入新的键值对，则返回 <code>null</code>。</li></ol><h4 id="HashMap为什么不支持高并发"><a href="#HashMap为什么不支持高并发" class="headerlink" title="HashMap为什么不支持高并发"></a>HashMap为什么不支持高并发</h4><h4 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h4><ul><li>JDK1.7及之前版本，存在多线程扩容死循环问题，如下：</li><li>JDK1.7 和 JDK 1.8 都存在数据丢失问题。如下：</li></ul><h4 id="HashMap多线程数据丢失问题"><a href="#HashMap多线程数据丢失问题" class="headerlink" title="HashMap多线程数据丢失问题"></a>HashMap多线程数据丢失问题</h4><p>在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶(bucket)，并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有数据覆盖的风险。</p><blockquote><p>例子：<br>线程 1，2 同时进行 <code>put</code> 操作，并且发生了哈希冲突(hash 函数计算出的插入下标是相同的)。<br>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。<br>随后，线程 1 获得时间片，由于之前已经进行过 <code>hash</code> 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></blockquote><h4 id="HashMap多线程扩容死循环问题"><a href="#HashMap多线程扩容死循环问题" class="headerlink" title="HashMap多线程扩容死循环问题"></a>HashMap多线程扩容死循环问题</h4><p>JDK1.7及之前版本的<code>HashMap</code>在多线程环境下扩容操作可能存在死循环问题。扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8 版本的<code> HashMap</code> 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p><blockquote><p>注意：不建议在多线程下使用 <code>HashMap</code>，会存在数据覆盖的问题，并发环境下，推荐使用<code>ConcurrentHashMap</code>。</p></blockquote><h4 id="HashMap扩容相关"><a href="#HashMap扩容相关" class="headerlink" title="HashMap扩容相关"></a>HashMap扩容相关</h4><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。 创建时即便给定了容量初始值，<code>HashMap</code> 也总是使用 2 的初始容量的幂作为哈希表的大小。</p><blockquote><p><code>HashTable</code> 已经被淘汰，不建议使用。<br><code>HashMap</code> <code>loadFactor</code> 负载因子默认为 0.75，即当 HashMap 中的元素个数超过容量的 75% 时，就会进行扩容操作。<code>threshold = capacity * loadFactor</code></p></blockquote><h4 id="HashMap长度为啥是2的幂次方"><a href="#HashMap长度为啥是2的幂次方" class="headerlink" title="HashMap长度为啥是2的幂次方"></a>HashMap长度为啥是2的幂次方</h4><p>key经过扰动函数<code>hash()</code>后得到 <code>hash</code> 值(取值范围是 [0, 2^32-1])，太大，用之前还要先做对数组的长度取余(%)运算，得到的余数对应的数组下标才是存放元素的位置。</p><p>“取余(%)操作中如果除数是 2 的幂次 则等价于 与其除数减一的与(&amp;)操作(也就是说 <code>hash % n == hash &amp; (n - 1)</code> 的前提是 n 是 2 的幂次)。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 <code>HashMap</code> 的长度为什么是 2 的幂次方。</p><h4 id="HashMap查询复杂度"><a href="#HashMap查询复杂度" class="headerlink" title="HashMap查询复杂度"></a>HashMap查询复杂度</h4><p><code>HashMap</code>的查询复杂度一般情况是 <code>O(1)</code>，在最坏情况下是 <code>O(logn)</code>或 <code>O(n)</code>。</p><ul><li>数组实现：<code>HashMap</code>由数组+链表或红黑树实现，数组查询复杂度<code>O(1)</code>。</li><li>处理哈希冲突：在理想情况下，不同的键会被映射到不同的索引位置上。若发生哈希冲突，HashMap 采用拉链法或者红黑树，所有映射到同一位置的键值对会被存储在一个链表或红黑树中。<ul><li>如果使用链表，查找复杂度最坏是O(n)，但链表较短，查询时间仍然是常数时间。</li><li>当链表长度超过阈值(默认8)，链表转为红黑树O(logn)。</li></ul></li></ul><p>影响<code>HashMap</code>的因素：</p><ul><li>哈希函数的质量：好的哈希函数会尽量将不同的键均匀地分布到哈希表的各个位置，从而减少冲突。但是坏的就会导致大量哈希冲突，使得链表数量加长，查询效率降低。</li><li>负载因子：<code>HashMap</code>通过负载因子来控制哈希表的扩容。负载因子越高，哈希表中的元素越多，冲突的概率就越大，从而可能降低查询效率。</li></ul><h3 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h3><p><a href="https://blog.csdn.net/cy973071263/article/details/122543826">https://blog.csdn.net/cy973071263/article/details/122543826</a><br>红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它可在 O(logN) 时间内完成查找、增加、删除等操作。红黑树的出现是为了应对二叉搜索树的极端情况(插入数据有序，则会退化成链表)。<br>特性：</p><ul><li>节点是红色或黑色</li><li>根是黑色</li><li>叶子节点(外部节点，空节点)都是黑色，这里的叶子节点指的是最底层的空节点(外部节点)，<code>null</code>节点才是叶子节点，<code>null</code>节点的父节点在红黑树里不将其看作叶子节点</li><li>红色节点的子节点都是黑色</li><li>红色节点的父节点都是黑色</li><li>从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点</li><li>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</li></ul><h3 id="ConcurrentHashMap-Hashtable区别"><a href="#ConcurrentHashMap-Hashtable区别" class="headerlink" title="ConcurrentHashMap&#x2F;Hashtable区别"></a>ConcurrentHashMap&#x2F;Hashtable区别</h3><ul><li>底层：JDK1.7的<code>ConcurrentHashMap</code>采用<strong>分段的数组+链表</strong> 实现，JDK1.8跟 <code>HashMap</code> 1.8结构一样，<strong>数组+链表&#x2F;红黑二叉树</strong>。<code>Hashtable</code> 是<strong>数组+链表</strong> 实现。</li><li>实现线程安全的方式：<ul><li>JDK1.7<code>ConcurrentHashMap</code> 对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组中每个元素都有一个锁，且每个元素包含一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code>中守护一个<code>HashEntry</code>，多个 <code>Segment</code> 组成一个 <code>ConcurrentHashMap</code>。当一个线程占用<code>Segment</code>锁访问其中的元素时，其他线程可以访问其他 <code>Segment</code>。</li><li>JDK1.8<code>ConcurrentHashMap</code> 摒弃 <code>Segment</code> 的概念，而是直接用 <strong><code>Node</code>数组+链表+红黑树</strong> 实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。(JDK1.6 以后 <code>synchronized</code> 锁做了很多优化) 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><code>Hashtable</code>(同一把锁) ：使用 <code>synchronized</code> 保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。</li></ul></li></ul><h3 id="ConcurrentHashMap底层✅"><a href="#ConcurrentHashMap底层✅" class="headerlink" title="ConcurrentHashMap底层✅"></a>ConcurrentHashMap底层✅</h3><p>JDK1.7<code>ConcurrentHashMap</code> 数据结构为<code>Segment</code>数组+<code>HashEntry</code>数组+链表。<code>ConcurrentHashMap</code>对整个桶数组进行分割分段(<code>Segment</code>，分段锁)，<code>Segment</code>数组每个元素存放一个<code>HashEntry</code>数组，其中每个<code>HashEntry</code>元素是一个链表，即一个<code>Segment</code> 守护一个 <code>HashEntry</code> 数组里的元素(<code>HashEntry</code>结构类似于<code>HashMap</code>)，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code> ，是可重入锁，<code>Segment</code> 的个数一旦初始化就不能改变，默认是 16，默认同时支持 16 个线程并发写。</p><p>JDK1.8<code>ConcurrentHashMap</code>取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code>1.8 的结构类似，<code>Node</code>数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值(8)时将链表(寻址时间复杂度为 O(N))转换为红黑树(寻址时间复杂度为 O(log(N)))。Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 <code>hash</code> 不冲突，就不会产生并发，就不会影响其他 <code>Node</code> 的读写，效率大幅提升。</p><h3 id="JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？"><a href="#JDK-1-7和1-8的ConcurrentHashMap实现有什么不同？" class="headerlink" title="JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？"></a>JDK 1.7和1.8的ConcurrentHashMap实现有什么不同？</h3><ul><li>线程安全实现方式：JDK 1.7采用 <code>Segment</code> 分段锁来保证安全，<code>Segment</code>继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li><li>Hash 碰撞解决方法 ： JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树(链表长度超过一定阈值时，将链表转换为红黑树)。</li><li>并发度：JDK 1.7最大并发度是 <code>Segment</code> 的个数，默认是 16。JDK 1.8 最大并发度是 <code>Node</code> 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap能保证复合操作的原子性吗？"><a href="#ConcurrentHashMap能保证复合操作的原子性吗？" class="headerlink" title="ConcurrentHashMap能保证复合操作的原子性吗？"></a>ConcurrentHashMap能保证复合操作的原子性吗？</h3><ul><li><code>ConcurrentHashMap</code>是线程安全的，可以保证多个线程同时对它进行读写操作，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。</li><li><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 <code>key</code> 和 <code>value</code> 来计算一个新的 <code>value</code>，并且将其更新到 <code>map</code> 中。</li></ul><h3 id="什么是LinkedHashMap"><a href="#什么是LinkedHashMap" class="headerlink" title="什么是LinkedHashMap"></a>什么是LinkedHashMap</h3><p>继承了 <code>HashMap</code> 的所有属性和方法，在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 <code>bucket</code> 上的节点、链表、红黑树有序关联起来。具备如下特性：</p><ul><li>支持遍历时会按照插入顺序有序进行迭代</li><li>支持按照元素访问顺序排序，_<strong>适用于封装 LRU 缓存工具</strong>_。</li><li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 <code>HashMap</code> 来说，迭代效率会高很多。</li></ul><blockquote><p><code>LinkedHashMap</code> 在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p></blockquote><h3 id="LinkedHashMap和HashMap的区别"><a href="#LinkedHashMap和HashMap的区别" class="headerlink" title="LinkedHashMap和HashMap的区别"></a>LinkedHashMap和HashMap的区别</h3><ul><li>最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。</li><li><code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 插入性能比 <code>HashMap</code> 略低，但提供了更多功能且迭代起来比<code>HashMap</code>更高效。</li></ul><h3 id="LinkedHashMap如何按照访问顺序迭代元素？"><a href="#LinkedHashMap如何按照访问顺序迭代元素？" class="headerlink" title="LinkedHashMap如何按照访问顺序迭代元素？"></a>LinkedHashMap如何按照访问顺序迭代元素？</h3><p><code>LinkedHashMap</code>通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 <code>true</code> 时，每访问一个元素，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p><h3 id="如何实现LRU缓存"><a href="#如何实现LRU缓存" class="headerlink" title="如何实现LRU缓存"></a>如何实现LRU缓存</h3><ul><li><code>accessOrder</code> &#x3D; <code>true</code> </li><li>继承<code>LinkedHashMap</code></li><li>重写 <code>removeEldestEntry</code> 方法。当链表大小超过容量时返回 <code>true</code>，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 <code>true</code> 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此实现 LRU 缓存。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity, <span class="number">1f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap-TreeMap区别"><a href="#HashMap-TreeMap区别" class="headerlink" title="HashMap&#x2F;TreeMap区别"></a>HashMap&#x2F;TreeMap区别</h3><ul><li><code>HashMap</code> 是基于哈希表实现的，<code>TreeMap</code> 是基于红黑树实现的。</li><li><code>HashMap</code> 是无序的，<code>TreeMap</code> 是有序的。</li><li><code>HashMap</code> 的键值对允许有一个 <code>null</code> key 和多个 <code>null</code> value，<code>TreeMap</code> 不允许有 <code>null</code> key，但允许有 <code>null</code> value。</li><li><code>HashMap</code> 的查询、插入、删除操作的时间复杂度是 O(1)，而 <code>TreeMap</code> 的时间复杂度是 O(logn)。</li></ul><p>相比于<code>HashMap</code>，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><h3 id="Set✅"><a href="#Set✅" class="headerlink" title="Set✅"></a>Set✅</h3><h3 id="HashSet-LinkedHashSet-TreeSet"><a href="#HashSet-LinkedHashSet-TreeSet" class="headerlink" title="HashSet&#x2F;LinkedHashSet&#x2F;TreeSet"></a>HashSet&#x2F;LinkedHashSet&#x2F;TreeSet</h3><ul><li>都是 <code>Set</code> 接口的实现类，都保证元素唯一，且都不是线程安全的。</li><li>主要区别在于底层数据结构不同。<ul><li><code>HashSet</code> 底层是哈希表(<code>HashMap</code>)。</li><li><code>LinkedHashSet</code> 底层是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li><li>底层数据结构不同导致三者应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>把对象加入<code>HashSet</code>时，先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，认为对象没有重复出现。但如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><p>在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在某元素，都会直接插入，只是会在<code>add()</code>方法的返回值处返回插入前是否存在相同元素。</p><h3 id="Queue✅"><a href="#Queue✅" class="headerlink" title="Queue✅"></a>Queue✅</h3><h3 id="Queue-Deque区别"><a href="#Queue-Deque区别" class="headerlink" title="Queue&#x2F;Deque区别"></a>Queue&#x2F;Deque区别</h3><ul><li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上遵循 先进先出(FIFO)规则。</li><li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，其还提供有 <code>push()</code>等方法，可用于模拟栈。</li></ul><h3 id="ArrayDeque-LinkedList区别"><a href="#ArrayDeque-LinkedList区别" class="headerlink" title="ArrayDeque&#x2F;LinkedList区别"></a>ArrayDeque&#x2F;LinkedList区别</h3><ul><li><code>ArrayDeque</code> 基于<strong>可变长数组</strong> 和<strong>双指针</strong> 来实现，而 <code>LinkedList</code> 通过链表来实现。</li><li><code>ArrayDeque</code> 不能存储 <code>NULL</code> 数据，<code>LinkedList</code> 能。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程，不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但每次插入数据时都要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 中元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li>默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><blockquote><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p></blockquote><h3 id="BlockingQueue及其实现类"><a href="#BlockingQueue及其实现类" class="headerlink" title="BlockingQueue及其实现类"></a>BlockingQueue及其实现类</h3><p><code>BlockingQueue</code>(阻塞队列)是一个接口，其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。常用于<strong>生产者-消费者模型</strong> 中，生产者线程向队列中添加数据，消费者线程从队列中取出数据进行处理。</p><p><strong>实现类</strong></p><ul><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>不同的是， 它仅支持非公平的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口且不能插入 <code>null</code> 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li><code>put()</code>、<code>take()</code>：插入和删除元素时，如果队列已满或者为空，会阻塞等待。</li><li><code>offer()</code>、<code>poll()</code>：插入和删除元素时，如果队列已满或者为空，不会阻塞，而是直接返回 <code>false</code> 或者 <code>null</code>。</li><li>并发控制采用可重入锁 <code>ReentrantLock</code> 保证线程安全，插入&#x2F;读取操作都需获取到锁才能进行，且支持公平&#x2F;非公平两种方式的锁访问机制，默认是非公平锁。</li></ul><h3 id="ArrayBlockingQueue实现原理"><a href="#ArrayBlockingQueue实现原理" class="headerlink" title="ArrayBlockingQueue实现原理"></a>ArrayBlockingQueue实现原理</h3><ul><li><code>ArrayBlockingQueue</code> 内部维护一个定长的数组用于存储元素。</li><li>通过使用 <code>ReentrantLock</code> 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。</li><li>通过 <code>Condition</code> 接口实现线程间的等待和唤醒操作。</li></ul><p>线程间的等待和唤醒具体的实现：</p><ul><li>当队列已满时，生产者线程会调用 <code>notFull.await()</code> 方法让生产者进行等待，等待队列非满时插入(非满条件)。</li><li>当队列为空时，消费者线程会调用 <code>notEmpty.await()</code>方法让消费者进行等待，等待队列非空时消费(非空条件)。</li><li>当有新的元素被添加时，生产者线程会调用 <code>notEmpty.signal()</code>方法唤醒正在等待消费的消费者线程。</li><li>当队列中有元素被取出时，消费者线程会调用 <code>notFull.signal()</code>方法唤醒正在等待插入元素的生产者线程。</li></ul><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>阻塞队列就是典型的生产者-消费者模型：</p><ul><li>当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。</li><li>当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。</li><li>当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。</li><li>当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。</li></ul><h3 id="ArrayBlockingQueue-LinkedBlockingQueue区别"><a href="#ArrayBlockingQueue-LinkedBlockingQueue区别" class="headerlink" title="ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别"></a>ArrayBlockingQueue&#x2F;LinkedBlockingQueue区别</h3><p>二者是Java并发中常用的两种阻塞队列实现，都是线程安全的。区别：</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离：<code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。因此，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul><h3 id="DelayQueue底层"><a href="#DelayQueue底层" class="headerlink" title="DelayQueue底层"></a>DelayQueue底层</h3><p>是线程安全的延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</p><p><strong>底层</strong><br><code>DelayQueue</code> 底层用 <code>PriorityQueue</code> 存储元素，<code>PriorityQueue</code> 采用<strong>二叉小顶堆</strong>的思想确保值小的元素排在最前面，使得 <code>DelayQueue</code> 对于延迟任务优先级的管理非常方便。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>，确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率还用到了 <code>Condition</code>接口，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁，实现线程安全的关键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//延迟队列底层存储数据的集合，确保元素按照到期时间升序排列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;E&gt;();</span><br><span class="line"><span class="comment">//指向准备执行优先级最高的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//实现多线程之间等待唤醒的交互</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p><code>leader</code>： 延迟队列的任务只有到期之后才会执行，对于没有到期的任务只有等待，为了确保优先级最高的任务到期后可以即刻被执行，用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。<br><code>available</code>： 等待唤醒操作的交互是通过 <code>available</code> 实现的，假如一个线程尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</p></blockquote><h3 id="DelayQueue是否线程安全？"><a href="#DelayQueue是否线程安全？" class="headerlink" title="DelayQueue是否线程安全？"></a>DelayQueue是否线程安全？</h3><p><code>DelayQueue</code>是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p><h3 id="DelayQueue使用场景"><a href="#DelayQueue使用场景" class="headerlink" title="DelayQueue使用场景"></a>DelayQueue使用场景</h3><p>通常用于实现定时任务调度和缓存过期删除等场景。</p><ul><li>在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。</li><li>缓存过期删除中，在数据被缓存到内存之后，可以将缓存的 <code>key</code> 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 <code>key</code>，将这个 <code>key</code> 从内存中移除。</li></ul><h3 id="DelayQueue中Delayed接口的作用是什么？"><a href="#DelayQueue中Delayed接口的作用是什么？" class="headerlink" title="DelayQueue中Delayed接口的作用是什么？"></a>DelayQueue中Delayed接口的作用是什么？</h3><p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法。<code>Delayed</code>接口定义了元素的剩余延迟时间(<code>getDelay()</code>)和元素之间的比较规则(继承 <code>Comparable</code> 接口)，否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p><h3 id="DelayQueue-Timer-TimerTask区别"><a href="#DelayQueue-Timer-TimerTask区别" class="headerlink" title="DelayQueue&#x2F;Timer&#x2F;TimerTask区别"></a>DelayQueue&#x2F;Timer&#x2F;TimerTask区别</h3><p>都可以用于实现定时任务调度，但实现方式不同。</p><ul><li><code>DelayQueue</code> 基于优先级队列和堆排序算法，可以实现多个任务按照时间先后顺序执行；</li><li><code>Timer/TimerTask</code> 基于单线程，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。</li><li><code>DelayQueue</code> 支持动态添加&#x2F;移除任务，<code>Timer/TimerTask</code> 只能在创建时指定任务。</li></ul><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p><h4 id="为什么需要Java内存模型"><a href="#为什么需要Java内存模型" class="headerlink" title="为什么需要Java内存模型"></a>为什么需要Java内存模型</h4><ul><li>Java是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</li><li>JMM是 Java 定义的并发编程相关的一组规范，主要目的是为了简化多线程编程，增强程序可移植性的。开发者可以利用这些规范更方便地开发多线程程序。</li><li>对于Java开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类(比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>)即可开发出并发安全的程序。</li></ul><h4 id="Java内存区域和Java内存模型有什么区别"><a href="#Java内存区域和Java内存模型有什么区别" class="headerlink" title="Java内存区域和Java内存模型有什么区别"></a>Java内存区域和Java内存模型有什么区别</h4><ul><li>Java 内存区域：是 Java 虚拟机管理的内存中的逻辑划分，包括堆、栈、方法区、本地方法栈、程序计数器等。</li><li>Java 内存模型：是 Java 虚拟机规范中定义的一套规范，用于规范 Java 程序中多线程并发访问共享变量的行为。</li></ul><h4 id="JMM是如何抽象线程和主内存之间的关系"><a href="#JMM是如何抽象线程和主内存之间的关系" class="headerlink" title="JMM是如何抽象线程和主内存之间的关系"></a>JMM是如何抽象线程和主内存之间的关系</h4><p>Java内存模型通过定义主内存和工作内存之间的关系，以及变量在两者之间的交互规则，确保了多线程环境下的内存可见性和一致性。JMM通过可见性、原子性和有序性等属性，以及<code>happens-before</code>规则，来保证多线程程序的正确性和可预测性。</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><ul><li>主内存：所有的变量(实例字段、静态字段和数组元素)都存储在主内存中，主内存是所有线程共享的内存区域。</li><li>工作内存：每个线程都有自己的工作内存，工作内存中存储了该线程从主内存中拷贝的变量副本。线程对变量的所有操作(读写等)都必须在工作内存中进行，不能直接操作主内存中的变量。</li></ul><p>####并发编程三大特性<br>可见性、原子性和有序性</p><ul><li>可见性(Visibility)：保证一个线程对变量的修改能够被其他线程及时看到。JMM通过内存屏障、<code>volatile</code>关键字、<code>synchronized</code>块等手段来实现可见性。</li><li>原子性(Atomicity)：确保操作的不可分割性，即某个操作一旦开始就不会被其他线程看到中间状态。基本的读写操作是原子性的，但更复杂的操作需要借助同步机制(如锁)来保证原子性。</li><li>有序性(Ordering)：保证程序执行的顺序符合一定规则，避免指令重排序带来的问题。JMM定义了一系列的<code>happens-before</code>规则，确保代码的执行顺序对多线程环境是可预测的。</li></ul><p>JMM通过上面三种属性来确保线程之间的内存一致性。</p><h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h4><p>在JMM中，<code>happens-before</code>规则是一套关键的规则，用于保证多线程环境下的内存可见性和操作的顺序性。这些规则定义了哪些操作对其他线程是可见的，以及它们之间的顺序关系。<code>happens-before</code>规则包括以下几个方面：</p><ul><li>程序顺序规则：在一个线程内，按照程序代码的顺序，前面的操作<code>happens-before</code>于后续的任何操作。这是最基本的规则，确保了单线程内操作的顺序性。</li><li><code>volatile</code>变量规则：对一个<code>volatile</code>变量的写操作<code>happens-before</code>于后续对这个<code>volatile</code>变量的读操作。这意味着，当一个线程修改了<code>volatile</code>变量的值，这个新值对于之后读取这个变量的其他线程是立即可见的。</li><li>传递性：如果操作A <code>happens-before</code> 操作B，操作B <code>happens-before</code> 操作C，那么可以推断出操作A <code>happens-before</code> 操作C。这个规则是逻辑上的传递性，用于组合其他规则以推导更复杂的<code>happens-before</code>关系。</li><li>锁定规则：对一个锁的解锁操作<code>happens-before</code>于后续对这个锁的加锁操作。这意味着，当一个线程释放了锁，其他线程才能获取该锁，从而访问被锁保护的资源，这保证了资源访问的顺序性和安全性。</li><li>线程启动规则：线程A调用线程B的<code>start()</code>方法，那么线程A的<code>start()</code>调用<code>happens-before</code>于线程B中的任意操作。这确保了线程B能够看到线程A在启动线程B之前对共享变量的修改。</li><li>线程终止规则：线程A等待线程B通过<code>join()</code>方法结束，那么线程B中的任意操作<code>happens-before</code>于线程A从<code>join()</code>方法调用返回。这确保了线程A能够看到线程B在其终止前对共享变量的所有修改。</li><li>线程中断规则(注意：这通常不是直接作为<code>happens-before</code>规则的一部分，但中断操作也涉及可见性和顺序性问题)：对线程<code>interrupt()</code>方法的调用<code>happens-before</code>于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成<code>happens-before</code>于它的<code>finalizer()</code>方法的开始。</li></ul><p>通过这些<code>happens-before</code>规则，Java内存模型确保了多线程程序中的内存可见性和操作的顺序性，从而提高了程序的正确性和可预测性。这些规则的实现通常依赖于底层的内存屏障(memory barrier)技术，来禁止编译器和处理器对操作的重排序，并确保操作的原子性和可见性。</p><h3 id="volatile关键字✅"><a href="#volatile关键字✅" class="headerlink" title="volatile关键字✅"></a>volatile关键字✅</h3><p><code>volatile</code> 关键字可以保证变量的可见性和防止指令重排序，如果将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><ol><li>可见性保证<ul><li>volatile关键字修饰的变量，任何一个线程对其进行修改后，都会立刻写回主内存。</li><li>其他线程在读取这个变量时，会直接从主内存中读取，而不是从线程的本地缓存中读取。因此，volatile变量的修改对所有线程都是可见的。</li></ul></li><li>禁止指令重排序<ul><li>在编译和运行时，JVM会对指令进行优化，其中可能包括重排序，即改变代码中指令的执行顺序，以提高效率。</li><li>使用volatile修饰的变量，编译器和处理器在读写该变量时会添加内存屏障(Memory Barrier)，防止指令重排序，从而确保对该变量的操作按程序中的顺序执行。</li></ul></li></ol><h4 id="如何禁止指令重排序"><a href="#如何禁止指令重排序" class="headerlink" title="如何禁止指令重排序"></a>如何禁止指令重排序</h4><p><code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><blockquote><p>注意，<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证，或者<code>Atomic</code>类</p></blockquote><h3 id="进程-线程-协程✅"><a href="#进程-线程-协程✅" class="headerlink" title="进程&#x2F;线程&#x2F;协程✅"></a>进程&#x2F;线程&#x2F;协程✅</h3><p><a href="https://blog.csdn.net/m0_60505735/article/details/131047046">https://blog.csdn.net/m0_60505735/article/details/131047046</a><br><a href="https://blog.csdn.net/weixin_49199646/article/details/109210547">https://blog.csdn.net/weixin_49199646/article/details/109210547</a></p><ul><li>进程： 进程是程序的一次执行过程，是系统资源分配和运行程序的基本单位；一个进程在其执行的过程中可以产生多个线程。</li><li>线程： 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li><li>协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li></ul><p><strong>进程与线程的区别</strong></p><ul><li>根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li>地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li>上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ul><p><strong>进程与线程的联系</strong><br>一个进程由共享空间(包括堆、代码区、数据区、进程空间和打开的文件描述符)和一个或多个线程组成，各个线程之间共享进程的内存空间。而一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成。</p><h4 id="进程与线程的选择"><a href="#进程与线程的选择" class="headerlink" title="进程与线程的选择"></a>进程与线程的选择</h4><ul><li>线程的创建或销毁的代价比进程小，需要频繁创建和销毁时应优先选用线程；</li><li>线程上下文切换的速度比进程快，需要大量计算时优先选用线程；</li><li>线程在CPU上的使用效率更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程</li><li>线程的安全性、稳定性没有进程好，需要更稳定安全时优先使用进程。</li></ul><p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，因此一般情况下优先选择线程进行高并发编程；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此对安全稳定性要求较高时，需要优先选择进程进行高并发编程。</p><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>进程间通信(Inter-Process Communication, IPC)是指在操作系统中不同进程之间传递数据或信息的机制。常见的进程间通信方式有多种，每种方式都有其独特的应用场景和优缺点。以下是一些主要的进程间通信方式：</p><ol><li>管道(Pipes)：<ul><li>匿名管道(Anonymous Pipes)：主要用于有亲缘关系的进程之间的通信，如父子进程。数据以字节流的形式在进程间传递。</li><li>命名管道(Named Pipes)：支持在无亲缘关系的进程之间进行通信。命名管道存在于文件系统中，可以被不同的进程打开和使用。</li></ul></li><li>消息队列(Message Queues)：<ul><li>允许进程通过发送和接收消息进行通信。消息队列提供了一种在进程间传递数据的有序方式，可以实现异步通信。</li></ul></li><li>共享内存(Shared Memory)：<ul><li>进程共享一段内存空间，进程可以直接读写这段共享内存中的数据。共享内存是最快的一种通信方式，因为数据不需要在进程间复制，但需要额外的同步机制来避免并发访问问题。</li></ul></li><li>信号量(Semaphores)：<ul><li>用于控制多个进程对共享资源的访问，通过信号量可以实现进程间的同步和互斥。</li></ul></li><li>信号(Signals)：<ul><li>信号是一种有限的异步通知机制，用于通知进程某个事件的发生。进程可以捕捉和处理信号，从而实现简单的通信和控制。</li></ul></li><li>套接字(Sockets)：<ul><li>套接字不仅支持同一台计算机上进程间的通信，也支持分布式网络中不同计算机上的进程间通信。常用于网络编程中。</li></ul></li><li>文件系统(File System)：<ul><li>进程可以通过读写共享的文件进行通信。这种方式简单但效率较低，适用于需要持久化存储的场景。</li></ul></li><li>内存映射文件(Memory-Mapped Files)：<ul><li>通过将文件映射到进程的地址空间，实现文件内容的共享和通信。与共享内存类似，但数据的持久化由文件系统提供。</li></ul></li></ol><h4 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h4><p>线程间的通信是指在同一个进程内，不同线程之间交换数据或信号的机制。常见的线程间通信方式包括以下几种：</p><ol><li>共享内存：<ul><li>全局变量：所有线程都可以访问和修改同一个全局变量。</li><li>静态变量：静态变量在进程的生命周期内只初始化一次，所有线程共享。</li></ul></li><li>互斥锁(Mutex)：<ul><li>用于防止多个线程同时访问共享资源，从而避免数据竞争。</li></ul></li><li>读写锁(RWLock)：<ul><li>允许多个线程同时读数据，但在写数据时需要独占锁，确保写操作的安全性。</li></ul></li><li>信号量(Semaphore)：<ul><li>主要用于限制对共享资源的访问数量，可以控制同时访问资源的线程数。</li></ul></li><li>条件变量(Condition Variable)：<ul><li>用于线程之间的等待通知机制，一个线程可以等待一个条件变量，而另一个线程可以通知该条件变量改变状态，从而唤醒等待的线程。</li></ul></li><li>事件(Event)：<ul><li>线程可以等待一个事件，直到另一个线程设置该事件，从而实现线程之间的同步。</li></ul></li><li>队列(Queue)：<ul><li>线程安全的队列，常用于生产者-消费者模型，一个线程放入数据，另一个线程取出数据。</li></ul></li><li>管道(Pipe)：<ul><li>用于线程之间的数据传输，常见于一些操作系统提供的进程间通信机制中。</li></ul></li><li>消息队列(Message Queue)：<ul><li>一种线程安全的队列，专门用于在多个线程之间传递消息。</li></ul></li><li>信号(Signal)：<ul><li>一种用于通知线程某个事件发生的机制，通常用在异步事件处理。</li></ul></li></ol><h4 id="为什么多个线程共享堆空间"><a href="#为什么多个线程共享堆空间" class="headerlink" title="为什么多个线程共享堆空间"></a>为什么多个线程共享堆空间</h4><p>堆内存的共享机制是 Java 内存模型(JMM)的一部分，旨在支持多线程编程。</p><ul><li>资源利用的高效性：共享堆内存使得内存资源的使用更高效。另外如在生产者-消费者模式中，生产者线程将对象放入共享的队列中，而消费者线程则从该队列中取出对象进行处理。这就需要堆内存是共享的，以便这些对象可以在不同线程间传递和使用。</li><li>堆是所有线程共享的，栈才是每个线程私有的。</li></ul><h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p><p>虚拟线程(<code>Virtual Thread</code>)是 JDK 而不是操作系统实现的轻量级线程(<code>Lightweight Process，LWP</code>)，由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>在没有虚拟线程之前，JVM使用的是<strong>平台线程</strong>，平台线程与内核线程的对应关系在 Windows 和 Linux 等主流操作系统中是一对一的(Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一)，这样会导致线程创建和销毁的开销较大，线程切换的开销也较大。</p><p>JVM 调度程序通过平台线程(载体线程)来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程(多个虚拟线程挂载在一个平台线程上)，当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p><strong>优点</strong></p><ul><li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li><li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱(Callback Hell)。</li><li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li></ul><p><strong>缺点</strong><br>不适用于计算密集型任务： 虚拟线程适用于 I&#x2F;O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。<br>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</p><h4 id="Java线程和操作系统线程有何区别"><a href="#Java线程和操作系统线程有何区别" class="headerlink" title="Java线程和操作系统线程有何区别"></a>Java线程和操作系统线程有何区别</h4><p>现在的 Java 线程的本质其实就是操作系统的线程。</p><ul><li>JDK1.2之前Java线程基于绿色线程(<code>Green Threads</code>)实现，即用户线程，由JVM自己实现线程调度，不依赖于操作系统的线程调度。</li><li>JDK 1.2 及以后，Java 线程改为基于原生线程(<code>Native Threads</code>)实现，也就是说 JVM 直接使用操作系统原生的内核级线程(内核线程)来实现 Java 线程，由操作系统内核进行线程的调度和管理。</li></ul><p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有三种： 一对一(一个用户线程对应一个内核线程)、 多对一、 多对多。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。</p><h4 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h4><ul><li>继承<code>Thread</code>类并重写<code>run()</code>方法</li><li>实现<code>Runnable</code>接口并重写<code>run()</code>方法</li><li>实现<code>Callable</code>接口并重写<code>call()</code>方法</li><li>使用线程池<code>ThreadPoolExecutor</code>创建线程</li><li>等等……</li></ul><p>其实只有一种方式可以创建线程，那就是通过 <code>new Thread().start()</code> 创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p>Java 线程 6 种状态：<br><code>NEW</code>： 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。<br><code>RUNNABLE</code>： 运行状态，线程被调用了 <code>start()</code>等待运行的状态。<br><code>BLOCKED</code>：阻塞状态，需要等待锁释放。<br><code>WAITING</code>：线程执行<code>wait()</code>方法等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)。<br><code>TIME_WAITING</code>：超时等待状态，调用<code>sleep(long millis)</code>可以在指定的时间后自行返回而不是像 <code>WAITING</code> 那样一直等待。<br><code>TERMINATED</code>：执行完<code>run()</code>方法进入终止状态，表示该线程已经运行完毕。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><h4 id="线程上下文切换开销"><a href="#线程上下文切换开销" class="headerlink" title="线程上下文切换开销"></a>线程上下文切换开销</h4><p>线程在执行过程中会有自己的运行条件和状态(也称<strong>上下文</strong>)，如程序计数器，栈信息等。 当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>、<code>wait()</code> 等。</li><li>时间片用完(操作系统防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死)。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h4 id="程序计数器为啥是私有的"><a href="#程序计数器为啥是私有的" class="headerlink" title="程序计数器为啥是私有的"></a>程序计数器为啥是私有的</h4><p>程序计数器主要有下面两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li><li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li></ul><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h3 id="虚拟机栈和本地方法栈为啥是私有的"><a href="#虚拟机栈和本地方法栈为啥是私有的" class="headerlink" title="虚拟机栈和本地方法栈为啥是私有的"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul><li>虚拟机栈： 每个 Java 方法在执行之前会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 <code>native</code> 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="Thread-sleep-方法和Object-wait-方法对比"><a href="#Thread-sleep-方法和Object-wait-方法对比" class="headerlink" title="Thread.sleep()方法和Object.wait()方法对比"></a>Thread.sleep()方法和Object.wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。<br>区别：</p><ul><li><code>sleep()</code> 方法没有释放锁，<code>wait()</code> 方法释放锁。</li><li><code>sleep()</code>通常被用于暂停执行，<code>wait()</code> 通常被用于线程间交互&#x2F;通信。</li><li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒(或者也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒)。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><h3 id="为什么wait-方法不定义在Thread中"><a href="#为什么wait-方法不定义在Thread中" class="headerlink" title="为什么wait()方法不定义在Thread中"></a>为什么wait()方法不定义在Thread中</h3><ul><li>锁是对象级别的，每个对象都有一把锁。</li><li><code>wait()</code> 方法是对对象的监视器(锁)进行操作，释放的是对象的锁，而不是线程的锁。</li></ul><h3 id="为什么sleep-方法定义在Thread中"><a href="#为什么sleep-方法定义在Thread中" class="headerlink" title="为什么sleep()方法定义在Thread中"></a>为什么sleep()方法定义在Thread中</h3><ul><li><code>sleep()</code> 是线程控制方法，作用对象是线程本身。</li><li>线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li></ul><h3 id="sleep-如何控制当前线程沉睡"><a href="#sleep-如何控制当前线程沉睡" class="headerlink" title="sleep()如何控制当前线程沉睡"></a>sleep()如何控制当前线程沉睡</h3><p>调用 <code>Thread.sleep()</code> 会作用于调用它的线程(当前线程)。它并不需要知道是哪一个线程调用的，因为它暂停的是当前线程。</p><h3 id="能直接调用Thread类的run方法吗"><a href="#能直接调用Thread类的run方法吗" class="headerlink" title="能直接调用Thread类的run方法吗"></a>能直接调用Thread类的run方法吗</h3><p>可以但不建议。<code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p><h3 id="并发-并行区别"><a href="#并发-并行区别" class="headerlink" title="并发&#x2F;并行区别"></a>并发&#x2F;并行区别</h3><ul><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h3 id="同步-异步区别"><a href="#同步-异步区别" class="headerlink" title="同步&#x2F;异步区别"></a>同步&#x2F;异步区别</h3><ul><li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="如何理解线程安全和不安全"><a href="#如何理解线程安全和不安全" class="headerlink" title="如何理解线程安全和不安全"></a>如何理解线程安全和不安全</h4><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其<strong>正确性</strong> 和<strong>一致性</strong> 的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h4 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h4><ul><li>线程切换和调度的成本远远小于进程。</li><li>单核时代：在单核时代多线程主要是提高单进程利用 CPU 和 IO 系统的效率。  当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。</li><li>多核时代：多核时代多线程主要是提高进程利用多核 CPU 的能力。  创建多个线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高。</li><li>并发编程是当代互联网发展趋势(现代系统并发量是百万级甚至千万级)。</li></ul><h4 id="使用多线程风险"><a href="#使用多线程风险" class="headerlink" title="使用多线程风险"></a>使用多线程风险</h4><ul><li>线程安全问题：多个线程访问共享资源时，可能会出现数据不一致的情况。</li><li>死锁：多个线程相互等待对方释放资源，导致所有线程都无法继续执行。</li><li>内存泄漏：线程未正确释放资源，导致内存泄漏。</li><li>上下文切换：线程频繁切换，会增加系统开销。</li><li>…</li></ul><h4 id="Java如何保证线程安全"><a href="#Java如何保证线程安全" class="headerlink" title="Java如何保证线程安全"></a>Java如何保证线程安全</h4><ol><li>同步代码块和方法：通过<code>synchronized</code>关键字来实现同步代码块和方法，只有一个线程可以在任意时刻进入同步代码块或方法，避免多个线程同时访问共享资源而导致数据不一致的问题。</li><li>显式锁：<code>java.util.concurrent.locks</code> 包中的显式锁(如 <code>ReentrantLock</code>)，这些锁提供了比 <code>synchronized</code> 更加灵活的锁定机制。</li><li>原子变量类：<code>java.util.concurrent.atomic</code> 包中的原子变量类(如 <code>AtomicInteger</code>、<code>AtomicLong</code>)，这些类提供了一些原子操作，支持无锁的线程安全操作。可以避免多线程访问共享资源时的数据不一致问题。</li><li>并发集合： 如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等，这些集合类内部实现了线程安全的操作。</li><li><code>volatile</code> 关键字用于声明一个变量在多个线程中是可见的，即当一个线程修改了该变量的值，其他线程立即可以看到修改后的值。</li><li>并发工具类：<code>java.util.concurrent</code> 包提供了许多用于线程安全的工具类，如 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>、<code>Exchanger</code> 等。这些工具类可以帮助管理和协调多个线程之间的交互。</li></ol><h4 id="多线程实现方式"><a href="#多线程实现方式" class="headerlink" title="多线程实现方式"></a>多线程实现方式</h4><ol><li><p>继承 <code>Thread</code> 类<br>通过继承 <code>Thread</code> 类，并重写 <code>run</code> 方法来实现多线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 <code>Runnable</code> 接口<br>通过实现 <code>Runnable</code> 接口，并将其实例传递给 <code>Thread</code> 对象来实现多线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Callable</code> 和 <code>Future</code><br><code>Callable</code> 接口和 <code>Future</code> 接口可以在任务完成时返回结果或抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>ExecutorService</code><br>通过 <code>ExecutorService</code> 管理线程池，执行多线程任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>ThreadPoolExecutor</code> 创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing: &quot;</span> + name + <span class="string">&quot; by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟任务执行时间</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Completed: &quot;</span> + name + <span class="string">&quot; by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建ThreadPoolExecutor</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 提交任务给线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;Task-&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;Submitting: &quot;</span> + task.name);</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待所有任务完成</span></span><br><span class="line">            <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                executor.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><h4 id="高并发存在什么问题-Java如何解决"><a href="#高并发存在什么问题-Java如何解决" class="headerlink" title="高并发存在什么问题&amp;Java如何解决"></a>高并发存在什么问题&amp;Java如何解决</h4><p><strong>高并发问题</strong></p><ul><li>资源竞争：多个线程竞争同一资源(如内存、文件、数据库连接等)，可能导致数据不一致、死锁等问题。</li><li>死锁：多个线程在等待对方释放资源，从而相互阻塞，导致程序无法继续执行。</li><li>上下文切换开销：线程之间的切换会消耗系统资源，频繁的上下文切换会降低系统性能。</li><li>线程安全：确保多个线程对共享资源的操作不会导致数据不一致的问题。</li><li>内存泄漏：大量创建和销毁线程，如果不合理管理，会导致内存泄漏。</li><li>饥饿和公平性：某些线程可能长期得不到资源，导致饥饿问题。如何确保线程公平地获取资源也是一个挑战。</li><li>负载均衡：在分布式系统中，如何将请求均衡地分配到不同的服务器，以避免某些服务器过载。</li></ul><p><strong>Java解决高并发问题</strong></p><ul><li>线程池(Thread Pool)：通过线程池管理线程的创建和销毁，减少资源消耗，提高系统性能。</li><li>同步机制(Synchronization)：使用 <code>synchronized</code>关键字或显示锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争。</li><li>并发工具类：如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，这些工具类可以帮助开发者更方便地实现线程间的协调和资源共享。</li><li>无锁算法(Lock-Free Algorithms)：使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换开销，提高性能。</li><li>CAS操作(Compare-And-Swap)：CAS是一种无锁算法，通过比较和交换操作来实现原子性。Java中的<code>Unsafe</code>类和<code>Atomic</code>包使用了CAS操作来实现无锁算法。</li><li>Fork&#x2F;Join框架：用于任务拆分和并行处理，适用于大规模数据并行处理。Java 7引入了<code>ForkJoinPool</code>来支持这一框架。</li><li>异步编程(Asynchronous Programming)：通过<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</li></ul><h4 id="Java如何实现高并发"><a href="#Java如何实现高并发" class="headerlink" title="Java如何实现高并发"></a>Java如何实现高并发</h4><p><strong>使用线程池</strong><br>线程池可以有效管理线程的创建和销毁，减少资源消耗和上下文切换开销。Java中的<code>ExecutorService</code>和<code>Executors</code>类提供了便捷的线程池实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><p><strong>同步机制</strong><br>使用<code>synchronized</code>关键字或者显式锁(如<code>ReentrantLock</code>)来确保线程安全，避免资源竞争和数据不一致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">safeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 线程安全代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 线程安全代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>并发集合类</strong><br>Java提供了线程安全的并发集合类，如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code>等，这些集合类可以简化多线程编程。</p><p><strong>原子变量类</strong><br>使用原子变量类(如<code>AtomicInteger</code>、<code>AtomicLong</code>)来实现无锁并发，减少上下文切换，提高性能。</p><p><strong>CAS操作</strong><br>Java的<code>Atomic</code>包和<code>Unsafe</code>类使用了CAS(Compare-And-Swap)操作来实现无锁算法，从而提高并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> count.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>异步编程</strong><br>使用<code>CompletableFuture</code>和异步方法调用，实现非阻塞的并发编程模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Async task</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result -&gt; &#123;</span><br><span class="line">    <span class="comment">// Process result</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用非阻塞I&#x2F;O</strong><br>在网络编程中，使用NIO(Non-blocking I&#x2F;O)实现高并发。NIO提供了选择器(<code>Selector</code>)、通道(<code>Channel</code>)和缓冲区(<code>Buffer</code>)等工具，可以实现高效的非阻塞I&#x2F;O操作。<br><strong>Fork&#x2F;Join框架</strong><br><code>ForkJoinPool</code>用于任务拆分和并行处理，适用于大规模数据的并行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">pool.invoke(<span class="keyword">new</span> <span class="title class_">RecursiveTask</span>&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Void <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Task implementation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用第三方并发框架</strong><br>如<code>Akka</code>、<code>RxJava</code>、<code>Vert.x</code>等，它们提供了更加高级的并发和反应式编程模型。</p><h4 id="针对转账高并发，在系统层面如何优化？"><a href="#针对转账高并发，在系统层面如何优化？" class="headerlink" title="针对转账高并发，在系统层面如何优化？"></a>针对转账高并发，在系统层面如何优化？</h4><p>在处理转账的高并发情况时，系统层面的优化涉及多个方面，包括架构设计、数据库优化、缓存使用、分布式事务处理等。以下是具体的优化策略：</p><ol><li>架构设计<ul><li>水平扩展(Scaling Out)：<ul><li>集群化：将服务部署到多个服务器上，使用负载均衡器(如Nginx、HAProxy)分发请求，以应对大量并发请求。</li><li>微服务架构：将系统拆分为多个独立的微服务，每个微服务负责特定的功能模块，这样可以独立扩展和优化各个服务。</li></ul></li></ul></li><li>异步处理：<ul><li>消息队列：使用消息队列(如RabbitMQ、Kafka)处理转账请求，异步处理可以减轻主系统的负载，提升系统的响应速度和稳定性。</li><li>事件驱动架构：通过事件驱动机制来处理转账请求，将转账操作分解成多个事件，以分布式的方式处理。</li></ul></li><li>数据库优化<ul><li>数据库分片：<ul><li>分库分表：将数据库按照某种规则进行分片(如按用户ID、地域等)，减小单个数据库的压力，提升整体处理能力。</li><li>读写分离：使用主从复制架构，将读操作分配到从库，写操作集中在主库，减少读操作对写操作的影响。</li></ul></li><li>索引优化：<ul><li>合理使用索引：为常用查询添加适当的索引，提升查询速度。</li><li>避免全表扫描：确保查询条件能够利用索引，避免全表扫描。</li></ul></li><li>事务优化：<ul><li>减小事务范围：尽量缩小事务的范围，减少锁的持有时间，提升并发处理能力。</li><li>乐观锁与悲观锁：根据业务场景选择合适的锁机制，避免不必要的锁争用。</li></ul></li></ul></li><li>缓存使用<ul><li>分布式缓存：<ul><li>使用缓存系统：如Redis、Memcached，将频繁访问的数据缓存起来，减轻数据库压力。</li><li>缓存一致性：设计缓存更新策略，确保数据的一致性，如使用缓存失效、定时刷新等机制。</li></ul></li><li>热点数据缓存：<ul><li>热点账户缓存：对频繁进行转账操作的账户进行缓存，减少对数据库的直接访问。</li><li>事务结果缓存：将转账结果缓存一段时间，避免重复查询数据库。</li></ul></li></ul></li></ol><ul><li>分布式事务处理</li><li>两阶段提交(2PC)：<ul><li>分布式事务协调器：使用两阶段提交协议确保分布式系统中的数据一致性，尽管性能可能受影响，但在需要强一致性的场景下是必要的。</li><li>TCC(Try-Confirm-Cancel)模式：<ul><li>三阶段事务控制：分别进行预留资源(Try)、确认操作(Confirm)和取消操作(Cancel)，通过分阶段的事务控制确保一致性和可靠性。</li></ul></li></ul></li><li>其他优化策略<ul><li>限流与降级：<ul><li>限流机制：使用令牌桶、漏桶算法等限流机制控制并发请求数量，防止系统过载。</li><li>降级策略：在高并发情况下，优先处理核心业务，非核心业务可以降级或延迟处理。</li></ul></li><li>监控与报警：<ul><li>实时监控：使用监控工具(如Prometheus、Grafana)监控系统性能指标(如QPS、响应时间、错误率等)，及时发现并解决问题。</li><li>报警机制：设置关键指标的报警规则，出现异常情况时及时通知相关人员。</li></ul></li><li>优化代码：<ul><li>提高代码效率：优化业务逻辑，减少不必要的操作和冗余代码。</li><li>并发处理：使用合适的并发处理技术(如线程池、协程等)提升系统的并发处理能力。</li></ul></li></ul></li></ul><p>通过上述多种优化措施，可以有效提升系统在高并发情况下的处理能力和稳定性，确保转账操作的快速和可靠执行。</p><h3 id="线程池✅"><a href="#线程池✅" class="headerlink" title="线程池✅"></a>线程池✅</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h4 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h4><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><blockquote><p>在计算机领域中有很多池化技术，线程池、数据库连接池、内存池、对象池等等，都是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><h4 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h4><ul><li>通过<code>ThreadPoolExecutor</code>构造函数来创建 <em><strong>(推荐)</strong></em> 。</li><li>通过<code>Executors</code>工具类来创建 <em><strong>(不推荐)</strong></em> 。通过这种方式可以创建出多种类型的线程池<ul><li><code>FixedThreadPool</code>：固定大小的线程池。</li><li><code>SingleThreadPool</code>：只有一个线程的线程池。</li><li><code>CachedThreadPool</code>：可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。</li><li><code>ScheduledThreadPool</code>：定时任务的线程池。</li></ul></li></ul><h4 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h4><ul><li><code>FixedThreadPool</code>，<code>SingleThreadPool</code>，<code>ScheduledThreadPool</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool</code>：使用同步队列<code>SynchronousQueue</code>，允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量线程，从而导致 OOM。</li></ul><h4 id="ThreadPoolExecutor参数"><a href="#ThreadPoolExecutor参数" class="headerlink" title="ThreadPoolExecutor参数"></a>ThreadPoolExecutor参数</h4><p>3 个最重要的参数：</p><ul><li><code>corePoolSize</code> ： 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> ： 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>workQueue</code>： 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>其他常见参数：</p><ul><li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> ：<code>executor</code> 创建新线程的时候会用到。</li><li><code>handler</code> ：拒绝策略，当提交的任务过多而不能及时处理时，可以定制策略来处理任务。</li></ul><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><ul><li><code>AbortPolicy</code>：直接抛出异常，阻止系统正常工作。</li><li><code>CallerRunsPolicy</code>：既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求。</li><li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li></ul><h4 id="CallerRunsPolicy策略风险及解决方案"><a href="#CallerRunsPolicy策略风险及解决方案" class="headerlink" title="CallerRunsPolicy策略风险及解决方案"></a>CallerRunsPolicy策略风险及解决方案</h4><p><strong>风险</strong><br><code>CallerRunsPolicy</code> 保证任何一个任务请求都要被执行，但这非常耗时，且如果提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p><p><strong>解决方案</strong></p><ol><li>使用<code>CallerRunsPolicy</code>是希望所有任务都被执行，而暂时无法处理的任务又被保存在阻塞队列<code>BlockingQueue</code>中，这样在内存允许的情况下，可以增加阻塞队列<code>BlockingQueue</code>的大小以容纳更多的任务，同时调整线程池的<code>maximumPoolSize</code> (最大线程数)参数，这样可以提高任务处理速度，避免累计在 <code>BlockingQueue</code>的任务过多导致内存用完。</li><li>使用<code>ThreadPoolExecutor</code>的<code>setRejectedExecutionHandler</code>方法，自定义拒绝策略，比如将任务保存到数据库中，或者将任务保存到消息队列中，等待下次执行，或者使用 <code>Redis</code>缓存任务。</li></ol><h4 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h4><ul><li><code>LinkedBlockingQueue</code>：基于链表的阻塞队列，大小默认为 <code>Integer.MAX_VALUE</code>，即任务队列永远不会放满。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>使用，前者只能创建核心线程数的线程，后者只能创建一个线程。</li><li><code>SyncronousQueue</code>：同步队列，1CachedThreadPool1使用。不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>：延迟阻塞队列，<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>使用。队列中的元素只有当其指定的延迟时间到了才能从队列中取出。内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h4 id="线程池处理任务流程"><a href="#线程池处理任务流程" class="headerlink" title="线程池处理任务流程"></a>线程池处理任务流程</h4><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败(任务队列已经满了)，但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，根据拒绝策略处理。</li></ol><h4 id="线程池中线程异常后销毁还是复用？"><a href="#线程池中线程异常后销毁还是复用？" class="headerlink" title="线程池中线程异常后销毁还是复用？"></a>线程池中线程异常后销毁还是复用？</h4><p>两种情况：</p><ul><li>使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；</li><li>使用<code>ExecutorService.submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</li></ul><h4 id="如何设定线程池大小"><a href="#如何设定线程池大小" class="headerlink" title="如何设定线程池大小"></a>如何设定线程池大小</h4><blockquote><p>注意，这里的线程池大小指的是最大线程数(<code>maximumPoolSize</code>)。</p></blockquote><ul><li>CPU 密集型任务(N+1)： 将线程数设置为 N_cpu_cores(CPU 核心数)+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</li><li>I&#x2F;O 密集型任务(2N)： IO密集型任务在执行过程中会频繁地等待I&#x2F;O操作完成(如读取文件、网络请求)，这些操作通常不占用CPU，可以多配些线程。<ul><li>线程池大小通常设置为 <code>N_threads = N_cpu_cores * U_cpu * (1 + W/C)</code>。<ul><li><code>N_cpu_cores</code> 是机器的CPU核心数。</li><li><code>U_cpu</code> 是期望的CPU利用率，通常取值在 0.5 到 0.9 之间。</li><li><code>W/C</code> 是等待时间与计算时间的比值，即 <code>W</code> 是线程在I&#x2F;O操作上的等待时间，<code>C</code> 是线程进行计算的时间。</li></ul></li></ul></li></ul><p><strong>具体如何设置线程池大小</strong><br>对于IO密集型任务，要估算 <code>W/C</code>，可以通过以下方法：</p><ol><li>测量: 可以通过实际测试任务的执行时间来测量出 <code>W</code> 和 <code>C</code>。例如，测量I&#x2F;O操作花费的时间 <code>W</code> 以及计算部分的时间 <code>C</code>，并计算出它们的比值。</li><li>假设: 如果没有具体的测量，可以根据任务的性质做出合理的假设。例如，对于网络I&#x2F;O密集型任务，<code>W/C</code> 通常会比较大，因为I&#x2F;O操作可能会占据大部分时间。</li><li>调整和优化: 通过监控实际应用的性能表现来调整线程池大小，确保资源利用率最大化，同时避免资源过度争用(如线程过多导致上下文切换频繁)。</li></ol><p><strong>例子</strong><br>假设一个系统有 8 个 CPU 核心(<code>N_cpu_cores = 8</code>)，任务的 <code>W/C = 5</code>，且期望 CPU 利用率 <code>U_cpu = 0.8</code>，那么线程池大小可以设置为：<br><code>N_threads = 8 * 0.8 * (1 + 5) = 8 * 0.8 * 6 = 38.4 ≈ 38</code></p><h4 id="如何设计一个根据任务优先级执行的线程池"><a href="#如何设计一个根据任务优先级执行的线程池" class="headerlink" title="如何设计一个根据任务优先级执行的线程池"></a>如何设计一个根据任务优先级执行的线程池</h4><ul><li>使用<code>PriorityBlockingQueue</code>作为任务队列，队列中的任务按照优先级顺序执行。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ul><p>这样还存在一些问题：</p><ul><li><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。<ul><li>解决方法：继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 <code>false</code> 。</li></ul></li><li>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。<ul><li>解决方法：优化设计，等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</li></ul></li></ul><h3 id="单核CPU上运行多个线程效率一定会高吗"><a href="#单核CPU上运行多个线程效率一定会高吗" class="headerlink" title="单核CPU上运行多个线程效率一定会高吗"></a>单核CPU上运行多个线程效率一定会高吗</h3><p>如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。<br>如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。</p><h3 id="锁✅"><a href="#锁✅" class="headerlink" title="锁✅"></a>锁✅</h3><p>Java 中，每个对象都有一个与之关联的监视器(<code>monitor</code>)，也叫做“对象锁”或“监视器锁”。当线程想要执行对象的同步方法或同步代码块时，必须首先获得该对象的监视器锁。如果其他线程已经持有该锁，则新的线程必须等待，直到该锁被释放。</p><h4 id="对锁的理解"><a href="#对锁的理解" class="headerlink" title="对锁的理解"></a>对锁的理解</h4><p>锁是用于控制多个线程并发访问共享资源的机制，确保在多线程环境下数据的完整性和一致性。锁的核心是控制对共享资源的访问，以防止多个线程同时修改同一个资源。</p><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ul><li><p>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p></li><li><p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p></li><li><p>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p><ul><li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li><li>悲观锁可能会存在死锁问题。</li><li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li></ul></li><li><p>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。</p><ul><li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li><li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li><li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul><li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li></ul></li><li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li></ul></li><li><p>可重入锁(Reentrant Lock)</p><ul><li>可重入锁是一种允许同一个线程多次获取同一个锁的锁机制。Java中的<code>ReentrantLock</code>类是其典型实现。可重入锁解决了递归调用中锁定的死锁问题。</li></ul></li><li><p>读写锁(Read-Write Lock)</p><ul><li>读写锁是一种允许多个线程同时读取共享资源，但在写操作时只能有一个线程访问的锁机制。<code>ReentrantReadWriteLock</code>是Java中的典型实现，适用于读多写少的场景，提升并发性能。</li></ul></li><li><p>分段锁(Segmented Lock)</p><ul><li>分段锁是一种细粒度锁机制，将资源分为多个段，每个段配有独立的锁，以提高并发性。Java中的<code>ConcurrentHashMap</code>就使用了分段锁来提高并发效率。</li></ul></li><li><p>轻量级锁(Lightweight Locking)</p><ul><li>轻量级锁是在没有线程竞争的情况下，通过CAS(Compare-And-Swap)操作进行加锁。轻量级锁适用于竞争不激烈的场景，可以减少传统重量级锁(Monitor)带来的性能开销。</li></ul></li><li><p>重量级锁(Heavyweight Locking)</p><ul><li>重量级锁是Java中最传统的锁机制，通过操作系统的互斥量(Mutex)实现。当多个线程竞争同一个锁时，未获得锁的线程会被阻塞，并由操作系统负责调度，这种锁的开销较大。</li></ul></li><li><p>自旋锁(Spin Lock)</p><ul><li>自旋锁是一种不断循环检查锁状态的锁机制，而不是让线程进入阻塞状态。线程会在一段时间内一直尝试获取锁，直到成功或达到一定重试次数为止。适用于锁的持有时间较短的场景，避免线程切换的开销。</li></ul></li><li><p>偏向锁(Biased Locking)</p><ul><li>偏向锁是一种优化手段，旨在减少无竞争情况下的锁获取开销。当一个线程获取锁时，会偏向于该线程，后续该线程再次获取锁时无需进行同步操作。这种锁会在没有其他线程竞争的情况下发挥作用，但如果有其他线程试图获取该锁，偏向锁会被撤销。</li></ul></li></ul><h4 id="Java中有哪些锁"><a href="#Java中有哪些锁" class="headerlink" title="Java中有哪些锁"></a>Java中有哪些锁</h4><ul><li><code>synchronized</code>关键字<ul><li>用于同步方法或同步代码块。</li><li>基于对象锁，每个对象都有一个监视器锁。</li></ul></li><li><code>ReentrantLock</code><ul><li>在<code>java.util.concurrent.locks</code>包中提供。</li><li>提供更灵活的锁机制，相比<code>synchronized</code>，支持公平锁、非公平锁等特性。</li><li>支持可重入锁，即同一个线程可以多次获取同一个锁。</li></ul></li><li><code>ReentrantReadWriteLock</code><ul><li>在<code>java.util.concurrent.locks</code>包中提供。</li><li>提供读写锁的实现，读锁共享，写锁独占。</li><li>适用于读多写少的场景，提升并发性能。</li></ul></li><li><code>Semaphore</code><ul><li>在<code>java.util.concurrent</code>包中提供。</li><li>用于控制同时访问特定资源的线程数量。</li></ul></li><li><code>Atomic</code>变量<ul><li>在<code>java.util.concurrent.atomic</code>包中提供。</li><li>提供了一些基本类型(如<code>AtomicInteger</code>、<code>AtomicLong</code>)的原子操作，实现了无锁的线程安全。</li></ul></li><li><code>CountDownLatch</code><ul><li>在<code>java.util.concurrent</code>包中提供。</li><li>允许一个或多个线程等待一组操作完成。</li></ul></li><li><code>CyclicBarrier</code><ul><li>在<code>java.util.concurrent</code>包中提供。</li><li>使一组线程在到达一个共同的屏障点时被阻塞，直到所有线程都到达该点。</li></ul></li><li><code>StampedLock</code><ul><li>在<code>java.util.concurrent.locks</code>包中提供。</li><li>提供三种锁模式：写锁、悲观读锁和乐观读锁。</li><li>乐观读锁在某些情况下可以避免加锁操作，提升性能。</li></ul></li><li><code>LockSupport</code><ul><li>提供基本的线程阻塞和唤醒机制。</li><li>通常用于构建更高级的同步器，如<code>Semaphore</code>、<code>CountDownLatch</code>等。</li></ul></li><li><code>Phaser</code><ul><li>在<code>java.util.concurrent</code>包中提供。</li><li>允许多阶段的线程协作，每个阶段完成后继续下一阶段。</li></ul></li></ul><p>这些锁机制可以根据具体的应用场景选择，以实现高效、安全的并发控制。</p><h4 id="锁升级原理了解吗"><a href="#锁升级原理了解吗" class="headerlink" title="锁升级原理了解吗"></a>锁升级原理了解吗</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><ul><li>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li></ul><h4 id="可中断锁-不可中断锁"><a href="#可中断锁-不可中断锁" class="headerlink" title="可中断锁&#x2F;不可中断锁"></a>可中断锁&#x2F;不可中断锁</h4><ul><li>可中断锁：正在等待获取锁的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 是可中断锁。</li><li>不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 是不可中断锁。</li></ul><h4 id="共享锁-独占锁"><a href="#共享锁-独占锁" class="headerlink" title="共享锁&#x2F;独占锁"></a>共享锁&#x2F;独占锁</h4><ul><li>共享锁：一把锁可以被多个线程同时获得。</li><li>独占锁：一把锁只能被一个线程获得。</li></ul><h4 id="线程持有读锁还能获取写锁吗"><a href="#线程持有读锁还能获取写锁吗" class="headerlink" title="线程持有读锁还能获取写锁吗"></a>线程持有读锁还能获取写锁吗</h4><ul><li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。</li></ul><h4 id="读锁为什么不能升级为写锁"><a href="#读锁为什么不能升级为写锁" class="headerlink" title="读锁为什么不能升级为写锁"></a>读锁为什么不能升级为写锁</h4><ul><li>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</li><li>可能会有死锁问题发生。<ul><li>举例：假设线程A、B都想要将持有的读锁升级为写锁。由于写锁是独占的，因此线程A在尝试升级写锁时，需要等待所有其他读锁(包括线程B持有的)被释放。同样，线程B也需要等待所有其他读锁(包括线程A持有的)被释放。这就形成了一个典型的死锁场景：线程A等待线程B释放读锁，而线程B又等待线程A释放读锁。两者都无法继续执行，都在等待对方释放资源。</li></ul></li></ul><h4 id="乐观锁-悲观锁-1"><a href="#乐观锁-悲观锁-1" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><ul><li>悲观锁：总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。<ul><li><code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</li><li>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统频繁的上下文切换，增加系统的性能开销。</li><li>悲观锁可能会存在死锁问题。</li><li>通常多用于写比较多的情况(多写场景，竞争激烈)，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li></ul></li><li>乐观锁：总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源(也就是数据)是否被其它线程修改了。<ul><li>具体方法可以使用版本号机制或 CAS 算法，<code>AtomicInteger</code>、<code>LongAdder</code>等都是乐观锁的实现。</li><li>高并发场景，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</li><li>如果冲突频繁发生(写占比非常多的情况)，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。<ul><li><code>LongAdder</code>以空间换时间的方式就解决了大量重试问题。</li></ul></li><li>通常多用于写比较少的情况(多读场景，竞争较少)，这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</li></ul></li></ul><h4 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁"></a>如何实现乐观锁</h4><ul><li>版本号机制：在数据表中增加一个版本号字段，每次更新数据的时候，将版本号加一，更新的时候判断版本号是否一致，一致则更新成功，否则失败。</li><li>CAS：如下。</li></ul><h4 id="CAS自旋锁"><a href="#CAS自旋锁" class="headerlink" title="CAS自旋锁"></a>CAS自旋锁</h4><ul><li>CAS：<code>compare and swap</code>，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。是原子操作。<ul><li>V：要更新的变量值(Var)，E：预期值(Expected)，N：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</li></ul></li></ul><blockquote><p>举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1(V &#x3D; 1，E &#x3D; 1，N &#x3D; 6，假设不存在 ABA 问题)。i(V) 与 1(E) 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6(N)。i(V) 与 1(E) 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p></blockquote><h4 id="CAS算法存在问题"><a href="#CAS算法存在问题" class="headerlink" title="CAS算法存在问题"></a>CAS算法存在问题</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>变量 V 初次读取的时候是 A 值，并且在使用 CAS算法 准备赋值的时候检查到它仍然是 A 值，不能说明它的值没有被其他线程修改过，因为在这段时间它的值可能被改为其他值(B)，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p><p>ABA问题的解决思路是在变量前面追加上版本号或者时间戳。</p><h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>CAS 经常会用到自旋操作来进行重试，自旋时间长，如果 CAS 一直不成功，会导致 CPU 一直自旋，这样会消耗 CPU 资源。</p><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效，这时可以使用<code>AtomicReference</code>。</p><h4 id="synchronized关键字✅"><a href="#synchronized关键字✅" class="headerlink" title="synchronized关键字✅"></a>synchronized关键字✅</h4><p><code>synchronized</code> 是一种同步锁。主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p><code>synchronized</code> 关键字是通过对象内部的一个叫做监视器锁(<code>monitor</code>)来实现的。</p><ul><li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li><li><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li></ul><p>两者的本质都是对对象监视器 <code>monitor</code> 的获取。</p><h4 id="JDK1-6之后synchronized的优化"><a href="#JDK1-6之后synchronized的优化" class="headerlink" title="JDK1.6之后synchronized的优化"></a>JDK1.6之后synchronized的优化</h4><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，但是在 Java 6 之后，<code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，使得 synchronized 的效率大大提高。</p><h4 id="如何使用synchronized"><a href="#如何使用synchronized" class="headerlink" title="如何使用synchronized"></a>如何使用synchronized</h4><ul><li>修饰实例方法：锁住当前实例对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修饰静态方法：锁住当前类的 Class 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修饰代码块：锁住括号里面的对象。<ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 给定对象的锁。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 给定 <code>Class</code> 的锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(类.class) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="synchronized和ReentrantLock有什么区别？"><a href="#synchronized和ReentrantLock有什么区别？" class="headerlink" title="synchronized和ReentrantLock有什么区别？"></a>synchronized和ReentrantLock有什么区别？</h4><p>两者都是可重入锁</p><ul><li><code>synchronized</code> 是关键字，是内置的语言实现，<code>ReentrantLock</code> 是一个类。</li><li><code>synchronized</code> 是 JVM 实现的，<code>ReentrantLock</code> 是 JDK 实现的(也就是 API 层面，需要 <code>lock()</code> 和 <code>unlock()</code> 方法配合 <code>try/finally</code> 语句块来完成)</li><li><code>synchronized</code> 是不可中断锁。<code>ReentrantLock</code> 是可中断锁。<ul><li><code>ReentrantLock</code>提供一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>实现。</li></ul></li><li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：<ul><li>可实现公平锁： <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。通过<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li>可实现选择性通知(锁可以绑定多个条件)： <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以，但需借助<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul></li></ul><blockquote><p>可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁(一个类中有多个<code>synchronized</code>修饰的方法)的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p></blockquote><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code> 是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承抽象类 <code>AQS(AbstractQueuedSynchronizer，抽象队列同步器)</code>，添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><strong>原理</strong><br><code>ReentrantLock</code>内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>(读锁)。读锁是<strong>共享锁</strong>，写锁是<strong>独占锁</strong>。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><blockquote><p>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。<br>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥(只有读读不互斥)。</p></blockquote><h4 id="如何自己设计一个悲观锁"><a href="#如何自己设计一个悲观锁" class="headerlink" title="如何自己设计一个悲观锁"></a>如何自己设计一个悲观锁</h4><p>使用<code>synchronized</code>关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PessimisticLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">            wait(); <span class="comment">// 如果已经被锁定，则等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="literal">true</span>; <span class="comment">// 获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        isLocked = <span class="literal">false</span>; <span class="comment">// 释放锁</span></span><br><span class="line">        notify(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h4><p>AQS(AbstractQueuedSynchronizer，抽象队列同步器) 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，使用基于<code>CLH</code>锁实现的一套线程阻塞等待以及被唤醒时锁分配机制。</p><p>以可重入互斥锁 <code>ReentrantLock</code> 为例，其内部维护了一个使用<code>volatile</code>修饰(保证线程可见性)的<code>state</code>变量，用来表示锁的占用状态。<code>state</code> 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 <code>lock()</code> 方法时，会尝试通过 <code>tryAcquire()</code> 方法独占该锁，并让 <code>state</code> 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列(<code>CLH</code> 锁队列)中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的(<code>state</code> 会累加)。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 <code>state</code> 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。</p><blockquote><p><code>CLH</code>锁是对自旋锁的一种改进，是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)，暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 <code>CLH</code> 队列锁的一个结点(<code>Node</code>)来实现锁的分配。在 <code>CLH</code> 队列锁中，一个节点表示一个线程，它保存着线程的引用(<code>thread</code>)、 当前节点在队列中的状态(<code>waitStatus</code>)、前驱节点(<code>prev</code>)、后继节点(<code>next</code>)。</p></blockquote><h4 id="AQS资源共享模式"><a href="#AQS资源共享模式" class="headerlink" title="AQS资源共享模式"></a>AQS资源共享模式</h4><p>AQS 支持两种资源共享方式：独占和共享。</p><ul><li><code>Exclusive</code>(独占，只有一个线程能执行，如<code>ReentrantLock</code>)</li><li><code>Share</code>(共享，多个线程可同时执行，如<code>Semaphore/CountDownLatch</code>)</li></ul><blockquote><p>也可以自定义同步器同时实现独占和共享，如<code>ReentrantReadWriteLock</code>，读操作时多个线程可以同时进行，写操作时只能一个线程进行。</p></blockquote><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，没有实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <code>CLH</code> 锁独立实现的。</p><p>提供三种访问模式：</p><ul><li>写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li><li>读锁 (悲观读)：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li>乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。(性能比<code>ReadWriteLock</code>更好的原因)</li></ul><h3 id="死锁✅"><a href="#死锁✅" class="headerlink" title="死锁✅"></a>死锁✅</h3><p>死锁是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><blockquote><p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p></blockquote><p>产生死锁的四个必要条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ul><h4 id="如何检测死锁"><a href="#如何检测死锁" class="headerlink" title="如何检测死锁"></a>如何检测死锁</h4><ul><li>一般死锁可能会导致 CPU 使用率飙升，线程处于 <code>BLOCKED</code> 状态，可以通过监控工具查看。</li><li>jConsole： 可以检测死锁，查看线程的状态。</li><li>jstack： 如有死锁，会输出<code>Found one Java-level deadlock: </code>线程的状态信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jps -l <span class="comment">// 查找当前正在运行的 Java 进程及其对应的 PID</span></span><br><span class="line"><span class="number">70191</span> DeadLockSample</span><br><span class="line">jstack -l &lt;PID&gt; <span class="comment">// jstack 命令将当前 Java 进程的线程堆栈信息输出到控制台</span></span><br><span class="line"></span><br><span class="line">jconsole <span class="comment">// 唤醒图形化界面，然后选择线程-&gt;检测死锁</span></span><br></pre></td></tr></table></figure><h4 id="如何预防和避免死锁"><a href="#如何预防和避免死锁" class="headerlink" title="如何预防和避免死锁"></a>如何预防和避免死锁</h4><p>破坏死锁的产生的必要条件：</p><ul><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><p>避免死锁就是在资源分配时，借助于算法(比如<strong>银行家算法</strong>)对资源分配进行计算评估，使其进入安全状态。</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>银行家算法通过预先判断系统是否处于安全状态来避免死锁的发生。它要求进程在申请资源时声明其最大需求量，并在分配资源前进行安全性检查。如果分配资源后系统仍处于安全状态，则进行资源分配；否则，拒绝分配资源并让进程等待。</p><blockquote><p>安全状态：如果存在一个由系统中所有进程构成的安全序列(即每个进程都能按照某种顺序顺利执行完成，且每个进程在执行过程中所需资源都能得到满足)，则系统处于安全状态。安全状态一定是没有死锁发生的。<br>不安全状态：不存在一个安全序列的状态称为不安全状态。不安全状态不一定导致死锁，但有可能发展为死锁。</p></blockquote><h3 id="ThreadLocal✅"><a href="#ThreadLocal✅" class="headerlink" title="ThreadLocal✅"></a>ThreadLocal✅</h3><p><code>ThreadLocal</code> 是一个线程内部的数据存储类，可以在每个线程中创建一个变量副本，各个线程之间的数据互不干扰。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h4 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h4><p><code>ThreadLocal</code> 通过 <code>ThreadLocalMap</code> 来实现线程内部的数据存储。<code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，每个线程中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocal</code> 通过 <code>get()</code>、<code>set()</code> 方法访问 <code>ThreadLocalMap</code>。在一个线程中创造多个<code>ThreadLocal</code>对象，这个许多个<code>ThreadLocal</code>对象会被放到一个<code>ThreadLocalMap</code>中。</p><blockquote><p><code>ThreadLocalMap</code>可以理解为一个定制化的 <code>HashMap</code>，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 是存储的值。<br>可以存在这种情况： 在线程 1 中创建了两个 <code>ThreadLocal</code> 对象，在线程 1 中只有一个 <code>ThreadLocal</code> 对象。</p></blockquote><h4 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h4><p><code>ThreadLocalMap</code> 中使用的 <code>key</code> 为 <code>ThreadLocal</code> 的弱引用，而 <code>value</code> 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，<code>key</code> 会被清理掉，而 <code>value</code> 不会被清理掉。这样一来就会出现 <code>key</code> 为 <code>null</code> 的 键值对。如果不做任何措施的话，<code>value</code> 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p>其实<code>ThreadLocalMap</code>实现中已经考虑了内存泄漏问题，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 <code>key</code> 为 <code>null</code> 的记录。不过使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><blockquote><p><code>HashMap</code> 的 <code>key</code> 和 <code>value</code> 都是强引用，因此不会存在弱引用导致的内存泄漏问题。</p></blockquote><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。其中的<code>state</code>表示许可数(&gt;&#x3D;1)，当一个线程调用 <code>acquire()</code> 方法时，会首先尝试获取一个许可，如果成功，该线程就可以继续执行，否则就会被阻塞。当一个线程调用 <code>release()</code> 方法时，会释放一个许可，这样就会唤醒一个被阻塞的线程。</p><h4 id="Semaphores信号量原理"><a href="#Semaphores信号量原理" class="headerlink" title="Semaphores信号量原理"></a>Semaphores信号量原理</h4><p>信号量(<code>Semaphore</code>)是一种用于进程间同步和互斥的机制。它通过维护一个计数器来管理多个进程对共享资源的访问。</p><p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，表示许可的数量。只有拿到许可证的线程才能执行。</p><ul><li>调用<code>semaphore.acquire()</code>，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 <code>Node</code> 节点加入阻塞队列，挂起当前线程。</li><li>调用<code>semaphore.release()</code>，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒阻塞队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code>，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</li></ul><h3 id="异步调用Future类"><a href="#异步调用Future类" class="headerlink" title="异步调用Future类"></a>异步调用Future类</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，具体来说是这样的：当主线程执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时主线程做其他事情，不用等待耗时任务执行完成。等事情干完后，再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p><code>Future</code>类是一个泛型接口，主要包含下面几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行，成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable和Future关系"><a href="#Callable和Future关系" class="headerlink" title="Callable和Future关系"></a>Callable和Future关系</h3><p><code>Callable</code> 用于定义可以返回结果的任务，<code>Future</code> 用于获取 <code>Callable</code> 任务的异步结果。两者常常结合使用，以便在并发编程中有效地管理任务执行和结果处理。</p><ul><li>任务提交与执行：通常通过 <code>ExecutorService</code> 提交 <code>Callable</code> 任务，<code>submit</code> 方法返回一个 <code>Future</code> 对象。</li><li>异步结果获取：<code>Future</code> 对象可以用来获取 <code>Callable</code> 任务的返回结果或处理异常。</li></ul><h3 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h3><p><code>Runnable</code>和<code>Callable</code>是两个用于并发编程的接口。</p><ol><li>返回值<ul><li><code>Runnable</code>：不返回结果。<code>Runnable</code>的<code>run()</code>方法是无返回值的(<code>void</code>)，所以无法通过它直接获取任务执行的结果。</li><li><code>Callable</code>：返回结果。<code>Callable</code>接口的<code>call()</code>方法返回一个泛型类型的值(可以是任意类型)，通常与<code>Future</code>或<code>FutureTask</code>结合使用，以便在任务完成后获取其结果。</li></ul></li><li>异常处理<ul><li><code>Runnable</code>：不能抛出受检异常(Checked Exception)。如果<code>Runnable</code>任务中有受检异常，需要在<code>run()</code>方法内捕获并处理。</li><li><code>Callable</code>：可以抛出受检异常。<code>Callable</code>的<code>call()</code>方法可以抛出异常，这使得它更适合需要处理异常的任务。</li></ul></li><li>使用场景<ul><li><code>Runnable</code>：常用于那些不需要返回结果的简单任务，如执行某个后台任务、周期性任务等。</li><li><code>Callable</code>：适用于需要返回结果或可能抛出受检异常的任务，比如计算密集型任务、获取某些资源或执行某些带有条件判断的任务。</li></ul></li></ol><h3 id="实现异步调用的多种方法"><a href="#实现异步调用的多种方法" class="headerlink" title="实现异步调用的多种方法"></a>实现异步调用的多种方法</h3><ol><li><code>Future</code>类：通过 <code>Future</code> 类的 <code>get()</code> 方法获取异步任务的执行结果。</li><li><code>CompletableFuture</code>类：Java 8 引入的 <code>CompletableFuture</code> 类，提供了更强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。</li><li><code>CompletionService</code>类和<code>Callable</code>类：<code>CompletionService</code> 是一个接口，它允许提交一组 <code>Callable</code> 任务，这些任务将异步执行，并且可以按照完成的顺序获取它们的结果。</li><li><code>FutureTask</code>类：<code>FutureTask</code> 是 <code>Future</code> 的一个实现类，它实现了 <code>Runnable</code> 接口，可以作为 <code>Runnable</code> 被线程执行，也可以作为 <code>Future</code> 得到任务的执行结果。</li><li><code>ExecutorService</code>类：<code>ExecutorService</code> 是一个接口，它是 <code>Executor</code> 的子接口，它提供了更丰富的线程池功能，可以提交任务、执行任务、关闭线程池等。</li><li><code>ForkJoinPool</code>、<code>ScheduledExecutorService</code>等。</li></ol><h3 id="CompletableFuture类有什么用？"><a href="#CompletableFuture类有什么用？" class="headerlink" title="CompletableFuture类有什么用？"></a>CompletableFuture类有什么用？</h3><p><code>CompletableFuture</code> 类是 Java 8 中引入的一个增强版 <code>Future</code>，它不仅可以代表一个异步计算的结果，还提供了强大的方法链和回调机制，用于构建复杂的异步逻辑和并行操作。与 <code>Future</code> 相比，<code>CompletableFuture</code> 更加灵活和强大，支持函数式编程、异步任务编排组合等能力。</p><h4 id="CompletableFuture类异步调用实现"><a href="#CompletableFuture类异步调用实现" class="headerlink" title="CompletableFuture类异步调用实现"></a>CompletableFuture类异步调用实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个CompletableFuture来执行异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟一个长时间运行的任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 休眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 注册一个回调函数，当任务完成时获取结果</span></span><br><span class="line">        future.thenAccept(result -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务结果: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程继续执行其他操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行...&quot;</span>);</span><br><span class="line">        <span class="comment">// 阻塞主线程，直到异步任务完成(可选)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这一步会阻塞主线程，直到异步任务完成</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务完成后获取的结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>Java内存区域&#x2F;Java虚拟机内存 被划分为多个部分，每个部分在Java应用程序运行时发挥不同的作用。</p><p>线程私有的内存区域包括：</p><ul><li><strong>程序计数器</strong>：<ul><li>这是当前线程执行的字节码行号指示器。每个线程都有一个独立的程序计数器，指向下一条要执行的字节码指令。</li><li>如果正在执行的是本地方法，这个计数器是未指定值(<code>undefined</code>)。</li></ul></li><li><strong>Java虚拟机栈</strong>：<ul><li>Java虚拟机栈用于存储局部变量、操作数栈、中间结果等。</li><li>栈帧(Stack Frame)是虚拟机栈中的基本元素，每个方法调用对应一个栈帧。栈帧包括局部变量表、操作数栈和帧数据(如方法返回地址、动态链接信息等)。</li></ul></li><li><strong>本地方法栈</strong>：<ul><li>本地方法栈与Java虚拟机栈类似，只不过它为本地方法(Native Methods)服务。</li><li>一般情况下，使用C语言等实现的本地方法的调用也会在本地方法栈中执行。</li></ul></li></ul><p>线程共享的内存区域包括：</p><ul><li><strong>堆</strong>：<ul><li>Java堆是所有线程共享的内存区域，用于存放对象实例及数组。所有对象实例及数组都在堆上分配。</li><li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</li><li>堆内存通常又被划分为年轻代(Young Generation)和老年代(Old Generation)，其中年轻代进一步划分为Eden区、Survivor0区和Survivor1区。<ul><li>JDK1.8将字符串常量池从方法区中移除，放到堆中，这样可以避免字符串常量池占用过多的方法区内存。</li></ul></li></ul></li><li><strong>方法区</strong>：<ul><li>方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区在JVM规范中是堆的一部分，但实际实现中常被单独划分，比如HotSpot虚拟机中的永久代(Permanent Generation，已在Java 8中被元空间Metaspace取代)。</li></ul></li><li><strong>运行时常量池</strong>：<ul><li>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这些常量在类加载后被放入方法区的运行时常量池中。</li><li>JDK1.7位于方法区，JDK1.8位于直接内存中的元空间。</li></ul></li></ul><p>本地内存：</p><ul><li>直接内存：<ul><li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</li><li>JDK1.8之后加入了元空间，元空间是直接内存的一部分，用于存放类的元数据信息。</li><li>JDK1.8将运行时常量池放到直接内存的元空间中，这样可以避免方法区内存溢出的问题。</li></ul></li></ul><p><strong>内存模型与内存管理</strong></p><ul><li>内存模型(Java Memory Model, JMM)：JMM定义了线程之间如何通过内存进行交互的规则，特别是如何确保操作的可见性、原子性和有序性。</li><li>垃圾收集(Garbage Collection, GC)：Java通过垃圾收集机制自动管理堆内存，回收无用对象以释放空间。常见的垃圾收集器包括Serial、Parallel、CMS和G1等。</li></ul><p><strong>总结</strong><br>Java内存区域划分的目的是为了提高性能和管理复杂性。程序计数器、Java虚拟机栈和本地方法栈是线程私有的，而堆和方法区是线程共享的。Java内存模型保证了多线程环境下的内存可见性和指令重排序的正确性，垃圾收集器则帮助管理堆内存，提升程序运行效率和稳定性。</p><h3 id="程序计数器为啥是私有的-1"><a href="#程序计数器为啥是私有的-1" class="headerlink" title="程序计数器为啥是私有的"></a>程序计数器为啥是私有的</h3><p>程序计数器主要有下面两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li><li>如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li></ul><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h3 id="虚拟机栈和本地方法栈为啥是私有的-1"><a href="#虚拟机栈和本地方法栈为啥是私有的-1" class="headerlink" title="虚拟机栈和本地方法栈为啥是私有的"></a>虚拟机栈和本地方法栈为啥是私有的</h3><ul><li>虚拟机栈： 每个 Java 方法在执行之前会创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 (也就是字节码)服务，而本地方法栈则为虚拟机使用到的 <code>native</code> 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="一句话简单了解堆和方法区-1"><a href="#一句话简单了解堆和方法区-1" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="一个Java应用配了最大堆和最小堆都是2个G，但运行一段时间后通过top发现其内存已经占了4个G，什么原因？"><a href="#一个Java应用配了最大堆和最小堆都是2个G，但运行一段时间后通过top发现其内存已经占了4个G，什么原因？" class="headerlink" title="一个Java应用配了最大堆和最小堆都是2个G，但运行一段时间后通过top发现其内存已经占了4个G，什么原因？"></a>一个Java应用配了最大堆和最小堆都是2个G，但运行一段时间后通过top发现其内存已经占了4个G，什么原因？</h3><p>Java应用使用的内存不仅仅包括堆内存，还可能涉及以下几个方面，会导致内存占用超过配置的堆大小：</p><ol><li>非堆内存：<ul><li>Java虚拟机还会为方法区和代码缓存分配非堆内存，主要存储类信息、常量池、JIT编译后的代码等。</li><li>通过参数<code>-XX:MaxMetaspaceSize</code>可以限制方法区的最大内存占用。</li></ul></li><li>本地内存分配：<ul><li>Java应用可能会通过JNI(Java Native Interface)或本地库进行本地内存的分配，这些内存不计入堆内存，但依然占用系统内存。</li><li>如果使用了大量的JNI调用或本地资源，比如图形库、数据库驱动等，可能会导致额外的内存消耗。</li></ul></li><li>线程栈：<ul><li>每个Java线程都会有自己的栈内存，其大小可以通过<code>-Xss</code>参数设置。大量线程或较大的栈大小会消耗更多内存。</li><li>如果应用中有很多线程，线程栈的内存消耗也会很显著。</li></ul></li><li>内存碎片：<ul><li>在堆和非堆内存区域中，随着内存的分配和释放，可能会产生内存碎片。这些碎片化的内存可能会导致实际使用的内存远超分配给堆的大小。</li></ul></li></ol><p><strong>建议的排查步骤</strong></p><ol><li>使用<code>jmap</code>、<code>jstat</code>或<code>jvisualvm</code>工具来分析堆外内存的使用情况。</li><li>检查是否有大量线程创建，或者栈空间设置得较大。</li><li>使用<code>-XX:+PrintFlagsFinal</code>来检查JVM参数的实际配置，看看是否有额外的非堆内存配置。</li></ol><h3 id="Java的各种变量存放在哪里"><a href="#Java的各种变量存放在哪里" class="headerlink" title="Java的各种变量存放在哪里"></a>Java的各种变量存放在哪里</h3><ol><li>栈：<ul><li>局部变量：方法中的基本数据类型(如 <code>int</code>, <code>char</code>, <code>boolean</code> 等)和对象引用变量(如 <code>ArrayList</code> 的引用)都存储在栈中。栈的特点是遵循“后进先出”(LIFO)的原则，方法调用结束后栈帧会被销毁，栈上的数据随之消失。</li></ul></li><li>堆：<ul><li>对象：所有通过 <code>new</code> 关键字创建的对象(如 <code>new ArrayList&lt;&gt;()</code>)都存储在堆中。堆内存用于动态分配内存空间，生命周期比栈长，直到没有任何引用指向它们时才会被垃圾回收器回收。</li></ul></li><li>方法区： <ul><li>类的元数据：存储类的结构信息，如类名、方法、字段、常量池、静态代码块等。方法区在JVM中也是堆的一部分。</li></ul></li><li>常量池：<ul><li>字符串常量和基本类型常量：例如 <code>String s = &quot;hello&quot;;</code> 中的字符串常量 <code>hello</code> 就存储在常量池中。常量池也是方法区的一部分。</li></ul></li></ol><h4 id="ArrayList的存储"><a href="#ArrayList的存储" class="headerlink" title="ArrayList的存储"></a><code>ArrayList</code>的存储</h4><p>当你创建一个 <code>ArrayList</code> 时，例如 <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code>：</p><ul><li><strong><code>list</code> 引用</strong>：存储在栈中。</li><li><strong><code>ArrayList</code> 对象本身</strong>：存储在堆中。这个对象包含实际存储元素的数组。</li><li><strong>数组中的元素</strong>：如果是对象类型(如 <code>String</code>)，这些对象也存储在堆中。</li></ul><h4 id="final修饰的变量"><a href="#final修饰的变量" class="headerlink" title="final修饰的变量"></a>final修饰的变量</h4><p><code>final</code> 修饰的变量根据它的具体类型(静态变量、实例变量、局部变量)存储位置会有所不同。</p><ul><li><code>final</code> 修饰的静态变量：存储在<strong>方法区</strong>的静态存储区中。</li><li><code>final</code> 修饰的实例变量：存储在<strong>堆内存</strong>中的实例对象中。</li><li><code>final</code> 修饰的局部变量：如果是方法内部的局部变量，它将存储在<strong>栈内存</strong>中。</li><li><code>final</code> 变量一旦被初始化后，其值不能再修改。对于基本类型，它存储的是值本身；而对于引用类型，它存储的是引用地址(即引用不可变，但对象的内部状态可以改变)。</li></ul><h4 id="所有的对象都存放在堆中吗"><a href="#所有的对象都存放在堆中吗" class="headerlink" title="所有的对象都存放在堆中吗"></a>所有的对象都存放在堆中吗</h4><p>几乎所有通过 <code>new</code> 关键字创建的对象都存储在堆中。然而，有一些特殊情况可能会存储到到其他存储区域：</p><ol><li>字符串常量池：<ul><li>字符串字面量(如 <code>&quot;hello&quot;</code>)存储在方法区的常量池中，不在堆中。如果你使用 <code>String s = &quot;hello&quot;;</code>，字符串 <code>&quot;hello&quot;</code> 就存储在常量池中，并且如果存在相同的字面量，Java不会再创建新的字符串对象，而是直接引用常量池中的现有对象。</li><li>如果使用 <code>new String(&quot;hello&quot;)</code>，则会在堆中创建一个新的 <code>String</code> 对象。</li></ul></li><li>栈上分配(逃逸分析)：理论上，Java虚拟机可以通过逃逸分析技术将某些不会逃逸出方法的对象直接分配在栈上，而不是堆上。这样，当方法结束时，对象会随栈帧一起销毁。然而，这种优化是由JVM自动完成的，程序员无法直接控制。</li><li>方法区：<ul><li>方法区中存储类的元数据和静态变量等，但不存储通过 <code>new</code> 创建的对象。静态变量的值(如果是对象)会存储在堆中。</li></ul></li></ol><h4 id="成员变量-全局变量-局部变量存放在哪里"><a href="#成员变量-全局变量-局部变量存放在哪里" class="headerlink" title="成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里"></a>成员变量&#x2F;全局变量&#x2F;局部变量存放在哪里</h4><ul><li>成员变量(实例变量)存储在堆内存中，每个对象都有自己的一份成员变量。</li><li>静态变量(类变量)存储在方法区(或元空间)中，是类级别的变量，共享给所有实例。</li><li>局部变量存储在栈内存中，属于方法调用帧的一部分。</li></ul><h3 id="垃圾回收机制✅"><a href="#垃圾回收机制✅" class="headerlink" title="垃圾回收机制✅"></a>垃圾回收机制✅</h3><p><strong>垃圾回收机制定义</strong><br>垃圾回收(GC)是内存管理的核心组成部分，它负责自动回收不再使用的内存空间。在Java中，程序员不需要手动释放对象占用的内存，一旦对象不再被引用，垃圾回收器就会在适当的时机回收它们所占用的内存。这样可以避免内存泄漏和野指针，从而大大减轻了程序员的负担，也使得Java成为一个相对安全、易于开发的编程语言。</p><p>垃圾回收的基本步骤分两步：</p><ul><li>查找堆内存中不再使用的对象(GC判断策略)</li><li>释放这些对象占用的内存(垃圾回收算法)</li></ul><p>接下来我将从堆空间的结构、内存分配和回收原则、GC判断策略、垃圾回收算法、常见垃圾回收器这五大方面来介绍垃圾回收机制。</p><h4 id="堆空间结构"><a href="#堆空间结构" class="headerlink" title="堆空间结构"></a>堆空间结构</h4><p>垃圾回收主要发生在堆内存中，JDK1.7之前，堆通常被分为新生代、老年代和永久代三部分。JDK1.8之后，永久代被元空间取代，堆内存结构变为新生代(Eden，S0，S1)、老年代和元空间。</p><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><ul><li>对象优先在新生代分配内存，新生代内存分为 Eden 区、Survivor0 区和 Survivor1 区。当 Eden 区内存不足时，虚拟机会触发一次 Minor GC，将 Eden 区中存活的对象复制到 Survivor0 区，然后清空 Eden 区。Survivor0 和 Survivor1 交替使用，当其中一个区域内存不足时，虚拟机会将存活的对象复制到另一个区域，然后清空原区域。当对象在新生代经历多次复制仍然存活时，会被晋升到老年代。</li><li>大对象直接进入老年代。如果对象的大小超过了新生代的某个阈值，虚拟机会直接将这个对象分配到老年代。</li><li>长期存活的对象将进入老年代。虚拟机会给每个对象定义一个年龄计数器，对象在新生代每经历一次 Minor GC，年龄加1。当对象的年龄达到一定阈值(默认 15)时，虚拟机会将这个对象晋升到老年代。</li></ul><h4 id="死亡对象判断策略"><a href="#死亡对象判断策略" class="headerlink" title="死亡对象判断策略"></a>死亡对象判断策略</h4><ul><li>引用计数法：引用计数法是最简单的垃圾回收算法，它通过引用计数器来判断对象是否存活。当对象被引用时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明对象不再被引用，可以被回收。但引用计数法无法解决循环引用的问题，因此在实际应用中很少使用。<ul><li>循环引用：两对象无外界引用，但因互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</li></ul></li><li>可达性分析法：可达性分析法是现代垃圾回收算法的主流。它通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是没有被引用，需要被回收。<ul><li>这些对象可以用作 GC Roots： <ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI(Java Native Interface)引用的对象</li></ul></li></ul></li></ul><blockquote><p>对象被标记为不可达，就代表一定会被回收吗？<br>不一定。真正宣告一个对象死亡至少要经过两次标记过程。</p></blockquote><h4 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h4><p>垃圾回收主要基于以下两种情况触发：</p><ul><li>Young GC&#x2F;Minor GC：年轻代的 Eden 区满时触发，回收年轻代的对象。</li><li>Full GC&#x2F;Major GC：老年代空间不足时或显式调用 <code>System.gc()</code> 时触发，回收老年代和年轻代的对象。</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记-清除算法：标记-清除算法是最基础的垃圾回收算法，分为标记和清除两个阶段。标记阶段遍历所有对象，标记出所有存活的对象；清除阶段清除所有未标记的对象。<ul><li>存在两个问题： 1. 效率问题：标记和清除两个过程效率都不高。 2. 空间问题：标记清除后会产生大量不连续的内存碎片，导致大对象无法分配内存。</li></ul></li><li>复制算法：复制算法将内存分为两块，每次只使用其中一块。当这一块内存用完后，将存活的对象复制到另一块内存中，然后清除当前内存。这样可以避免内存碎片化问题。这种算法实现简单，运行高效，不会产生内存碎片。<ul><li>存在两个问题：1. 内存利用率低，只有一半的内存可以使用。2. 不适用于老年代，因为老年代存活对象较多，复制成本高。</li></ul></li><li>标记-整理算法：标记-整理算法是根据老年代的特点提出的一种标记算法，它在标记阶段完成后，将存活的对象向一端移动，然后清除边界外的对象。这样可以避免内存碎片化问题。<ul><li>问题：整理的过程效率也不高。</li></ul></li><li>分代收集算法：分代收集算法是目前主流的垃圾回收算法，它根据对象存活周期的不同将内存划分为不同的区域，每个区域采用适合的垃圾回收算法。一般将堆内存划分为新生代和老年代，新生代使用标记-复制算法，老年代使用标记-整理算法。</li></ul><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>默认收集器：<br>JDK 8：Parallel Scavenge(新生代)+ Parallel Old(老年代)<br>JDK 9 ~ JDK20： G1(Garbage-First)收集器</p><ul><li>Serial 收集器：Serial 收集器是最基础的垃圾收集器，它是单线程的收集器，只会使用一个线程进行垃圾回收，在进行垃圾收集工作的时候必须暂停其他所有的工作线程(“Stop The World”)，直到它收集结束。Serial 收集器适用于单核处理器和小内存的环境。使用标记-清除(Mark-Sweep)和复制算法。</li><li>ParNew 收集器：ParNew 收集器是 Serial 收集器的多线程版本，它可以使用多个线程进行垃圾回收。ParNew 收集器适用于多核处理器和多线程环境。使用复制算法。</li><li>Parallel Scavenge 收集器：Parallel Scavenge 收集器是一种以获取最大吞吐量为目标的收集器，它使用多线程进行垃圾回收，可以充分利用多核处理器的优势。Parallel Scavenge 收集器适用于对吞吐量要求较高的应用。使用复制算法。</li><li>Serial Old 收集器：Serial Old 收集器是 Serial 收集器的老年代版本，它使用单线程进行垃圾回收，适用于单核处理器和小内存的环境。使用标记-压缩算法。</li><li>Parallel Old 收集器：Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，它使用多线程进行垃圾回收，适用于多核处理器和多线程环境。使用标记-压缩算法。</li><li>CMS 收集器：CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，它使用多线程进行垃圾回收，可以显著减少垃圾回收的停顿时间。CMS 收集器适用于对停顿时间要求较高的应用。使用标记-清除算法，主要目标是缩短垃圾回收的停顿时间，分为初始标记、并发标记、重新标记、并发清除四个阶段。</li><li>G1 收集器：G1 收集器是一种面向服务端应用的垃圾收集器，它将堆内存划分为多个区域，每个区域可以根据垃圾回收的需要进行独立回收。G1 收集器适用于大内存、多核处理器和对停顿时间要求较高的应用。使用标记-清除和区域分代相结合的方式，堆内存被划分为多个区域，回收时首先处理垃圾最多的区域，以尽量缩短停顿时间。</li><li>ZGC 收集器：ZGC 收集器是一种低延迟的垃圾收集器，它可以在几毫秒内完成垃圾回收，适用于对停顿时间要求极高的应用。使用标记-压缩算法。</li></ul><h4 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h4><ul><li>防止内存泄漏：手动管理内存容易导致内存泄漏，而GC可以自动回收不再使用的对象，防止内存泄漏的发生。</li><li>提高开发效率：程序员不再需要关心内存释放的问题，可以更加集中精力在业务逻辑的实现上。</li><li>系统性能和稳定性：通过有效的垃圾回收策略，可以保证系统的性能和稳定性。</li></ul><h4 id="CMS垃圾回收器流程"><a href="#CMS垃圾回收器流程" class="headerlink" title="CMS垃圾回收器流程"></a>CMS垃圾回收器流程</h4><p>CMS(Concurrent Mark-Sweep)收集器是一种以最小化停顿时间为目标的垃圾收集器，适用于对响应时间要求较高的应用。它的垃圾清理流程分为四个主要阶段：</p><ol><li>初始标记(Initial Mark)<ul><li>目的：标记所有直接可达的对象(GC Roots直接引用的对象)。</li><li>特点：该阶段是“Stop The World”事件，需要暂停所有应用线程，但时间非常短，因为只标记与GC Roots直接关联的对象。</li></ul></li><li>并发标记(Concurrent Mark)<ul><li>目的：从初始标记阶段标记的对象开始，进行整个堆中的对象图遍历，标记出所有可达的对象。</li><li>特点：该阶段是并发的，不会暂停应用线程。应用程序可以继续运行，GC线程与应用线程并发执行。</li></ul></li><li>重新标记(Remark)<ul><li>目的：修正并发标记阶段由于应用程序继续运行而产生的标记变化，确保所有存活对象都被正确标记。</li><li>特点：这是一个“Stop The World”事件，需要短暂暂停应用线程，但时间比初始标记稍长，因为需要处理更多的标记变化。</li></ul></li><li>并发清除(Concurrent Sweep)<ul><li>目的：清理掉标记为不可达的对象，回收它们占用的内存。</li><li>特点：该阶段是并发的，和应用线程一起运行，不会影响应用的执行。</li></ul></li></ol><p><strong>CMS收集器的特点</strong></p><ul><li>碎片化问题：由于CMS使用的是标记-清除算法，它不会对堆进行压缩，可能会导致内存碎片化，从而引发“浮动垃圾”问题(在并发清除阶段，新产生的垃圾无法立即清理)。</li><li>并发模式失效：如果在清理过程中，内存分配的速度快于垃圾回收的速度，CMS可能会触发“Concurrent Mode Failure”，此时会退回到Serial Old收集器进行垃圾回收，导致长时间的停顿。</li></ul><p><strong>优点与适用场景</strong></p><ul><li>优点：CMS最大的优点是可以显著减少应用的停顿时间，非常适合需要低延迟的应用场景。</li><li>适用场景：CMS适用于需要快速响应的服务端应用，例如高并发的Web服务、实时系统等。</li></ul><h4 id="Full-Young-GC区别"><a href="#Full-Young-GC区别" class="headerlink" title="Full&#x2F;Young GC区别"></a>Full&#x2F;Young GC区别</h4><p>Young GC(Minor GC)</p><ul><li>作用范围：只回收 <strong>年轻代(Young Generation)</strong> 中的内存。</li><li>触发条件：当年轻代中的 <strong>Eden 区</strong> 填满时触发，回收 Eden 区中的无用对象，并将存活对象移动到 Survivor 区。</li><li>回收算法：一般使用 **复制算法(Copying Algorithm)**，将存活对象从 Eden 区复制到 Survivor 区，或者将存活对象晋升到老年代(Old Generation)中。</li><li>执行速度：因为年轻代对象大多数是短生命周期的，所以回收速度较快，回收频繁。</li><li>影响：对应用的暂停时间较短(STW，Stop the World)，回收效率高。</li></ul><p>Full GC(Major GC)</p><ul><li>作用范围：回收整个堆内存，包括 <strong>年轻代</strong> 和 <strong>老年代</strong>，以及 **元空间(Metaspace)**。</li><li>触发条件：<ul><li>老年代空间不足。</li><li>显式调用 <code>System.gc()</code>。</li><li>为了腾出足够的空间将存活的年轻代对象晋升到老年代时，发现老年代空间不足。</li><li>永久代(PermGen)或元空间(Metaspace)溢出时。</li><li>老年代对象经过多次 Young GC 仍然存活，无法移动到 Survivor 区。</li></ul></li><li>回收算法：通常使用 <strong>标记-清除(Mark-Sweep)</strong> 或 <strong>标记-整理(Mark-Compact)</strong> 算法，因为老年代中对象存活时间长，不适合复制算法。</li><li>执行速度：Full GC 通常比 Young GC 慢得多，因为涉及到更多的对象和整个堆内存的清理。</li><li>影响：Full GC 会导致较长的应用暂停时间，可能对性能敏感的应用造成较大的影响。</li></ul><h4 id="Full-GC详细流程"><a href="#Full-GC详细流程" class="headerlink" title="Full GC详细流程"></a>Full GC详细流程</h4><p>Full GC 是对整个堆空间进行清理，包括年轻代和老年代，其过程相对复杂，通常分为以下几个步骤：</p><ol><li>标记阶段<ul><li>根可达性分析：Full GC 首先从一组称为 GC Roots 的对象开始进行根可达性分析。GC Roots 包括线程栈中的局部变量、静态变量、活动线程、类加载器等。</li><li>标记存活对象：遍历所有可达的对象，标记它们为活跃的，表示这些对象不能被回收。</li></ul></li><li>清除阶段<ul><li>回收不可达对象：标记阶段结束后，JVM 会清理所有没有被标记为存活的对象，释放这些对象所占用的内存。</li><li>问题：标记-清除阶段可能会导致内存碎片化，因为被清理的对象可能不连续。</li></ul></li><li>整理阶段(仅在需要时执行)<ul><li>整理内存空间：在一些回收器中(例如使用标记-整理算法的垃圾回收器)，Full GC 不仅会清理无用的对象，还会将存活的对象整理到堆的一侧，以消除内存碎片。</li><li>对象压缩：存活对象会被压缩到堆的一端，腾出连续的内存空间，提高后续内存分配的效率。</li></ul></li><li>元空间清理：Full GC 还会回收 元空间 中的类元数据，尤其是在类卸载后，JVM 需要回收被卸载类的相关元数据。</li><li>触发 Finalize 方法(如果有)：如果对象有 <code>finalize()</code> 方法且没有被标记为存活，那么 GC 在执行回收前会调用该对象的 <code>finalize()</code> 方法，给对象最后一次自救的机会。不过，在实际编程中应尽量避免使用 <code>finalize()</code> 方法，因为它会延迟对象的回收，并增加 GC 的复杂性。</li></ol><p><strong>Full GC 的优化建议</strong></p><ul><li>调优 GC 参数：通过合理配置堆大小、年轻代与老年代的比例、GC 回收器等，可以降低 Full GC 的频率。</li><li>减少老年代内存分配：减少对象长期存活的时间，避免对象过早晋升到老年代。例如，通过调节对象的晋升阈值。</li><li>使用适合的 GC 算法：如果应用对暂停时间敏感，建议使用 G1 GC 或 CMS GC，而不是 Full GC 次数较多的 Serial 或 Parallel GC。</li></ul><h4 id="Young-GC详细流程"><a href="#Young-GC详细流程" class="headerlink" title="Young GC详细流程"></a>Young GC详细流程</h4><p>Young GC是 JVM 垃圾回收的一部分，专门负责回收堆内存中的 <strong>年轻代</strong>。年轻代中的对象大多是生命周期较短的新创建对象，因此 Young GC 的回收频率较高，通常在 <strong>Eden 区满时</strong> 触发。</p><p>Young GC 主要使用 <strong>复制算法</strong>，该算法具有高效的回收性能。其具体步骤如下：</p><ol><li>标记存活对象<ul><li>根可达性分析：Young GC 首先从 GC Roots(如栈帧中的引用、静态变量等)开始，标记所有从 GC Roots 可达的对象为存活对象。<ul><li>GC Roots 的引用遍历包括：<ul><li>当前执行线程栈中的所有局部变量和方法参数。</li><li>各种类的静态成员。</li><li>JNI 引用和当前执行线程。</li></ul></li></ul></li><li>标记存活对象：遍历 GC Roots，找到所有直接或间接被引用的对象，将它们标记为存活对象。</li></ul></li><li>回收 Eden 区<ul><li>清理 Eden 区：在完成标记后，Eden 区中没有被标记为存活的对象将被视为垃圾，所有这些对象的内存将被释放。</li><li>复制存活对象：Eden 区中被标记为存活的对象将被复制到其中一个 Survivor 区(S0 或 S1)。</li></ul></li><li>处理 Survivor 区<ul><li>复制 Survivor 区存活对象：处理上一次 GC 存放在当前 Survivor 区中的对象。这些对象也会被再次进行根可达性分析，并标记存活对象。存活的对象会被复制到另一个 Survivor 区(从 S0 到 S1，或从 S1 到 S0)。</li><li>晋升到老年代：如果某些对象经过多次 Young GC 后仍然存活，并且达到了设定的 晋升阈值，这些对象将会被移动到老年代。通常，晋升阈值是指对象在 Survivor 区中经过的 GC 次数，当次数达到阈值后，对象就会被晋升到老年代。<ul><li>晋升阈值是可配置的，默认情况下，对象在 Survivor 区中经历 15 次 GC 后被晋升到老年代。可以通过 JVM 参数 <code>-XX:MaxTenuringThreshold</code> 来调整这个值。</li></ul></li></ul></li><li>切换 Survivor 区</li></ol><ul><li>Survivor 区交替使用：在每次 Young GC 结束后，两个 Survivor 区会进行交换。当前的 Survivor 区 S0 中的存活对象会被复制到 S1，下次 GC 时，S1 就会成为复制目标区域，S0 则会被清空。</li></ul><p><strong>Young GC 调优</strong></p><ul><li>Eden 和 Survivor 区比例：可以通过 JVM 参数 <code>-XX:SurvivorRatio</code> 来调整 Eden 区与 Survivor 区的比例。默认情况下，Eden 区较大，两个 Survivor 区较小，这样可以减少对象在 Survivor 区之间来回复制的次数。</li><li>晋升阈值：可以通过 <code>-XX:MaxTenuringThreshold</code> 来调整对象晋升到老年代的阈值。如果应用程序中对象的生命周期较长，可以适当提高晋升阈值，减少老年代的内存压力。</li><li>并行 GC：使用 Parallel GC 或 G1 GC 可以减少 STW 的时间，提高垃圾回收的效率。</li></ul><h3 id="强引用-软引用-弱引用-虚引用✅"><a href="#强引用-软引用-弱引用-虚引用✅" class="headerlink" title="强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅"></a>强引用&#x2F;软引用&#x2F;弱引用&#x2F;虚引用✅</h3><p><a href="https://blog.csdn.net/u013718071/article/details/134789666">https://blog.csdn.net/u013718071/article/details/134789666</a><br>Java中的引用类型主要分为强引用、软引用、弱引用和虚引用，它们之间的区别主要体现在垃圾回收的行为上。</p><ul><li>强引用(Strong Reference)：这是使用最普遍和默认的引用类型。如果一个对象具有强引用，那么垃圾回收器就永远不会回收它。当内存空间不足，Java虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，也不会回收这种对象。</li><li>软引用(Soft Reference)：软引用是用来描述一些还有用但并非必需的对象。只有当JVM认为内存不足时，才会去剔除这些基于软引用的对象。在Java中，可以用 <code>SoftReference</code> 类来实现软引用。</li><li>弱引用(Weak Reference)：弱引用则是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在Java中，可以用 <code>WeakReference</code> 类来实现弱引用。</li><li>虚引用(Phantom Reference)：虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与其他几种引用的一个区别在于：虚引用必须和引用队列(<code>ReferenceQueue</code>)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，将这个虚引用加入到与之关联的引用队列中。</li></ul><p>以上四种引用类型，强度依次递减：强引用最强，虚引用最弱。在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出(OutOfMemory)等问题的产生。</p><h3 id="对象的创建过程-5步"><a href="#对象的创建过程-5步" class="headerlink" title="对象的创建过程(5步)"></a>对象的创建过程(5步)</h3><ol><li>类加载检查。虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li>分配内存。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li><li>初始化零值。内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li>设置对象头。初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li>执行 <code>init</code> 方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域：</p><ul><li>对象头(<code>Header</code>)：<ul><li>标记字段(<code>Mark Word</code>)：用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li>类型指针(<code>Klass Word</code>)：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul></li><li>实例数据(<code>Instance Data</code>)： 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li><li>对齐填充(<code>Padding</code>)： 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。</p><ul><li>句柄。如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</li><li>直接指针。如果使用直接指针访问，reference 中存储的直接就是对象的地址。</li></ul><p>两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h3 id="如何判断一个类是无用的"><a href="#如何判断一个类是无用的" class="headerlink" title="如何判断一个类是无用的"></a>如何判断一个类是无用的</h3><p>类需要同时满足下面 3 个条件才能算是 “无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以(不是必然)对满足上述 3 个条件的无用类进行回收</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)。</p><p>其中验证、准备、解析 3 部分统称为连接。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>分三步：加载、连接(验证、准备、解析)、初始化。</p><p><strong>加载</strong><br>加载使用类加载器完成。类加载器有很多种，当想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定。加载主要分下面三步：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><blockquote><p>加载和连接阶段的部分动作(如验证)是交叉进行的。加载还没结束，连接可能就已经开始了。</p></blockquote><p><strong>验证</strong><br>连接的第一步，确保 <code>Class</code> 文件的字节流中包含的信息符合规范，并且不会危害虚拟机自身的安全。主要包括四个阶段：</p><ol><li>文件格式验证：验证字节流是否符合 Class 文件格式规范。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其符合 Java 语言规范。<ul><li>如验证类是否有父类</li></ul></li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<ul><li>如验证函数的参数是否正确</li></ul></li><li>符号引用验证：确保解析动作能正确执行。<ul><li>如验证该类要使用的其他类、方法是否存在。</li></ul></li></ol><p><strong>准备</strong><br>连接的第二步，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(Java 7 之前分配在永久代，Java 8 之后移动到堆中)中分配。</p><ul><li>进行内存分配的仅包括类变量(被<code>static</code>修饰)而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>初始值是数据类型的默认值，如 0、null 等。</li></ul><p><strong>解析</strong><br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。主要包括类或接口、字段、类方法、接口方法、方法类型等。</p><p><strong>初始化</strong><br>初始化阶段是执行初始化方法 <code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p>卸载类即该类的 <code>Class</code> 对象被 GC。</p><p>卸载类需要满足 3 个要求：</p><ul><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ul><p>在 JVM 生命周期内，由 JVM 自带的类加载器加载的类(如<code>BootstrapClassLoader</code>、<code>ExtClassLoader</code>、<code>AppClassLoader</code> )是不会被卸载的。但是由自定义的类加载器加载的类是可能被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器是一个负责加载类的对象。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 创建的(数组类没有对应的二进制字节流)，是由 JVM 直接生成的。</p><blockquote><p>类加载器的主要作用就是加载 Java 类的字节码( .class 文件)到 JVM 中(在内存中生成一个代表该类的 Class 对象)。</p></blockquote><p>JVM内置三个重要的类加载器：<br><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 <code>null</code>，并且没有父级，主要用来加载 JDK 内部的核心类库。<br><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<br><code>AppClassLoader</code>(应用程序类加载器)：面向用户的加载器，负责加载当前应用 <code>classpath</code> 下的所有 jar 包和类。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型是一种类加载器的层次结构，每个类加载器都有一个父类加载器。当一个类加载器收到加载类的请求时，它会先将请求委派给父类加载器，直到最顶层的类加载器。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。</p><p><strong>优点</strong><br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类)，也保证了 Java 的核心 API 不被篡改。</p><p>如果需要打破双亲委派模型，需要自定义类加载器，并重写 <code>loadClass</code> 方法。</p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>IO(<code>Input/Output</code>)即输入&#x2F;输出，数据输入到计算机内存的过程即输入，反之输出到外部存储(比如数据库，文件，远程主机)的过程即输出。</p><p>IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream/Reader</code>： 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream/Writer</code>： 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="Stream流中的map和flatMap区别"><a href="#Stream流中的map和flatMap区别" class="headerlink" title="Stream流中的map和flatMap区别"></a>Stream流中的map和flatMap区别</h3><ul><li><code>map</code><ul><li>作用：<code>map</code>函数用于对流中的每一个元素执行一个给定的函数，并将结果作为新的流返回。这意味着，如果原始流中有n个元素，那么处理后的流也将有n个元素，只不过这些元素是原始元素经过函数处理后的结果。</li><li>返回值：<code>map</code>函数的返回值是一个新的流，这个流中的元素是原始流中每个元素经过函数转换后的结果。重要的是，如果函数返回的是一个集合或数组，那么这个集合或数组会被视为流中的一个单独元素。</li><li>应用场景：需要对流中的每个元素进行一对一的转换，并且不需要改变流中元素的数量时，可以使用<code>map</code>。</li></ul></li><li><code>flatMap</code><ul><li>作用：<code>flatMap</code>函数也用于对流中的每一个元素执行一个给定的函数，但与<code>map</code>不同的是，该函数必须返回一个流。然后，<code>flatMap</code>会将所有这些流“扁平化”为一个单一的流。这意味着，如果原始流中的某个元素经过函数处理后产生了m个元素，那么这些元素都会被添加到最终的流中，从而导致最终流的元素数量可能与原始流不同。</li><li>返回值：<code>flatMap</code>函数的返回值是一个扁平化后的新流，这个流包含了原始流中所有元素经过函数处理并扁平化后的结果。</li><li>应用场景：需要对流中的每个元素执行一对多的转换，或者需要处理嵌套集合(如二维数组或二维集合类)时，用<code>flatMap</code>。它能够将嵌套的结构扁平化，从而方便地进行后续操作。</li></ul></li></ul><h3 id="Java为什么要分字节流和字符流"><a href="#Java为什么要分字节流和字符流" class="headerlink" title="Java为什么要分字节流和字符流"></a>Java为什么要分字节流和字符流</h3><p>Java 分为字符流和字节流是为了更好地处理不同类型的数据、简化程序编写和提高代码的可读性与可维护性。</p><ul><li>字符流自动处理字符编码问题，非常适合文本数据；</li><li>字节流则适合处理所有类型的文件，特别是非文本数据如图片、视频、音频等。</li></ul><h3 id="字节流和字符流区别"><a href="#字节流和字符流区别" class="headerlink" title="字节流和字符流区别"></a>字节流和字符流区别</h3><ul><li>字节流处理的基本单位是字节(8 bit)，字符流处理的基本单位是字符(16 bit)。</li><li>字节流可以处理所有类型的数据，包括二进制文件(如图像、视频、音频)以及文本文件，字符流专门用于处理文本数据(字符数据)，适合处理各种语言的文本文件。</li><li>字节流不进行字符编码转换，直接读写原始的二进制数据，字符流自动进行字符编码和解码，读写时可以处理不同的字符集(如UTF-8、UTF-16、ISO-8859-1等)。</li></ul><h3 id="IO设计模式总结"><a href="#IO设计模式总结" class="headerlink" title="IO设计模式总结"></a>IO设计模式总结</h3><ul><li>装饰器模式：可以在不改变原有对象的情况下拓展其功能。可以对原始类嵌套使用多个装饰器类。</li><li>适配器模式：主要用于接口互不兼容的类的协调工作，适配器分为对象适配器和类适配器，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</li><li>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li><li>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。</li></ul><h3 id="装饰器模式和适配器模式区别"><a href="#装饰器模式和适配器模式区别" class="headerlink" title="装饰器模式和适配器模式区别"></a>装饰器模式和适配器模式区别</h3><ul><li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li><li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。</li></ul><h3 id="3种常见的IO模型"><a href="#3种常见的IO模型" class="headerlink" title="3种常见的IO模型"></a>3种常见的IO模型</h3><ul><li>BIO(<code>Blocking IO</code>)：同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。<ul><li>优点：编程简单，代码易于理解。</li><li>缺点：并发性能低，每个连接都需要独立的线程进行处理，线程资源消耗大。</li></ul></li><li>NIO(<code>Non-blocking IO</code>)：同步非阻塞 IO 模型中，应用程序发起 read 调用后，会立即返回，不会阻塞，应用程序需要不断轮询内核，直到数据准备好。<ul><li>优点：单线程可以处理多个连接，提高并发性能。</li><li>缺点：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</li></ul></li><li>AIO(<code>Asynchronous IO</code>)：异步非阻塞 IO 模型中，应用程序发起 read 调用后，不会阻塞，内核会在数据准备好后通知应用程序。<ul><li>优点：异步 IO 模型的优势在于 IO 操作完全由操作系统来完成，应用程序只需要在数据准备好时得到通知，不需要不断轮询内核。</li><li>缺点：AIO 是 Java 7 引入的，不太常用，且实现较为复杂。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN/LSTM/GRU/GCN</title>
      <link href="/posts/17765.html"/>
      <url>/posts/17765.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近对强化学习算法和预测结合有些想法，阅读了下面两篇文章对之有了大致认识。</p></blockquote><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/587276701">https://zhuanlan.zhihu.com/p/587276701</a><br>参考：<a href="https://zhuanlan.zhihu.com/p/605750441">https://zhuanlan.zhihu.com/p/605750441</a></p></blockquote><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p>传统的神经网络只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。</p><p>由此诞生了RNN。</p><p>循环神经网络(Recurrent Neural Network, RNN)是一类以序列(sequence)数据为输入，在序列的演进方向进行递归(recursion)且所有节点(循环单元)按链式连接的递归神经网络。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_1.png" alt="img_1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x 输入层 向量</span><br><span class="line">U 输入层到隐藏层的 权重矩阵</span><br><span class="line">s 隐藏层 向量</span><br><span class="line">V 隐藏层到输出层的 权重矩阵</span><br><span class="line">o 输出层 向量</span><br><span class="line">W 上一次隐藏层的值作为这一次输入的权重 权重矩阵</span><br></pre></td></tr></table></figure><p>循环神经网络的隐藏层的值s不仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_2.png" alt="img_2.png"></p><p>具体的抽象图：<br><img src="/../image/RNN-LSTM-GRU-GCN/img.png" alt="img.png"></p><h2 id="长短期记忆网络LSTM"><a href="#长短期记忆网络LSTM" class="headerlink" title="长短期记忆网络LSTM"></a>长短期记忆网络LSTM</h2><p>长短期记忆(Long short-term memory, LSTM)是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p><p><img src="/../image/RNN-LSTM-GRU-GCN/img_3.png" alt="img_3.png"><br>(左：RNN，右：LSTM)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MARL</title>
      <link href="/posts/17763.html"/>
      <url>/posts/17763.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于我的科研方向是<code>多智能体强化学习</code>，且由于研一忙于课程和一些开源项目，导致我对一些科研方面的算法理解不够充分。刚好，最近一次和东大的联合组会轮到我讲了，借此深度理解一下这些算法。</p></blockquote><blockquote><p>在这篇笔记中，我会总结我的直系学长推荐我先看的多智能体强化学习知乎专栏内容，然后如果有时间，再总结我导师之前发给我让我看的论文。相关链接我会放在下面。</p></blockquote><p>知乎专栏：<a href="https://www.zhihu.com/column/c_1061939147282915328">https://www.zhihu.com/column/c_1061939147282915328</a></p><h2 id="基础知识与博弈"><a href="#基础知识与博弈" class="headerlink" title="基础知识与博弈"></a>基础知识与博弈</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在多智能体系统中，每个智能体通过与环境进行交互获取奖励值(reward)来学习改善自己的策略，从而获得该环境下最优策略的过程就多智能体强化学习。</p><p>在单智能体强化学习中，智能体所在的环境是稳定不变的，但是在多智能体强化学习中，环境是复杂的、动态的，因此给学习过程带来很大的困难。</p><ol><li>维度爆炸：在单体强化学习中，需要存储状态值函数或动作-状态值函数。在多体强化学习中，状态空间变大，联结动作空间随智能体数量指数增长，维度非常大，计算复杂。</li><li>目标奖励确定困难：多智能体系统中每个智能体的任务可能不同，但是彼此之间又相互耦合影响。奖励设计的优劣直接影响学习到的策略的好坏。</li><li>不稳定性：在多智能体系统中，多个智能体是同时学习的。当同伴的策略改变时，每个智能体自身的最优策略也可能会变化，这将对算法的收敛性带来影响。</li><li>探索-利用：探索不光要考虑自身对环境的探索，也要对同伴的策略变化进行探索，可能打破同伴策略的平衡状态。每个智能体的探索都可能对同伴智能体的策略产生影响，这将使算法很难稳定，学习速度慢。</li></ol><p>多智能体系统中智能体之间可能涉及到合作与竞争等关系，引入博弈的概念，将博弈论与强化学习相结合可以很好的处理这些问题。</p><h3 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h3><p><img src="/../image/MARL/img_1.png" alt="img_1.png"></p><h3 id="完全混合策略"><a href="#完全混合策略" class="headerlink" title="完全混合策略"></a>完全混合策略</h3><p>若一个策略对于智能体动作集中的所有动作的概率都大于0，则这个策略为一个完全混合策略。</p><h3 id="纯策略"><a href="#纯策略" class="headerlink" title="纯策略"></a>纯策略</h3><p>若智能体的策略对一个动作的概率分布为1，对其余的动作的概率分布为0，则这个策略为一个纯策略。</p><h3 id="零和博弈"><a href="#零和博弈" class="headerlink" title="零和博弈"></a>零和博弈</h3><p>零和博弈中，两个智能体是完全竞争对抗关系，则 <code>R1 = - R2</code> 。在零和博弈中只有一个纳什均衡值，即使可能有很多纳什均衡策略，但是期望的奖励是相同的。</p><h3 id="一般和博弈"><a href="#一般和博弈" class="headerlink" title="一般和博弈"></a>一般和博弈</h3><p>一般和博弈是指任何类型的矩阵博弈，包括完全对抗博弈、完全合作博弈以及二者的混合博弈。在一般和博弈中可能存在多个纳什均衡点。</p><blockquote><p>矩阵博弈和线性规划求双智能体矩阵博弈的纳什均衡策略可以看这篇：<a href="https://zhuanlan.zhihu.com/p/53474965">https://zhuanlan.zhihu.com/p/53474965</a></p></blockquote><h2 id="Minimax-Q"><a href="#Minimax-Q" class="headerlink" title="Minimax-Q"></a>Minimax-Q</h2><p>论文：<a href="https://courses.cs.duke.edu/spring07/cps296.3/littman94markov.pdf">Markov games as a framework for multi-agent reinforcement learning</a></p><p>Minimax-Q算法应用于<code>两个玩家的零和随机博弈中</code>。<code>Minimax-Q中的Minimax指的是使用minimax方法构建线性规划来求解每个特定状态s的阶段博弈的纳什均衡策略。Q指的是借用Q-learning中的TD方法来迭代学习状态值函数或动作-状态值函数。</code></p><p>在两玩家零和随机博弈中，给定一个状态s，则定义第i个智能体的状态值函数如下：意义为，<code>每个智能体最大化在与对手博弈中最差情况下的期望奖励值</code>。</p><p><img src="/../image/MARL/img_2.png" alt="img_2.png"></p><p>理想情况，如果算法能够对每一个状态-动作对访问无限次，那么该算法能够收敛到纳什均衡策略。但是在上述算法中存在几个缺点：</p><ol><li>在第5步中需要不断求解一个线性规划，这将造成学习速度的降低，增加计算时间。</li><li>为了求解第5步，智能体i需要知道所有智能体的动作空间，这个在分布式系统中将无法满足。</li><li>只满足收敛性，不满足合理性。Minimax-Q算法能够找到多智能体强化学习的纳什均衡策略，但是假设对手使用的不是纳什均衡策略，而是一个较差的策略，则当前智能体并不能根据对手的策略学习到一个更优的策略。该算法无法让智能体根据对手的策略来调节优化自己的策略，而只能找到随机博弈的纳什均衡策略。这是由于Minimax-Q算法是一个对手独立算法(opponent-independent algorithm)，不论对手策略是怎么样的，都收敛到该博弈的纳什均衡策略。就算对手采用一个非常弱的策略，当前智能体也不能学习到一个比纳什均衡策略更好的策略。</li></ol><h2 id="Nash-Q-Learning"><a href="#Nash-Q-Learning" class="headerlink" title="Nash Q-Learning"></a>Nash Q-Learning</h2><p>论文：<a href="https://www.jmlr.org/papers/volume4/temp/hu03a.pdf">Nash Q-learning for general-sum stochastic games</a></p><p>Nash Q-Learning算法是将Minimax-Q算法<code>从零和博弈扩展到多人一般和博弈</code>的算法。在Minimax-Q算法中需要通过Minimax线性规划求解阶段博弈的纳什均衡点，拓展到<code>Nash Q-Learning算法就是使用二次规划求解纳什均衡点</code>。Nash Q-Learning算法在合作性均衡或对抗性均衡的环境中能够收敛到纳什均衡点，其收敛性条件是，在每一个状态s的阶段博弈中，都能够找到一个全局最优点或者鞍点，只有满足这个条件，Nash Q-Learning算法才能够收敛。与Minimax-Q算法相同，Nash Q-Learning算法求解二次规划的过程也非常耗时，降低了算法的学习速度。</p><p>其算法流程如下：</p><p><img src="/../image/MARL/img_3.png" alt="img_3.png"></p><p>该算法需要观测其他所有智能体的动作ai与奖励值ri。并且与Minimax-Q算法一样，只满足收敛性，不满足合理性。只能收敛到纳什均衡策略，不能根据其他智能体的策略来优化调剂自身的策略。</p><h2 id="Friend-or-Foe-Q-Learning"><a href="#Friend-or-Foe-Q-Learning" class="headerlink" title="Friend-or-Foe Q-Learning"></a>Friend-or-Foe Q-Learning</h2><p>论文：<a href="https://www.researchgate.net/profile/Michael-Littman/publication/2933305_Friend-or-Foe_Q-learning_in_General-Sum_Games/links/54b66cb80cf24eb34f6d19dc/Friend-or-Foe-Q-learning-in-General-Sum-Games.pdf">Friend-or-foe Q-learning in general-sum games</a></p><p>Friend-or-Foe Q-Learning(FFQ)算法也是从Minimax-Q算法拓展而来。为了能够处理一般和博弈，FFQ算法对一个智能体i，将其他所有智能体分为两组，一组为i的friend帮助i一起最大化其奖励回报，另一组为i的foe对抗i并降低i的奖励回报，因此对每个智能体而言都有两组。这样一个n智能体的一般和博弈就转化为了一个两智能体的零和博弈。</p><p>其纳什均衡策略求解方法如下所示：</p><p><img src="/../image/MARL/img_4.png" alt="img_4.png"></p><p>算法流程如下：</p><p><img src="/../image/MARL/img_5.png" alt="img_5.png"></p><p>有一种利用Minimax-Q算法进行多人博弈方法为，两队零和博弈，将所有智能体分成两个小组进行零和博弈。两队零和博弈中每一组有一个leader才控制这一队智能体的所有策略，获取的奖励值也是这一个小组的整体奖励值。</p><p>FFQ算法没有team learder，每个人选择自己动作学习自己的策略获得自己的奖励值，但是为了更新值，每个智能体需要在每一步观测其他所有friend与foe的执行动作。</p><p>FFQ与Minimax-Q算法一样都需要利用线性规划，因此算法整体学习速度会变慢。</p><h2 id="WoLF-Policy-Hill-Climbing"><a href="#WoLF-Policy-Hill-Climbing" class="headerlink" title="WoLF Policy Hill-Climbing"></a>WoLF Policy Hill-Climbing</h2><p>论文：<a href="https://pdf.sciencedirectassets.com/271585/1-s2.0-S0004370200X00872/1-s2.0-S0004370202001212/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEGUaCXVzLWVhc3QtMSJHMEUCIQC83rDT43qYROWb01kvyuybyC5EMghziFRQfbzKh2phkAIgDDv7TwK+il2pEyYMJNLreVUvpkwWBgC41FYPaJ1i06cqvAUInf//////////ARAFGgwwNTkwMDM1NDY4NjUiDDwT6ryaWf366e7YEyqQBSV+k4Sy0RKqs/FblDXiW14ORHDzZeMEKYZ5LfWZdVYpVxwo4vTYmKH2nercH63Et4tIjK0e9nL/zjvPpjmkrFWHn6hO0F8KjMsnwlmzVepHF0btXh7AkZ3e5t/2bnTZ7qTDIfyIUlvNHlEKL/9K5mHZexxj3w3tRoxmqUu8NYM6l2eVAv+cEGunXeil0OTm/SRkYiIlKRNiuZikU2EPu3h9Psh00bAXL07iFhI5W4y3QkVAmyWJ9ZRz3XtitHSz+TVlNngLHNqDlo4LosRLqb7IYbTMz8mTRt+upsy1T6e+t1k0PCXzBrMR4xqRuv006eN8HG7/OHDEpmrKu7kne4KeuWyh1qyIHWZOtG2cqhDN/+t8okdIhgmNbKIikDVOUqNwejq1Mnka+0qSkQ1BabTqjK1RKv1gFNC3vkHeEheIYU8+1kJIT3NWLWHfETSWvpuS6cVQSBNvCJ4CkXUMq3tQFOkc1B36oBuNEDLMvBXbjpYWp9DgKJ3yAeyqO8juXKnp5J/3NM7Uom6qpwgK4XNNxbXWrpzjYQpeahoFc2F9qyOzBHnX3mb+2+MdRq1fUwZ0fxzmF0HwBL8VcOWdbgiPhK6qDQmufFdZsMowZirITlDpFdg0pa5F4PkH+OpYXYXQA+usAbQ/JLnUibNKgBd8Ssk2Fj7+Aj1H1+7hEDC+KVib31jzGP9aBwfa76WjOdwk+/VtOJmEMkw2novRj1vcWCAOB3rfg5xFumwxuEK0uDT1R0He0KxhDRKGErfMTRXnb/yzBt5MLsmAz5g8wUFQtqhEq3QhLmuGTVdOVFkX6vG2qiPJMQFrehup1kL1jEGqTSK7K9pcr+Mh//5bt5/spmxqMvOBRUAeZCYaEAYlMMnvpqoGOrEBjuaNrgG15OoT+QiARadKSKYw5yb49jYpL5ODDxgi370KIIs7mCTNedup3876q1Q1OH4IMlTPYRONhLrYVCCr/op8JfLOur2Kx4cAbHsxPmwrtlKhbwv/ByOhbxlQf+UKhNjDXNuR1tSn0DNiTsUyHtUoHD5Pp7unY1PXGDGbYbrnCR7ByWapCYxFzQ1IqYENVSoMPhKfMoOaVw3CEXofL7EIi2a840t/p1COhmawkApQ&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20231107T051949Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYYPNOQKWR/20231107/us-east-1/s3/aws4_request&X-Amz-Signature=3d4d8f4e51351b7226cd8bc38cbc9fa5109884a7636050217642770bc18913c9&hash=c607cf9fed0bd128c473b32bef56a596967a6b23b8e4d2b87884f7626c46df4c&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0004370202001212&tid=spdf-d5458afb-6fde-4cc5-bd92-4518991575a2&sid=8008b1c63c486948dc7b9aa27c1ce9ec5b7fgxrqa&type=client&tsoh=d3d3LnNjaWVuY2VkaXJlY3QuY29t&ua=120e5c515d53530157&rr=82231f9f7f2904c0&cc=hk">Multiagent learning using a variable learning rate</a></p><p><img src="/../image/MARL/img_6.png" alt="img_6.png"></p><p>WolF是指，当智能体做的比期望值好的时候小心缓慢的调整参数，当智能体做的比期望值差的时候，加快步伐调整参数。</p><p>PHC是一种单智能体在稳定环境下的一种学习算法。该算法的核心就是通常强化学习的思想，增大能够得到最大累积期望的动作的选取概率。该算法具有合理性，能够收敛到最优策略。</p><p>其算法流程如下：</p><p><img src="/../image/MARL/img_7.png" alt="img_7.png"></p><p>为了将PHC应用于动态环境中，将WoLF与PHC算法结合，使得智能体获得的奖励在比预期差时，能够快速调整适应其他智能体策略变化，当比预期好时谨慎学习，给其他智能体适应策略变化的时间。并且WoLF-PHC算法能够收敛到纳什均衡策略，并且具备合理性，当其他智能体采用某个固定策略使，其也能收敛到一个目前状况下的最优策略而不是收敛到一个可能效果不好的纳什均衡策略处。在WoLF-PHC算法中，使用一个可变的学习速率 <code>δ</code> 来实现WoLF效果，当策略效果较差时使用 <code>δl</code> ，策略效果较好时使用 <code>δw</code> ，并且满足 <code>δl &gt; δw</code> 。还有一个优势是，WoLF-PHC算法不用观测其他智能体的策略、动作及奖励值，需要更少的空间去记录Q值，并且WoLF-PHC算法是通过PHC算法进行学习改进策略的，所以不需要使用线性规划或者二次规划求解纳什均衡，算法速度得到了提高。虽然WoLF-PHC算法在实际应用中取得了非常好的效果，并且能够收敛到最优策略。但是其收敛性在理论上一直没有得到证明。</p><p>其算法流程如下所示：</p><p><img src="/../image/MARL/img_8.png" alt="img_8.png"></p><blockquote><p>关于MiniMax-Q、Nash Q-Learning、Friend-or-Foe Q-Learning、WoLF Policy Hill-Climbing算法的详细介绍可以看这篇：<a href="https://www.cnblogs.com/zuti666/p/16909220.html">https://www.cnblogs.com/zuti666/p/16909220.html</a> 和 <a href="https://zhuanlan.zhihu.com/p/53563792">https://zhuanlan.zhihu.com/p/53563792</a></p></blockquote><h2 id="MADDPG"><a href="#MADDPG" class="headerlink" title="MADDPG"></a>MADDPG</h2><p>论文：<a href="https://arxiv.org/abs/1706.02275">Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments</a></p><p>OpenAI 2017发表在NIPS 上的一篇文章。主要是将AC算法进行了一系列改进，使其能够适用于传统RL算法无法处理的复杂多智能体场景。</p><p>传统RL算法面临的一个主要问题是由于每个智能体都是在不断学习改进其策略，因此从每一个智能体的角度看，环境是一个动态不稳定的，这不符合传统RL收敛条件。并且在一定程度上，无法通过仅仅改变智能体自身的策略来适应动态不稳定的环境。由于环境的不稳定，将无法直接使用之前的经验回放等DQN的关键技巧。policy gradient算法会由于智能体数量的变多使得本就有的方差大的问题加剧。</p><p>MADDPG算法具有以下三点特征： </p><ol><li>通过学习得到的最优策略，在应用时只利用局部信息就能给出最优动作。 </li><li>不需要知道环境的动力学模型以及特殊的通信需求。 </li><li>该算法不仅能用于合作环境，也能用于竞争环境。</li></ol><p>MADDPG算法具有以下三点技巧：</p><ol><li>集中式训练，分布式执行：训练时采用集中式学习训练critic与actor，使用时actor只用知道局部信息就能运行。critic需要其他智能体的策略信息，本文给了一种估计其他智能体策略的方法，能够只用知道其他智能体的观测与动作。</li><li>改进了经验回放记录的数据。为了能够适用于动态环境，每一条信息由(x, x’, a1,…, an, r1,…, rn)组成，X &#x3D; (o1,…, on)。表示每个智能体的观测。</li><li>利用策略集合效果优化(policy ensemble)：对每个智能体学习多个策略，改进时利用所有策略的整体效果进行优化。以提高算法的稳定性以及鲁棒性。</li></ol><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h4><p>深度Q网络(deep Q-network)<br><img src="/../image/MARL/img_9.png" alt="img_9.png"></p><h4 id="SPG"><a href="#SPG" class="headerlink" title="SPG"></a>SPG</h4><p>随机策略梯度(stochastic policy gradient)</p><p><img src="/../image/MARL/img_10.png" alt="img_10.png"></p><h4 id="DPG"><a href="#DPG" class="headerlink" title="DPG"></a>DPG</h4><p>确定性策略梯度(deterministic policy gradient)</p><p><img src="/../image/MARL/img_11.png" alt="img_11.png"></p><h3 id="MADDPG-1"><a href="#MADDPG-1" class="headerlink" title="MADDPG"></a>MADDPG</h3><h4 id="多智能体AC设计"><a href="#多智能体AC设计" class="headerlink" title="多智能体AC设计"></a>多智能体AC设计</h4><p>MADDPG集中式的学习，分布式的应用。因此允许使用一些额外的信息(全局信息)进行学习，只要在应用的时候使用局部信息进行决策就行。这点就是Q-learning的一个不足之处，Q-learning在学习与应用时必须采用相同的信息。所以这里MADDPG对传统的AC算法进行了一个改进，Critic扩展为可以利用其他智能体的策略进行学习，这点的进一步改进就是每个智能体对其他智能体的策略进行一个函数逼近。<br><img src="/../image/MARL/img_12.png" alt="img_12.png"><br><img src="/../image/MARL/img_13.png" alt="img_13.png"></p><h4 id="估计其他智能体策略"><a href="#估计其他智能体策略" class="headerlink" title="估计其他智能体策略"></a>估计其他智能体策略</h4><p><img src="/../image/MARL/img_14.png" alt="img_14.png"></p><h4 id="策略集合优化"><a href="#策略集合优化" class="headerlink" title="策略集合优化"></a>策略集合优化</h4><p><img src="/../image/MARL/img_15.png" alt="img_15.png"></p><h3 id="相关PPT"><a href="#相关PPT" class="headerlink" title="相关PPT"></a>相关PPT</h3><p><img src="/../image/MARL/img_16.png" alt="img_16.png"><br><img src="/../image/MARL/img_17.png" alt="img_17.png"><br><img src="/../image/MARL/img_18.png" alt="img_18.png"><br><img src="/../image/MARL/img_19.png" alt="img_19.png"><br><img src="/../image/MARL/img_20.png" alt="img_20.png"></p><h2 id="IQL"><a href="#IQL" class="headerlink" title="IQL"></a>IQL</h2><p>论文：<a href="https://arxiv.org/abs/1511.08779">Multiagent Cooperation and Competition with Deep Reinforcement Learning</a></p><p>Independent Q-Learning</p><p>本文讲的是介绍如何将DQN用到Multi-agent问题中，并表示最直接的方法就是，智能体把其他智能体喝环境看作整体，每个智能体之间的决策相互独立(用原文的话说就是each agent is controlled by an independent Deep Q-Network)。</p><p>IQL发现，两个智能体都独立采用DQN，在不修改除了reward外的任何参数、细节，agent都能取得不错的成绩。这说明IQL可以作为多智能体强化学习的baseline。</p><p>IQL(independent Q-learning)算法非常简单暴力地给每个智能体执行一个Deep-Q-learning算法。IQL把单智能体Deep-Q-learning算法直接应用在多智能体学习领域，各个智能体是各自为政的。<code>这是此类算法的一个极端。</code></p><p>其他没啥要讲的。。。</p><p><img src="/../image/MARL/img_21.png" alt="img_21.png"></p><h2 id="COMA"><a href="#COMA" class="headerlink" title="COMA"></a>COMA</h2><p>论文：<a href="https://arxiv.org/abs/1705.08926">Counterfactual Multi-Agent Policy Gradients</a></p><p>COMA (counterfactual multi-agent) 使用一个集中式的critic网络计算优势函数A，统一给Agenti计算对应的actioni分别去执行。所谓CTDE(central training decentralize execution)。COMA是把Actor-critic单智能体算法直接应用在多智能体学习领域，各个智能体按照集中的critic网络指令行事，它们是完全协作关系。<code>这是此类算法的另一个极端。</code><br><img src="/../image/MARL/img_23.png" alt="img_23.png"></p><p>多智能体强化学习算法必然都是在IQL和COMA两个算法之间做平衡。Agent既不能完全独立行事，也不能完全按中心节点指令行事。</p><p>那么这些算法都在解决什么问题呢？</p><p>只要模型共享Qtot值函数，团队奖励值ri有可能仅仅是某几个智能体获得的，其它智能体并没有做贡献但缺获得了奖励值ri。这就是所谓多智能体信用分配(credit assignment)问题。</p><p>在COMA算法中，为了解决多智能体信用分配问题，提出了优势函数A(遍历Agenti动作空间μi里的所有动作，而保持其它Agent的动作空间μ–不变，计算每个Agenti的参数值)，用来计算反事实基线(counterfactual baseline)。</p><p><img src="/../image/MARL/img_24.png" alt="img_24.png"></p><p>这个思想来自difference reward。difference reward的思想是：保持其他智能体的联合动作不动，把当前智能体的action替换为一个default action，检查值函数Q是否有变化，如果没有，代表当前智能体的action是无贡献的action，因为奖励r不是当前智能体的action获得的。但是difference reward思想有个问题，default action选谁？？？无法选择！！！为了解决这个问题，COMA定义了优势函数A，解决了多智能体信用分配问题。如果仔细看算法的A函数公式，它其实就是AC算法中常用的优势函数A在多智能体领域的扩展而已。</p><p><img src="/../image/MARL/img_25.png" alt="img_25.png"></p><p>COMA 与 MADDPG 在 actor network 上的不同之处在于前者使用的是 GRU 网络，为了更好的处理局部观察问题，但是后者使用的则是普通的 DNN。</p><p>COMA算法具体框架如下图所示：<br><img src="/../image/MARL/img_22.png" alt="img_22.png"></p><p>网络架构：<br><img src="/../image/MARL/img_26.png" alt="img_26.png"></p><h2 id="VDN"><a href="#VDN" class="headerlink" title="VDN"></a>VDN</h2><p>论文：<a href="https://arxiv.org/abs/1706.05296">Value-Decomposition Networks For Cooperative Multi-Agent Learning</a></p><p>VDN(Value-Decomposition Networks)算法是一种用于多智能体强化学习(MARL)的算法。它旨在解决多智能体系统中合作与竞争的问题，其中各个智能体需要同时考虑个体利益与整体目标。</p><p>VDN算是大名鼎鼎的QMIX算法的前身。VDN算法假定：<code>Qtot是每个智能体的Qi的算术加和。对于智能体Agenti来说，它只用最大化Qtot函数的子项Qi函数即可。</code>如下图：<br>左边是IQL，右边是VDN<br><img src="/../image/MARL/img_27.png" alt="img_27.png"></p><p>作者假定如下等式成立：<br><img src="/../image/MARL/img_29.png" alt="img_29.png"></p><p>h表示序列观察，a表示序列动作。 注意到，上述分解满足一个很好的性质，即对左边的联合 Q function 进行 操作，等价于对右边每一个局部 Q function 分别进行 。这样可以保证训练完毕后去中心化执行时，即使整个系统只基于局部观察进行决策，其策略也是与基于全局观察进行决策是一致的。</p><p>推导上式：<br>假定整个多智能体系统中包含两个智能体，并且全局回报函数是每个智能体的局部回报函数的加和：<br><img src="/../image/MARL/img_30.png" alt="img_30.png"><br>这样分解后的 Q 函数是基于全局观察的。由于使用的网络结构是 LSTM，那么估计误差是可以缩小的，并且还可以通过智能体之间的通信来进一步减小误差，所以本文假设：<br><img src="/../image/MARL/img_31.png" alt="img_31.png"></p><p>网络架构：<br><img src="/../image/MARL/img_28.png" alt="img_28.png"></p><p>VDN算法强调的是把总的Q相信分解为多个Q之和，每个Q对应每个智能体的动作价值，这种会导致一个结果，那就是这样累计求和的Q可能没有具体的意义、吃大锅饭导致有agent划水之类的结果。这些问题在QMIX中得到了比较好的解决。</p><h2 id="QMIX"><a href="#QMIX" class="headerlink" title="QMIX"></a>QMIX</h2><p>论文：<a href="https://arxiv.org/abs/1803.11485">QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning</a></p><p>深度多智能体强化学习的单调值函数分解</p><p>QMIX是一个多智能体强化学习算法，具有如下特点： </p><ol><li>学习得到分布式策略。 </li><li>本质是一个值函数逼近算法。 </li><li>由于对一个联合动作-状态只有一个总奖励值，而不是每个智能体得到一个自己的奖励值，因此只能用于合作环境，而不能用于竞争对抗环境。 </li><li>QMIX算法采用集中式学习，分布式执行应用的框架。通过集中式的信息学习，得到每个智能体的分布式策略。 </li><li>训练时借用全局状态信息来提高算法效果。是后文提到的VDN方法的改进。 </li><li>接上一条，QMIX设计一个神经网络来整合每个智能体的局部值函数而得到联合动作值函数，VDN是直接求和。 </li><li>每个智能体的局部值函数只需要自己的局部观测，因此整个系统在执行时是一个分布式的，通过局部值函数，选出累积期望奖励最大的动作执行。 </li><li>算法使联合动作值函数与每个局部值函数的单调性相同，因此对局部值函数取最大动作也就是使联合动作值函数最大。 </li><li>算法针对的模型是一个分布式多智能体部分可观马尔可夫决策过程(Dec-POMDP)。</li></ol><h3 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="MARL核心问题"><a href="#MARL核心问题" class="headerlink" title="MARL核心问题"></a>MARL核心问题</h4><p>在多智能体强化学习中一个关键的问题就是如何学习联合动作值函数，因为该函数的参数会随着智能体数量的增多而成指数增长，<code>如果动作值函数的输入空间过大，则很难拟合出一个合适函数来表示真实的联合动作值函数</code>。另一个问题就是学得了联合动作值函数后，<code>如何通过联合值函数提取出一个优秀的分布式的策略</code>。这其实是单智能体强化学习拓展到MARL的核心问题。</p><h4 id="Dec-POMDP"><a href="#Dec-POMDP" class="headerlink" title="Dec-POMDP"></a>Dec-POMDP</h4><p>Dec-POMDP指的是分布式部分可观察马尔可夫决策过程(Decentralized Partially Observable Markov Decision Process)。在 Dec-POMDP 中，有多个智能体同时存在，并且每个智能体只能观察到局部的环境信息，而不能直接获取全局状态。此外，每个智能体的动作会影响整个系统的演变。<br><img src="/../image/MARL/img_32.png" alt="img_32.png"></p><h4 id="IQL-1"><a href="#IQL-1" class="headerlink" title="IQL"></a>IQL</h4><p>IQL(independent Q-learning)就是非常暴力的给每个智能体执行一个Q-learning算法，因为共享环境，并且环境随着每个智能体策略、状态发生改变，对每个智能体来说，环境是动态不稳定的，因此这个算法也无法收敛，但是在部分应用中也具有较好的效果。</p><h4 id="VDN-1"><a href="#VDN-1" class="headerlink" title="VDN"></a>VDN</h4><p>如前介绍：<br><img src="/../image/MARL/img_33.png" alt="img_33.png"></p><h4 id="DRQN"><a href="#DRQN" class="headerlink" title="DRQN"></a>DRQN</h4><p>DRQN是一个用来处理POMDP(部分可观马尔可夫决策过程)的一个算法，其采用LSTM替换DQN卷基层后的一个全连接层，来达到能够记忆历史状态的作用，因此可以在部分可观的情况下提高算法性能。由于QMIX解决的是多智能体的POMDP问题，因此每个智能体采用的是DRQN算法。</p><h3 id="QMIX-1"><a href="#QMIX-1" class="headerlink" title="QMIX"></a>QMIX</h3><p>QMIX是在VDN上的一种拓展，由于VDN只是将每个智能体的局部动作值函数求和相加得到联合动作值函数，虽然满足联合值函数与局部值函数单调性相同的可以进行分布化策略的条件，但是其没有在学习时利用状态信息以及没有采用非线性方式对单智能体局部值函数进行整合，使得VDN算法还有很大的提升空间。QMIX就是采用一个混合网络对单智能体局部值函数进行合并，并在训练学习过程中加入全局状态信息辅助，来提高算法性能。</p><p>QMIX约束条件：<br><img src="/../image/MARL/img_34.png" alt="img_34.png"><br>也就是总Q关于每个agent的偏导都必须是正的。也就是，对于每个agent来说，追求自身收益的最大化是没有错误的(都对全局有不小于0的贡献)。</p><p>具体网络结构如下：<br><img src="/../image/MARL/img_35.png" alt="img_35.png"></p><p>图(c)表示每个智能体采用一个DRQN来拟合自身的Q值函数得到Qi(τi,ai; θi)，DRQN循环输入当前的观测oi,t，以及上一时刻的动作ai,t-1来得到Q值。</p><p>图(b)表示混合网络的结构。其输入为每个DRQN网络的输出。为了满足上述的单调性约束，混合网络的所有权值都是非负数，对偏移量不做限制，这样就可以确保满足单调性约束。</p><p>为了能够更多的利用到系统的状态信息st ，采用一种超网络(hypernetwork)，将状态st作为输入，输出为混合网络的权值及偏移量。为了保证权值的非负性，采用一个线性网络以及绝对值激活函数保证输出不为负数。对偏移量采用同样方式但没有非负性的约束，混合网络最后一层的偏移量通过两层网络以及ReLU激活函数得到非线性映射网络。由于状态信息st是通过超网络混合到Qtot中的，而不是仅仅作为混合网络的输入项，这样带来的一个好处是，如果作为输入项则st的系数均为正，这样则无法充分利用状态信息来提高系统性能，相当于舍弃了一半的信息量。</p><p>QMIX的Loss：<br><img src="/../image/MARL/img_36.png" alt="img_36.png"></p><p>更新用到了传统的DQN的思想，其中b表示从经验记忆中采样的样本数量，<br><img src="/../image/MARL/img_37.png" alt="img_37.png"></p><p>由于满足上文的单调性约束，对Qtot进行argmax 操作的计算量就不在是随智能体数量呈指数增长了，而是随智能体数量线性增长，极大的提高了算法效率。</p><h2 id="QTRAN"><a href="#QTRAN" class="headerlink" title="QTRAN"></a>QTRAN</h2><p>论文：<a href="https://arxiv.org/abs/1905.05408">QTRAN: Learning to Factorize with Transformation for Cooperative Multi-Agent Reinforcement Learning</a></p><p>学习因式分解以实现协作多智能体强化学习 Q-Tran</p><p>QMIX 在近似𝑄𝑡𝑜𝑡𝑎𝑙(𝒔, 𝒖)时额外使用了全局状态𝒔，这样就可以基于全局状态𝒔进行训练。但是如果直接将𝒔和[𝑄1, … , 𝑄𝑁]一起输入到神经网络𝑓去得到𝑄𝑡𝑜𝑡𝑎𝑙， 由于前面限制了𝑓中的参数是非负的， 但这会对𝑄𝑡𝑜𝑡𝑎𝑙和𝒔的关系进行不必要的限制，因为只希望局部最优动作就是全局最优动作。QTRAN 聚焦于释放累加性和单调性的限制， 去分解所有可分解的任务。 其思想在于只要保证个体最优动作𝑢̅和联合最优动作𝑢∗是相同的。</p><p>QTRAN 认为既然 VDN 和 QMIX 是通过累加或者单调近似得到的𝑄𝑡𝑜𝑡𝑎𝑙， 那么𝑄𝑡𝑜𝑡𝑎𝑙就很有可能与真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 相差很远， 那我不如直接去学习一个真实的𝑄𝑡𝑜𝑡𝑎𝑙 ∗ 。</p><p><img src="/../image/MARL/img_38.png" alt="img_38.png"></p><p>这里的Qjt就是学习得到的，介于各个agent的收益Q之和和实际局面价值之间的联合补偿,建立了局部Q和全局Q之间的联系。</p><p>为了满足上述定理，QTRAN 提出了两个算法 QTRAN-base 以及 QTRAN-alt:<br><img src="/../image/MARL/img_41.png" alt="img_41.png"></p><h3 id="TRAN-base"><a href="#TRAN-base" class="headerlink" title="TRAN-base"></a>TRAN-base</h3><p>分为三部分：</p><ol><li>独立 Q 网络</li><li>联合 Q 网络</li><li>联合 V 网络</li></ol><p>整体的Loss如下：<br><img src="/../image/MARL/img_39.png" alt="img_39.png"><br><img src="/../image/MARL/img_40.png" alt="img_40.png"></p><h3 id="TRAN-alt"><a href="#TRAN-alt" class="headerlink" title="TRAN-alt"></a>TRAN-alt</h3><p>QTRAN-alt 是针对 QTRAN(Q-function Transfer)算法的一个改进版本，旨在解决原始 QTRAN 在处理非零约束时的问题。</p><p>作者认为约束：<br><img src="/../image/MARL/img_42.png" alt="img_42.png"></p><p>在原始 QTRAN 算法中，对于非零动作的约束(对应公式中的第二个约束)，可能会过于松弛，导致算法难以准确地拟合联合 Q 函数。这是因为在训练数据中的数据很少，大部分的数据都可能满足第二个约束。</p><p>为了解决这个问题，QTRAN-alt 提出了一个新的定理，将原始约束中的第二个约束替换为一个更强的约束。这个新的约束使得算法能够更准确地拟合联合 Q 函数，从而提升了算法的性能和训练效果。<br><img src="/../image/MARL/img_43.png" alt="img_43.png"><br>这个约束更多的聚焦于非0的训练数据(这一部分数据占训练初期训练集的大部分)。为了满足这一约束，需要把上面列出的第三个损失函数替换为：</p><p><img src="/../image/MARL/img_44.png" alt="img_44.png"></p><p>具体来说，QTRAN-alt 对于非零动作的约束更加严格，以提高算法的性能。这种改进使得 QTRAN-alt 在处理合作问题中的分工与协作时表现更为优越。</p><p>算法流程：<br><img src="/../image/MARL/img.png" alt="img.png"></p><h2 id="MFMARL"><a href="#MFMARL" class="headerlink" title="MFMARL"></a>MFMARL</h2><p>论文：<a href="https://arxiv.org/abs/1802.05438v4">Mean Field Multi-Agent Reinforcement Learning</a></p><p>平均场多智能体强化学习</p><p><code>MFMARL主要致力于极大规模的多智能体强化学习问题，解决大规模智能体之间的交互及计算困难。</code>由于多智能体强化学习问题不仅有环境交互问题，还有智能体之间的动态影响，因此为了得到最优策略，每个智能体都需要考察其他智能体的动作及状态得到联合动作值函数。由于状态空间跟动作空间随着智能体数量的增多而迅速扩大，这给计算以及探索带来了非常大的困难。</p><p>MFMARL算法借用了平均场论(Mean Field Theory，MFT)的思想，其对多智能体系统给出了一个近似假设：对某个智能体，其他所有智能体对其产生的作用可以用一个均值替代。这样就就将一个智能体与其邻居智能体之间的相互作用简化为两个智能体之间的相互作用(该智能体与其所有邻居的均值)。这样极大地简化了智能体数量带来的模型空间的增大。应用平均场论后，学习在两个智能体之间是相互促进的：单个智能体的最优策略的学习是基于智能体群体的动态；同时，集体的动态也根据个体的策略进行更新。</p><p>下面具体介绍算法细节，其结合平均场论得出两个主要算法MF-Q与MF-AC，是对Q-learning以及AC算法的改进，并且在理论上给出了收敛性证明，能够收敛到纳什均衡点。该算法可以应用于竞争环境或合作环境，并且每个智能体不知道环境的模型以及奖励模型，但是能够观察邻居智能体的动作及奖励。每个智能体有自己的奖励值。</p><h3 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="随机博弈"><a href="#随机博弈" class="headerlink" title="随机博弈"></a>随机博弈</h4><p><img src="/../image/MARL/img_45.png" alt="img_45.png"></p><h4 id="Nash-Q"><a href="#Nash-Q" class="headerlink" title="Nash-Q"></a>Nash-Q</h4><p><img src="/../image/MARL/img_46.png" alt="img_46.png"></p><h3 id="Mean-Field-MARL"><a href="#Mean-Field-MARL" class="headerlink" title="Mean Field MARL"></a>Mean Field MARL</h3><p><img src="/../image/MARL/img_50.png" alt="img_50.png"></p><h4 id="平均场近似"><a href="#平均场近似" class="headerlink" title="平均场近似"></a>平均场近似</h4><p><img src="/../image/MARL/img_47.png" alt="img_47.png"></p><p><img src="/../image/MARL/img_48.png" alt="img_48.png"></p><p><img src="/../image/MARL/img_49.png" alt="img_49.png"></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>原文中将(7)通过参数化用神经网络进行拟合逼近，与DQN以及AC算法结合，分别给出了MF-Q与MF-AC算法。</p><h4 id="MF-Q"><a href="#MF-Q" class="headerlink" title="MF-Q"></a>MF-Q</h4><p>通过神经网络拟合(7)式中的Q函数，使用如下所示的代价函数，与DQN中相同，为了减小拟合的Q值与真实Q值之间的误差<br><img src="/../image/MARL/img_51.png" alt="img_51.png"></p><p>对上式求导可以得出参数梯度方向如下:<br><img src="/../image/MARL/img_52.png" alt="img_52.png"></p><p>通过梯度下降法可以得到参数更新公式。</p><p>算法流程：<br><img src="/../image/MARL/img_53.png" alt="img_53.png"></p><h4 id="MF-AC"><a href="#MF-AC" class="headerlink" title="MF-AC"></a>MF-AC</h4><p>类似DPG，使用神经网络拟合一个策略替换玻尔兹曼机通过Q的到的策略，则得到了MF-AC算法。</p><p>类似SPG，actor策略梯度公式可以写为：<br><img src="/../image/MARL/img_54.png" alt="img_54.png"></p><p>critic类似于MF-Q的更新方式(9)</p><p><img src="/../image/MARL/img_55.png" alt="img_55.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../image/MARL/img_56.png" alt="img_56.png"></p><blockquote><p>至此，MARL的入门已结束，后面会结合科研方向看论文想点子。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
          <category> 多智能体强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
            <tag> 多智能体强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/posts/17762.html"/>
      <url>/posts/17762.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前没有深入和系统的学习过强化学习，最近由于科研刚需，上网查资料刚好看到知乎上面有个大佬的强化学习的系列文章，感觉写的很好，于是就把他的文章看了一遍，顺便做了一些笔记，这里记录一下。</p></blockquote><p>原文： <a href="https://zhuanlan.zhihu.com/p/111895463">https://zhuanlan.zhihu.com/p/111895463</a></p><p>卧槽大佬讲的真的好，笔记记不了一点！！！建议大家都去看原文！</p><p>后面可能会自己写一下 <code>MADDPG</code> 和 <code>MATD3</code> 的相关内容，到时候再更新。</p><blockquote><p>2023&#x2F;10&#x2F;23 这几天把大佬的强化学习专栏看了一遍了，真的很不错，但是我觉得还是得自己总结一下重难点，且这周五和东大的联合组会轮到我讲了，刚好深入理解一下强化学习算法。所以还是写一下这篇笔记吧！</p></blockquote><p>学习路线：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png" alt="学习路线"></p><h2 id="马尔可夫树"><a href="#马尔可夫树" class="headerlink" title="马尔可夫树"></a>马尔可夫树</h2><p>强化学习的任务：</p><ul><li>希望用强化学习的方式，使某个<strong>智能体</strong>获得<strong>独立自主</strong>地完成某种任务的能力。 </li><li>智能体学习和工作的地方，称为<strong>环境</strong>。</li><li>所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</li></ul><h3 id="经典马尔可夫链"><a href="#经典马尔可夫链" class="headerlink" title="经典马尔可夫链"></a>经典马尔可夫链</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png" alt="马尔科夫链.png"></p><ul><li>状态(state)：智能体观察到的当前环境的部分或者全部特征。<ul><li>注意：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以也用observation表示状态。</li></ul></li><li>动作(action)：智能体做出的具体行为。<ul><li><strong>动作空间</strong>就是该智能体能够做出的动作数量。智能体身处十字路口。那么方向就有4个。也就是说，动作空间为4个动作。</li></ul></li><li>奖励(reward)：智能体在某个状态下采取某个动作所获得的反馈。<ul><li>奖励是一个标量，可以是正数，也可以是负数。奖励越大，说明智能体做的越好。奖励越小，说明智能体做的越差。</li></ul></li></ul><h3 id="RL一般步骤"><a href="#RL一般步骤" class="headerlink" title="RL一般步骤"></a>RL一般步骤</h3><ol><li>智能体在环境中，观察到状态(S)；</li><li>状态(S)被输入到智能体，智能体经过计算，选择动作(A);</li><li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。</li><li>智能体根据返回，调整自己的策略。 重复以上步骤，一步一步创造马尔科夫链。</li></ol><h3 id="马尔可夫树-1"><a href="#马尔可夫树-1" class="headerlink" title="马尔可夫树"></a>马尔可夫树</h3><p>马尔科夫链之所以是现在看到的一条链条。是因为站在现在往过去看，所以是一条确定的路径。但如果往前看，就并不是一条路径，而是充满了各种”不确定性”， 即”马尔可夫树”。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A0%91.png" alt="马尔科夫树.png"></p><p>这种”不确定性”来自两个方面： </p><ul><li>智能体的行动选择(策略)。</li><li>环境的不确定性。</li></ul><h2 id="RL中的Q值和V值"><a href="#RL中的Q值和V值" class="headerlink" title="RL中的Q值和V值"></a>RL中的Q值和V值</h2><p>并不能单纯通过R来衡量一个动作的好坏，因为R只是一个瞬时的反馈，而需要的是长期的反馈。在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p><p>希望可以有一种方法评估我做出每种选择价值。这样，只要看一下标记，以后的事情也不用理，选择那个动作价值更大，就选那个动作就可以了。</p><ul><li>评估动作的价值称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望。</li><li>评估状态的价值称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。</li></ul><p>价值越高，表示从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p><h3 id="V值的定义"><a href="#V值的定义" class="headerlink" title="V值的定义"></a>V值的定义</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="V值的定义.png"></p><p>假设现在需要求某状态S的V值，可以这样：</p><ol><li>从S点出发，并影分身出若干个自己;</li><li>每个分身按照当前的策略 选择行为;</li><li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li><li>计算每个影分身获得的平均值,这个平均值就是要求的V值。</li></ol><p>总结：<code>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值。</code></p><p><code>V值跟选择的策略有很大的关系</code> 。</p><p>看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BE%8B%E5%AD%901.png" alt="例子1.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A51.png" alt="策略1.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A52.png" alt="策略2.png"></p><p>可以看出不同的策略，计算出的V值是不一样的。</p><h3 id="Q值的定义"><a href="#Q值的定义" class="headerlink" title="Q值的定义"></a>Q值的定义</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="Q值的定义.png"></p><p>现在需要计算，某个状态S0下的一个动作A的Q值： </p><ol><li>从A这个节点出发，使用影分身之术； </li><li>每个影分身走到最终状态,并记录所获得的奖励； </li><li>求取所有影分身获得奖励的平均值，这个平均值就是要求的Q值。</li></ol><p>总结：<code>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值。</code></p><p>与V值不同，Q值和策略并没有直接相关，而<code>与环境的状态转移概率相关，而环境的状态转移概率是不变的。</code></p><h3 id="V值和Q值关系"><a href="#V值和Q值关系" class="headerlink" title="V值和Q值关系"></a>V值和Q值关系</h3><p><code>Q和V之间是可以相互换算的</code>。</p><h4 id="Q值转V值"><a href="#Q值转V值" class="headerlink" title="Q值转V值"></a>Q值转V值</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC.png" alt="Q值转V值.png"></p><p>从定义出发，要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p><p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p><p>假设已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q%E5%80%BC%E8%BD%ACV%E5%80%BC1.png" alt="Q值转V值1.png"></p><p>更正式的公式如下：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F1.png" alt="公式1.png"></p><p>解释：<code>一个状态的V值，就是这个状态下的所有动作的Q值，在策略下的期望。</code></p><h4 id="V值转Q值"><a href="#V值转Q值" class="headerlink" title="V值转Q值"></a>V值转Q值</h4><p><code>Q是V的期望。</code>而这里不需要关注策略，这里是环境的状态转移概率决定的。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC.png" alt="V值转Q值.png"></p><p><code>当选择A，并转移到新的状态时，就能获得奖励，必须把这个奖励也算上！</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACQ%E5%80%BC1.png" alt="V值转Q值1.png"></p><p>更正式的公式如下：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F2.png" alt="公式2.png"></p><blockquote><p>折扣率 在强化学习中，有某些参数是人为主观制定。这些参数并不能推导，但在实际应用中却能解决问题，所以称这些参数为超参数，而折扣率就是一个超参数。</p></blockquote><h3 id="V值转V值"><a href="#V值转V值" class="headerlink" title="V值转V值"></a>V值转V值</h3><p>实际应用中，更多会从V到V。其实就是把Q值的公式代入V值的公式。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/V%E5%80%BC%E8%BD%ACV%E5%80%BC.png" alt="V值转V值.png"></p><h2 id="MC"><a href="#MC" class="headerlink" title="MC"></a>MC</h2><p>蒙地卡罗方法(Monte-Carlo)</p><h3 id="蒙地卡罗算法"><a href="#蒙地卡罗算法" class="headerlink" title="蒙地卡罗算法"></a>蒙地卡罗算法</h3><ol><li>把智能体放到环境的任意状态；</li><li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li><li>重复步骤2，直到最终状态；</li><li>从最终状态开始向前回溯：计算每个状态的G值。</li><li>重复1-4多次，然后平均每个状态的G值，这就是要求的V值。</li></ol><h3 id="G值的意义"><a href="#G值的意义" class="headerlink" title="G值的意义"></a>G值的意义</h3><p>重要：<code>G值是一个具体的累积奖励值，而Q值和V值是对这个累积奖励值的估计。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/G%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89.png" alt="G值的意义.png"></p><ul><li>第一步，根据策略往前走，一直走到最后，期间什么都不用算，还需要记录每一个状态转移，获得多少奖励r即可。</li><li>第二步，从终点往前走，一遍走一遍计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上r。</li></ul><p>所以G值的意义在于，<code>在这一次游戏中，某个状态到最终状态的奖励总和(理解时可以忽略折扣值gamma)。</code></p><p>当进行多次试验后，有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。<code>而V值是某个状态下，通过影分身到达最终状态，所有影分身获得的奖励的平均值。</code></p><p>理解：</p><ol><li><code>G的意义：在某个路径上，状态S到最终状态的总收获。 </code></li><li><code>V和G的关系：V是G的平均数。</code></li></ol><h3 id="V和策略相关"><a href="#V和策略相关" class="headerlink" title="V和策略相关"></a>V和策略相关</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A53.png" alt="策略3.png"></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A54.png" alt="策略4.png"></p><p>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</p><h3 id="蒙地卡罗算法的缺点"><a href="#蒙地卡罗算法的缺点" class="headerlink" title="蒙地卡罗算法的缺点"></a>蒙地卡罗算法的缺点</h3><p>每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，那可能每一次都要转很久很久才能更新一次G值。</p><h3 id="MC的更新公式"><a href="#MC的更新公式" class="headerlink" title="MC的更新公式"></a>MC的更新公式</h3><p>上面计算V值其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p><p>那有没有一种方法，可以用更少的空间计算V值呢？当然有，那就是<code>增量更新</code>。</p><h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>现在只需要记录之前的平均值V，新加进来的G，和次数N。把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。 </p><p><code>V_new = (V_old - G) * (1 / N) + V_old</code></p><ul><li>V_old：原来的V值</li><li>G：这一次回溯后，计算出来的G值</li><li>N: 这个状态被经过多少次</li><li>V_new：新计算出来的V值</li></ul><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>这样计算还是比较麻烦，甚至可以不用记录N，把(1&#x2F;N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。把这个值称为<code>学习率</code>。</p><p>这就相当于，新来的G和V_old的差的十分之一，会被加到V_new上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p><p>这里的G，也称为V的更新目标。</p><p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。</p><h4 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%A4%E7%A7%8D%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F.png" alt="两种理解方式.png"></p><h2 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h2><p>时序差分算法TD(Temporal-Difference)</p><h3 id="TD和MC的比较"><a href="#TD和MC的比较" class="headerlink" title="TD和MC的比较"></a>TD和MC的比较</h3><p>TD算法对蒙地卡罗(MC)进行了改进：</p><ol><li>和蒙地卡罗(MC)不同：<code>TD算法只需要走N步，不用走到终点，就可以开始回溯更新。</code> </li><li>和蒙地卡罗(MC)一样：需要先走N步，每经过一个状态，把奖励r记录下来。然后开始回溯。 </li><li>那么，状态的V值怎么算呢？其实和蒙地卡罗一样，就假设N步之后，就到达了最终状态了。<ul><li>假设“最终状态”上之前没有走过，所以这个状态上的纸是空白的。这个时候就当这个状态为0. </li><li>假设“最终状态”上已经走过了，这个状态的V值，就是当前值。然后开始回溯。</li></ul></li></ol><h3 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h3><p>从A状态，经过1步，到B状态。什么都不管就当B状态是最终状态了。此时<code>N = 0</code>，也叫做<code>TD(0)</code>。</p><p>但B状态本身就带有一定的价值，也就是V值。其意义就是从B状态到最终状态的总价值期望。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0).png" alt="TD(0).png"></p><p>假设B状态的V值是对的，那么，通过回溯计算，就能知道A状态的更新目标了。</p><h3 id="更新公式"><a href="#更新公式" class="headerlink" title="更新公式"></a>更新公式</h3><p>TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。 <code>所以只需要把MC的更新目标，改为TD的更新目标即可。</code></p><p><code>在MC，G是更新目标，而在TD，只不过把更新目标从G，改成r+gamma*V</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png" alt="更新公式.png"></p><h2 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h2><p>之前用TD(0)预估状态价值V:<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F.png" alt="TD(0)更新公式.png"></p><p>图解：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E5%9B%BE%E8%A7%A3.png" alt="TD(0)图解.png"></p><p>TD能够用在V值，那么也能用在计算Q值上。</p><h3 id="TD之于Q值估算"><a href="#TD之于Q值估算" class="headerlink" title="TD之于Q值估算"></a>TD之于Q值估算</h3><p>现在用上TD的思路。 在St，智能体根据策略pi，选择动作At，进入S(t+1)状态，并获得奖励R。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8TD%E4%BC%B0%E8%AE%A1Q%E5%80%BC.png" alt="用TD估计Q值.png"></p><ul><li>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 </li><li>Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。</li></ul><p>在这里要估算两个东西，一个是V值，一个是Q值。人们想到用下一个动作的Q值代替V值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%94%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8A%A8%E4%BD%9C%E7%9A%84Q%E4%BB%A3%E6%9B%BFV.png" alt="用下一个动作的Q代替V.png"></p><p>但是，这里就有个坑：<code>虽然从状态St+1到动作At+1之间没有奖励反馈，但还是不能直接用At+1的Q价值，代替St+1的V价值。</code></p><p>因为<code>马尔可夫树!</code><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9D%91%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt="坑的解释.png"></p><p><code>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</code></p><p>虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p><ol><li>在相同策略下产生的动作At+1。这就是<code>SARSA</code>。</li><li>选择能够产生最大Q值的动作At+1。这就是<code>Qlearning</code>。</li></ol><h3 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA.png" alt="SARSA.png"></p><p>其实SARSA和上一篇说的TD估算V值几乎一模一样，只不过挪了一下，从V改成Q了。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png" alt="SARSA公式.png"><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(0)%E4%B8%8ESARSA%E5%AF%B9%E6%AF%94.png" alt="TD(0)与SARSA对比.png"></p><p>注意: <code>这里的At+1是在同一策略产生的。也就是说,St选At的策略和St+1选At+1是同一个策略。这也是SARSA和Qlearning的唯一区别。</code></p><h3 id="Qlearning"><a href="#Qlearning" class="headerlink" title="Qlearning"></a>Qlearning</h3><p><code>Qlearning将能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%9B%BE%E8%A7%A3.png" alt="Qlearning图解.png"></p><p>理解：因为需要寻着的是能获得最多奖励的动作，Q值就代表能够获得今后奖励的期望值。所以选择Q值最大的，也只有最大Q值能够代表V值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qlearning%E5%85%AC%E5%BC%8F.png" alt="Qlearning公式.png"></p><p><code>Q(S,a)的更新目标</code>：在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/SARSA%E5%85%AC%E5%BC%8F.png" alt="SARSA公式.png"></p><p>Qleanring和SARSA，两者的差别仅仅在Qlearning中多了个max。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。 </li><li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。 </li><li>既要估算Q值，又要估算V值会显得比较麻烦。所以用下一状态下的某一个动作的Q值，来代表St+1的V值。 </li><li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 <ul><li>SARSA 选择的是在St同一个策略产生的动作。 </li><li>Qlearning 选择的是能够产生最大的Q值的动作。</li></ul></li></ol><h3 id="Qlearning-实现"><a href="#Qlearning-实现" class="headerlink" title="Qlearning 实现"></a>Qlearning 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="深度神经网络"><a href="#深度神经网络" class="headerlink" title="深度神经网络"></a>深度神经网络</h2><p>深度强化学习：用深度神经网络辅助强化学习。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>假如知道X，y有关系，那么不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)&#x3D;y。</p><p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。 任务就是需要求这个Magic函数。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic(X).png" alt="Magic(X).png"></p><p>现在假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。</p><p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p><p>…但这没所谓，因为这是刚开始。任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p><p>y’和真实y之间的差距，叫损失，也就是loss。有时候也会把y称为目标(target)，因为任务就是让Magic’(X)越来越靠近这个目标。</p><p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，话题太大暂时不展开。</p><p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么就可以认为Magic’(X)和Magic(X)函数非常接近，可以通过Magic’(X)计算出y。</p><p>当有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Magic'(X).png" alt="Magic&#39;(X).png"></p><h4 id="放大镜下的深度神经网络"><a href="#放大镜下的深度神经网络" class="headerlink" title="放大镜下的深度神经网络"></a>放大镜下的深度神经网络</h4><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%B7%A5%E5%8E%82.png" alt="数据加工厂.png"></p><p>现在可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p><p>为了让这个数据加工厂运行得更快，通常需要把要加工的数据X变得更<code>标准</code>一些。</p><p>例如图片的尺寸大小，有多少通道的颜色等等，然后<code>分批(batch)</code>，输入工厂。</p><p>在输入工厂的时候，会有一个‘大门’，称为<code>输入层</code>，去检查数据是否已经按照工厂的标准整理好。</p><p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，需要定义好这个车间的操作标准。</p><p>一般称这些车间叫<code>层</code>。<code>这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了</code>。常用的层包括：<code>Dense、Conv2D、LSTM、Reshape、Flatten</code>等。</p><p>最终，数据工厂会把原数据X，加工成产品<code>y&#39;(也叫做：logits)</code>。从源数据加工成产品的过程，叫<code>正向传播</code>。</p><p>但产品y’是否是一个合格的产品，还需要真正的<code>y(lables)</code>作为标准去鉴定。把<code>鉴定出来的差距就是loss</code>。</p><p>工厂根据鉴定结果，以梯度下降的方式，反向传递给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p><p>经过N个批次(batch)的数据输入，然后鉴别，工厂调整。最后工厂就能达到生产标准了。也就是说magic函数已经被训练好了。</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><blockquote><p><code>DQN: TD + 神经网络</code></p></blockquote><p>在Qlearning中，有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p><p>Qtable的作用是当输入状态S，通过查表返回能够获得最大Q值的动作A。也就是需要找一个S-A的对应关系。</p><p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是离散而是连续的。</p><p><code>用神经网络解决Qlearning中动作离散的问题，让动作变成连续的，这就是DQN。</code></p><p><code>Deep network + Qlearning = DQN</code></p><p>神经网络万能函数(神经网络)Magic(X)接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p><h3 id="理解DQN中的神经网络"><a href="#理解DQN中的神经网络" class="headerlink" title="理解DQN中的神经网络"></a>理解DQN中的神经网络</h3><p>Qtable三维可视化：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Qtable%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="Qtable三维可视化.png"></p><p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p><p><code>现在用函数来表示，相当于要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%89%AD%E6%9B%B2%E7%9A%84%E6%9B%B2%E7%BA%BF.png" alt="扭曲的曲线.png"></p><p>从二维状态看：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%9B%B2%E7%BA%BF.png" alt="二维曲线.png"></p><p>所以现在不但可以取状态3和状态4，还可以取状态3.5的Q值。</p><p>现在就很清楚了，其实Qlearning和DQN并没有根本的区别。<code>只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</code></p><h3 id="更新目标"><a href="#更新目标" class="headerlink" title="更新目标"></a>更新目标</h3><p>更新目标就是Magic(X)，最终要向这个Magix(X)靠近。</p><p>在Qlearning，用下一状态St+1的最大Q值替代St+1的V值。V(St+1)加上状态转移产生的奖励R。就是Q(S,a)的更新目标。</p><p>DQN和Qlearning一样：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN.png" alt="DQN.png"><br>假设需要更新当前状态St下的某动作A的Q值：Q(S,A),可以这样做： </p><ol><li>执行A，往前一步，到达St+1; </li><li>把St+1输入Q网络，计算St+1下所有动作的Q值； </li><li>获得最大的Q值加上奖励R作为更新目标； </li><li>计算损失 <ul><li>Q(S,A)相当于有监督学习中的logits</li><li>maxQ(St+1) + R 相当于有监督学习中的lables </li><li>用mse函数，得出两者的loss </li><li>Loss &#x3D; (Q(S, A) - [gamma * maxQ(St+1) + R])^2</li></ul></li><li>用loss更新Q网络。(反向传播)</li></ol><blockquote><p>通常会使用一个折扣因子 gamma 来考虑未来奖励的重要性。折扣因子 gamma 的作用是对未来奖励进行衰减，使得当前时刻的奖励比未来时刻的奖励更具有影响力。</p></blockquote><p>也就是，用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。这个就是更新目标<br><code>Target = R + gamma * maxQ(St+1)</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E5%85%AC%E5%BC%8F.png" alt="DQN公式.png"></p><p>总结：</p><ol><li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li><li>解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li><li>和有监督学习不同，深度强化学习中，需要自己找更新目标。通常在马尔科夫链体系下，两个相邻状态状态差一个奖励r经常能够作为更新目标。</li></ol><h3 id="DQN-实现"><a href="#DQN-实现" class="headerlink" title="DQN 实现"></a>DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h2><h3 id="经验回放"><a href="#经验回放" class="headerlink" title="经验回放"></a>经验回放</h3><p>经验回放解决了强化学习中的两个问题： <code>训练网络数据采集慢</code> 和 <code>过度拟合</code></p><p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来时快很多的。所以训练的瓶颈一般在智能体跟环境互动的过程中。 如果能把互动过程中的数据，都存起来，当数据最够多的时候，再训练网络，那么就快很多了。</p><p>把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。都存在一个叫回放缓存的地方(replay buffer)。<br>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….<br>当数据量足够，达到设定一个batch的大小，便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。<br>训练之后继续进行游戏，继续把新产生的数据添加到回放缓存里…<br>就这样每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p><p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。<br>过度拟合，放到人身上就是<code>过度依赖局部经验</code>了。<br>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。<br>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。说这就是过度拟合造成的，导致模型不够健壮。</p><h3 id="DQN的问题"><a href="#DQN的问题" class="headerlink" title="DQN的问题"></a>DQN的问题</h3><p>DQN的目标：<br><code>Target = R + gamma * maxQ(St+1)</code></p><p>目标本身就包含一个Q网络，理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p><p>如果把训练神经网络比喻成射击游戏，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p><p>要解决这个问题，就把移动靶弄成是固定的靶，先停止10秒。10后挪动靶再打新的靶。这就是<code>Fixed Q-targets</code>的思路。</p><h3 id="Fixed-Q-targets"><a href="#Fixed-Q-targets" class="headerlink" title="Fixed Q-targets"></a>Fixed Q-targets</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/fix-Q-targets.png" alt="fix-Q-targets.png"></p><p>其他地方和DQN一样，唯一不同是用了两个Q网络。</p><ul><li>原来的Q网络，用于估算Q(s);</li><li>targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。<ul><li><code>y = r + gamma * max(targetQ(s&#39;))</code></li><li>进行N次更新后，就把新Q网络的参数赋值给旧Q网络，保持训练的稳定性。</li></ul></li></ul><h3 id="Double-DQN-1"><a href="#Double-DQN-1" class="headerlink" title="Double DQN"></a>Double DQN</h3><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p><p>这个思路也很直观。如果只有一个Q网络，Q值的估计往往偏大。那就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。选取评估出来较小的值来计算更新目标。这样就能有效避免Q网络估值偏大的情况发生了。</p><p>另外一种做法也需要用到两个Q网络：Q1网络推荐能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p><h3 id="Double-DQN-实现"><a href="#Double-DQN-实现" class="headerlink" title="Double DQN 实现"></a>Double DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="Duel-DQN"><a href="#Duel-DQN" class="headerlink" title="Duel DQN"></a>Duel DQN</h2><h3 id="Dueling-DQN原理"><a href="#Dueling-DQN原理" class="headerlink" title="Dueling DQN原理"></a>Dueling DQN原理</h3><p>回到Qtable， 原来会直接预估Q值表的数据，现在改为需要预估两个值：S值和A值。即<code>Q = S + A</code></p><ul><li>S: 在特定状态下采取任何行动的平均价值,也就是该state下的Q值的平均数。</li><li>A: 在特定状态下采取特定动作相对于采取平均动作的优势。A的平均值为0。</li></ul><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q=S+A%E8%A1%A8%E6%A0%BC.png" alt="Q=S+A表格.png"></p><p>普通DQN的Q网络，可以理解用一个曲线去拟合Qtable的Q值。现在取一个截面，表示当取某个S下，各个动作的Q值。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9ADQN.png" alt="普通DQN.png"></p><p>普通DQN在提升某个状态下的S值时，只会提升某个动作。</p><p>Dueling DQN： 在网络更新的时候，由于有A值之和必须为0的限制，所以网络会优先更新S值。S值是Q值的平均数，平均数的调整相当于一次性S下的所有Q值都更新一遍。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN.png" alt="DuelDQN.png"></p><p>如上图，橙色虚线是平均值，也就是S值。 所以网络在更新的时候，不但更新某个动作的Q值，而是把这个状态下，所有动作的Q值都调整一次。这样，就可以在更少的次数让更多的值进行更新。</p><blockquote><p>这样调整最后的数值是对的吗？放心，在DuelingDQN，只是优先调整S值。但最终的target目标是没有变的，所以最后更新出来也是对的。</p></blockquote><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DuelDQN%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.png" alt="DuelDQN网络架构.png"></p><p>可以把dueling DQN分为三部分：</p><ul><li>第一部分：和普通DQN一样，用来处理和学习数据。</li><li>第二部分：计算svalue，就是让网络预估的平均值。</li><li>第三部分：计算avalue，和svalue一样，都是从h2层输入到该层。然后对avalue进行归一化处理，也就是增加“A值的平均值为0”的限制。<ul><li>归一化的处理很简单，求A值的平均值，然后用A值减去平均值即可。A-mean(A)</li></ul></li></ul><p>DeulingDQN的实现很简单，只需要修改Q网络的网络架构就可以了。而且可以和其他DQN的技巧，例如经验回放，固定网络，双网络计算目标等可以共用。</p><h3 id="Duel-DQN-实现"><a href="#Duel-DQN-实现" class="headerlink" title="Duel DQN 实现"></a>Duel DQN 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h2><p>策略梯度(Policy Gradient)</p><p>之前的MC、TD、Qlearning、DQN都是基于值的方法，就是一定要算Q值和V值。但事实上最终目的是要找一个策略，能获得最多的奖励。</p><p>这就是<code>策略梯度(Policy Gradient)</code></p><h3 id="PG原理"><a href="#PG原理" class="headerlink" title="PG原理"></a>PG原理</h3><p>认识到：</p><blockquote><p><code>DQN: TD + 神经网络</code><br><code>PG: MC + 神经网络</code></p></blockquote><p>PG中的Magic(state):<br>当输入state的时候，输出pi，告诉智能体这个状态，应该如何应对： &#x3D; magic(state)。如果智能体的动作是对的，那么就让这个动作获得更多被选择的几率；相反，如果这个动作是错的，那么这个动作被选择的几率将会减少。</p><p>复习一下蒙地卡罗：<br>从某个state出发，然后一直走，直到<code>最终状态</code>。然后从最终状态原路返回，对每个状态评估G值。 所以G值能够表示在策略下，智能体选择的这条路径的好坏。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A0MC.png" alt="复习MC.png"></p><h3 id="直观感受PG"><a href="#直观感受PG" class="headerlink" title="直观感受PG"></a>直观感受PG</h3><p>从某个state出发，可以采取三个动作。 假设当前智能体对这一无所知，那么，可能采取平均策略 Pi0 &#x3D; [33%,33%,33%]。智能体出发，选择动作A，到达最终状态后开始回溯，计算得到 G &#x3D; 1。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG1.png" alt="直观感受PG1.png"></p><p>更新策略，因为该路径选择了A而产生的，并获得G &#x3D; 1；因此要更新策略：让A的概率提升，相对地，BC的概率就会降低。 计算得新策略为： Pi1 &#x3D; [50%,25%,25%]。虽然B概率比较低，但仍然有可能被选中。第二轮刚好选中B。智能体选择了B，到达最终状态后回溯，计算得到 G &#x3D; -1。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG2.png" alt="直观感受PG2.png"></p><p>此时对B动作的评价比较低，并且希望以后会少点选择B，因此要降低B选择的概率，而相对地，AC的选择将会提高。计算得新策略为： Pi2 &#x3D; [55%,15%,30%]。最后随机到C，回溯计算后，计算得G &#x3D; 5。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97PG3.png" alt="直观感受PG3.png"></p><p>C比A还要多得多。因此这一次更新，C的概率需要大幅提升，相对地，AB概率降低。 Pi3 &#x3D; [20%,5%,75%]。</p><h3 id="PG-实现"><a href="#PG-实现" class="headerlink" title="PG 实现"></a>PG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h2><blockquote><p><code>AC: PG + DQN(TD + 神经网络)</code></p></blockquote><p>PG利用带权重的梯度下降方法更新策略，而获得权重的方法是MC计算G值。MC需要完成整个游戏过程，直到最终状态，才能通过回溯计算G值。这使得PG方法的效率被限制。</p><p>改为TD可以解决上面的问题。接下来又面临另一个问题：<br>在PG，需要计算G值；那么在TD中，应该怎样估算每一步的Q值呢？答案是用神经网络。</p><p>也就是说，Actor-Critic，其实是用了两个网络：</p><p>两网络都输入状态S，Critic比Actor多一个St+1: </p><ul><li>一个网络输出策略，负责选择动作，把这个网络成为Actor； </li><li>一个网络负责计算每个动作的分数，把这个网络成为Critic。</li></ul><h3 id="TD-error"><a href="#TD-error" class="headerlink" title="TD-error"></a>TD-error</h3><p><code>在DQN预估的是Q值，在AC中的Critic，估算的是V值。</code>不估算Q值是因为效果不好。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%B0%E7%AE%97Q.png" alt="为什么不估算Q.png"></p><p>假设用Critic网络，预估到S状态下三个动作A1，A2，A3的Q值分别为1,2,10。 但在开始的时候，采用平均策略，于是随机到A1。于是用策略梯度的带权重方法更新策略，这里的权重就是Q值。于是策略会更倾向于选择A1，意味着更大概率选择A1。结果A1的概率就持续升高…</p><p>这就掉进了正数陷阱。明明希望A3能够获得更多的机会，最后却是A1获得最多的机会。这是为什么呢？<br>因为Q值用于是一个正数，如果权重是一个正数，那么相当于提高对应动作的选择的概率。权重越大，调整的幅度将会越大。其实当有足够的迭代次数，这个是不用担心这个问题的。因为总会有机会抽中到权重更大的动作，因为权重比较大，抽中一次就能提高很高的概率。</p><p>但在强化学习中，往往没有足够的时间去和环境互动。这就会出现由于运气不好，使得一个很好的动作没有被采样到的情况发生。要解决这个问题，可以通过减去一个baseline，令到权重有正有负。而通常这个baseline，选取的是权重的平均值。减去平均值之后，值就变成有正有负了。而<code>Q值的期望(均值)就是V。</code></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD-error.png" alt="TD-error.png"></p><p>可以得到更新的权重：<code>Q(s,a)-V(s)</code>，Q(s,a)用<code>gamma * V(s&#39;) + r</code> 代替。<br>得到TD-error：<code>TD-error = gamma * V(s&#39;) + r - V(s)</code></p><p>和之前DQN的更新公式非常像，只不过DQN的更新用了Q，而TD-error用的是V。如果Critic是用来预估V值，而不是原来讨论的Q值。那么，这个TD-error是用来更新Critic的loss了！没错，Critic的任务就是让TD-error尽量小。然后TD-error给Actor做更新。</p><p>至于为啥TD-error是用来更新Critic的loss呢？<br>取TD-error的方差来作为critic的loss，其实类似于DQN中的Q网络，认为下个状态的估算值比目前状态的Q值更精确，所以把下个状态的估算值作为目标，来更新Q网络。此处单看critic网络吗，其目的仅在于预测V值，所以它的估算值也要向更准确的下个阶段估算值来靠近，即TD-error越来越小。<br>再来看actor网络，TD-error在其中的作用仅是更新网络时的权重，其与动作的选择并无直接关系。前期TD-error较大，每次更新时，动作的概率都会进行相对较大的改动，随着不断地训练，动作的概率逐渐成熟，TD-error越来越小，所以每次更新时对动作概率的改动也随之减小。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>为了避免正数陷阱，希望Actor的更新权重有正有负。因此，把Q值减去他们的均值V。有：<code>Q(s,a)-V(s)</code></li><li>为了避免需要预估V值和Q值，把Q和V统一；由于<code>Q(s,a) = gamma * V(s&#39;) + r - V(s)</code>。所以得到TD-error公式： <code>TD-error = gamma * V(s&#39;) + r - V(s)</code></li><li><code>TD-error就是Actor更新策略时候，带权重更新中的权重值</code>；</li><li>现在Critic不再需要预估Q，而是预估V。而根据马可洛夫链所学，知道TD-error就是Critic网络需要的loss，也就是说，Critic函数需要最小化TD-error。</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>定义两个network：Actor 和 Critic</li><li>进行N次更新。<ol><li>从状态s开始，执行动作a，得到奖励r，进入状态s’</li><li>记录的数据。</li><li>把输入到Critic，根据公式： TD-error &#x3D; gamma * V(s’) + r - V(s) 求 TD-error，并缩小TD-error</li><li>把输入到Actor，计算策略分布。</li></ol></li></ol><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/AC%E7%AE%97%E6%B3%95.png" alt="AC算法.png"></p><p>可以看出：在PG，智能体需要从头一直跑到尾，直到最终状态才开始进行学习。 在AC，智能体采用是每步更新的方式。</p><h3 id="AC-实现"><a href="#AC-实现" class="headerlink" title="AC 实现"></a>AC 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h2><p>PPO是基于AC框架的</p><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>首先要想办法处理连续动作的输出问题。</p><ul><li>离散动作：离散动作就像一个个的按钮，按一个按钮就能智能体就做一个动作。</li><li>连续动作：相当于按钮不但有开关的概念，而且还有力度大小的概念。就像开车，不但是前进后退转弯，并且要控制油门踩多深，刹车踩多少的，转弯时候转向转多少的问题。</li></ul><p>在离散动作空间的问题中，最终输出的策略呈现出下面形式：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E5%8A%A8%E4%BD%9C-%E7%AD%96%E7%95%A5%E5%88%86%E5%B8%83.png" alt="离散动作-策略分布.png"></p><p>假设动作空间有只有action1 和 action2，有40%的概率选择action1 ，60%概率选择action2。即在此状态下的策略分布: pi &#x3D; [0.4, 0.6]。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="连续型概率分布示意图.png"></p><p>在连续型，不再用数组表示，而是用函数表示。例如，策略分布函数 ： P &#x3D; (action)代表在策略下，选择某个action的概率P。</p><p>用神经网络预测输出的策略是一个固定的shape，而不是连续的。那又什么办法可以表示连续型的概率呢？可以假定策略分布函数服从一个概率分布，例如正态分布。</p><p>这样，只用两个参数就可以表示了。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="正态分布.png"></p><p>正态分布：</p><ul><li>sigma：表示方差，当sigma越大，图像越扁平；sigma约小，图像越突出。而最大值所在的位置，就是中轴线。</li><li>mu：表示平均数，也就是整个正态分布的中轴线。mu的变化，表示整个图像向左右移动。</li></ul><p>神经网络直接输出mu和sigma，就能获得整个策略的概率密度函数了。现在，当要按概率选择一个动作时，就只需要按照这个概率密度函数，随机抽取一个数，就能得到一个动作了。</p><h3 id="AC的问题"><a href="#AC的问题" class="headerlink" title="AC的问题"></a>AC的问题</h3><p>上面的正态分布解决了AC处理连续状态空间的问题。但是，AC还有一个问题：AC产生的数据，只能进行1次更新，更新完就只能丢掉，等待下一次的数据。</p><ul><li><p>行为策略：行为策略是代理在与环境交互时采取行动的策略。它决定了代理在当前状态下选择每一个可能的行动的概率分布。不是当前策略，用于产出数据。</p></li><li><p>目标策略：目标策略是代理在训练过程中试图优化的策略。它是代理最终想要学习到的最优策略，它通常被设计为最大化期望累积奖励。会更新的策略，是需要被优化的策略。</p></li><li><p>在线策略：在线策略是指在与环境交互时实时地采取行动，并根据实时的反馈来更新策略。也就是说，代理在与环境互动时，采取行动并根据实际结果来调整策略。目标策略和行为策略是同一个策略，那么是在线策略。</p><ul><li>实时更新：在线策略会根据每次与环境交互的结果来进行即时更新。</li><li>依赖实时反馈：在线策略依赖于实时的环境反馈来进行学习和调整。</li></ul></li><li><p>离线策略：离线策略是指在事先收集好的数据集上进行训练，而不需要实时地与环境交互。也就是说，代理使用事先收集的经验数据来训练策略，而不依赖于实时环境反馈。目标策略和行为策略不是同一个策略，那么是离线策略。</p><ul><li>离线数据：训练过程中不需要实时地与环境进行交互，可以使用先前收集的数据。</li><li>无需环境互动：训练过程中不需要实时环境反馈。</li></ul></li></ul><p>例子：<br>如果在智能体和环境进行互动时产生的数据打上一个标记。标记这是第几版本的策略产生的数据,例如 1， 2… 10。现在智能体用的策略 10，需要更新到 11。如果算法只能用 10版本的产生的数据来更新，那么这个就是在线策略；如果算法允许用其他版本的数据来更新，那么就是离线策略。</p><p>例如PG，就是一个在线策略。因为PG用于产生数据的策略(行为策略)，和需要更新的策略(目标策略)是一致。 而DQN则是一个离线策略。会让智能体在环境互动一定次数，获得数据。用这些数据优化策略后，继续跑新的数据。但老版本的数据仍然是可以用的。也就是说，产生数据的策略，和要更新的目标策略不是同一个策略。所以DQN是一个离线策略。</p><p><strong>为什么PG和AC中的Actor更新策略，不能像DQN一样把数据存起来，只能用一次产生的数据？</strong></p><p>看一个例子：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B.png" alt="策略P和策略B.png"></p><blockquote><p>TD-error 可以理解为从状态S 到下一个状态动作的价值，所以动作1的 TD-error 大，所以希望选择动作1的概率大</p></blockquote><p>假设，已知在同一个环境下，有两个动作可以选择。现在两个策略，分别是P和B： P: [0.5,0.5] B: [0.1,0.9]</p><p>现在按照两个策略，进行采样；也就是分别按照这两个策略，以S状态下出发，与环境进行10次互动。获得如图数据。那么，可以用B策略下获得的数据，更新P吗？</p><p>答案是不行，回顾PG算法，<code>PG算法会按照TD-error作为权重，更新策略。权重越大，更新幅度越大；权重越小，更新幅度越小。</code></p><p>但可以从如下示意图看到，如果用行动策略B[0.1,0.9]产出的数据，对目标策略P进行更新，动作1会被更新1次，而动作2会更新9次。虽然动作1的TD-error比较大，但由于动作2更新的次数更多，最终动作2的概率会比动作1的要大。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%AD%96%E7%95%A5P%E5%92%8C%E7%AD%96%E7%95%A5B%E6%9B%B4%E6%96%B0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="策略P和策略B更新示意图.png"></p><p>这不是期望看到的更新结果，因为动作1的TD-error比动作2要大，希望的是选择概率动作1的能更多。由此可以明白，在策略更新的时候不能使用其他策略产生的数据。</p><p><strong>为什么DQN可以多次重复使用数据？</strong></p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DQN%E6%9B%B4%E6%96%B0%E7%9A%84%E6%98%AFQ%E5%80%BC.png" alt="DQN更新的是Q值.png"></p><p>两个角度：</p><ul><li>更新Q值，和策略无关。 在同一个动作出发，可能会通往不同的state，但其中的概率是状态转移概率决定的，与环境有关，而不是策略所决定的。所以产生的数据和策略并没有关系。</li><li>在DQN的更新中是有”目标”的。 虽然目标比较飘忽，但每次更新，其实都是尽量向目标靠近。无论更新多少次，最终都会在目标附近徘徊。但PG算法，更新是不断远离原来的策略分布的，所以远离多少、远离的次数比例都必须把握好。</li></ul><blockquote><p>在Actor-Critic (AC) 方法中，Critic 网络更新的是状态值函数(Value Function)V，而不是动作值函数(Q函数)。</p></blockquote><h3 id="重要性采样技术"><a href="#重要性采样技术" class="headerlink" title="重要性采样技术"></a>重要性采样技术</h3><p>在PPO中，如果想使用策略B的数据来更新策略P，那就要把TD-error乘上一个重要性权重(importance weight)。</p><p>在这里<code>IW = P(a)/ B(a)</code></p><p>就是 <code>IW = 目标策略出现动作a的概率 / 行为策略出现a的概率</code>。</p><ul><li>目标策略：要更新的策略。</li><li>行为策略：数据的策略。</li></ul><p>这里是用策略B的数据来更新策略P，所以P是目标策略，B是行为策略。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E9%87%8D%E8%A6%81%E6%80%A7%E6%9D%83%E9%87%8D%E8%A1%A8%E6%A0%BC.png" alt="重要性权重表格.png"></p><p>现在即使用P策略: [0.5,0.5]进行更新，a1提升的概率也会比a2的更多。</p><p>PPO使用重要性采样技术把AC从在线策略变成离线策略。</p><h3 id="N步更新"><a href="#N步更新" class="headerlink" title="N步更新"></a>N步更新</h3><p>之前的TD叫做TD(0)，而N步更新为TD(n)。可以看成TD(0)其实是TD(n)的一种特殊情况。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD(N).png" alt="TD(N).png"></p><p>如图，实际上只需要计算最后的V(s’)，根据这个估算的V(s’), 反推经过的所有state的V值。这个其实和PG估算G的过程是一样的，只不过并不需要走到最后，而是中途截断，用网络估算。</p><p><code>V = R + gamma * V(s&#39;)</code></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>实际上，P策略和B策略差异并不能太大，为了能处理这个问题，有两个做法，PPO1 和 PPO2 。主流是PPO2。</p><ol><li>用AC来解决连续型控制问题。方法是输入mu和sigma，构造一个正态分布来表示策略； </li><li>PPO延展了TD(0)，变成TD(N)的N步更新； </li><li>AC是一个在线算法，但为了增加AC的效率，希望把它变成一个离线策略，这样就可以多次使用数据了。为了解决这个问题，PPO使用了重要性采样。</li></ol><h3 id="PPO-实现"><a href="#PPO-实现" class="headerlink" title="PPO 实现"></a>PPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="DDPG"><a href="#DDPG" class="headerlink" title="DDPG"></a>DDPG</h2><p>DDPG，全称是deep deterministic policy gradient，深度确定性策略梯度算法。</p><ul><li>deep: 深度网络。</li><li>policy gradient: PG</li><li>deterministic: 其实DDPG也是解决连续控制型问题的的一个算法，不过和PPO不一样，PPO输出的是一个策略，也就是一个概率分布，而DDPG输出的直接是一个动作。</li></ul><p>DDPG更接近DQN，是用一个actor去弥补DQN不能处理连续控制性问题的缺点。</p><h3 id="回顾DQN"><a href="#回顾DQN" class="headerlink" title="回顾DQN"></a>回顾DQN</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEDQN.png" alt="回顾DQN.png"></p><p>从公式中也能看出，DQN不能用于连续控制问题原因，是因为maxQ(s’,a’)函数只能处理离散型的。这个就是DDPG中的Actor的功能: 用一个magic函数，直接替代maxQ(s’,a’)的功能。也就是说，期待输入状态s，magic函数返回动作action的取值，这个取值能够让q值最大。</p><h3 id="理解DDPG"><a href="#理解DDPG" class="headerlink" title="理解DDPG"></a>理解DDPG</h3><p>DDPG中Critic的功能，像是DQN的深度网络，用一张布去覆盖Qlearning中的Qtable。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png" alt="理解DDPG1.png"></p><p>当把某个state输入到DDPG的Actor中的时候，相当于在这块布上做沿着state所在的位置剪开，会看到这个边缘是一条曲线。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png" alt="理解DDPG2.png"></p><blockquote><p>注意: 这条曲线很像概率分布，但要一定注意，这里并不是策略，也不是PPO和AC中的V值。是在某个状态state下，选择某个动作值的时候，能获得的Q值。</p></blockquote><p>Actor的任务就是在寻找这个曲线的最高点，然后返回能获得这个最高点，也是最大Q值的动作。 所以，DDPG其实并不是PG，并没有做带权重的梯度更新。而是在梯度上升，在寻找最大值。 这也就解释了，为什么DDPG是一个离线策略，但可以多次更新却不用importance sampling。这是因为这个算法就是DQN，和策略没有直接的关系。</p><h3 id="DDPG-1"><a href="#DDPG-1" class="headerlink" title="DDPG"></a>DDPG</h3><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG1.png" alt="DDPG1.png"></p><p>整理下：</p><h4 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h4><ol><li>Critic网络的作用是预估Q，虽然它还叫Critic，但和AC中的Critic不一样，这里预估的是Q不是V；</li><li>注意Critic的输入有两个：动作和状态，需要一起输入到Critic中；</li><li>Critic网络的loss其还是和AC一样，用的是TD-error。</li></ol><h4 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h4><ol><li>和AC不同，Actor输出的是一个动作；</li><li>Actor的功能是，输出一个动作A，这个动作A输入到Critic后，能够获得最大的Q值。</li><li>Actor的更新方式和AC不同，不是用带权重梯度更新，而是用梯度上升。</li></ol><p>和DQN一样，DDPG更新的时候如果更新目标在不断变动，会造成更新困难。所以DDPG和DQN一样，用了固定网络(fix network)技术，就是先冻结住用来求target的网络。在更新之后，再把参数赋值到target网络。</p><p>所以实际做的时候使用了4个网络：actor, critic, Actor_target, cirtic_target。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png" alt="DDPG2.png"></p><blockquote><p>目标网络只是用在求target的过程中。如果不是求target用的，就不用目标网络。</p></blockquote><h3 id="DDPG-实现"><a href="#DDPG-实现" class="headerlink" title="DDPG 实现"></a>DDPG 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="TD3"><a href="#TD3" class="headerlink" title="TD3"></a>TD3</h2><p>Twin Delayed Deep Deterministic policy gradient algorithm，双延迟深度确定性策略梯度</p><p>TD3是对DDPG的优化，三个重要优化。</p><h3 id="double-network"><a href="#double-network" class="headerlink" title="double network"></a>double network</h3><p>DDPG起源于DQN，DQN有一个众所周知的问题就是Q值会被过高估计。这是因为用argmaxQ(s’)去代替V(s’)，去评估Q(s)。当每一步都这样做的时候，很容易就会出现高估Q值的情况。</p><p>在TD3中，用了两套网络估算Q值，相对较小的那个作为更新的目标。这就是TD3的基本思路。</p><p>回顾DDPG：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/DDPG2.png" alt="DDPG2.png"></p><p>通过Critic网络估算动作的A值。一个Critic的评估可能会较高。所以加一个。</p><p>TD3需要用到6个网络：<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/TD3.png" alt="TD3.png"></p><p>在目标网络中，估算出来的Q值会用min()函数求出较小值。以这个值作为更新的目标。这个目标会更新两个网络 Critic网络_1 和 Critic网络_2。 这两个网络是完全独立，他们只是都用同一个目标进行更新。 剩余的就和DDPG一样了。过一段时间，把学习好的网络赋值给目标网络。</p><h4 id="Critic部分的学习"><a href="#Critic部分的学习" class="headerlink" title="Critic部分的学习"></a>Critic部分的学习</h4><p>只有在计算Critic的更新目标时，才用target network。其中就包括了一个Policy network，用于计算A’；两个critic target Q network ,用于计算两个Q值：Q1(A’) 和Q2(A’)。</p><p>Q1(A’) 和Q2(A’) 取最小值 min(Q1,Q2) 将代替DDPG的 Q(a’) 计算更新目标，也就是说： target &#x3D; min(Q1,Q2) * gamma + r</p><p>target 将会是 Q_network_1 和 Q_network_2 两个网络的更新目标。</p><p><code>TD-error_1 = gamma * min(Q1,Q2) + r - Q1</code><br><code>TD-error_2 = gamma * min(Q1,Q2) + r - Q2</code></p><p>既然更新目标是一样的，那么为什么还需要两个网络呢?</p><p>虽然更新目标一样，两个网络会越来越趋近与和实际q值相同。但由于网络参数的初始值不一样，会导致计算出来的值有所不同。所以可以有空间选择较小的值去估算q值，避免q值被高估。</p><h4 id="Actor部分的学习"><a href="#Actor部分的学习" class="headerlink" title="Actor部分的学习"></a>Actor部分的学习</h4><p>DDPG网络图像上就可以想象成一张布，覆盖在qtable上。当输入某个状态的时候，相当于这块布上的一个截面，能够看到在这个状态下的一条曲线。</p><p>而actor的任务，就是用梯度上升的方法，寻着这条线的最高点。</p><p>对于actor来说，其实并不在乎Q值是否会被高估，他的任务只是不断做梯度上升，寻找这条最大的Q值。随着更新的进行Q1和Q2两个网络，将会变得越来越像。所以用Q1还是Q2，还是两者都用，对于actor的问题不大。</p><h3 id="actor延迟更新"><a href="#actor延迟更新" class="headerlink" title="actor延迟更新"></a>actor延迟更新</h3><p>actor更新的delay，也就是说相对于critic可以更新多次后，actor再进行更新。</p><p>为什么要这样做呢？</p><p>回到qnet拟合出来的那块”布”上。 qnet在学习过程中，的q值是不断变化的，也就是说这块布是不断变形的。所以要寻着最高点的任务有时候就挺难为的actor了。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG1.png" alt="理解DDPG1.png"><br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%A7%A3DDPG2.png" alt="理解DDPG2.png"></p><p>可以想象，本来是最高点的，当actor好不容易去到最高点；q值更新了，这并不是最高点。这时候actor只能转头再继续寻找新的最高点。更坏的情况可能是actor被困在次高点，没有找到正确的最高点。</p><p>所以可以把Critic的更新频率，调的比Actor要高一点。让critic更加确定，actor再行动。</p><h3 id="target网络噪声"><a href="#target网络噪声" class="headerlink" title="target网络噪声"></a>target网络噪声</h3><p>TD3中，价值函数的更新目标每次都在action上加一个小扰动，这个操作就是target policy smoothing regularization</p><p>为什么要这样呢？</p><p>回到关于“布”的想象。 在DDPG中，计算target的时候，输入时s_和a_，获得q，也就是这块布上的一点A。通过估算target估算另外一点s，a，也就是布上的另外一点B的Q值。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E7%AE%97Q%201.png" alt="Q&#39;估算Q 1.png"></p><p>在TD3中，计算target时候，输入s_到actor输出a后，给a加上噪音，让a在一定范围内随机。这又什么好处呢。</p><p>好处就是，当更新多次的时候，就相当于用A点附近的一小部分范围(准确来说是在s_这条线上的一定范围)的去估算B，这样可以让B点的估计更准确，更健壮。<br><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/Q'%E4%BC%B0%E8%AE%A1Q%202.png" alt="Q&#39;估计Q 2.png"></p><p>这里注意三个地方：</p><ol><li>在实验中，同样加上了了noise。这个时候的noise是为了更充分地开发整个游戏空间。</li><li>计算target的时候，actor加上noise，是为了预估更准确，网络更有健壮性。</li><li>更新actor的时候，不需要加上noise，这里是希望actor能够寻着最大值。加上noise并没有任何意义。</li></ol><h3 id="TD3-实现"><a href="#TD3-实现" class="headerlink" title="TD3 实现"></a>TD3 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><p>这里的TD3仅针对自己的实验平台实现了类似于MATD3的效果，但是实际上，没有明确的MATD3。后面再考虑在gym上实现以加深理解。</p><h2 id="A3C"><a href="#A3C" class="headerlink" title="A3C"></a>A3C</h2><p>强化学习的一个难点，智能体的用于学习的数据，需要智能体和环境不断进行交互。和一般有监督学习的先比，数据数量太少了。</p><p>在算法没有更大进步的时候，有人就想出，如果有多个智能体和环境进行互动，那么每个智能体都能产出数据，这些数据就可以一起给模型进行学习了。</p><p>由此诞生了A3C。</p><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C.png" alt="A3C.png"></p><p>注意几点：</p><ol><li>在A3C中，worker不仅要和环境互动，产生数据，而且要自己从这些数据里面学习到“心得”。这里的所谓新的，其实就是计算出来的梯度；需要强调的是，worker向全局网络汇总的是梯度，而不是自己探索出来的数据。<blockquote><p>在这一点上，很容易和DPPO混淆。DPPO和A3C，也是一个分布式的架构，但work自己并不学习，而是提交数据让全局网络学习。</p></blockquote></li><li>worker向全局网络汇总梯度之后，并应用在全局网络的参数后，全局网络会把当前学习到的最新版本的参数，直接给worker。worker按照最新的网络继续跟环境做互动。互动后，再把梯度提交，获取新的参数…… 如此循环。</li></ol><p><img src="/../image/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/A3C1.png" alt="A3C1.png"></p><h3 id="A3C-实现"><a href="#A3C-实现" class="headerlink" title="A3C 实现"></a>A3C 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="DPPO"><a href="#DPPO" class="headerlink" title="DPPO"></a>DPPO</h2><p>DPPO和A3C的思路其实是一致的，希望用多个智能体同时和环境互动，并对全局的PPO网络进行更新。</p><p>在A3C，需要跑数据并且计算好梯度，再更新全局网络。这是因为AC是一个在线的算法，所以在更新的时候，产生数据的策略和更新的策略需要时同一个网络。所以不能把worker产出的数据，直接给全局网络计算梯度用。</p><p>但PPO解决了离线更新策略的问题，所以DPPO的工人只需要提供数据给全局网络，由全局网络从数据中直接学习。</p><h3 id="DPPO-实现"><a href="#DPPO-实现" class="headerlink" title="DPPO 实现"></a>DPPO 实现</h3><p>TODO: 这里所有算法的代码仅仅是看了一遍，还没有自己手写一遍，等这周联合组会后再说。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>到这里，传统强化学习的总结就结束了，后面由于我的科研方向是<code>多智能体强化学习</code>，会更新关于多智能体强化学习的算法。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react技巧</title>
      <link href="/posts/56292.html"/>
      <url>/posts/56292.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要是对开源项目中react-native的一些使用技巧进行总结。具体项目见：<a href="https://github.com/cwp0/casdoor-app">casdoor-app</a></p></blockquote><blockquote><p>后面如果做react的话可能也会做一些总结，到时候再加。</p></blockquote><h1 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h1><h2 id="React-Context"><a href="#React-Context" class="headerlink" title="React Context"></a>React Context</h2><p>用于在不同的组件中或者 <code>js</code> 文件中共享同一个数据。</p><p>使用方法：</p><p>例如要共享 <code>userInfo</code></p><ol><li><p>在应用程序中创建一个 <code>React Context</code>，用于共享 <code>userInfo</code>。</p><p><code>UserContext.js</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserProvider</span> = <span class="title class_">UserContext</span>.<span class="property">Provider</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UserConsumer</span> = <span class="title class_">UserContext</span>.<span class="property">Consumer</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">UserContext</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>App.js</code> 中使用 <strong><code>UserProvider</code></strong> 包裹应用程序</p><p>注意这里要设置需要共享的数据 <code>value=&#123;&#123;userInfo, setUserInfo&#125;&#125;</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">PaperProvider</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NavigationBar</span> <span class="keyword">from</span> <span class="string">&quot;./NavigationBar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NavigationContainer</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@react-navigation/native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./Header&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">UserProvider</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [userInfo, setUserInfo] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">UserProvider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;userInfo,</span> <span class="attr">setUserInfo</span>&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">PaperProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">NavigationBar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">PaperProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">UserProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li><li><p>在其他组件中，通过导入 <code>UserContext.js</code> 进行使用共享的数据。</p><p>注意：声明新的 <code>React.useContext</code>的时候需要用花括号。</p><p><code>Header.js</code></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Appbar</span>, <span class="title class_">Avatar</span>, <span class="title class_">Button</span>, <span class="title class_">Menu</span>, <span class="title class_">Text</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserContext</span> <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CasdoorLoginPage</span>, &#123;<span class="title class_">CasdoorLogout</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./CasdoorLoginPage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Header</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;userInfo, setUserInfo&#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">UserContext</span>);</span><br><span class="line">  <span class="keyword">const</span> [showLoginPage, setShowLoginPage] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [menuVisible, setMenuVisible] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">openMenu</span> = (<span class="params"></span>) =&gt; <span class="title function_">setMenuVisible</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">closeMenu</span> = (<span class="params"></span>) =&gt; <span class="title function_">setMenuVisible</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleMenuLogoutClicked</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">handleCasdoorLogout</span>();</span><br><span class="line">    <span class="title function_">closeMenu</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCasdoorLogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowLoginPage</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCasdoorLogout</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">CasdoorLogout</span>();</span><br><span class="line">    <span class="title function_">setUserInfo</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleHideLoginPage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowLoginPage</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Appbar.Header</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> <span class="attr">40</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Appbar.Content</span> <span class="attr">title</span>=<span class="string">&quot;Casdoor&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">visible</span>=<span class="string">&#123;menuVisible&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">anchor</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &lt;<span class="attr">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>, <span class="attr">backgroundColor:</span> &quot;<span class="attr">transparent</span>&quot;, <span class="attr">height:</span> <span class="attr">40</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onPress</span>=<span class="string">&#123;userInfo</span> === <span class="string">null</span> ? <span class="attr">handleCasdoorLogin</span> <span class="attr">:</span> <span class="attr">openMenu</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;</span></span><br><span class="line"><span class="language-xml">                userInfo === null ?</span></span><br><span class="line"><span class="language-xml">                  null :</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">Avatar.Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">size</span>=<span class="string">&#123;32&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">userInfo.avatar</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>, <span class="attr">backgroundColor:</span> &quot;<span class="attr">transparent</span>&quot;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  /&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginRight:</span> <span class="attr">10</span>&#125;&#125; <span class="attr">variant</span>=<span class="string">&quot;titleMedium&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;userInfo === null ? &quot;Login&quot; : userInfo.name&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          onDismiss=&#123;closeMenu&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> handleMenuLogoutClicked()&#125; title=&quot;Logout&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Appbar.Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;showLoginPage &amp;&amp; <span class="tag">&lt;<span class="name">CasdoorLoginPage</span> <span class="attr">onWebviewClose</span>=<span class="string">&#123;handleHideLoginPage&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Header</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="子组件使用父组件的函数等参数"><a href="#子组件使用父组件的函数等参数" class="headerlink" title="子组件使用父组件的函数等参数"></a>子组件使用父组件的函数等参数</h2><p>在父组件中：</p><p>定义好相关函数及变量，将参数传递给子组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [placeholder, setPlaceholder] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">closeEditAccountModal</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setShowEditAccountModal</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onAccountEdit</span> = (<span class="params">accountDescp</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> accountToEdit = accountList.<span class="title function_">find</span>(<span class="function"><span class="params">account</span> =&gt;</span> account.<span class="title function_">getEditStatus</span>() === <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (accountToEdit) &#123;</span><br><span class="line">      accountToEdit.<span class="title function_">setTitle</span>(accountDescp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setPlaceholder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="title function_">closeEditAccountModal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">EditAccountDetails</span> onClose=&#123;closeEditAccountModal&#125; onEdit=&#123;onAccountEdit&#125; placeholder=&#123;placeholder&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在子组件中：</p><p>添加相关代码，将父组件的函数等参数接收过来，然后就可以使用父组件的相关参数了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Text</span>, <span class="title class_">TextInput</span>, <span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Button</span>, <span class="title class_">IconButton</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">EnterAccountDetails</span>(<span class="params">&#123;onClose, onEdit, placeholder&#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">EnterAccountDetails</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">onClose</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">onEdit</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">placeholder</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [description, setDescription] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">onEdit</span>(description);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>, <span class="attr">justifyContent:</span> &quot;<span class="attr">center</span>&quot;, <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span> <span class="attr">24</span>, <span class="attr">marginBottom:</span> <span class="attr">5</span>&#125;&#125;&gt;</span>Enter new description<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flexDirection:</span> &quot;<span class="attr">row</span>&quot;, <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">IconButton</span> <span class="attr">icon</span>=<span class="string">&quot;account-details&quot;</span> <span class="attr">size</span>=<span class="string">&#123;35&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TextInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;description&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChangeText</span>=<span class="string">&#123;(text)</span> =&gt;</span> setDescription(text)&#125;</span></span><br><span class="line"><span class="language-xml">          style=&#123;&#123;borderWidth: 3, borderColor: &quot;white&quot;, margin: 10, width: 230, height: 50, borderRadius: 5, fontSize: 18, color: &quot;gray&quot;, paddingLeft: 10&#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">backgroundColor:</span> &quot;#<span class="attr">E6DFF3</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderRadius:</span> <span class="attr">5</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">margin:</span> <span class="attr">10</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">alignItems:</span> &quot;<span class="attr">center</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">position:</span> &quot;<span class="attr">absolute</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">top:</span> <span class="attr">160</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">width:</span> <span class="attr">300</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onPress</span>=<span class="string">&#123;handleConfirm&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span> <span class="attr">18</span>, <span class="attr">width:</span> <span class="attr">280</span>&#125;&#125;&gt;</span>Confirm<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">IconButton</span> <span class="attr">icon</span>=<span class="string">&#123;</span>&quot;<span class="attr">close</span>&quot;&#125; <span class="attr">size</span>=<span class="string">&#123;30&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;onClose&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span> &quot;<span class="attr">absolute</span>&quot;, <span class="attr">top:</span> <span class="attr">5</span>, <span class="attr">right:</span> <span class="attr">5</span>&#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父组件使用自组件的函数等参数"><a href="#父组件使用自组件的函数等参数" class="headerlink" title="父组件使用自组件的函数等参数"></a>父组件使用自组件的函数等参数</h2><p>在子组件中：</p><p>将父组件要使用的函数导出：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">WebView</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-webview&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">View</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Portal</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-native-paper&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CasdoorSdkConfig</span> <span class="keyword">from</span> <span class="string">&quot;./CasdoorSdkConfig&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">SDK</span> <span class="keyword">from</span> <span class="string">&quot;casdoor-react-native-sdk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserContext</span> <span class="keyword">from</span> <span class="string">&quot;./UserContext&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="comment">// import &#123;LogBox&#125; from &quot;react-native&quot;;</span></span><br><span class="line"><span class="comment">// LogBox.ignoreAllLogs();</span></span><br><span class="line"><span class="keyword">const</span> sdk = <span class="keyword">new</span> <span class="title function_">SDK</span>(<span class="title class_">CasdoorSdkConfig</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CasdoorLoginPage</span> = (<span class="params">&#123;onWebviewClose&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">CasdoorLoginPage</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">onWebviewClose</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [casdoorLoginURL, setCasdoorLoginURL] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;setUserInfo&#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">UserContext</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getCasdoorSignInUrl</span> = <span class="keyword">async</span>(<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> signinUrl = <span class="keyword">await</span> sdk.<span class="title function_">getSigninUrl</span>();</span><br><span class="line">    <span class="title function_">setCasdoorLoginURL</span>(signinUrl);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getCasdoorSignInUrl</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onNavigationStateChange</span> = <span class="keyword">async</span>(<span class="params">navState</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (navState.<span class="property">url</span>.<span class="title function_">startsWith</span>(<span class="title class_">CasdoorSdkConfig</span>.<span class="property">redirectPath</span>)) &#123;</span><br><span class="line">      <span class="title function_">onWebviewClose</span>();</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> sdk.<span class="title function_">getAccessToken</span>(navState.<span class="property">url</span>);</span><br><span class="line">      <span class="keyword">const</span> userInfo = sdk.<span class="title class_">JwtDecode</span>(token);</span><br><span class="line">      <span class="title function_">setUserInfo</span>(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Portal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;casdoorLoginURL !== &quot;&quot; &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">WebView</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> <span class="attr">casdoorLoginURL</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onNavigationStateChange</span>=<span class="string">&#123;onNavigationStateChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;flex:</span> <span class="attr">1</span>&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">mixedContentMode</span>=<span class="string">&quot;always&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">javaScriptEnabled</span>=<span class="string">&#123;true&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Portal</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">CasdoorLogout</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  sdk.<span class="title function_">clearState</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">CasdoorLoginPage</span>;</span><br></pre></td></tr></table></figure><p>在父组件中：</p><p>导入子组件及其导出的函数，注意导出的方式，导出的组件直接 <code>import</code> ，导出的组件的函数要使用花括号来包裹。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> 前端 </tag>
            
            <tag> react </tag>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云笔记系统扩容</title>
      <link href="/posts/36313.html"/>
      <url>/posts/36313.html</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前部署的云笔记系统的存储卷太小了，当用户数量增加的时候，笔记及用户信息会增大，这有可能会引起内存爆掉的情况。存储用户信息的 <code>mysql</code>和存储笔记信息的 <code>mongodb</code>在部署的时候我都设置了 <code>1G</code>的存储卷，这是远远不够的，因此需对其进行扩容。</p><p>根据老师要求，需将内存从 <code>1G</code>扩展到  <code>50G</code>，这是针对存笔记系统的 <code>mongodb</code>，为了更加稳妥，跟学弟协商后决定将存用户数据的 <code>mysql</code>也扩充到 <code>10G</code>。</p><h3 id="大体思路："><a href="#大体思路：" class="headerlink" title="大体思路："></a>大体思路：</h3><ol><li>确定 <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>所在的 <code>node</code>节点。</li><li>备份数据</li><li>删除旧的 <code>pod</code></li><li>分别修改 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>为 <code>50Gi</code>、 <code>10Gi</code>。</li><li>指定 <code>mongodb</code>和 <code>mysql</code>的 <code>pv</code>、 <code>pvc</code>及 <code>mongodb</code>、 <code>mysql</code>部署的亲和性，让其部署在指定 <code>node</code>节点，便于扩容。</li><li>重新部署相应 <code>pod</code></li><li>扩容指定的 <code>mongodb</code>、 <code>mysql</code>部署的节点的虚拟机。</li></ol><blockquote><p>注：本笔记图片里的 <code>deployment</code>的编号等信息可能会不一样，因为自己操作的时候可能会删了pod在重建导致其编号及时间等不一样，图片仅用于描述过程及结果。</p></blockquote><h2 id="1-确定pod所在的node节点"><a href="#1-确定pod所在的node节点" class="headerlink" title="1. 确定pod所在的node节点"></a>1. 确定pod所在的node节点</h2><p>首先远程连接 <code>131</code>服务器。</p><p>云笔记系统有 <code>6</code>个 <code>pod</code>，在 <code>note</code>空间里，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod.png" alt="pod"></p><p>需确定 <code>mongodb</code>、 <code>mysql</code>所在的 <code>node</code>节点，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note -o wide</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-node.png" alt="pod-node"></p><p>由上图可知， <code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>分别被部署到了 <code>k8s-node6</code>、 <code>k8s-node7</code>节点。</p><h2 id="2-备份数据"><a href="#2-备份数据" class="headerlink" title="2. 备份数据"></a>2. 备份数据</h2><p>问学长得知， <code>k8s-node6</code>、 <code>k8s-node7</code>节点位于 <code>122</code>服务器</p><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，登录 <code>node6</code>节点：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png" alt="vmware"></p><p>账号密码为 <code>root 123456</code>，登陆后如下：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/login.png" alt="login"></p><p>按下面命令将数据拷贝到 <code>tmp/backup</code>文件夹下进行备份：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup.png" alt="backup"></p><p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p><p>为了保险起见，使用 <code>xShell</code>中的 <code>xftp</code>将备份的文件再备份到桌面一份：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/xftp.png" alt="xftp"></p><p>打开 <code>xshell</code>点击新建文件传输，将 <code>/home</code>下的 <code>mongodb</code>文件夹拖动到桌面。</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/backup-desktop.png" alt="backup-desktop"></p><p>对 <code>node7</code>下的 <code>mysql</code>进行同样操作，不再赘述。</p><h2 id="3-删除旧的pod"><a href="#3-删除旧的pod" class="headerlink" title="3. 删除旧的pod"></a>3. 删除旧的pod</h2><p>删除旧的 <code>pod</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mysql-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mysql.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mongodb-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">delete</span> <span class="string">-f</span> <span class="string">note-mongodb.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/delete-pod.png" alt="delete-pod"></p><p>此时查看 <code>pod</code>结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deleted.png" alt="pod-after-deleted"></p><p><code>mongodb</code>和 <code>mysql</code>的 <code>pod</code>已经被删掉。</p><h2 id="4-修改pv、pvc"><a href="#4-修改pv、pvc" class="headerlink" title="4. 修改pv、pvc"></a>4. 修改pv、pvc</h2><p>将相关的 <code>yaml</code>文件修改为如下内容：</p><p><code>note-mongodb-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mysql-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p><code>yaml</code>文件里已经将内存修改为目标内存。</p><h2 id="5-指定亲和性"><a href="#5-指定亲和性" class="headerlink" title="5. 指定亲和性"></a>5. 指定亲和性</h2><p>这里的亲和性是 <code>Affinity</code>，指定了这个后会让其部署在指定标签的 <code>node</code>节点上。这样仅需将指定的 <code>node</code>节点的虚拟机扩容即可。</p><p>首先需要为 <code>node</code>节点添加标签。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为节点6和7添加label</span></span><br><span class="line">kubectl label nodes k8s-node6 notelabel=mongodb</span><br><span class="line">kubectl label nodes k8s-node7 notelabel=mysql</span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/add-labels.png" alt="add-labels"></p><p>指定完标签就可以添加亲和性了，如下：</p><p><code>note-mongodb-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mongodb</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">50Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mysql-pvc.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p><code>note-mongodb.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">mongodb</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30017</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><p><code>note-mysql.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">nodeAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">notelabel</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mysql-pvc</span> <span class="comment"># 使用之前创建的持久卷声明</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30006</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>这样，亲和性就修改完毕了。</p><h2 id="6-重新部署相应的pod"><a href="#6-重新部署相应的pod" class="headerlink" title="6. 重新部署相应的pod"></a>6. 重新部署相应的pod</h2><p>接下来按 <code>5. 指定亲和性</code> 所修改的 <code>yaml</code>重新进行 <code>pod</code>部署：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mysql-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mysql.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mongodb-pvc.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">note-mongodb.yaml</span> <span class="string">-n</span> <span class="string">note</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-deploy.png" alt="pod-deploy"></p><p>查看部署的结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">note</span> <span class="string">-o</span> <span class="string">wide</span></span><br></pre></td></tr></table></figure><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/pod-after-deploy.png" alt="pod-after-deploy"></p><p>可以看到已经将 <code>mongodb</code>和 <code>mysql</code>分别部署到了节点 <code>6</code>和 <code>7</code>上。</p><h2 id="7-扩容节点的虚拟机"><a href="#7-扩容节点的虚拟机" class="headerlink" title="7. 扩容节点的虚拟机"></a>7. 扩容节点的虚拟机</h2><p>远程连接 <code>122</code>服务器后，打开 <code>VMWare Workstation Pro</code>，如下：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/vmware.png" alt="vmware"></p><p>对于 <code>sx-k8s-node6</code>，先双击，然后点击上面的橙色运行按钮右边的下拉倒三角，关机。</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/shutdown.png" alt="shutdown"></p><p>然后右键 <code>sx-k8s-node6</code>，点设置</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/setting.png" alt="setting"></p><p>点击硬盘后点击右下角扩展</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/expand.png" alt="expand"></p><p>对硬盘容量进行修改。</p><p>这里原本是 <code>40G</code>，我增加了 <code>50G</code>后变为了 <code>90G</code>。</p><p><code>sx-k8s-node7</code>的操作类似，不再赘述。</p><p>此时打开网址，访问成功！扩容成功！</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问(连校园网，关梯子)：</p><p><a href="http://192.10.84.209:33395/cloudNote/">http://192.10.84.209:33395/cloudNote/</a></p><p>账号：姓名小写拼音</p><p>密码：123456</p><p>效果：</p><p><img src="/../image/%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s部署云笔记系统</title>
      <link href="/posts/16330.html"/>
      <url>/posts/16330.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>起因是导师之前让两个研一的学弟学妹写了个前后端的云笔记系统，然后后面让我部署到服务器中，因此记录一下。</p></blockquote><h2 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h2><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建namespace</span><br><span class="line">kubectl create namespace note</span><br></pre></td></tr></table></figure><h2 id="1-部署MySQL"><a href="#1-部署MySQL" class="headerlink" title="1. 部署MySQL"></a>1. 部署MySQL</h2><p>创建mysql文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /home/mysql/data</span><br></pre></td></tr></table></figure><h3 id="1-1-挂载数据卷"><a href="#1-1-挂载数据卷" class="headerlink" title="1.1 挂载数据卷"></a>1.1 挂载数据卷</h3><p>note-mysql-pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line"><span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/home/mysql/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line"><span class="attr">requests:</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">volumeName:</span> <span class="string">note-mysql-pv</span></span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mysql-pvc.yaml -n note</span><br></pre></td></tr></table></figure><p>查看是否部署成功：</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/1.png" alt="mysql是否部署成功"></p><h3 id="1-2-部署mysql"><a href="#1-2-部署mysql" class="headerlink" title="1.2 部署mysql"></a>1.2 部署mysql</h3><p>note-mysql.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_mysql:v1.1.0</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mysql-persistent-storage</span></span><br><span class="line"><span class="attr">persistentVolumeClaim:</span></span><br><span class="line">  <span class="attr">claimName:</span> <span class="string">note-mysql-pvc</span> <span class="comment"># 使用之前创建的持久卷声明</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">note-mysql-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">nodePort:</span> <span class="number">30006</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line"><span class="attr">targetPort:</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mysql.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="2-部署redis"><a href="#2-部署redis" class="headerlink" title="2. 部署redis"></a>2. 部署redis</h2><p>note-redis.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-redis-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-redis</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-redis-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-redis-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30079</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-redis.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="3-部署mongodb"><a href="#3-部署mongodb" class="headerlink" title="3. 部署mongodb"></a>3. 部署mongodb</h2><p>创建mongodb文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /home/mongodb/data</span><br></pre></td></tr></table></figure><h3 id="3-1-挂载数据卷"><a href="#3-1-挂载数据卷" class="headerlink" title="3.1 挂载数据卷"></a>3.1 挂载数据卷</h3><p>note-mongodb-pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/mongodb/data</span> <span class="comment"># 主机上的数据存储路径</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">volumeName:</span> <span class="string">note-mongodb-pv</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mongodb-pvc.yaml -n note</span><br></pre></td></tr></table></figure><p>查看是否装好：</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/2.png" alt="mongodb-pvc"></p><h3 id="3-2-部署"><a href="#3-2-部署" class="headerlink" title="3.2 部署"></a>3.2 部署</h3><p>note-mongodb.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-mongodb:v1.1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_USERNAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">admin</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_INITDB_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">5c8b18289f7848e9b0af98e81562649d</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-mongodb-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">note-mongodb-pvc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-mongodb-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-mongodb-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30017</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-mongodb.yaml -n note</span><br></pre></td></tr></table></figure><p>检查部署情况</p><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/3.png" alt="mongodb"></p><h2 id="4-部署服务bert-flask"><a href="#4-部署服务bert-flask" class="headerlink" title="4. 部署服务bert_flask"></a>4. 部署服务bert_flask</h2><p>bert_flask.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bert-flask-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">bert-flask</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/bert_flask:v1.3.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bert-flask-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">bert-flask-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30050</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f bert_flask.yaml -n note</span><br></pre></td></tr></table></figure><p>检查部署情况<br><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png" alt="bert_flask"></p><h2 id="5-部署服务note-cloud"><a href="#5-部署服务note-cloud" class="headerlink" title="5. 部署服务note_cloud"></a>5. 部署服务note_cloud</h2><h3 id="5-1-配置ConfigMap"><a href="#5-1-配置ConfigMap" class="headerlink" title="5.1 配置ConfigMap"></a>5.1 配置ConfigMap</h3><p>   新建application-prod.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://note-mysql-service:3306/db_note</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dfa6f1b032ee42ed95d12647225f2ff4</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">note-redis-service</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">adcc64a4a9b04324914626590fb52a1a</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">      <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span> <span class="comment"># JSON处理时忽略非空字段</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://note-user:c88c1b8c2ed94010-8372efbc0879bdcb@note-mongodb-service:27017/mongodb_note</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">10MB</span></span><br><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">base64-encoded-secret-key:</span> <span class="string">lab_of_njust_cloud_computing</span> <span class="comment"># jwt的签名密码</span></span><br><span class="line"><span class="attr">bert-base-chinese-service:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bert-flask-service</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap note-cloud-config -n note --fromfile=application-prod.yml</span><br></pre></td></tr></table></figure><p>   查看部署状态<br>   <img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/4.png" alt="部署效果"></p><h3 id="5-2-部署服务"><a href="#5-2-部署服务" class="headerlink" title="5.2 部署服务"></a>5.2 部署服务</h3><p>note-cloud.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-cloud-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-cloud</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note_cloud:v1.3.0</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/app/config</span> <span class="comment"># 配置文件将挂载到容器的/app/config目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">note-cloud-config</span> <span class="comment"># 引用之前创建的 ConfigMap</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-cloud-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-cloud-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-cloud.yaml -n note</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n note</span><br><span class="line">kubectl logs -f note-cloud-deployment-6687c5cb49-vc7kl -n note</span><br></pre></td></tr></table></figure><h2 id="6-部署前端"><a href="#6-部署前端" class="headerlink" title="6. 部署前端"></a>6. 部署前端</h2><p>note-nginx.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">note-nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lucas-njfu/note-nginx:v2.2.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">note-nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">note-nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30088</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767),如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>helm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f note-nginx.yaml -n note</span><br></pre></td></tr></table></figure><h2 id="最终部署pod查看"><a href="#最终部署pod查看" class="headerlink" title="最终部署pod查看"></a>最终部署pod查看</h2><p><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/5.png" alt="pod"></p><p>访问(连校园网，关梯子)：</p><p><a href="http://192.10.84.209:33395/cloudNote/">http://192.10.84.209:33395/cloudNote/</a><br>账号：姓名小写拼音<br>密码：123456</p><p>最终效果：<br><img src="/../image/k8s%E9%83%A8%E7%BD%B2%E4%BA%91%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
