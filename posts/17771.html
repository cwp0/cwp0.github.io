<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>框架 | cwp0</title><meta name="author" content="cwp0"><meta name="copyright" content="cwp0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="框架方面的面经">
<meta property="og:type" content="article">
<meta property="og:title" content="框架">
<meta property="og:url" content="https://cwp0.github.io/posts/17771.html">
<meta property="og:site_name" content="cwp0">
<meta property="og:description" content="框架方面的面经">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png">
<meta property="article:published_time" content="2024-06-12T14:49:36.000Z">
<meta property="article:modified_time" content="2024-07-06T07:52:00.000Z">
<meta property="article:author" content="cwp0">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png"><link rel="shortcut icon" href="/img/assets/%E5%A4%B4%E5%83%8F.JPG"><link rel="canonical" href="https://cwp0.github.io/posts/17771.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"YNCOX66CR4","apiKey":"5c661928f53edb93f42b2f41a467cbfb","indexName":"cwp0_github_io","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":66,"languages":{"author":"Author: cwp0","link":"Link: ","source":"Source: cwp0","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-06 15:52:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/assets/%E5%A4%B4%E5%83%8F.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-image"></i><span> Picture</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/06/12/avltHdTKVQ4JADx.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cwp0"><img class="site-icon" src="/img/assets/%E5%A4%B4%E5%83%8F.JPG"/><span class="site-name">cwp0</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-image"></i><span> Picture</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-12T14:49:36.000Z" title="Created 2024-06-12 22:49:36">2024-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-07-06T07:52:00.000Z" title="Updated 2024-07-06 15:52:00">2024-07-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">22.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>75min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文参考 <a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide</a></p>
</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h3><p>Spring 是一款基于 Java 的轻量级开源开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>Spring 框架(Spring Framework)是很多模块的集合，使用这些模块可以很方便地协助进行开发。Spring 支持控制反转(Inversion of Control, IOC) 和 面向切面编程(Aspect-Oriented Programming, AOP)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件(电子邮件，任务，调度，缓存等等)、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<p>Spring的核心功能主要是 <code>IoC</code> 和 <code>AOP</code>，核心思想是不重新造轮子，开箱即用，提高开发效率。</p>
<h3 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p><img src="/./image/Framework/Spring-4-x.png" alt="Spring 4.x"></p>
<p>Spring5.x 版本中 Web 模块的 <code>Portlet</code> 组件已经被废弃掉，同时增加了用于异步响应式处理的 <code>WebFlux</code> 组件。</p>
<ul>
<li><code>Core Container</code>：Spring 框架的核心模块、基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块。<ul>
<li><code>spring-core</code>：Spring 框架基本的核心工具类。</li>
<li><code>spring-beans</code>：提供对 <code>bean</code> 的创建、配置和管理等功能的支持。</li>
<li><code>spring-context</code>：提供对国际化、事件传播、资源加载等功能的支持。</li>
<li><code>spring-expression</code>：提供对表达式语言(Spring Expression Language, SpEL)的支持，只依赖于 <code>core</code> 模块，不依赖于其他模块，可以单独使用。</li>
</ul>
</li>
<li><code>AOP</code>：面向切面编程，提供对切面编程的支持。<ul>
<li><code>spring-aop</code>：提供了面向切面的编程实现。</li>
<li><code>spring-aspects</code>：该模块为与 <code>AspectJ</code> 的集成提供支持。</li>
<li><code>spring-instrument</code>：提供了为 JVM 添加代理(agent)的功能。其为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。</li>
</ul>
</li>
<li><code>Data Access/Integration</code>：数据访问&#x2F;集成层，提供对数据库访问、事务管理、ORM、OXM、JMS 等功能的支持。<ul>
<li><code>spring-jdbc</code>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><code>spring-tx</code>：提供事务管理的支持。</li>
<li><code>spring-orm</code>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</li>
<li><code>spring-oxm</code>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li>
<li><code>spring-jms</code>：消息服务。自 Spring Framework 4.1 以后，它还提供了对 <code>spring-messaging</code> 模块的继承。</li>
</ul>
</li>
<li><code>Spring Web</code>：Web 模块，提供对 Web 应用开发的支持。<ul>
<li><code>spring-web</code>：提供了基本的 Web 功能，如多文件上传、使用 <code>Servlet</code> 监听器初始化 Spring IoC 容器等。</li>
<li><code>spring-webmvc</code>：提供了 Spring MVC 的实现。</li>
<li><code>spring-websocket</code>：提供了对 WebSocket 的支持，可以让客户端和服务端进行双向通信。</li>
<li><code>spring-webflux</code>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li>
</ul>
</li>
<li><code>Messaging</code>：<code>spring-messaging</code> 是Spring4.0新加入的模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li>
<li><code>Spring Test</code>：Spring有控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。Spring 的测试模块对 JUnit(单元测试框架)、TestNG(类似 JUnit)、Mockito(主要用来 Mock 对象)、PowerMock(解决 Mockito 的问题比如无法模拟 <code>final</code>，<code>static</code>，<code>private</code> 方法)等等常用的测试框架支持的都比较好。</li>
</ul>
<p><img src="/./image/Framework/Spring%E5%90%84%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="Spring各模块依赖关系"></p>
<h3 id="Spring-Spring-Boot-Spring-MVC之间的关系"><a href="#Spring-Spring-Boot-Spring-MVC之间的关系" class="headerlink" title="Spring&#x2F;Spring Boot&#x2F;Spring MVC之间的关系"></a>Spring&#x2F;Spring Boot&#x2F;Spring MVC之间的关系</h3><ul>
<li>Spring是基于 Java 的轻量级开源框架，包含众多模块，其中最重要的是<code>Spring-Core</code>(主要提供 <code>IoC</code> 依赖注入功能的支持)模块， Spring中的其他模块(如 <code>Spring MVC</code>)的功能实现基本都需要依赖于该模块。</li>
<li><code>Spring MVC</code> 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</li>
<li>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。过于麻烦，所以 <code>Spring Boot</code> 诞生了，其只是简化了配置，如果需要构建 MVC 架构的 Web 程序，还是需要使用 <code>Spring MVC</code> 作为 MVC 框架，只是说 <code>Spring Boot</code> 简化了 <code>Spring MVC</code> 的很多配置，真正做到开箱即用！<ul>
<li>Spring 旨在简化 J2EE 企业应用程序开发。<code>Spring Boot</code> 旨在简化 Spring 开发(减少配置文件，开箱即用！)。</li>
</ul>
</li>
</ul>
<h3 id="Spring-IoC✅"><a href="#Spring-IoC✅" class="headerlink" title="Spring IoC✅"></a>Spring IoC✅</h3><h3 id="什么是Spring-IoC"><a href="#什么是Spring-IoC" class="headerlink" title="什么是Spring IoC"></a>什么是Spring IoC</h3><p>控制反转(Inversion of Control, IoC)是一种设计思想，而不是一个具体的技术实现，并非Spring特有。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
<p>现有类 A 依赖于类 B</p>
<ul>
<li>传统的开发方式 ：往往是在类 A 中手动通过 <code>new</code> 关键字来 new 一个 B 的对象出来</li>
<li>使用 IoC 思想的开发方式 ：不通过 <code>new</code> 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。</li>
</ul>
<p>IoC使开发者丧失了创建、管理对象的权利，但是也使得开发者不用再考虑对象的创建、管理等一系列的事情，只需要专注于业务逻辑的实现。</p>
<h3 id="IoC解决了什么问题"><a href="#IoC解决了什么问题" class="headerlink" title="IoC解决了什么问题"></a>IoC解决了什么问题</h3><ol>
<li><strong>依赖管理和解耦</strong>：在传统的Java应用中，类与类之间的依赖是通过硬编码实现的，这导致了代码的高度耦合和难以维护。Spring IoC通过依赖注入(Dependency Injection，DI)模式，将对象的创建和依赖关系的管理交给Spring容器处理，从而实现了组件之间的解耦，提升了代码的可维护性和可测试性。</li>
<li><strong>对象生命周期管理</strong>：Spring容器负责管理Bean的生命周期，从创建、初始化到销毁，开发者可以通过配置和注解来控制这些生命周期方法，从而避免了手动管理对象生命周期的复杂性。</li>
<li><strong>配置集中管理</strong>：通过Spring IoC，可以将应用程序的配置信息集中在一个或多个配置文件中(如XML文件、Java配置类或注解)，从而使得配置更加集中和统一，便于管理和维护。</li>
<li><strong>代码的可测试性</strong>：通过依赖注入，可以轻松地替换实际的依赖对象为模拟对象(mock objects)，从而提高了单元测试的可行性和便捷性。</li>
<li><strong>模块化和可插拔性</strong>：Spring IoC支持通过不同的配置方式(XML、注解、Java配置类等)来实现模块化配置，便于扩展和维护。同时，Spring IoC容器支持不同类型的Bean作用域(如单例、原型等)，增强了系统的灵活性和可扩展性。</li>
</ol>
<p>通过Spring IoC的依赖注入和面向接口编程的方式，开发者可以更加专注于业务逻辑的实现，而不必过多关心对象的创建和管理，从而提升了开发效率和代码质量。</p>
<h3 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h3><p>控制反转指将对象的创建和依赖关系的管理从应用程序代码中抽离出来，交给Spring容器进行管理。</p>
<p><strong>控制反转</strong></p>
<ul>
<li>控制：指的是对象创建(实例化、管理)的权力</li>
<li>反转：控制权交给外部环境(Spring 框架、<code>IoC</code> 容器)</li>
</ul>
<p>实现控制反转有多种方式：</p>
<ul>
<li>依赖注入：通过注入方式实现依赖管理，易于测试和维护，广泛应用于现代开发框架(如Spring)。</li>
<li>服务定位器模式：通过中央注册器获取服务，使用方便，但可能引入全局状态和隐藏依赖。</li>
<li>事件驱动架构：通过事件进行解耦，适用于异步处理和复杂业务流程。</li>
<li>依赖查找：通过标准API查找依赖，适用于某些特定场景，但查找过程可能较为复杂。</li>
</ul>
<p><strong>Spring IoC容器</strong><br>Spring IoC容器是负责管理对象及其依赖关系的核心组件。IoC 容器实际上就是个 Map(key，value)，Map 中存放的是各种对象。主要的IoC容器有：</p>
<ul>
<li><code>BeanFactory</code>：最基础的IoC容器，提供基本的依赖注入功能。</li>
<li><code>ApplicationContext</code>：继承自<code>BeanFactory</code>，提供更多高级功能，如事件发布、国际化、AOP等。</li>
</ul>
<h3 id="什么是Spring-Bean"><a href="#什么是Spring-Bean" class="headerlink" title="什么是Spring Bean"></a>什么是Spring Bean</h3><p>在Spring中，bean是由IoC容器管理的对象。bean的定义和配置可以通过以下几种方式：</p>
<ul>
<li>XML配置文件：在XML文件中定义<code>bean</code>及其依赖关系。</li>
<li>注解配置：通过Java注解(如<code>@Component</code>、<code>@Autowired</code>等)定义和注入<code>bean</code>。</li>
<li>Java配置类：使用<code>@Configuration</code>和<code>@Bean</code>注解，通过Java类定义<code>bean</code>。</li>
</ul>
<h3 id="将一个类声明为Bean的注解有哪些"><a href="#将一个类声明为Bean的注解有哪些" class="headerlink" title="将一个类声明为Bean的注解有哪些"></a>将一个类声明为Bean的注解有哪些</h3><ul>
<li><code>@Component</code>：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code>： 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code>： 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code>： 对应 <code>Spring MVC</code> 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="Component-Bean区别"><a href="#Component-Bean区别" class="headerlink" title="@Component&#x2F;@Bean区别"></a>@Component&#x2F;@Bean区别</h3><p><strong>主要区别</strong></p>
<ol>
<li>定义方式：</li>
</ol>
<ul>
<li><code>@Component</code> 是在类上使用，Spring 自动扫描并注册 Bean。</li>
<li><code>@Bean</code> 是在方法上使用，返回值被注册为 Bean。</li>
</ul>
<ol start="2">
<li>适用场景：</li>
</ol>
<ul>
<li><code>@Component</code> 适用于开发人员自己编写的类。</li>
<li><code>@Bean</code> 适用于第三方库的类或需要复杂配置的 Bean。</li>
</ul>
<ol start="3">
<li>扫描和配置：</li>
</ol>
<ul>
<li><code>@Component</code> 需要启用组件扫描。</li>
<li><code>@Bean</code> 通常与配置类一起使用，不需要组件扫描。</li>
</ul>
<p>总结来说，<code>@Component</code> 更适合于直接在类上进行标注，简化了配置过程；而 <code>@Bean</code> 则提供了更多的灵活性，可以在配置类中以编程的方式定义 Bean。</p>
<p><strong>@Component</strong></p>
<ul>
<li>用途：<code>@Component</code> 用于标记一个类为 Spring 容器的组件(Bean)。</li>
<li>使用方式：直接在类上使用。Spring 会自动扫描带有 <code>@Component</code> 注解的类，并将其注册为 Spring 容器中的 Bean。</li>
<li>扫描：需要在配置类上使用 <code>@ComponentScan</code> 注解来启用自动扫描。</li>
<li>适用范围：通常用于标记服务层、数据访问层、控制层等组件类。</li>
<li>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 服务实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>@Bean</strong></li>
<li>用途：<code>@Bean</code> 用于在配置类中定义一个方法，该方法的返回值会被注册为 Spring 容器中的 Bean。</li>
<li>使用方式：在配置类的方法上使用，方法的返回值会作为 Bean 注册到 Spring 容器中。</li>
<li>配置类：通常与 <code>@Configuration</code> 注解一起使用，表明这是一个配置类。</li>
<li>适用范围：通常用于定义第三方库的 Bean，或者需要复杂初始化的 Bean。</li>
<li>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用于注入Bean的注解有哪些？"><a href="#用于注入Bean的注解有哪些？" class="headerlink" title="用于注入Bean的注解有哪些？"></a>用于注入Bean的注解有哪些？</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li><strong>用途</strong>：<code>@Autowired</code> 用于自动注入 Bean，Spring 会自动满足标记了该注解的依赖。</li>
<li><strong>使用位置</strong>：可以用在字段、构造方法、Setter 方法以及普通方法上。</li>
<li><strong>特点</strong>：默认按类型注入，可以结合 <code>@Qualifier</code> 按名称注入。</li>
<li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li><strong>用途</strong>：<code>@Resource</code> 是 JSR-250 标准的注解，可以按名称或类型注入。</li>
<li><strong>使用位置</strong>：字段、Setter 方法。</li>
<li><strong>特点</strong>：默认按名称注入，如果找不到匹配的 Bean，则按类型注入。</li>
<li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name = &quot;myRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><ul>
<li><strong>用途</strong>：与 <code>@Autowired</code> 一起使用，按名称注入 Bean。</li>
<li><strong>使用位置</strong>：字段、构造方法参数、Setter 方法参数。</li>
<li><strong>特点</strong>：解决同类型 Bean 多个实例的冲突问题。</li>
<li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;specificRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h4><ul>
<li><strong>用途</strong>：<code>@Inject</code> 是 JSR-330 标准的注解，功能与 <code>@Autowired</code> 类似。</li>
<li><strong>使用位置</strong>：字段、构造方法、Setter 方法。</li>
<li><strong>特点</strong>：仅支持按类型注入，可以结合 <code>@Named</code> 注解按名称注入。</li>
<li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用构造方法注入</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ul>
<li><strong>用途</strong>：<code>@Value</code> 用于注入简单值，比如基本类型、字符串、Spring EL 表达式等。</li>
<li><strong>使用位置</strong>：字段、构造方法参数、Setter 方法参数。</li>
<li><strong>特点</strong>：可以注入配置文件中的属性值。</li>
<li><strong>例子</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>@Autowired</code> 和<code>@Resource</code>用的多一些。</p>
<h3 id="Autowired-Resource区别"><a href="#Autowired-Resource区别" class="headerlink" title="@Autowired&#x2F;@Resource区别"></a>@Autowired&#x2F;@Resource区别</h3><ul>
<li>默认注入方式：<ul>
<li><code>@Autowired</code> 默认根据接口类型(<code>byType</code>)去匹配并注入Bean(接口的实现类)。当一个接口存在多个实现类的话，<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定类名称。</li>
<li><code>@Resource</code> 当一个接口存在多个实现类的话，默认按类名称(<code>byName</code>)注入。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</li>
</ul>
</li>
<li>注解来源：<ul>
<li><code>@Autowired</code>：Spring 框架提供的注解。</li>
<li><code>@Resource</code>：JSR-250(JDK) 标准提供的注解。</li>
</ul>
</li>
<li>使用位置：<ul>
<li><code>@Autowired</code> 可以用在构造函数、方法、字段以及参数上。</li>
<li><code>@Resource</code> 通常用在字段和 Setter 方法上的注入。</li>
</ul>
</li>
<li>配置属性：<ul>
<li><code>@Autowired</code>：可以结合 <code>@Qualifier</code> 按名称注入。</li>
<li><code>@Resource</code>：可以通过 <code>name</code> 属性指定 <code>Bean</code> 名称，通过 <code>type</code> 属性指定 Bean 类型。</li>
</ul>
</li>
<li>处理机制：<ul>
<li><code>@Autowired</code>：使用 Spring 的依赖注入机制。</li>
<li><code>@Resource</code>：使用 JNDI 进行资源查找，适合在 Java EE 容器环境中使用。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>@Autowired</code> 更加灵活和强大，适合在 Spring 应用中广泛使用；而 <code>@Resource</code> 则提供了一种更标准化的方式进行依赖注入，特别是在需要与 Java EE 容器进行集成时。</p>
<blockquote>
<p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>(名称)、<code>type</code>(类型)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code>和<code>type</code>属性(不建议这么做)则注入方式为<code>byType</code>+<code>byName</code>。</p>
</blockquote>
<h3 id="Bean的作用域有哪些？"><a href="#Bean的作用域有哪些？" class="headerlink" title="Bean的作用域有哪些？"></a>Bean的作用域有哪些？</h3><p>在 Spring 框架中，Bean 的作用域(scope)定义了 Bean 的生命周期和可见性。Spring 提供了以下几种常见的 Bean 作用域：</p>
<ul>
<li><code>Singleton</code><ul>
<li><strong>描述</strong>：默认作用域。在整个 Spring 容器中只有一个 Bean 实例，每次请求该 Bean 时都会返回同一个实例。</li>
<li><strong>使用场景</strong>：大多数情况下使用，适用于无状态的 Bean。</li>
</ul>
</li>
<li><code>Prototype</code><ul>
<li><strong>描述</strong>：每次请求该 Bean 时，都会创建一个新的实例。</li>
<li><strong>使用场景</strong>：适用于有状态的 Bean 或需要每次使用时创建新实例的 Bean。</li>
</ul>
</li>
<li><code>Request</code><ul>
<li><strong>描述</strong>：在一个 HTTP 请求中，每次请求该 Bean 时，都会创建一个新的实例。该作用域仅在 Web 应用程序中有效。</li>
<li><strong>使用场景</strong>：适用于每个 HTTP 请求需要一个独立 Bean 实例的情况，例如处理用户请求的控制器。</li>
</ul>
</li>
<li><code>Session</code><ul>
<li><strong>描述</strong>：在一个 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域仅在 Web 应用程序中有效。</li>
<li><strong>使用场景</strong>：适用于需要在整个用户会话期间保持状态的 Bean。</li>
</ul>
</li>
<li><code>Global Session</code><ul>
<li><strong>描述</strong>：在一个全局 HTTP 会话中，每次请求该 Bean 时，都会返回同一个实例。该作用域主要用于 Portlet 应用程序。</li>
<li><strong>使用场景</strong>：适用于需要在全局 Portlet 会话期间保持状态的 Bean。</li>
</ul>
</li>
<li><code>Application</code><ul>
<li><strong>描述</strong>：在整个应用程序生命周期内，每次请求该 Bean 时，都会返回同一个实例。通常在 Web 应用程序中使用。</li>
<li><strong>使用场景</strong>：适用于需要在整个应用程序生命周期内共享的 Bean。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scope中可以指定Bean的作用域，取值：singleton、prototype、request、session、globalSession、application</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingletonBean</span> &#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h3><p>在 Spring 框架中，Bean 的线程安全性取决于其作用域和状态。以下是一些常见情况：</p>
<h4 id="Singleton-Bean"><a href="#Singleton-Bean" class="headerlink" title="Singleton Bean"></a>Singleton Bean</h4><ul>
<li><strong>默认作用域</strong>：<code>@Scope(&quot;singleton&quot;)</code></li>
<li><strong>描述</strong>：单例 Bean 在 Spring 容器中只有一个实例，并且该实例会被多个线程共享。</li>
<li><strong>线程安全性</strong>：单例 Bean 本身并不是线程安全的。如果单例 Bean 中包含可变的共享状态，则需要确保其线程安全。这可以通过以下方式实现：<ul>
<li>不在单例 Bean 中使用可变状态。</li>
<li>使用线程安全的数据结构(如 <code>ConcurrentHashMap</code>)。</li>
<li>在访问可变状态时使用同步(如 <code>synchronized</code>)。</li>
<li>采用无状态的设计模式。</li>
</ul>
</li>
</ul>
<h4 id="Prototype-Bean"><a href="#Prototype-Bean" class="headerlink" title="Prototype Bean"></a>Prototype Bean</h4><ul>
<li><strong>作用域</strong>：<code>@Scope(&quot;prototype&quot;)</code></li>
<li><strong>描述</strong>：原型 Bean 每次请求时都会创建一个新的实例，因此每个线程都会获得一个新的实例。</li>
<li><strong>线程安全性</strong>：由于每个线程都有自己的实例，原型 Bean 通常是线程安全的。但是，原型 Bean 的生命周期由使用它的对象管理，可能需要注意其创建和销毁的时机。</li>
</ul>
<h4 id="Request-Session-Scoped-Beans"><a href="#Request-Session-Scoped-Beans" class="headerlink" title="Request &amp; Session Scoped Beans"></a>Request &amp; Session Scoped Beans</h4><ul>
<li><strong>作用域</strong>：<code>@Scope(&quot;request&quot;)</code> 和 <code>@Scope(&quot;session&quot;)</code></li>
<li><strong>描述</strong>：请求作用域的 Bean 在一个 HTTP 请求中创建和销毁。会话作用域的 Bean 在一个 HTTP 会话中创建和销毁。</li>
<li><strong>线程安全性</strong>：请求作用域的 Bean 通常是线程安全的，因为每个请求都是独立的。会话作用域的 Bean 可能会被多个线程共享，需要考虑线程安全性。</li>
</ul>
<h4 id="Application-Scoped-Beans"><a href="#Application-Scoped-Beans" class="headerlink" title="Application Scoped Beans"></a>Application Scoped Beans</h4><ul>
<li><strong>作用域</strong>：<code>@Scope(&quot;application&quot;)</code></li>
<li><strong>描述</strong>：应用程序作用域的 Bean 在整个应用程序生命周期内共享。</li>
<li><strong>线程安全性</strong>：与单例 Bean 类似，应用程序作用域的 Bean 需要注意线程安全性问题。</li>
</ul>
<h4 id="Global-Session-Scoped-Beans"><a href="#Global-Session-Scoped-Beans" class="headerlink" title="Global Session Scoped Beans"></a>Global Session Scoped Beans</h4><ul>
<li><strong>作用域</strong>：<code>@Scope(&quot;globalSession&quot;)</code></li>
<li><strong>描述</strong>：全局会话作用域的 Bean 在 Portlet 应用程序的全局会话中共享。</li>
<li><strong>线程安全性</strong>：类似于会话作用域的 Bean，需要考虑线程安全性。</li>
</ul>
<p>总之，除非 Bean 的设计明确考虑了线程安全性，否则默认情况下 Spring 容器不会保证 Bean 的线程安全。确保线程安全的最佳实践包括无状态设计、使用线程安全的数据结构以及适当的同步机制。</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ol>
<li>创建 Bean 的实例：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</li>
<li>Bean 属性填充(依赖注入)：为 Bean 设置相关属性和依赖，如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li>
<li>Bean的初始化<ol>
<li>调用<code>Aware</code>接口的方法：<ul>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>如果实现了其他 *.Aware接口，就调用相应的方法。</li>
</ul>
</li>
<li>前置处理：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>初始化方法：如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li>
<li>后置处理：如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li>
</ol>
</li>
<li>使用 Bean：Bean 可以被容器使用了，可以调用 Bean 的方法处理业务逻辑。</li>
<li>销毁 Bean：销毁并不是立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。</li>
<li>也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li>
</ul>
</li>
</ol>
<p><img src="/./image/Framework/spring-bean-lifestyle.png" alt="Bean的生命周期"></p>
<blockquote>
<p>Spring 中提供的 Aware 接口主要有：<br><code>BeanNameAware</code>：注入当前 <code>bean</code> 对应 <code>beanName</code>；<br><code>BeanClassLoaderAware</code>：注入加载当前 <code>bean</code> 的 <code>ClassLoader</code>；<br><code>BeanFactoryAware</code>：注入当前 <code>BeanFactory</code> 容器的引用。</p>
</blockquote>
<h3 id="Spring-AOP✅"><a href="#Spring-AOP✅" class="headerlink" title="Spring AOP✅"></a>Spring AOP✅</h3><h3 id="对Spring-AOP的理解"><a href="#对Spring-AOP的理解" class="headerlink" title="对Spring AOP的理解"></a>对Spring AOP的理解</h3><p>面向切面编程(Aspect-Oriented Programming, AOP)是面向对象编程(OOP)的延续，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 CGLIB 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="/./image/Framework/230ae587a322d6e4d09510161987d346.jpeg" alt="Spring AOP代理方式"></p>
<p>Spring AOP也集成了 AspectJ，可以使用 AspectJ 的注解来实现 AOP。</p>
<h3 id="AOP解决了什么问题"><a href="#AOP解决了什么问题" class="headerlink" title="AOP解决了什么问题"></a>AOP解决了什么问题</h3><ol>
<li><strong>横切关注点分离</strong>：在传统的面向对象编程中，某些功能(如日志记录、事务管理、安全性验证等)往往分散在多个类和方法中，导致代码的重复和耦合。AOP通过将这些横切关注点独立出来，以切面的形式进行集中管理，从而简化了核心业务逻辑。</li>
<li><strong>提高代码可读性和可维护性</strong>：通过将横切关注点分离出来，核心业务代码变得更加简洁、清晰。这样，开发者可以更加专注于业务逻辑的实现，提高代码的可读性和可维护性。</li>
<li><strong>动态代理和拦截功能</strong>：AOP提供了动态代理机制，可以在不修改原有代码的情况下，对方法进行拦截和增强。这种机制在处理权限验证、性能监控、缓存管理等场景时非常有用。</li>
<li><strong>代码重用</strong>：由于横切关注点可以以独立的切面形式存在，可以在不同的应用和模块之间共享和重用，提高了代码的复用性。</li>
<li><strong>减少代码耦合</strong>：通过AOP，将横切关注点从业务逻辑中分离出来，使得各个模块之间的耦合度降低，从而提高了系统的灵活性和可扩展性。</li>
</ol>
<h3 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h3><ol>
<li><strong>日志记录</strong>：可以在方法执行前后自动记录日志，而不需要在每个方法中手动添加日志代码。</li>
<li><strong>事务管理</strong>：可以在方法开始时开启事务，方法结束时提交或回滚事务，确保数据一致性。</li>
<li><strong>安全性验证</strong>：可以在方法执行前进行权限验证，确保用户有权限执行该操作。</li>
<li><strong>性能监控</strong>：可以统计方法的执行时间，进行性能分析和优化。</li>
<li><strong>异常处理</strong>：可以统一处理方法中的异常，避免重复的异常处理代码。</li>
</ol>
<h3 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h3><p>Spring AOP(面向切面编程)是Spring框架中的一个重要模块，用于在不修改现有代码的情况下向程序中添加新的行为。基本原理和关键概念如下：</p>
<ol>
<li>核心概念<ul>
<li>Target(目标)：被通知的对象</li>
<li>Proxy(代理)：向目标对象应用通知之后创建的代理对象</li>
<li>Join Point(连接点)：目标对象的所属类中，定义的所有方法均为连接点</li>
<li>Pointcut(切点)：切点是用于匹配连接点的表达式。被切面拦截 &#x2F; 增强的连接点(切入点一定是连接点，连接点不一定是切入点)</li>
<li>Advice(通知)：增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情。Spring AOP支持五种类型的通知：前置通知(Before)、后置通知(After)、返回通知(AfterReturning)、异常通知(AfterThrowing)和环绕通知(Around)。</li>
<li>Aspect(切面)：切面是AOP的核心概念。切入点(Pointcut)+通知(Advice)。</li>
<li>Weaving(织入)：将通知应用到目标对象，进而生成代理对象的过程动作。Spring AOP在运行时通过动态代理实现织入。</li>
</ul>
</li>
<li>实现机制<br>Spring AOP主要通过两种方式来实现AOP功能：<ul>
<li>JDK动态代理：适用于基于接口的代理。Spring AOP使用JDK动态代理来创建实现了一个或多个接口的代理对象。 </li>
<li>CGLIB代理：适用于没有实现接口的类。Spring AOP使用CGLIB库生成目标类的子类来实现代理。</li>
</ul>
</li>
<li>工作流程<ul>
<li>定义切面和通知：使用<code>@Aspect</code>注解定义切面，并在切面类中使用<code>@Before</code>、<code>@After</code>等注解定义通知。 </li>
<li>配置AOP：在Spring配置文件中启用AOP支持，或使用<code>@EnableAspectJAutoProxy</code>注解来启用AOP自动代理。 </li>
<li>应用切面：Spring容器根据配置和切点表达式在运行时生成代理对象，并将通知织入到目标方法的执行中。</li>
</ul>
</li>
</ol>
<p>Spring AOP的核心在于通过动态代理和切点表达式，实现了对横切关注点的模块化管理，使得代码更易于维护和扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 定义切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 定义前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Method executed: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启用AOP支持</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoggingAspect <span class="title function_">loggingAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoggingAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中，定义了一个<code>LoggingAspect</code>切面，其中包含前置通知和后置通知。然后，在Spring配置中启用了AOP支持，并将切面类注册为Bean。Spring容器将在运行时生成代理对象，并在目标方法执行前后执行通知。</p>
<h3 id="Spring-AOP-AspectJ-AOP区别"><a href="#Spring-AOP-AspectJ-AOP区别" class="headerlink" title="Spring AOP&#x2F;AspectJ AOP区别"></a>Spring AOP&#x2F;AspectJ AOP区别</h3><ol>
<li>实现方式<ul>
<li>Spring AOP：基于代理机制(Proxy-based)，主要使用JDK动态代理和CGLIB动态代理。属于运行时增强 </li>
<li>AspectJ AOP：基于字节码操作(Bytecode Manipulation)，通过编译时、加载时和运行时织入(Weaving)实现。属于编译时增强</li>
</ul>
</li>
<li>功能<ul>
<li>Spring AOP：只支持方法级别的AOP。 </li>
<li>AspectJ AOP：提供更强大的功能和更高的性能，适用于类级别和方法级别的AOP。</li>
</ul>
</li>
<li>性能<ul>
<li>Spring AOP：由于基于代理机制，性能相对较低，适用于大多数应用场景，但在高性能要求的场景中可能不够高效。 </li>
<li>AspectJ AOP：由于直接操作字节码，性能较高，适用于对性能要求较高的应用场景。</li>
</ul>
</li>
<li>配置和使用<ul>
<li>Spring AOP：配置相对简单，使用Spring的注解和配置文件即可实现。适用于已经使用Spring框架的应用，容易集成和使用。 </li>
<li>AspectJ AOP：配置较为复杂，需要AspectJ编译器或AspectJ加载时编织器。需要对AspectJ的语法和配置有一定了解，适用于需要更强大AOP功能的应用。</li>
</ul>
</li>
<li>使用场景 <ul>
<li>Spring AOP：适用于大多数Spring应用，特别是那些只需要方法级别AOP的场景。 </li>
<li>AspectJ AOP：适用于需要更强大AOP功能、更高性能和更细粒度控制的场景。</li>
</ul>
</li>
</ol>
<p>如果项目已经在使用Spring框架并且AOP需求较为简单，Spring AOP是一个不错的选择；如果需要更强大和高性能的AOP功能，AspectJ AOP是更好的选择。</p>
<h3 id="AspectJ-AOP的五种通知类型"><a href="#AspectJ-AOP的五种通知类型" class="headerlink" title="AspectJ AOP的五种通知类型"></a>AspectJ AOP的五种通知类型</h3><ul>
<li>Before(前置通知)：目标对象的方法调用之前触发</li>
<li>After (后置通知)：目标对象的方法调用之后触发</li>
<li>AfterReturning(返回通知)：目标对象的方法调用完成，在返回结果值之后触发</li>
<li>AfterThrowing(异常通知)：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li>Around (环绕通知)：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h3 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制"></a>多个切面的执行顺序如何控制</h3><ol>
<li><p>通常使用<code>@Order</code> 注解直接定义切面顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="SpringMVC✅"><a href="#SpringMVC✅" class="headerlink" title="SpringMVC✅"></a>SpringMVC✅</h3><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层(处理业务)、Dao 层(数据库操作)、Entity 层(实体类)、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="MVC核心组件"><a href="#MVC核心组件" class="headerlink" title="MVC核心组件"></a>MVC核心组件</h3><ul>
<li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<h3 id="SpringMVC工作原理"><a href="#SpringMVC工作原理" class="headerlink" title="SpringMVC工作原理"></a>SpringMVC工作原理</h3><p><img src="/./image/Framework/de6d2b213f112297298f3e223bf08f28.png" alt="SpringMVC工作原理"></p>
<p><strong>流程</strong></p>
<ol>
<li>客户端(浏览器)发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>(也就是 <code>Controller</code> 控制器) ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>(视图渲染)。</li>
<li>把 <code>View</code> 返回给请求者(浏览器)</li>
</ol>
<h3 id="Spring框架中用到了哪些设计模式"><a href="#Spring框架中用到了哪些设计模式" class="headerlink" title="Spring框架中用到了哪些设计模式"></a>Spring框架中用到了哪些设计模式</h3><ol>
<li>**工厂模式 (Factory Pattern)**：<ul>
<li>Spring 使用工厂模式来创建对象实例。<code>BeanFactory</code> 和 <code>ApplicationContext</code> 是 Spring 中的两种主要的工厂类，用于管理和创建 bean 对象。<ul>
<li><code>BeanFactory</code>：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code>：容器启动的时候，不管用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
</li>
</ul>
</li>
<li>**单例模式 (Singleton Pattern)**：<ul>
<li>默认情况下，Spring 容器中的 bean 是单例的，这意味着在整个 Spring 容器中只有一个 bean 实例存在。这通过 Spring 的 IoC 容器来管理。</li>
</ul>
</li>
<li>**代理模式 (Proxy Pattern)**：<ul>
<li>Spring AOP (Aspect-Oriented Programming) 使用代理模式来实现横切关注点(如事务管理、日志记录等)的分离。Spring 提供了 JDK 动态代理和 CGLIB 代理两种方式。</li>
</ul>
</li>
<li>**模板模式 (Template Method Pattern)**：<ul>
<li>Spring 中的模板类(如 <code>JdbcTemplate</code>, <code>RestTemplate</code>)通过封装一系列的操作步骤，简化了数据库操作和 REST 调用等重复性的编程任务。</li>
</ul>
</li>
<li>**依赖注入模式 (Dependency Injection Pattern)**：<ul>
<li>依赖注入是 Spring 的核心设计模式，通过构造器注入、setter 注入和接口注入等方式，实现了对象之间的松耦合。</li>
</ul>
</li>
<li>**观察者模式 (Observer Pattern)**：<ul>
<li>Spring 事件机制使用了观察者模式。可以通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 在应用程序中发布和监听事件。</li>
</ul>
</li>
<li>**适配器模式 (Adapter Pattern)**：<ul>
<li>Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code>。</li>
<li>Spring MVC 中的 <code>HandlerAdapter</code> 用于适配不同类型的处理器方法，使得这些方法可以作为统一的处理器进行调用。</li>
</ul>
</li>
<li>**策略模式 (Strategy Pattern)**：<ul>
<li>Spring 中的某些功能(如事务管理)使用了策略模式，允许在运行时选择具体的实现策略。</li>
</ul>
</li>
<li>**装饰者模式 (Decorator Pattern)**：<ul>
<li>Spring 的 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 用于在 bean 初始化前后进行一些自定义的处理，这实际上是对原有 bean 的功能进行扩展和增强。</li>
</ul>
</li>
</ol>
<p>这些设计模式的使用，使得 Spring 框架具备高度的灵活性、可扩展性和可维护性。</p>
<h3 id="BeanFactory-ApplicationContext区别"><a href="#BeanFactory-ApplicationContext区别" class="headerlink" title="BeanFactory&#x2F;ApplicationContext区别"></a>BeanFactory&#x2F;ApplicationContext区别</h3><ul>
<li><p>功能：</p>
<ul>
<li><code>BeanFactory</code>是Spring的核心接口，提供了基本的IOC(Inversion of Control)容器功能，负责实例化、配置和管理bean。</li>
<li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，扩展了更多的企业级功能，如事件机制、国际化支持、AOP(面向切面编程)集成、Web应用上下文等。</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li><code>BeanFactory</code>采用懒加载机制，只有在第一次访问某个bean时，才会实例化该bean。这对启动性能有好处，但可能会导致首次访问时的延迟。</li>
<li><code>ApplicationContext</code>预初始化：其在启动时会预先实例化所有单例bean，确保在应用启动时所有必要的bean已经准备好。这有助于捕获配置问题并提升应用的响应速度。</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li><code>BeanFactory</code>适用于资源受限的环境，如移动设备或嵌入式系统，适用于对性能要求高且对Spring的高级功能需求较少的应用。</li>
<li><code>ApplicationContext</code>适用于标准的企业级应用中，特别是Web应用，适用于需要Spring框架提供的所有功能和高级特性的应用。</li>
</ul>
</li>
<li><p>依赖查找：</p>
<ul>
<li><code>BeanFactory</code>依赖于显式的查找，开发者需要通过<code>getBean</code>方法手动获取bean。</li>
<li><code>ApplicationContext</code>除了显式查找外，还支持自动注入和其他更加灵活的依赖管理方式。</li>
</ul>
</li>
<li><p>如果应用需要完整的Spring功能，包括事件发布、国际化、AOP支持以及其他企业级特性，使用<code>ApplicationContext</code>。</p>
</li>
<li><p>如果应用在一个资源受限的环境中运行并且只需要基本的IOC容器功能，<code>BeanFactory</code>可能更合适。</p>
</li>
</ul>
<p>通常在实际的Spring应用开发中，大多数开发者会选择使用<code>ApplicationContext</code>，因为它提供了更丰富的功能和更好的开发体验。</p>
<h3 id="Spring循环依赖及解决方案"><a href="#Spring循环依赖及解决方案" class="headerlink" title="Spring循环依赖及解决方案"></a>Spring循环依赖及解决方案</h3><p>在Spring框架中，循环依赖是指两个或多个bean之间相互依赖，导致无法正常实例化的问题。例如，Bean A依赖Bean B，而Bean B又依赖Bean A。这种情况下，Spring容器无法确定先实例化哪个bean，从而陷入死循环。</p>
<p>Spring主要通过三级缓存解决循环依赖：<br>如果发生循环依赖的话，就去 三级缓存 <code>singletonFactories</code> 中拿到三级缓存中存储的 <code>ObjectFactory</code> 并调用它的 <code>getObject()</code> 方法来获取这个循环依赖对象的前期暴露对象(虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了)，并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p>
<p>循环依赖的问题主要有两种情况：</p>
<ol>
<li>构造函数循环依赖：构造函数循环依赖指的是两个bean在构造函数中相互依赖。这种情况由于在实例化bean时必须提供构造函数的参数，所以Spring无法解决这种类型的循环依赖。<ol>
<li>将构造函数注入改为setter注入：Setter注入是解决循环依赖的常用方法。Spring能够在实例化一个bean并将其放入singleton池后，通过setter方法注入其他bean的依赖。</li>
<li>使用<code>@Lazy</code>注解：<code>@Lazy</code>注解可以延迟bean的初始化，直到真正需要该bean时才进行实例化，从而打破循环依赖。</li>
<li>使用接口和代理：使用Spring AOP可以创建代理对象，从而打破循环依赖。通过AOP，Spring可以创建一个代理对象来代替实际的bean，这样即使两个bean相互依赖，Spring也能处理。</li>
</ol>
</li>
<li>Setter循环依赖：Setter循环依赖指的是两个bean通过setter方法相互依赖。Spring可以通过三级缓存机制来解决这种类型的循环依赖。<ol>
<li>Spring默认已经能够解决setter循环依赖，无需额外的配置。Spring会在实例化bean时，通过三级缓存提前暴露bean的引用，从而解决循环依赖。</li>
<li>使用<code>@PostConstruct</code>注解：使用<code>@PostConstruct</code>注解可以在依赖注入完成后执行初始化方法，这样可以在方法内部设置依赖，避免循环依赖。</li>
</ol>
</li>
</ol>
<h3 id="Spring的三级缓存"><a href="#Spring的三级缓存" class="headerlink" title="Spring的三级缓存"></a>Spring的三级缓存</h3><p>Spring通过三级缓存解决了循环依赖的问题。三级缓存分别是<code>singletonObjects</code>、<code>earlySingletonObjects</code>和<code>singletonFactories</code>，分别是三个 Map。</p>
<ul>
<li>一级缓存(singletonObjects)：存放最终形态的 Bean(已经实例化、属性填充、初始化)，单例池，为“Spring 的单例属性”⽽⽣。一般获取 Bean 都是从这里获取的，但非所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</li>
<li>二级缓存(earlySingletonObjects)：存放过渡 Bean(半成品，尚未属性填充)，也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</li>
<li>三级缓存(singletonFactories)：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法可以生成原始 Bean 对象或者代理对象。三级缓存只会对单例 Bean 生效。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加了内存开销(需要维护三级缓存，也就是三个 Map)，降低了性能(需要进行多次检查和转换)。</li>
<li>少部分情况是不支持循环依赖的，比如非单例的 bean 和@Async注解的 bean 无法支持循环依赖。</li>
</ul>
<h3 id="Spring创建Bean流程"><a href="#Spring创建Bean流程" class="headerlink" title="Spring创建Bean流程"></a>Spring创建Bean流程</h3><ol>
<li>先去 一级缓存 <code>singletonObjects</code> 中获取，存在就返回；</li>
<li>如果不存在或者对象正在创建中，于是去 二级缓存 <code>earlySingletonObjects</code> 中获取；</li>
<li>如果还没有获取到，就去 三级缓存 <code>singletonFactories</code> 中获取，通过执行 <code>ObjectFacotry</code> 的 <code>getObject()</code> 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。</li>
</ol>
<p>Spring 在创建 Bean 的时候，如果允许循环依赖的话，Spring 就会将刚刚实例化完成，但是属性还没有初始化完的 Bean 对象给提前暴露出去。</p>
<h3 id="三级缓存解决循环依赖流程"><a href="#三级缓存解决循环依赖流程" class="headerlink" title="三级缓存解决循环依赖流程"></a>三级缓存解决循环依赖流程</h3><ul>
<li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li>
<li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 一二级缓存 中肯定没有 A；</li>
<li>那么此时就去三级缓存中调用 getObject() 方法去获取 A 的 前期暴露的对象 ，也就是调用上边加入的 getEarlyBeanReference() 方法，生成一个 A 的 前期暴露对象；</li>
<li>然后就将这个 ObjectFactory 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li>
</ul>
<h3 id="只有两级缓存可以吗"><a href="#只有两级缓存可以吗" class="headerlink" title="只有两级缓存可以吗"></a>只有两级缓存可以吗</h3><p>在没有 AOP 的情况下，确实可以只使用一级和三级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。</p>
<h3 id="Lazy解决循环依赖"><a href="#Lazy解决循环依赖" class="headerlink" title="@Lazy解决循环依赖"></a>@Lazy解决循环依赖</h3><p><code>@Lazy</code> 用来标识类是否需要懒加载&#x2F;延迟加载，可以作用在类上、方法上、构造器上、方法参数上、成员变量中。</p>
<ul>
<li>如果一个 Bean 没有被标记为懒加载，那么它会在 Spring IoC 容器启动的过程中被创建和初始化。</li>
<li>如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化，而是在第一次被请求时才创建。这可以帮助减少应用启动时的初始化时间，也可以用来解决循环依赖问题。</li>
</ul>
<p><code>@Lazy</code>解决循环依赖的原理：<br>举一个例子，比如说有两个 Bean，A 和 B发生了循环依赖。那么 A 的构造器上添加 <code>@Lazy</code> 注解之后(延迟 Bean B 的实例化)，加载的流程如下：</p>
<ol>
<li>创建BeanA实例：Spring开始创建BeanA实例。在创建BeanA实例时，Spring发现其构造函数参数BeanB上有<code>@Lazy</code>注解。</li>
<li>创建BeanB的代理对象：由于<code>@Lazy</code>注解的存在，Spring不会立即创建BeanB实例，而是创建一个BeanB的 _代理对象_。这个代理对象会延迟实际的BeanB实例化，直到代理对象的某个方法被调用时才创建目标bean。</li>
<li>注入代理对象：Spring将BeanB的代理对象注入到BeanA中。</li>
<li>完成BeanA的创建：Spring完成BeanA的创建，并继续执行BeanA的初始化方法。</li>
<li>创建BeanB实例：当BeanB需要创建时，代理对象会触发实际的BeanB实例化过程。</li>
<li>注入BeanA实例：在创建BeanB实例时，Spring会发现BeanB依赖于BeanA，此时BeanA已经创建完成并且在Spring容器中可用，所以可以直接注入BeanA实例。</li>
</ol>
<blockquote>
<p>这里的代理对象使用 AOP 实现，Spring可以创建两种类型的代理对象：</p>
<ul>
<li>JDK动态代理：使用Java的反射机制创建代理对象，适用于实现了接口的bean。</li>
<li>CGLIB代理：使用CGLIB库生成代理对象，适用于没有实现接口的bean。</li>
</ul>
</blockquote>
<h3 id="Spring事务✅"><a href="#Spring事务✅" class="headerlink" title="Spring事务✅"></a>Spring事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>四大特性：</p>
<ul>
<li>原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性(Consistency)：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li>隔离性(Isolation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性(Durability)：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h3><p>程序是否支持事务首先取决于数据库 ，如使用 MySQL，若 存储引擎是 <code>innodb</code> 引擎，则可以支持事务的，若是 <code>myisam</code> 引擎，那就不支持事务的。</p>
<h3 id="Spring管理事务的两种方式"><a href="#Spring管理事务的两种方式" class="headerlink" title="Spring管理事务的两种方式"></a>Spring管理事务的两种方式</h3><ul>
<li>编程式事务：在代码中硬编码(在分布式系统中推荐使用) ：通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>
<li>声明式事务：在 XML 配置文件中配置或者直接基于注解(单体应用或者简单业务系统推荐使用)：实际是通过 AOP 实现(基于@Transactional 的全注解方式使用最多)，开发中推荐使用，代码入侵性小。</li>
</ul>
<h3 id="Spring中的事务管理接口"><a href="#Spring中的事务管理接口" class="headerlink" title="Spring中的事务管理接口"></a>Spring中的事务管理接口</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li><code>PlatformTransactionManager</code>：(平台)事务管理器，Spring 事务策略的核心。Spring通过该接口，为JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等平台提供了对应的事务管理器，但具体由各个平台自己实现。<ul>
<li>主要定义了三个方法：<code>getTransaction()</code>、<code>commit()</code>、<code>rollback()</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得事务</span></span><br><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br></pre></td></tr></table></figure></li>
<li>该接口将事务管理行为抽象出来，然后不同的平台去实现它，这样可以保证提供给外部的行为不变，方便扩展。</li>
</ul>
</li>
<li><code>TransactionDefinition</code>：事务属性(包含五个方面：事务隔离级别、传播行为、事务超时、是否只读、回滚规则)。</li>
<li><code>TransactionStatus</code>：事务运行状态。<ul>
<li>该接口用来记录事务的状态 定义了一组方法，用来获取或判断事务的相应状态信息。</li>
</ul>
</li>
</ul>
<p>可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。</p>
<p><code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h3 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h3><p>在 Spring 框架中，事务传播行为(Transaction Propagation Behavior)定义了事务方法如何与现有事务协作。这些传播行为决定了一个事务方法是否在一个现有事务中运行，是否创建一个新的事务，或者是否在没有事务的情况下运行。</p>
<p>Spring 提供了七种事务传播行为：</p>
<ol>
<li><strong>PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是最常用的传播行为。<ul>
<li>行为：加入当前事务或创建一个新的事务。</li>
<li>适用场景：大多数业务场景，确保方法在一个事务中运行。</li>
</ul>
</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则将当前事务挂起。<ul>
<li>行为：始终创建一个新事务，并挂起当前事务(如果存在)。</li>
<li>适用场景：需要在一个完全独立的事务中运行的方法，例如日志记录。</li>
</ul>
</li>
<li><strong>PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。<ul>
<li>行为：如果有事务则使用事务，没有则非事务执行。</li>
<li>适用场景：既可以在事务中执行也可以在非事务中执行的方法。</li>
</ul>
</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，则将当前事务挂起。<ul>
<li>行为：非事务方式执行，如果有事务则挂起当前事务。</li>
<li>适用场景：方法必须在非事务中执行，例如读操作不需要事务管理。</li>
</ul>
</li>
<li><strong>PROPAGATION_NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。<ul>
<li>行为：非事务方式执行，如果有事务则抛出异常。</li>
<li>适用场景：确保方法绝对不会在事务中运行的情况。</li>
</ul>
</li>
<li><strong>PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<ul>
<li>行为：必须在事务中执行，如果没有事务则抛出异常。</li>
<li>适用场景：必须有现有事务的方法，例如依赖上游事务的操作。</li>
</ul>
</li>
<li><strong>PROPAGATION_NESTED</strong>：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则与 <code>PROPAGATION_REQUIRED</code> 的效果相同。<ul>
<li>行为：如果有事务则创建一个嵌套事务，如果没有则创建一个新事务。</li>
<li>适用场景：需要保存部分回滚点的方法，适合复杂的业务场景。</li>
</ul>
</li>
</ol>
<h3 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h3><ul>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="Transactional-rollbackFor-Exception-class-注解"><a href="#Transactional-rollbackFor-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解</h3><p>Exception 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p><code>@Transactional</code> 注解默认回滚策略是只有在遇到<code>RuntimeException</code>(运行时异常) 或者 <code>Error</code> 时才会回滚事务，而不会回滚 <code>Checked Exception</code>(受检查异常)。这是因为 Spring 认为<code>RuntimeException</code>和 <code>Error</code> 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑来处理。</p>
<p>如果想要修改默认的回滚策略，可以使用 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性来指定哪些异常需要回滚，哪些异常不需要回滚。例如，如果想要让所有的异常都回滚事务，可以使用如下的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要让某些特定的异常不回滚事务，可以使用如下的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = CustomException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring事务失效场景"><a href="#Spring事务失效场景" class="headerlink" title="Spring事务失效场景"></a>Spring事务失效场景</h3><p>在使用 Spring 框架时，事务管理（Spring Transaction）是一个非常重要的功能，但在某些情况下，事务可能会失效。以下是常见的事务失效场景及其原因分析：</p>
<p><strong>方法未被代理</strong><br>原因：Spring 的事务管理依赖于 AOP 代理，如果事务方法没有通过代理调用，事务将不会生效。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务操作</span></span><br><span class="line">    methodB(); <span class="comment">// 内部调用，不走代理，事务无效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li>将 methodB() 提取到另一个带有 @Transactional 注解的类中，由代理管理。</li>
<li>通过 ApplicationContext 获取当前 Bean 并调用 methodB()。</li>
</ul>
<p><strong>事务方法为 private 或 final</strong><br>原因：Spring AOP 基于动态代理，代理类无法拦截 private 或 final 方法。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 事务无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：确保事务方法的访问修饰符为 public。</p>
<p><strong>异常未被捕获</strong><br>原因：Spring 默认只有未捕获的 运行时异常（RuntimeException）或错误（Error）会触发事务回滚。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 事务操作</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Checked Exception&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常被捕获，事务不会回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：手动抛出异常或配置事务注解，使其支持检查型异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure>

<p><strong>嵌套事务传播属性设置错误</strong><br>原因：默认传播属性为 Propagation.REQUIRED，如果不正确设置传播属性，可能导致事务嵌套失效或不生效。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    methodB(); <span class="comment">// 默认 REQUIRED，参与同一事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：根据实际需求设置正确的传播属性（REQUIRED、REQUIRES_NEW、NESTED 等）。</p>
<p><strong>代理模式不匹配</strong><br>原因：Spring AOP 默认使用 JDK 动态代理或 CGLIB。如果使用 JDK 动态代理，事务失效可能是由于目标类未实现接口。<br>解决方法：确保目标类实现接口，或者强制使用 CGLIB 代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure>

<p><strong>未启用事务管理</strong><br>原因：如果没有配置事务管理器或未启用事务支持，事务注解无效。<br>解决方法：确保在配置类中启用了事务管理：@EnableTransactionManagement</p>
<p><strong>多数据源事务问题</strong><br>原因：在多数据源环境下，如果没有配置分布式事务或多个数据源事务管理器，事务可能无法正确回滚。<br>解决方法：使用 @Primary 指定默认事务管理器。 配置分布式事务管理器（如 Atomikos、Seata）。</p>
<p><strong>事务拦截器优先级问题</strong><br>原因：如果某些切面拦截器优先级高于事务拦截器，可能导致事务未生效。<br>解决方法：检查 AOP 切面优先级，调整为事务优先级最高。</p>
<h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><p>Spring Data JPA 是 Spring Data 项目的一部分，它为 Java 持久化 API (JPA) 提供了一个高层次的抽象。其主要目的是简化与数据库交互的复杂性，通过最小化配置和编码，使开发者能够更轻松地创建、读取、更新和删除数据库中的数据。</p>
<p><strong>主要特点和功能</strong></p>
<ol>
<li><strong>简化的存储库接口</strong>：<ul>
<li>Spring Data JPA 提供了 <code>JpaRepository</code> 接口，继承该接口的存储库(Repository)可以自动拥有常见的数据操作方法，如 <code>save</code>、<code>findAll</code>、<code>findById</code>、<code>delete</code> 等。</li>
</ul>
</li>
<li><strong>自定义查询方法</strong>：<ul>
<li>通过定义遵循命名规则的方法名，Spring Data JPA 可以自动生成 SQL 查询。例如，<code>findByLastName</code> 方法会生成一个根据 <code>lastName</code> 字段进行查询的 SQL。</li>
</ul>
</li>
<li><strong>查询注解</strong>：<ul>
<li>可以使用 <code>@Query</code> 注解编写自定义的 JPQL 或原生 SQL 查询。</li>
</ul>
</li>
<li><strong>分页和排序</strong>：<ul>
<li>支持分页和排序，通过方法参数 <code>Pageable</code> 和 <code>Sort</code>，可以轻松实现分页和排序功能。</li>
</ul>
</li>
<li><strong>规格查询</strong>：<ul>
<li>使用 <code>Specification</code> 接口，可以创建复杂的动态查询。</li>
</ul>
</li>
<li><strong>自动实现</strong>：<ul>
<li>Spring Data JPA 可以根据接口自动生成实现类，无需手动编写实现代码。</li>
</ul>
</li>
</ol>
<p><strong>核心组件</strong></p>
<ol>
<li><strong>Repository 接口</strong>：<ul>
<li><code>CrudRepository</code>：提供基本的 CRUD 操作。</li>
<li><code>PagingAndSortingRepository</code>：在 <code>CrudRepository</code> 的基础上增加分页和排序功能。</li>
<li><code>JpaRepository</code>：在 <code>PagingAndSortingRepository</code> 的基础上增加 JPA 相关操作。</li>
</ul>
</li>
<li><strong>实体类</strong>：<ul>
<li>使用 JPA 注解(如 <code>@Entity</code>、<code>@Table</code>、<code>@Id</code> 等)来映射数据库表和字段。</li>
</ul>
</li>
<li><strong>Spring Data JPA 配置</strong>：<ul>
<li>通过配置文件(如 <code>application.properties</code> 或 <code>application.yml</code>)来配置数据源、JPA 供应商、数据库方言等。</li>
</ul>
</li>
</ol>
<p>通过这些组件，开发者可以快速创建与数据库交互的应用程序，而不必编写大量的样板代码。Spring Data JPA 的抽象和自动化能力，使得开发过程更加高效和简洁。</p>
<h3 id="JPA审计功能"><a href="#JPA审计功能" class="headerlink" title="JPA审计功能"></a>JPA审计功能</h3><p>审计功能主要是帮助记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p>
<h3 id="实体之间的关联关系注解"><a href="#实体之间的关联关系注解" class="headerlink" title="实体之间的关联关系注解"></a>实体之间的关联关系注解</h3><ul>
<li><code>@OneToOne</code>：一对一。</li>
<li><code>@ManyToMany</code>：多对多。</li>
<li><code>@OneToMany</code>：一对多。</li>
<li><code>@ManyToOne</code>：多对一。</li>
</ul>
<p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>Spring Security 是一个强大的且高度可定制的认证和访问控制框架，属于 Spring 框架的一部分。它为基于 Spring 的企业应用程序提供了全面的安全性解决方案。以下是 Spring Security 的一些关键特性和功能：</p>
<ol>
<li>认证(Authentication)：Spring Security 提供了多种认证方式，包括基于表单的登录、HTTP Basic 认证、OAuth2 认证等。它还支持自定义认证逻辑，可以与数据库、LDAP、OAuth2 提供者等集成。</li>
<li>授权(Authorization)：授权是指控制用户对资源的访问权限。Spring Security 使用表达式和基于角色的访问控制来实现细粒度的授权控制。你可以通过注解(如 <code>@PreAuthorize</code>、<code>@Secured</code>)或基于 URL 的配置来定义访问规则。</li>
<li>安全上下文(Security Context)：Spring Security 维护一个安全上下文，其中包含当前用户的认证信息。这个安全上下文可以在应用程序的各个部分访问，用于确定用户的身份和权限。</li>
<li>防护机制：Spring Security 提供了多种安全防护机制来防止常见的攻击，如：<ul>
<li><strong>CSRF(跨站请求伪造)防护</strong>：通过生成和验证 CSRF 令牌来防止跨站请求伪造攻击。</li>
<li><strong>会话固定攻击防护</strong>：通过在用户登录后生成新的会话 ID 来防止会话固定攻击。</li>
<li>**内容安全策略(CSP)**：防止 XSS(跨站脚本攻击)和数据注入攻击。</li>
</ul>
</li>
<li>密码存储：Spring Security 提供了多种密码编码器(如 BCrypt、SCrypt、PBKDF2)来安全地存储用户密码。你可以选择合适的密码编码器来加强密码存储的安全性。</li>
<li>集成：Spring Security 与其他 Spring 项目(如 Spring Boot、Spring MVC)无缝集成，简化了安全配置和管理。使用 Spring Boot，可以通过自动配置快速启动安全功能。</li>
<li>可扩展性：Spring Security 是高度可定制的。你可以扩展或替换其默认实现来满足特定的安全需求。比如，自定义认证提供者、授权管理器、过滤器等。</li>
</ol>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>MyBatis 是一个流行的持久层框架，用于简化 Java 应用程序与数据库之间的交互。主要提供下面功能：</p>
<ul>
<li>SQL 映射：MyBatis 允许你使用 XML 或注解的方式将 SQL 语句映射到 Java 方法上，这样可以直接在代码中调用这些方法来执行 SQL 查询和更新操作。</li>
<li>简化 JDBC 操作：MyBatis 封装了 JDBC 操作，使开发者不需要处理复杂的 JDBC API，如手动管理连接、结果集处理等。</li>
<li>动态 SQL：MyBatis 支持动态生成 SQL 语句，可以根据条件灵活构建查询或更新语句，避免了在代码中拼接 SQL 字符串的麻烦。</li>
<li>缓存支持：MyBatis 提供了一级缓存(默认开启)和二级缓存(可选配置)，通过缓存机制提高了数据库查询的性能。</li>
<li>灵活的配置：MyBatis 提供了多种配置方式，可以通过 XML 文件、注解和 Java 配置类进行配置，满足不同的使用需求。</li>
<li>扩展性：MyBatis 具有良好的扩展性，开发者可以通过插件机制自定义和扩展 MyBatis 的功能，如自定义类型处理器、插件等。</li>
</ul>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a>#{} 和 ${} 的区别是什么？</h3><p><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于原样文本替换，可以替换任意内容，比如${driver}会被原样替换为<code>com.mysql.jdbc. Driver</code>。</p>
<p>一个示例：根据参数按任意字段排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderCols&#125;</span><br></pre></td></tr></table></figure>

<p><code>orderCols</code>可以是 <code>name</code>、<code>name desc</code>、<code>name,sex asc</code>等，实现灵活的排序。</p>
<p><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</p>
<h3 id="xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？"><a href="#xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签？" class="headerlink" title="xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？"></a>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</h3><p>注：这道题是京东面试官面试我时问的。</p>
<p>答：还有很多其他的标签， <code>&lt;resultMap&gt;</code>、 <code>&lt;parameterMap&gt;</code>、 <code>&lt;sql&gt;</code>、 <code>&lt;include&gt;</code>、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<h3 id="Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>注：这道题也是京东面试官面试我被问的。</p>
<p>答：最佳实践中，通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ，举例：<code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code>、 <code>&lt;insert&gt;</code>、 <code>&lt;update&gt;</code>、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>
<p><del>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</del></p>
<p>Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。</p>
<p>Mybatis 版本 3.3.0，亲测如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper接口里面方法重载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StuMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"> List&lt;Student&gt; <span class="title function_">getAllStu</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> List&lt;Student&gt; <span class="title function_">getAllStu</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>StuMapper.xml</code> 中利用 Mybatis 的动态 sql 就可以实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllStu&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">  select * from student</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">      id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。</p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>相关 issue：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1122">更正：Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复！</a>。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p>
<p><strong>补充</strong>：</p>
<p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<p><strong>测试如下</strong>：</p>
<p><code>PersonDao.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="title function_">queryById</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Person <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">Person <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br></pre></td></tr></table></figure>

<p><code>PersonMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;PersonMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">      id, name, age, address</span><br><span class="line">    from person</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    limit 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.scripting.xmltags. DynamicContext. ContextAccessor#getProperty</code> 方法用于获取 <code>&lt;if&gt;</code> 标签中的条件值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProperty</span><span class="params">(Map context, Object target, Object name)</span> &#123;</span><br><span class="line">  <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) target;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> map.get(name);</span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(name) || result != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">parameterObject</span> <span class="operator">=</span> map.get(PARAMETER_OBJECT_KEY);</span><br><span class="line">  <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Map)parameterObject).get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parameterObject</code> 为 map，存放的是 Dao 接口中参数相关信息。</p>
<p><code>((Map)parameterObject).get(name)</code> 方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">super</span>.containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>queryById()</code>方法执行时，<code>parameterObject</code>为 null，<code>getProperty</code>方法返回 null 值，<code>&lt;if&gt;</code>标签获取的所有条件值都为 null，所有条件不成立，动态 sql 可以正常执行。</li>
<li><code>queryById(1L)</code>方法执行时，<code>parameterObject</code>为 map，包含了<code>id</code>和<code>param1</code>两个 key 值。当获取<code>&lt;if&gt;</code>标签中<code>name</code>的属性值时，进入<code>((Map)parameterObject).get(name)</code>方法中，map 中 key 不包含<code>name</code>，所以抛出异常。</li>
<li><code>queryById(1L,&quot;1&quot;)</code>方法执行时，<code>parameterObject</code>中包含<code>id</code>,<code>param1</code>,<code>name</code>,<code>param2</code>四个 key 值，<code>id</code>和<code>name</code>属性都可以获取到，动态 sql 正常执行。</li>
</ol>
<h3 id="MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>MyBatis 是如何进行分页的？分页插件的原理是什么？</h3><p>注：我出的。</p>
<p>答：**(1)** MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code> ，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h3 id="简述-MyBatis-的插件运行原理，以及如何编写一个插件"><a href="#简述-MyBatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述 MyBatis 的插件运行原理，以及如何编写一个插件"></a>简述 MyBatis 的插件运行原理，以及如何编写一个插件</h3><p>注：我出的。</p>
<p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、 <code>ResultSetHandler</code>、 <code>StatementHandler</code>、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 <code>Interceptor</code> 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h3 id="MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>MyBatis 执行批量插入，能返回数据库主键列表吗？</h3><p>注：我出的。</p>
<p>答：能，JDBC 都能，MyBatis 当然也能。</p>
<h3 id="MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h3><p>注：我出的。</p>
<p>答：MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<p>MyBatis 提供了 9 种动态 sql 标签:</p>
<ul>
<li><code>&lt;if&gt;&lt;/if&gt;</code></li>
<li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
<p>关于 MyBatis 动态 SQL 的详细介绍，请看这篇文章：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039335704">Mybatis 系列全解（八）：Mybatis 的 9 大动态 SQL 标签你知道几个？</a> 。</p>
<p>关于这些动态 SQL 的具体使用方法，请看这篇文章：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1943349">Mybatis【13】– Mybatis 动态 sql 标签怎么使用？</a></p>
<h3 id="MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>注：我出的。</p>
<p>答：第一种是使用 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a>MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</h3><p>注：我出的。</p>
<p>答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code> 修改为 <code>selectList()</code> 即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code> 修改为 <code>selectList()</code> 即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的 <code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据 <code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能， <code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h3 id="MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>注：我出的。</p>
<p>答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用 <code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code> ，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h3 id="MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？"><a href="#MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？" class="headerlink" title="MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？"></a>MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？</h3><p>注：我出的。</p>
<p>答：不同的 xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h3 id="MyBatis-中如何执行批处理？"><a href="#MyBatis-中如何执行批处理？" class="headerlink" title="MyBatis 中如何执行批处理？"></a>MyBatis 中如何执行批处理？</h3><p>注：我出的。</p>
<p>答：使用 <code>BatchExecutor</code> 完成批处理。</p>
<h3 id="MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>注：我出的</p>
<p>答：MyBatis 有三种基本的 <code>Executor</code> 执行器：</p>
<ul>
<li><strong><code>SimpleExecutor</code>：</strong> 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li><strong><code>ReuseExecutor</code>：</strong> 执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>**<code>BatchExecutor</code>**：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</li>
</ul>
<p>作用范围：<code>Executor</code> 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h3 id="MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>MyBatis 中如何指定使用哪一种 Executor 执行器？</h3><p>注：我出的</p>
<p>答：在 MyBatis 配置文件中，可以指定默认的 <code>ExecutorType</code> 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 <code>ExecutorType</code> 类型参数。</p>
<h3 id="MyBatis-是否可以映射-Enum-枚举类？"><a href="#MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="MyBatis 是否可以映射 Enum 枚举类？"></a>MyBatis 是否可以映射 Enum 枚举类？</h3><p>注：我出的</p>
<p>答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code> ，实现 <code>TypeHandler</code> 的 <code>setParameter()</code> 和 <code>getResult()</code> 接口方法。 <code>TypeHandler</code> 有两个作用：</p>
<ul>
<li>一是完成从 javaType 至 jdbcType 的转换；</li>
<li>二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code> 和 <code>getResult()</code> 两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</li>
</ul>
<h3 id="MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h3><p>注：我出的</p>
<p>答：虽然 MyBatis 解析 xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h3 id="简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？"><a href="#简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"></a>简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h3><p>注：我出的</p>
<p>答：MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 xml 映射文件中， <code>&lt;parameterMap&gt;</code> 标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。 <code>&lt;resultMap&gt;</code> 标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h3 id="为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h3><p>注：我出的</p>
<p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。</p>
<!-- @include: @article-footer.snippet.md -->

<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7273516671574687759">2W 字全面剖析 Mybatis 中的 9 种设计模式</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WUEAdFDwZsZ4EKO8ix0ijg">从零开始实现一个 MyBatis 加解密插件</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7051910683264286750">MyBatis 最全使用指南</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7269390456530190376">脑洞打开！第一次看到这样使用 MyBatis 的，看得我一愣一愣的。</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7264921613551730722">MyBatis 居然也有并发问题</a></li>
</ul>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot注解"><a href="#SpringBoot注解" class="headerlink" title="SpringBoot注解"></a>SpringBoot注解</h3><p>Spring Boot 注解是用来简化配置和开发的核心部分，通过注解可以方便地配置应用程序，处理依赖注入，定义控制器，管理数据库实体等。以下是一些常用的 Spring Boot 注解及其功能：</p>
<h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. <strong>@SpringBootApplication</strong></h3><ul>
<li><p>是一个复合注解，包含了 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个注解。</p>
</li>
<li><p>用来标记一个主程序类，表示这是一个 Spring Boot 应用的入口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Configuration"><a href="#2-Configuration" class="headerlink" title="2. @Configuration"></a>2. <strong>@Configuration</strong></h3><ul>
<li><p>用于标记一个类作为 Spring IoC 容器的配置类，替代传统的 XML 配置文件。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Bean"><a href="#3-Bean" class="headerlink" title="3. @Bean"></a>3. <strong>@Bean</strong></h3><ul>
<li><p>用于定义 Spring IoC 容器管理的 Bean，通常与 <code>@Configuration</code> 一起使用。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-ComponentScan"><a href="#4-ComponentScan" class="headerlink" title="4. @ComponentScan"></a>4. <strong>@ComponentScan</strong></h3><ul>
<li><p>用于指定要扫描的包及其组件。Spring Boot 自动扫描 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等注解的类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example.myapp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-EnableAutoConfiguration"><a href="#5-EnableAutoConfiguration" class="headerlink" title="5. @EnableAutoConfiguration"></a>5. <strong>@EnableAutoConfiguration</strong></h3><ul>
<li>告诉 Spring Boot 根据添加的依赖来自动配置 Spring 应用程序。</li>
</ul>
<h3 id="6-RestController"><a href="#6-RestController" class="headerlink" title="6. @RestController"></a>6. <strong>@RestController</strong></h3><ul>
<li><p>是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合，通常用于 RESTful Web 服务。</p>
</li>
<li><p>表示该类中的每个方法都会返回一个 JSON 或 XML 响应，而不是视图。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-RequestMapping"><a href="#7-RequestMapping" class="headerlink" title="7. @RequestMapping"></a>7. <strong>@RequestMapping</strong></h3><ul>
<li><p>用于映射 HTTP 请求到处理方法上，支持 GET, POST, PUT, DELETE 等。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#8-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="8. @GetMapping, @PostMapping, @PutMapping, @DeleteMapping"></a>8. <strong>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping</strong></h3><ul>
<li>这些注解是 <code>@RequestMapping</code> 的简化版本，用于分别处理 GET、POST、PUT 和 DELETE 请求。</li>
</ul>
<h3 id="9-Autowired"><a href="#9-Autowired" class="headerlink" title="9. @Autowired"></a>9. <strong>@Autowired</strong></h3><ul>
<li><p>用于自动注入依赖，Spring 会自动找到并注入该类型的 Bean。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-Service"><a href="#10-Service" class="headerlink" title="10. @Service"></a>10. <strong>@Service</strong></h3><ul>
<li>标记业务逻辑类，Spring 会自动将其注册为 Bean，并可用于自动注入。</li>
</ul>
<h3 id="11-Repository"><a href="#11-Repository" class="headerlink" title="11. @Repository"></a>11. <strong>@Repository</strong></h3><ul>
<li>标记数据访问类（DAO 层），Spring 会自动处理异常的转换。</li>
</ul>
<h3 id="12-Controller"><a href="#12-Controller" class="headerlink" title="12. @Controller"></a>12. <strong>@Controller</strong></h3><ul>
<li>标记为控制器类，处理请求并返回视图。</li>
</ul>
<h3 id="13-PathVariable"><a href="#13-PathVariable" class="headerlink" title="13. @PathVariable"></a>13. <strong>@PathVariable</strong></h3><ul>
<li><p>用于获取 URL 中的动态路径参数。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-RequestParam"><a href="#14-RequestParam" class="headerlink" title="14. @RequestParam"></a>14. <strong>@RequestParam</strong></h3><ul>
<li><p>用于获取请求参数中的值。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/search&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.searchByName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="15-RequestBody"><a href="#15-RequestBody" class="headerlink" title="15. @RequestBody"></a>15. <strong>@RequestBody</strong></h3><ul>
<li><p>用于将请求体中的 JSON 自动转换为 Java 对象。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-Transactional"><a href="#16-Transactional" class="headerlink" title="16. @Transactional"></a>16. <strong>@Transactional</strong></h3><ul>
<li><p>用于标记方法或类的事务性操作，确保方法内的操作要么全部成功，要么全部回滚。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(Long fromAccountId, Long toAccountId, Double amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些注解大大简化了 Spring Boot 的配置和开发过程，使开发者能够快速构建健壮的 Web 应用。</p>
<h3 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h3><ol>
<li>调用启动类的<code>main</code> 方法<ul>
<li>Spring Boot 应用通常是通过一个包含 <code>@SpringBootApplication</code> 注解的主类启动的，该类的 <code>main</code> 方法中调用<code>SpringApplication.run()</code>。</li>
</ul>
</li>
<li>创建 <code>SpringApplication</code> 实例<ul>
<li><code>SpringApplication.run()</code> 内部首先会创建一个 <code>SpringApplication</code> 实例，主要用于配置和管理整个应用的启动过程。</li>
<li>这个实例初始化了一些基本的属性，比如：启动参数、运行环境(如开发、生产)、应用类型(如 Web 应用或非 Web 应用)。</li>
</ul>
</li>
<li>设置启动配置<ul>
<li>Spring Boot 会根据应用的上下文和依赖来设置配置属性，例如：<ul>
<li>通过 <code>ApplicationContextInitializer</code> 实例对上下文进行初始化。</li>
<li>加载所有在 <code>META-INF/spring.factories</code> 文件中声明的 <code>ApplicationListener</code> 监听器。</li>
</ul>
</li>
<li>此时，<code>SpringApplication</code> 根据类路径、系统属性等配置自动决定应用类型(<code>Reactive</code>、<code>Servlet</code> 或 <code>None</code>)。</li>
</ul>
</li>
<li>启动引导器(<code>SpringApplicationRunListeners</code>)：Spring Boot 创建并启动 <code>SpringApplicationRunListeners</code>，它们会监听应用启动的各个阶段，并触发相应事件。主要包括以下几个事件：<ul>
<li>Starting：表示应用程序刚刚启动。</li>
<li>Environment Prepared：此阶段设置环境参数(例如配置文件、属性源等)。</li>
<li>Context Prepared：在创建并配置好 <code>ApplicationContext</code> 后触发。</li>
<li>Context Loaded：当所有 Bean 定义被加载到上下文但尚未被实例化时触发。</li>
<li>Started：表示 <code>ApplicationContext</code> 已经启动并准备接受请求。</li>
</ul>
</li>
<li>创建并准备 <code>ApplicationContext</code><ul>
<li>Spring Boot 根据应用的类型(比如 Web 应用)创建适当的 <code>ApplicationContext</code>，例如：<ul>
<li>Web 应用使用 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li>非 Web 应用使用 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
</li>
<li>然后，Spring Boot 开始加载 <code>@Configuration</code> 类、扫描组件并注册所有的 Bean 定义。</li>
</ul>
</li>
<li>配置环境 (<code>Environment</code>)<ul>
<li>在 <code>ApplicationContext</code> 准备好后，Spring Boot 开始配置运行时环境。</li>
<li>环境配置包含了系统属性、环境变量以及外部配置文件(如 <code>application.properties</code> 或 <code>application.yml</code>)，并通过 <code>ConfigurableEnvironment</code> 注入到上下文中。</li>
</ul>
</li>
<li>刷新 <code>ApplicationContext</code><ul>
<li>Spring Boot 调用 <code>refresh()</code> 方法，完成 <code>ApplicationContext</code> 的初始化，包括 Bean 的创建、依赖注入、生命周期管理等。</li>
<li>在此阶段，所有的 Bean 被完全加载和实例化，<code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 也会在此之后执行。</li>
</ul>
</li>
<li>启动内嵌的 Web 服务器(如果有)<ul>
<li>如果是 Web 应用，Spring Boot 会在应用上下文加载完成后启动内嵌的 Web 服务器(例如 Tomcat、Jetty 或 Undertow)。</li>
<li>这个步骤通常是通过 <code>WebServerStartStopLifecycle</code> 组件来完成的。</li>
</ul>
</li>
<li><code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 执行<ul>
<li>一旦所有的 Bean 都初始化完毕，Spring Boot 会执行所有实现了 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口的组件。这些组件通常用于执行一些应用启动后的初始化逻辑。</li>
</ul>
</li>
<li>完成启动，进入事件循环<ul>
<li>启动流程最后，Spring Boot 进入应用的主事件循环(对于 Web 应用来说)。此时应用已经可以接收 HTTP 请求或执行其他业务逻辑。</li>
</ul>
</li>
</ol>
<h4 id="Tomcat如何接收http请求"><a href="#Tomcat如何接收http请求" class="headerlink" title="Tomcat如何接收http请求"></a>Tomcat如何接收http请求</h4><ol>
<li>启动和初始化<ol>
<li>启动 Tomcat<ul>
<li>当 Tomcat 启动时，它会加载并初始化所有配置文件(如 <code>server.xml</code>、<code>web.xml</code>)。</li>
<li>它会创建并配置一个或多个 Connector 对象，这些对象负责接收来自客户端的 HTTP 请求。</li>
</ul>
</li>
<li>配置 Connector<ul>
<li>在 <code>server.xml</code> 文件中配置 Connector，例如：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>Connector 会监听指定的端口(例如 8080)，并处理进入的请求。</li>
</ul>
</li>
</ol>
</li>
<li>接收 HTTP 请求<ol>
<li>监听端口：Connector 监听配置的端口，接收来自客户端的 TCP 连接。</li>
<li>建立连接：当有客户端发起连接时，Connector 接受这个连接，并将其交给一个处理线程。</li>
</ol>
</li>
<li>请求处理<ol>
<li>请求解析：处理线程会解析 HTTP 请求数据，包括请求行(请求方法、请求 URI 和协议)、请求头和请求体。请求数据会被封装成一个 <code>HttpServletRequest</code> 对象。</li>
<li>请求路由：Tomcat 会根据请求的 URI 进行路由，将请求分发到相应的 <code>Servlet</code>。</li>
<li>调用 Servlet：请求会被传递到适当的 <code>Servlet</code> 实例的 <code>service()</code> 方法中。具体的处理由 <code>doGet()</code>、<code>doPost()</code> 等方法实现，取决于请求的方法类型。</li>
<li>生成响应：<code>Servlet</code> 处理完请求后，会生成响应内容并将其封装到 <code>HttpServletResponse</code> 对象中。响应内容包括响应状态码、响应头和响应体。</li>
<li>发送响应：处理线程将 <code>HttpServletResponse</code> 对象中的响应数据写回到客户端。Tomcat 会将响应数据通过网络发送回客户端，并关闭连接(如果是非持久连接)。</li>
</ol>
</li>
<li>关闭连接：根据请求的 <code>Connection</code> 头部的值(如 <code>Connection: keep-alive</code>)，Tomcat 决定是否保持连接以处理后续请求。在处理完请求后，Tomcat 可能会关闭连接或重用以提高性能。</li>
</ol>
<h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>自动装配(Auto-Configuration)是Spring Boot框架的一个核心特性之一，它通过扫描应用程序的classpath和依赖关系，自动配置和装配Spring应用程序所需的各种组件。</p>
<p>在传统的Spring应用程序中，开发者需要手动配置大量的bean，例如数据源、事务管理器、视图解析器等。这些配置过程繁琐而容易出错，加大了开发难度和成本。而Spring Boot的自动装配机制则能够自动完成这些配置过程，使得开发者可以更加专注于业务逻辑的实现。</p>
<ol>
<li>启动类注解扫描<br>@SpringBootApplication：这是Spring Boot应用程序的入口注解，它集成了多个关键功能，包括自动配置(@EnableAutoConfiguration)、组件扫描(@ComponentScan)和配置(@Configuration)。<br>@EnableAutoConfiguration：启动自动配置机制。<br>@ComponentScan：扫描@Component、@Service、@Controller等注解的Bean，将它们注册到Spring容器中。</li>
<li>自动配置类的加载<br>Spring Boot在启动时，会扫描项目依赖中的jar包，查找META-INF&#x2F;spring.factories文件。<br>这个文件中列出了所有自动配置类的全限定类名。<br>Spring Boot通过SpringFactoriesLoader读取这些类名，并加载相应的自动配置类。</li>
<li>条件化装配<br>自动配置类中的配置并不是无条件加载的，而是根据条件注解(如@ConditionalOnClass、@ConditionalOnBean、@ConditionalOnProperty等)来决定是否加载某个配置。<br>@ConditionalOnClass：当类路径中存在指定的类时，才加载配置。<br>@ConditionalOnBean：当容器中存在指定类型的Bean时，才加载配置。<br>@ConditionalOnProperty：当配置文件中存在指定的属性且值满足条件时，才加载配置。</li>
<li>配置类的注册与绑定<br>生效的配置类会将带有@Bean注解的组件注册到Spring的IOC容器中。<br>同时，配置类也可以进行配置绑定，通过@ConfigurationProperties注解将配置文件中的值绑定到对应的Properties类中。</li>
<li>配置文件的解析与覆盖<br>Spring Boot默认使用application.properties或application.yml作为全局配置文件。<br>开发者可以在这些文件中定义或覆盖自动配置的默认值，以满足特定的需求。</li>
<li>自定义配置与排除<br>开发者可以创建自定义的自动配置类，通过@Configuration和条件注解来定义自己的自动装配规则。<br>如果需要排除某个自动装配的组件或配置，可以使用@SpringBootApplication注解的exclude属性，或在配置文件中通过spring.autoconfigure.exclude属性来实现。</li>
<li>SpringApplication.run方法执行<br>当执行SpringApplication.run(XXX.class, args)方法时，Spring Boot会启动并执行上述流程。<br>这个方法会判断应用的类型(普通项目还是Web项目)，加载初始化器和应用程序监听器，推动并设置main方法的定义类，最终启动Spring容器。<br>综上所述，Spring Boot的自动装配流程是一个基于条件化装配的自动化过程，它通过注解、配置文件和条件注解来实现应用程序的自动配置和组件的自动注册。这个过程极大地简化了Spring应用程序的搭建和配置工作，让开发者能够更专注于业务逻辑的开发。</li>
</ol>
<h3 id="SpringBoot如何配置跨域"><a href="#SpringBoot如何配置跨域" class="headerlink" title="SpringBoot如何配置跨域"></a>SpringBoot如何配置跨域</h3><p>在Spring Boot中实现跨域操作，主要是通过配置CORS(跨源资源共享)来实现的。CORS是一个W3C标准，它允许你指定哪些动态资源允许跨域访问。Spring Boot通过提供@CrossOrigin注解和全局CORS配置两种方式来实现跨域请求的支持。</p>
<ol>
<li><p>使用@CrossOrigin注解<br>@CrossOrigin注解可以添加到控制器(Controller)类上或特定的方法上，以允许跨域请求。这个注解可以指定允许的源(origins)、HTTP方法、头部(headers)等。</p>
</li>
<li><p>全局CORS配置<br>如果应用中有多个控制器或方法需要跨域访问，那么使用全局CORS配置会更加方便。Spring Boot允许你通过添加一个配置类并实现WebMvcConfigurer接口来自定义CORS策略。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://example.com&quot;)</span> <span class="comment">// 只允许来自http://example.com的跨域请求  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;  </span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 允许所有路径  </span></span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://example.com&quot;</span>) <span class="comment">// 允许的源  </span></span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许的HTTP方法  </span></span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 允许的头信息  </span></span><br><span class="line">            .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否允许发送Cookie  </span></span><br><span class="line">            .maxAge(<span class="number">3600</span>); <span class="comment">// 缓存预检请求的结果的时间，单位为秒  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="SpringClod"><a href="#SpringClod" class="headerlink" title="SpringClod"></a>SpringClod</h2><h3 id="SpringBoot-SpringCloud区别"><a href="#SpringBoot-SpringCloud区别" class="headerlink" title="SpringBoot&#x2F;SpringCloud区别"></a>SpringBoot&#x2F;SpringCloud区别</h3><p>Spring Boot和Spring Cloud是Spring生态系统中两个不同但经常一起使用的框架，它们在职责和应用场景上有所区别：</p>
<h3 id="1-Spring-Boot："><a href="#1-Spring-Boot：" class="headerlink" title="1. Spring Boot："></a>1. <strong>Spring Boot</strong>：</h3><ul>
<li><strong>定义</strong>：Spring Boot是一个快速构建单个独立应用的框架，简化了Spring应用的开发过程。</li>
<li><strong>功能</strong>：通过自动配置、内嵌服务器（如Tomcat）、无XML配置、应用监控等特性，使开发人员可以快速构建和启动应用程序。</li>
<li><strong>适用场景</strong>：适合开发单体应用或微服务的基础服务，通常是用来构建单个、独立的微服务。</li>
<li><strong>核心组件</strong>：<ul>
<li>自动配置 (<code>@EnableAutoConfiguration</code>)：简化配置</li>
<li>Starter模块：提供常用的依赖集合，如<code>spring-boot-starter-web</code>用于Web开发，<code>spring-boot-starter-data-jpa</code>用于JPA持久层开发</li>
<li>Actuator：提供监控和管理功能</li>
</ul>
</li>
</ul>
<h3 id="2-Spring-Cloud："><a href="#2-Spring-Cloud：" class="headerlink" title="2. Spring Cloud："></a>2. <strong>Spring Cloud</strong>：</h3><ul>
<li><strong>定义</strong>：Spring Cloud是基于Spring Boot，用于构建分布式系统和微服务架构的工具集。</li>
<li><strong>功能</strong>：提供了微服务架构下的常用组件和解决方案，如服务注册与发现、负载均衡、分布式配置管理、熔断、网关、链路追踪等。</li>
<li><strong>适用场景</strong>：适合开发和管理大规模的分布式系统，尤其是微服务架构。</li>
<li><strong>核心组件</strong>：<ul>
<li>服务发现（Eureka、Consul、Zookeeper）</li>
<li>配置管理（Spring Cloud Config）</li>
<li>负载均衡（Ribbon）</li>
<li>熔断器（Hystrix）</li>
<li>网关（Spring Cloud Gateway）</li>
<li>分布式追踪（Sleuth）</li>
</ul>
</li>
</ul>
<h3 id="3-关系："><a href="#3-关系：" class="headerlink" title="3. 关系："></a>3. <strong>关系</strong>：</h3><ul>
<li>Spring Cloud依赖于Spring Boot提供的自动配置和模块化支持，通常基于Spring Boot进行服务的开发和管理。</li>
<li><strong>使用方式</strong>：一般来说，Spring Boot用于开发具体的微服务，而Spring Cloud用于管理这些微服务之间的交互和通信。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>Spring Boot</strong>关注的是简化单个服务的开发，而<strong>Spring Cloud</strong>关注的是简化微服务架构的分布式管理。</li>
<li>Spring Boot更适合构建单体或微服务的基础应用，而Spring Cloud则提供微服务架构中的高级组件支持，适合构建大规模分布式系统。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://cwp0.github.io">cwp0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cwp0.github.io/posts/17771.html">https://cwp0.github.io/posts/17771.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png" data-sites="facebook,twitter,wechat,weibo,qq,google,linkedin,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.JPG" target="_blank"><img class="post-qr-code-img" src="/img/wechat.JPG" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.JPG" target="_blank"><img class="post-qr-code-img" src="/img/alipay.JPG" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/17772.html" title="手撕相关"><img class="cover" src="https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">手撕相关</div></div></a></div><div class="next-post pull-right"><a href="/posts/17769.html" title="数据库"><img class="cover" src="https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">数据库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/17775.html" title="C++知识点"><img class="cover" src="https://s2.loli.net/2024/06/27/xvtGedjogpz15iE.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-27</div><div class="title">C++知识点</div></div></a></div><div><a href="/posts/17776.html" title="Python知识点"><img class="cover" src="https://s2.loli.net/2024/06/27/RATGUg5c6FXC7mH.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-27</div><div class="title">Python知识点</div></div></a></div><div><a href="/posts/17780.html" title="分布式&#x2F;高性能&#x2F;高可用"><img class="cover" src="https://s2.loli.net/2024/09/03/Mjecv3GDVUYPBJ1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">分布式&#x2F;高性能&#x2F;高可用</div></div></a></div><div><a href="/posts/17766.html" title="Java后端面经"><img class="cover" src="https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">Java后端面经</div></div></a></div><div><a href="/posts/17767.html" title="前端&amp;移动端面经"><img class="cover" src="https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">前端&amp;移动端面经</div></div></a></div><div><a href="/posts/17777.html" title="智力题"><img class="cover" src="https://s2.loli.net/2024/06/27/9KWGke8lsJaM1fi.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-27</div><div class="title">智力题</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment"> Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/assets/%E5%A4%B4%E5%83%8F.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cwp0</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cwp0"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cwp0" target="_blank" title="Github"><i class="fab fa-github" style="color: #9F9F9F;"></i></a><a class="social-icon" href="mailto:wenpengchen@njust.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: 9F9F9F;"></i></a><a class="social-icon" href="/img/alipay.JPG" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #9F9F9F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This site is under construction...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring"><span class="toc-text">什么是Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A8%A1%E5%9D%97"><span class="toc-text">Spring模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Spring-Boot-Spring-MVC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">Spring&#x2F;Spring Boot&#x2F;Spring MVC之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IoC%E2%9C%85"><span class="toc-text">Spring IoC✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring-IoC"><span class="toc-text">什么是Spring IoC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">IoC解决了什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IoC%E5%8E%9F%E7%90%86"><span class="toc-text">Spring IoC原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring-Bean"><span class="toc-text">什么是Spring Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BABean%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">将一个类声明为Bean的注解有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-Bean%E5%8C%BA%E5%88%AB"><span class="toc-text">@Component&#x2F;@Bean区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">用于注入Bean的注解有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired"><span class="toc-text">@Autowired</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource"><span class="toc-text">@Resource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Qualifier"><span class="toc-text">@Qualifier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inject"><span class="toc-text">@Inject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value"><span class="toc-text">@Value</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired-Resource%E5%8C%BA%E5%88%AB"><span class="toc-text">@Autowired&#x2F;@Resource区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Bean的作用域有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-text">Bean是线程安全的吗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Singleton-Bean"><span class="toc-text">Singleton Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prototype-Bean"><span class="toc-text">Prototype Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Request-Session-Scoped-Beans"><span class="toc-text">Request &amp; Session Scoped Beans</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-Scoped-Beans"><span class="toc-text">Application Scoped Beans</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Global-Session-Scoped-Beans"><span class="toc-text">Global Session Scoped Beans</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP%E2%9C%85"><span class="toc-text">Spring AOP✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Spring-AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">对Spring AOP的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">AOP解决了什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">AOP应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP%E5%8E%9F%E7%90%86"><span class="toc-text">Spring AOP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP-AspectJ-AOP%E5%8C%BA%E5%88%AB"><span class="toc-text">Spring AOP&#x2F;AspectJ AOP区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AspectJ-AOP%E7%9A%84%E4%BA%94%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">AspectJ AOP的五种通知类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6"><span class="toc-text">多个切面的执行顺序如何控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E2%9C%85"><span class="toc-text">SpringMVC✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">MVC核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">SpringMVC工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">Spring框架中用到了哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory-ApplicationContext%E5%8C%BA%E5%88%AB"><span class="toc-text">BeanFactory&#x2F;ApplicationContext区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">Spring循环依赖及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">Spring的三级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%88%9B%E5%BB%BABean%E6%B5%81%E7%A8%8B"><span class="toc-text">Spring创建Bean流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%B5%81%E7%A8%8B"><span class="toc-text">三级缓存解决循环依赖流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="toc-text">只有两级缓存可以吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">@Lazy解决循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E2%9C%85"><span class="toc-text">Spring事务✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">Spring对事务的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">Spring管理事务的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">Spring中的事务管理接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">Spring事务传播行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">Spring事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transactional-rollbackFor-Exception-class-%E6%B3%A8%E8%A7%A3"><span class="toc-text">@Transactional(rollbackFor &#x3D; Exception.class)注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-text">Spring事务失效场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-JPA"><span class="toc-text">Spring Data JPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JPA%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD"><span class="toc-text">JPA审计功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%B3%A8%E8%A7%A3"><span class="toc-text">实体之间的关联关系注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security"><span class="toc-text">Spring Security</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis"><span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">#{} 和 ${} 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-select%E3%80%81insert%E3%80%81update%E3%80%81delete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-text">xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dao-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDao-%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97%EF%BC%9F"><span class="toc-text">Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">MyBatis 是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-MyBatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="toc-text">简述 MyBatis 的插件运行原理，以及如何编写一个插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%EF%BC%8C%E8%83%BD%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%88%97%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-text">MyBatis 执行批量插入，能返回数据库主键列表吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><span class="toc-text">MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86-sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-text">MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8Cid-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-text">MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">MyBatis 中如何执行批处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F"><span class="toc-text">MyBatis 中如何指定使用哪一种 Executor 执行器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%A0%E5%B0%84-Enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%9F"><span class="toc-text">MyBatis 是否可以映射 Enum 枚举类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-A-%E6%A0%87%E7%AD%BE%E9%80%9A%E8%BF%87-include-%E5%BC%95%E7%94%A8%E4%BA%86-B-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E8%AF%B7%E9%97%AE%EF%BC%8CB-%E6%A0%87%E7%AD%BE%E8%83%BD%E5%90%A6%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AF%B4%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%8D%E9%9D%A2%EF%BC%9F"><span class="toc-text">MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-MyBatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C-MyBatis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-MyBatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-ORM-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%EF%BC%9F%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90"><span class="toc-text">文章推荐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot"><span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E6%B3%A8%E8%A7%A3"><span class="toc-text">SpringBoot注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SpringBootApplication"><span class="toc-text">1. @SpringBootApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Configuration"><span class="toc-text">2. @Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Bean"><span class="toc-text">3. @Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ComponentScan"><span class="toc-text">4. @ComponentScan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-EnableAutoConfiguration"><span class="toc-text">5. @EnableAutoConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-RestController"><span class="toc-text">6. @RestController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-RequestMapping"><span class="toc-text">7. @RequestMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-GetMapping-PostMapping-PutMapping-DeleteMapping"><span class="toc-text">8. @GetMapping, @PostMapping, @PutMapping, @DeleteMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Autowired"><span class="toc-text">9. @Autowired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Service"><span class="toc-text">10. @Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Repository"><span class="toc-text">11. @Repository</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Controller"><span class="toc-text">12. @Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-PathVariable"><span class="toc-text">13. @PathVariable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-RequestParam"><span class="toc-text">14. @RequestParam</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-RequestBody"><span class="toc-text">15. @RequestBody</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Transactional"><span class="toc-text">16. @Transactional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">SpringBoot启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6http%E8%AF%B7%E6%B1%82"><span class="toc-text">Tomcat如何接收http请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-text">SpringBoot自动装配原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F"><span class="toc-text">SpringBoot如何配置跨域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringClod"><span class="toc-text">SpringClod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot-SpringCloud%E5%8C%BA%E5%88%AB"><span class="toc-text">SpringBoot&#x2F;SpringCloud区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Boot%EF%BC%9A"><span class="toc-text">1. Spring Boot：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring-Cloud%EF%BC%9A"><span class="toc-text">2. Spring Cloud：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-text">3. 关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/17781.html" title="华为笔试/手撕"><img src="https://s2.loli.net/2024/02/06/t5V92W3qvbceOTh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华为笔试/手撕"/></a><div class="content"><a class="title" href="/posts/17781.html" title="华为笔试/手撕">华为笔试/手撕</a><time datetime="2024-11-15T03:51:23.000Z" title="Created 2024-11-15 11:51:23">2024-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17780.html" title="分布式/高性能/高可用"><img src="https://s2.loli.net/2024/09/03/Mjecv3GDVUYPBJ1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式/高性能/高可用"/></a><div class="content"><a class="title" href="/posts/17780.html" title="分布式/高性能/高可用">分布式/高性能/高可用</a><time datetime="2024-09-03T09:21:00.000Z" title="Created 2024-09-03 17:21:00">2024-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17779.html" title="游戏研发面经"><img src="https://s2.loli.net/2024/06/28/RviHxaoQPJhA8wj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="游戏研发面经"/></a><div class="content"><a class="title" href="/posts/17779.html" title="游戏研发面经">游戏研发面经</a><time datetime="2024-06-27T16:10:26.000Z" title="Created 2024-06-28 00:10:26">2024-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17777.html" title="智力题"><img src="https://s2.loli.net/2024/06/27/9KWGke8lsJaM1fi.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智力题"/></a><div class="content"><a class="title" href="/posts/17777.html" title="智力题">智力题</a><time datetime="2024-06-27T15:39:07.000Z" title="Created 2024-06-27 23:39:07">2024-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17778.html" title="系统设计"><img src="https://s2.loli.net/2024/06/27/OKRYQHdoCfGmgxr.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="系统设计"/></a><div class="content"><a class="title" href="/posts/17778.html" title="系统设计">系统设计</a><time datetime="2024-06-27T15:39:07.000Z" title="Created 2024-06-27 23:39:07">2024-06-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> cwp0</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'nfRxTBEmIAeb6gP2K0LOdLqw-gzGzoHsz',
      appKey: 'vmeDN8k58dVdPv5Yz7NEkvSN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      tagMeta: ["博主", "小伙伴", "访客"],
      master: ['fb5b8162294f5bda9321f095ee3a5857', '8c0fcea8917ddba8e86ee8a88c2a15a9'],
      friends:  [],
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine()
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "19701af9-3bff-41b9-919e-742aca557e36";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => {
      $crisp.push(["do", "chat:hide"])
    }

    close()
    $crisp.push(["on", "chat:closed", function() {
      close()
    }])

    window.chatBtnFn = () => {
      $crisp.is("chat:visible") ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        $crisp.push(["do", "chat:hide"])
      },
      show: () => {
        $crisp.push(["do", "chat:show"])
      }
    }
  }
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>