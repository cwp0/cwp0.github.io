<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库 | cwp0</title><meta name="author" content="cwp0"><meta name="copyright" content="cwp0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库面经">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="https://cwp0.github.io/posts/17769.html">
<meta property="og:site_name" content="cwp0">
<meta property="og:description" content="数据库面经">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png">
<meta property="article:published_time" content="2024-06-12T14:47:36.000Z">
<meta property="article:modified_time" content="2024-06-22T10:28:16.000Z">
<meta property="article:author" content="cwp0">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="NoSQL">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="mongodb">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png"><link rel="shortcut icon" href="/img/assets/%E5%A4%B4%E5%83%8F.JPG"><link rel="canonical" href="https://cwp0.github.io/posts/17769.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"YNCOX66CR4","apiKey":"5c661928f53edb93f42b2f41a467cbfb","indexName":"cwp0_github_io","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":66,"languages":{"author":"Author: cwp0","link":"Link: ","source":"Source: cwp0","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-22 18:28:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/assets/%E5%A4%B4%E5%83%8F.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-image"></i><span> Picture</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/06/12/2LNhRokYTJBEUrZ.png')"><nav id="nav"><span id="blog-info"><a href="/" title="cwp0"><img class="site-icon" src="/img/assets/%E5%A4%B4%E5%83%8F.JPG"/><span class="site-name">cwp0</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-image"></i><span> Picture</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-12T14:47:36.000Z" title="Created 2024-06-12 22:47:36">2024-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-22T10:28:16.000Z" title="Updated 2024-06-22 18:28:16">2024-06-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">47.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>150min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文参考 <a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide</a></p>
</blockquote>
<h2 id="SQL-NoSQL基础"><a href="#SQL-NoSQL基础" class="headerlink" title="SQL&#x2F;NoSQL基础"></a>SQL&#x2F;NoSQL基础</h2><h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><p>SQL 是一种结构化查询语言(Structured Query Language)，提供一种从数据库中读写数据的简单有效的方法。几乎所有的主流关系数据库都支持 SQL ，适用性非常强。一些非关系型数据库也兼容 SQL 或者使用类似于 SQL 的查询语言。</p>
<h3 id="DB-DBMS-DBS-DBA"><a href="#DB-DBMS-DBS-DBA" class="headerlink" title="DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA"></a>DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</h3><ul>
<li>数据库：数据库(DataBase,DB)是由数据库管理系统管理的数据的集合。</li>
<li>数据库管理系统：数据库管理系统(Database Management System,DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>
<li>数据库系统：数据库系统(Data Base System,DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>
<li>数据库管理员：数据库管理员(Database Administrator,DBA)负责全面管理和控制数据库系统。</li>
</ul>
<h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul>
<li>数据库(<code>database</code>)：保存有组织的数据的容器(通常是一个文件或一组文件)。</li>
<li>数据表(<code>table</code>)：某种特定类型数据的结构化清单。</li>
<li>模式(<code>schema</code>)：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li>
<li>列(<code>column</code>)：表中的一个字段。所有表都是由一个或多个列组成的。</li>
<li>行(<code>row</code>)：表中的一个记录。</li>
<li>主键(<code>primary key</code>)：一列(或一组列)，其值能够唯一标识表中每一行。</li>
</ul>
<h3 id="元组-码-候选码-主码-外码-主属性-非主属性概念"><a href="#元组-码-候选码-主码-外码-主属性-非主属性概念" class="headerlink" title="元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念"></a>元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</h3><ul>
<li>元组：元组(tuple)是关系数据库中的基本概念，关系是一张表，表中的每行(即数据库中的每条记录)就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>
<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>
<li>候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>
<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>
<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>
<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人(工号，身份证号，姓名，性别，部门). 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生(学号，姓名，年龄，性别，班级)中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER 图(<code>Entity Relationship Diagram</code>，实体联系图)，提供了表示实体类型、属性和联系的方法。ER图三要素：</p>
<ul>
<li>实体：通常是现实世界的业务对象，也可以使用一些逻辑对象。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>
<li>属性：即某个实体拥有的属性，属性用来描述组成实体的要素，在 ER 图中，属性使用椭圆形表示。</li>
<li>联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>
</ul>
<h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><p>数据库设计的三个范式是指数据库设计的规范，是为了减少冗余数据，提高数据的存储效率。数据库设计的三个范式分别是：</p>
<ul>
<li>1NF(第一范式)：属性不可再分。<ul>
<li>1NF 是所有<strong>关系型数据库</strong>的最基本要求 ，关系型数据库中创建的表一定满足第一范式。</li>
</ul>
</li>
<li>2NF(第二范式)： 1NF 的基础之上，消除了非主属性对于码的<strong>部分函数依赖</strong>。</li>
<li>3NF(第三范式)： 3NF 在 2NF 的基础之上，消除了非主属性对于码的<strong>传递函数依赖</strong>。<ul>
<li>符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>函数依赖：在一张表中，在属性(或属性组)X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<ul>
<li>例子：学生基本信息表 R 中(学号，身份证号，姓名)当然学号属性取值是唯一的，在 R 关系中，(学号，身份证号)-&gt;(姓名)，(学号)-&gt;(姓名)，(身份证号)-&gt;(姓名)；所以姓名部分函数依赖于(学号，身份证号)；</li>
</ul>
</li>
<li>部分函数依赖：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。<ul>
<li>例子：学生基本信息表 R(学号，班级，姓名)假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，(学号，班级)-&gt;(姓名)，但是(学号)-&gt;(姓名)不成立，(班级)-&gt;(姓名)不成立，所以姓名完全函数依赖与(学号，班级)；</li>
</ul>
</li>
<li>完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。</li>
<li>传递函数依赖：在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，(X∪Y)∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。<strong>传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。</strong><ul>
<li>例子：在关系 R(学号，姓名，系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="主键-外键区别"><a href="#主键-外键区别" class="headerlink" title="主键&#x2F;外键区别"></a>主键&#x2F;外键区别</h3><p>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</p>
<h3 id="为什么不推荐使用外键和级联操作"><a href="#为什么不推荐使用外键和级联操作" class="headerlink" title="为什么不推荐使用外键和级联操作"></a>为什么不推荐使用外键和级联操作</h3><p>以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。如果更新学生表中的 <code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</strong></p>
<ul>
<li>增加了复杂型：每次做 <code>DELETE</code> 或者 <code>UPDATE</code> 都必须考虑外键约束，会导致开发的时候很痛苦， 测试数据极为不方便；</li>
<li>增加了资源消耗：做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；</li>
<li>对分库分表的支持不友好：分库分表时需要考虑外键的约束，很麻烦。</li>
</ul>
<p><strong>外键好处</strong></p>
<ul>
<li>保证了数据库数据的一致性和完整性；</li>
<li>级联操作方便，减轻了程序代码量；</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程是一种预编译的 SQL 语句，存储在数据库中，可以被多次调用。存储过程可以接收参数，可以返回结果，可以包含流程控制语句，可以实现一些复杂的逻辑。</p>
<p>存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。但存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>
<h3 id="DROP-TRUNCATE-DELETE区别"><a href="#DROP-TRUNCATE-DELETE区别" class="headerlink" title="DROP&#x2F;TRUNCATE&#x2F;DELETE区别"></a>DROP&#x2F;TRUNCATE&#x2F;DELETE区别</h3><ol>
<li>用法不同</li>
</ol>
<ul>
<li><code>DROP</code>(丢弃数据)：<code>DROP table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>
<li><code>TRUNCATE</code>(清空数据)：<code>TRUNCATE table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li><code>DELETE</code>(删除数据)：<code>DELETE FROM 表名 WHERE 列名=值</code>，删除某一行的数据，如果不加 <code>WHERE</code> 子句和<code>TRUNCATE table 表名</code>作用类似。</li>
</ul>
<p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据不删除表的结构(定义)，<code>DROP</code>会删除表的结构。</p>
<ol start="2">
<li>属于不同的数据库语言</li>
</ol>
<ul>
<li><code>DROP</code> 和 <code>TRUNCATE</code> 是 <code>DDL(Data Definition Language)</code> 数据定义语言，<code>DELETE</code> 是 <code>DML(Data Manipulation Language)</code> 数据操纵语言。</li>
</ul>
<ol start="3">
<li>执行速度不同：<code>DROP &gt; TRUNCATE &gt; DELETE</code>。</li>
</ol>
<ul>
<li><code>DELETE</code>命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>
<li><code>TRUNCATE</code>命令执行的时候不会产生数据库日志，因此比<code>DELETE</code>要快。但其需要把表的自增值重置和索引恢复到初始大小等。</li>
<li><code>DROP</code>命令会把表占用的空间全部释放掉。</li>
</ul>
<h3 id="数据库设计分为哪几个步"><a href="#数据库设计分为哪几个步" class="headerlink" title="数据库设计分为哪几个步"></a>数据库设计分为哪几个步</h3><ol>
<li>需求分析：分析用户的需求，包括数据、功能和性能需求。</li>
<li>概念结构设计：主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li>逻辑结构设计：通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li>数据库实施：包括编程、测试和试运行</li>
<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>
</ol>
<h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><p><code>NoSQL(Not Only SQL)</code>泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>
<p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据，只是与关系型数据库的存储方式不同。</p>
<blockquote>
<p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p>
</blockquote>
<h3 id="SQL-NoSQL区别"><a href="#SQL-NoSQL区别" class="headerlink" title="SQL&#x2F;NoSQL区别"></a>SQL&#x2F;NoSQL区别</h3><p>|         | SQL 数据库                                      | NoSQL 数据库                                                                                |<br>|：——–|———————————————-|——————————————————————————————|<br>| 数据存储模型  | 结构化存储，具有固定行和列的表格                             | 非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边                                             |<br>| ACID 属性 | 提供原子性、一致性、隔离性和持久性 (ACID) 属性                  | 通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。   |<br>| 性能      | 性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。        | 性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。                                                           |<br>| 扩展      | 垂直(使用性能更强大的服务器进行扩展)、读写分离、分库分表                | 横向(增加服务器的方式横向扩展，通常是基于分片机制)                                                               |<br>| 用途      | 普通企业级的项目的数据存储                                | 用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化                                       |<br>| 查询语法    | 结构化查询语言 (SQL)                                | 数据访问语法可能因数据库而异                                                                           |<br>| 发展历程    | 开发于 1970 年代，重点是减少数据重复                        | 开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本                                                     |<br>| 例子      | Oracle、MySQL、Microsoft SQL Server、PostgreSQL | 文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph |</p>
<h3 id="NoSQL优劣"><a href="#NoSQL优劣" class="headerlink" title="NoSQL优劣"></a>NoSQL优劣</h3><p><strong>优点</strong></p>
<ul>
<li>灵活性：提供灵活的架构，以实现更快速、更多的迭代开发，是存储半结构化和非结构化数据的理想之选。</li>
<li>可扩展性：通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>
<li>高性能：NoSQL 数据库通常是为了提供高性能而设计的，因为它们通常是基于键值对的，而不是基于关系的。</li>
<li>功能强大：提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>一致性：NoSQL 数据库通常不支持 ACID 属性，因此在某些情况下可能会导致数据不一致。</li>
<li>缺乏标准化：NoSQL 数据库通常没有标准化的查询语言，这可能会导致开发人员需要学习多种不同的查询语言。</li>
</ul>
<h3 id="NoSQL分类"><a href="#NoSQL分类" class="headerlink" title="NoSQL分类"></a>NoSQL分类</h3><ul>
<li>键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 <code>value</code> 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li>
<li>文档：文档数据库中的数据被存储在类似于 JSON(JavaScript 对象表示法)对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li>
<li>图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li>
<li>宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li>
</ul>
<h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><p><code>DDL/DML/DCL/TCL</code></p>
<ul>
<li><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。<ul>
<li>DDL 不涉及表中数据的操作，只是对表的定义、结构的修改。</li>
</ul>
</li>
<li><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。<ul>
<li>DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。</li>
</ul>
</li>
<li><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</li>
<li><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</li>
</ul>
<h3 id="SQL三种注释方式"><a href="#SQL三种注释方式" class="headerlink" title="SQL三种注释方式"></a>SQL三种注释方式</h3><ul>
<li>单行注释：<code>-- 注释内容</code> 或 <code># 注释内容</code>。</li>
<li>多行注释：<code>/* 注释内容 */</code>。</li>
<li>行尾注释：<code>SELECT * FROM table_name; -- 注释内容</code>。</li>
</ul>
<h3 id="DML语句✅"><a href="#DML语句✅" class="headerlink" title="DML语句✅"></a>DML语句✅</h3><p><code>DML(Data Manipulation Language)</code> 数据操纵语言：用来操作数据库中的记录，对数据库其中的对象和数据运行访问工作的编程语句。核心指令：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>，这四个指令合称<code>CRUD(Create, Read, Update, Delete)</code>，即增删改查。</p>
<h3 id="增删改查CRUD"><a href="#增删改查CRUD" class="headerlink" title="增删改查CRUD"></a>增删改查CRUD</h3><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p>
<p><strong>插入数据</strong><br><code>INSERT INTO</code> 语句用于向表中插入新记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整的行</span></span><br><span class="line"><span class="comment">-- 插入一行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">12</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>), (<span class="number">18</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入行的一部分</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询出来的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username)</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<p><strong>更新数据</strong><br><code>UPDATE</code> 语句用于更新表中的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<ul>
<li><code>DELETE</code> 语句用于删除表中的记录。</li>
<li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表中的指定数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空表中的数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查询数据</strong></p>
<ul>
<li><code>SELECT</code> 语句用于从数据库中查询数据。</li>
<li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li>
<li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>
<li><code>ASC</code>：升序(默认)</li>
<li><code>DESC</code>：降序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询单列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询多列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询不同的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">vend_id <span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制查询结果</span></span><br><span class="line"><span class="comment">-- 返回前 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 返回第 3 ~ 5 行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</li>
<li><code>ORDER BY</code> 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>**<code>GROUP BY</code>**：</p>
<ul>
<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>
<li><code>GROUP BY</code> 为每个组返回一个记录。</li>
<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>
<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>
<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分组</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组后排序</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(cust_address) <span class="keyword">AS</span> addr_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul>
<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>
<li><code>HAVING</code> 一般都是和 <code>GROUP BY</code> 连用。</li>
<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 WHERE 和 HAVING 过滤数据</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> NumberOfOrders</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="WHERE-HAVING对比"><a href="#WHERE-HAVING对比" class="headerlink" title="WHERE&#x2F;HAVING对比"></a>WHERE&#x2F;HAVING对比</h3><ul>
<li><code>WHERE</code>：过滤过滤指定的行，后面不能加聚合函数(分组函数)。<code>WHERE</code> 在<code>GROUP BY</code> 前。</li>
<li><code>HAVING</code>：过滤分组，一般都是和 <code>GROUP BY</code> 连用，不能单独使用。<code>HAVING</code> 在 <code>GROUP BY</code> 之后。</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>MYSQL4.1才开始支持子查询(子查询需要放入括号<code>()</code>内)</p>
<p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询(子查询)的结果作为另一个 SQL 语句(主查询)的数据来源或者判断条件。</p>
<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>
<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>
<ul>
<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 <code>WHERE</code> 子句查询条件的值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span>   table1 [, table2 ]</span><br><span class="line"><span class="keyword">WHERE</span>  column_name operator</span><br><span class="line">    (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">    <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">    [<span class="keyword">WHERE</span>])</span><br></pre></td></tr></table></figure></li>
<li>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">WHERE</span>]) <span class="keyword">as</span> temp_table_name</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>子查询的子查询</strong><br>首先会执行子查询，然后将子查询的结果作为外部查询的条件，再执行外部查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul>
<li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li>
<li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li>
<li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SELECT语句中的WHERE</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- UPDATE语句中的WHERE</span></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Jack Jones&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DELETE语句中的WHERE</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Kids Place&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>可以在 <code>WHERE</code> 子句中使用的操作符。<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code></td>
<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 <code>!=</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>BETWEEN</code></td>
<td>在某个范围内</td>
</tr>
<tr>
<td><code>LIKE</code></td>
<td>搜索某种模式</td>
</tr>
<tr>
<td><code>IN</code></td>
<td>指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="IN-BETWEEN"><a href="#IN-BETWEEN" class="headerlink" title="IN&#x2F;BETWEEN"></a>IN&#x2F;BETWEEN</h3><ul>
<li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li>
<li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BETWEEN示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AND-OR-NOT"><a href="#AND-OR-NOT" class="headerlink" title="AND&#x2F;OR&#x2F;NOT"></a>AND&#x2F;OR&#x2F;NOT</h3><ul>
<li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li>
<li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li>
<li><code>AND</code> 操作符表示左右条件都要满足。</li>
<li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li>
<li><code>NOT</code> 操作符用于否定一个条件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- AND示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul>
<li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li>
<li>只有字段是文本值时才使用 <code>LIKE</code>。</li>
<li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li>
<li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li>
<li><code>%</code> 表示任何字符出现任意次数。</li>
<li><code>_</code> 表示任何字符出现一次。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- _示例</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="连接JOIN"><a href="#连接JOIN" class="headerlink" title="连接JOIN"></a>连接JOIN</h3><p><code>JOIN</code> 子句用于将两个或者多个表联合起来进行查询。连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表(临时表，仅存在于本次查询中)。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column1, table2.column2...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column1 <span class="operator">=</span> table2.common_column2; <span class="comment">-- 连接条件，可以使用多个运算符， =、&gt;、&lt;、&lt;&gt;、&lt;=、&gt;=、!=、between、like 或者 not</span></span><br></pre></td></tr></table></figure>
<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>
<p>如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># JOIN....ON</span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders o</span><br><span class="line"><span class="keyword">ON</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="comment">-- 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....using()</span></span><br><span class="line"><span class="comment">-- using(cust_id) 代替 ON c.cust_id = o.cust_id</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.cust_name;</span><br></pre></td></tr></table></figure>

<h3 id="内连接-外连接"><a href="#内连接-外连接" class="headerlink" title="内连接&#x2F;外连接"></a>内连接&#x2F;外连接</h3><ul>
<li><code>内连接</code>：<code>INNER JOIN</code> 或者 <code>JOIN</code>，只返回两个表中满足连接条件的行，是连接表的默认方式。</li>
<li><code>外连接</code>：<ul>
<li><code>左外连接</code>：<code>LEFT JOIN</code>&#x2F;<code>LEFT OUTER JOIN</code>，返回左表中所有记录和右表中满足连接条件的记录。</li>
<li><code>右外连接</code>：<code>RIGHT JOIN</code>&#x2F;<code>RIGHT OUTER JOIN</code>，返回右表中所有记录和左表中满足连接条件的记录。</li>
<li><code>全外连接</code>：<code>FULL JOIN</code>&#x2F;<code>FULL OUTER JOIN</code>，返回左表和右表中所有记录，如果没有匹配的记录，结果集中会包含 <code>NULL</code> 值。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">student表</span></span><br><span class="line"><span class="comment">student_id	name</span></span><br><span class="line"><span class="comment">1	        Alice</span></span><br><span class="line"><span class="comment">2	        Bob</span></span><br><span class="line"><span class="comment">3	        Carol</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">courses表</span></span><br><span class="line"><span class="comment">course_id	student_id	course_name</span></span><br><span class="line"><span class="comment">101	        1	        Math</span></span><br><span class="line"><span class="comment">102	        2	        Science</span></span><br><span class="line"><span class="comment">103	        4	        History</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">name	course_name</span></span><br><span class="line"><span class="comment">Alice	Math</span></span><br><span class="line"><span class="comment">Bob	Science</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">name	course_name</span></span><br><span class="line"><span class="comment">Alice	Math</span></span><br><span class="line"><span class="comment">Bob	Science</span></span><br><span class="line"><span class="comment">Carol	NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">name	course_name</span></span><br><span class="line"><span class="comment">Alice	Math</span></span><br><span class="line"><span class="comment">Bob	Science</span></span><br><span class="line"><span class="comment">NULL	History</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> students.name, courses.course_name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> courses <span class="keyword">ON</span> students.student_id <span class="operator">=</span> courses.student_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">name	course_name</span></span><br><span class="line"><span class="comment">Alice	Math</span></span><br><span class="line"><span class="comment">Bob	Science</span></span><br><span class="line"><span class="comment">Carol	NULL</span></span><br><span class="line"><span class="comment">NULL	History</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="ON-WHERE区别"><a href="#ON-WHERE区别" class="headerlink" title="ON&#x2F;WHERE区别"></a>ON&#x2F;WHERE区别</h3><ul>
<li><code>ON</code> 子句是在执行 <code>JOIN</code> 操作时使用的，它指定了两个表之间的连接条件，决定临时表的生成。</li>
<li><code>WHERE</code> 子句是在从临时表中检索数据时使用的，它指定了检索数据的条件。</li>
</ul>
<h3 id="组合UNION"><a href="#组合UNION" class="headerlink" title="组合UNION"></a>组合UNION</h3><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>
<p><code>UNION</code> 基本规则：</p>
<ul>
<li>所有查询的列数和列顺序必须相同。</li>
<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>
<li>通常返回的列名取自第一个查询。</li>
<li><code>UNION</code> 默认选取不同的值。如果允许重复的值，用 <code>UNION ALL</code>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>

<h3 id="DDL语言✅"><a href="#DDL语言✅" class="headerlink" title="DDL语言✅"></a>DDL语言✅</h3><p><code>DDL(Data Definition Language)</code> 数据定义语言：用来定义数据库对象：数据库、表、列等。关键字：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>TRUNCATE</code>。</p>
<h3 id="数据库DATABSE"><a href="#数据库DATABSE" class="headerlink" title="数据库DATABSE"></a>数据库DATABSE</h3><ul>
<li>创建数据库：<code>CREATE DATABASE 数据库名;</code></li>
<li>删除数据库：<code>DROP DATABASE 数据库名;</code></li>
<li>选择数据库：<code>USE 数据库名;</code></li>
<li>查看数据库：<code>SHOW DATABASES;</code></li>
</ul>
<h3 id="数据表TABLE"><a href="#数据表TABLE" class="headerlink" title="数据表TABLE"></a>数据表TABLE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据已有表创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vip_user <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="comment">-- ALTER用于修改表</span></span><br><span class="line"><span class="keyword">ADD</span> age <span class="type">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> age tinyint;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h3 id="视图VIEW"><a href="#视图VIEW" class="headerlink" title="视图VIEW"></a>视图VIEW</h3><p>在SQL中，视图<code>VIEW</code>是一种虚拟表，作用类似于一个保存了查询结果的表。视图并不实际存储数据，而是存储一个查询，当访问视图时，数据库会动态地执行这个查询来生成结果。</p>
<p>作用：</p>
<ul>
<li>简化复杂查询：视图可以将复杂的查询封装起来，使得用户可以通过简单的SELECT语句来访问复杂的数据。</li>
<li>提高数据安全性：用来限制用户访问敏感数据。</li>
<li>数据抽象和逻辑独立性：视图提供了一层抽象，使得底层表的结构变化不会影响到用户。</li>
<li>重用SQL逻辑：可以将经常使用的查询逻辑存储在视图中，从而避免在多个地方重复相同的查询逻辑。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top_10_user_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> top_10_user_view;</span><br></pre></td></tr></table></figure>

<h3 id="索引INDEX"><a href="#索引INDEX" class="headerlink" title="索引INDEX"></a>索引INDEX</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>
<p><strong>优点</strong></p>
<ul>
<li>使用索引可以大大加快 数据的检索速度(大大减少检索的数据量)， 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX user_index(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX user_index</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX user_index;</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定(通过 <code>CREATE TABLE 语句</code>)，或者在表创建之后规定(<code>通过 ALTER TABLE 语句</code>)。</p>
<p><strong>约束类型</strong></p>
<ul>
<li><code>NOT NULL</code>：指示某列不能存储 <code>NULL</code> 值。</li>
<li><code>UNIQUE</code>：保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code>：<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合。确保某列(或两个列多个列的结合)有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code>：保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code>：保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code>：规定没有给列赋值时的默认值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Users (</span><br><span class="line">  Id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增Id&#x27;</span>,</span><br><span class="line">  Username <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  Password <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  Email <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱地址&#x27;</span>,</span><br><span class="line">  Enabled TINYINT(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否有效&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (Id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="TCL语句✅"><a href="#TCL语句✅" class="headerlink" title="TCL语句✅"></a>TCL语句✅</h3><p><code>TCL(Transaction Control Language)</code> 事务控制语言：用于管理数据库中的事务。关键字：<code>COMMIT</code>、<code>ROLLBACK</code>。</p>
<h3 id="事务TRANSACTION"><a href="#事务TRANSACTION" class="headerlink" title="事务TRANSACTION"></a>事务TRANSACTION</h3><p>事务是一个操作序列，这些操作要么都执行，要么都不执行，是数据库管理系统(DBMS)执行的一个操作单元。事务是数据库维护完整性的单位，在事务中的所有操作要么全部完成，要么全部不完成。</p>
<p><strong>事务的四个特性(ACID)</strong></p>
<ul>
<li><code>原子性(Atomicity)</code>：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>
<li><code>一致性(Consistency)</code>：执行事务前后，数据保持一致。</li>
<li><code>隔离性(Isolation)</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li><code>持久性(Durability)</code>：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>
</ul>
<p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<blockquote>
<p>注意：不能回退 <code>CREATE</code> 或 <code>DROP</code> 等 DDL 语句。也不能回退 <code>SELECT</code>语句，回退也没意义。针对每个连接，通过设置<code>set autocommit=0</code>取消自动提交，<code>set autocommit=1</code> 才会自动提交。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h3 id="DCL语句✅"><a href="#DCL语句✅" class="headerlink" title="DCL语句✅"></a>DCL语句✅</h3><p><code>DCL(Data Control Language)</code> 数据控制语言：用来控制数据库用户的访问权限。关键字：<code>GRANT</code>、<code>REVOKE</code>。</p>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li>授予用户帐户权限，用<code>GRANT</code>命令。<ul>
<li>在<code>GRANT</code>关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。</li>
<li><code>ON privilege_level</code> 确定权限应用级别。MySQL 支持 global(<code>*.*</code>)，database(<code>database.*</code>)，table(<code>database.table</code>)和列级别。如果使用列权限级别，必须在每个权限之后指定一个或逗号分隔列的列表。</li>
<li><code>user</code> 是要授予权限的用户。如果用户已存在，则<code>GRANT</code>语句将修改其权限。否则，<code>GRANT</code>语句将创建一个新用户。可选子句<code>IDENTIFIED BY</code>允许您为用户设置新的密码。</li>
<li><code>REQUIRE tsl_option</code>指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。</li>
<li>可选 <code>WITH GRANT OPTION</code> 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用<code>WITH</code>子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。</li>
</ul>
</li>
<li>撤销用户的权限，用<code>REVOKE</code>命令。<ul>
<li>在 <code>REVOKE</code> 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。</li>
<li>指定在 <code>ON</code> 子句中撤销特权的特权级别。</li>
<li>指定要撤消 <code>FROM</code> 子句中的权限的用户帐户。</li>
</ul>
</li>
</ul>
<p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li>
<li>整个数据库，使用 <code>ON database.*</code>；</li>
<li>特定的表，使用 <code>ON database.table</code>；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- GRANT用法</span></span><br><span class="line"><span class="keyword">GRANT</span> privilege,[privilege],.. <span class="keyword">ON</span> privilege_level</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> password]</span><br><span class="line">[REQUIRE tsl_option]</span><br><span class="line">[<span class="keyword">WITH</span> [GRANT_OPTION <span class="operator">|</span> resource_option]];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- REVOKE用法</span></span><br><span class="line"><span class="keyword">REVOKE</span> privilege_type [(column_list)]</span><br><span class="line">       [, priv_type [(column_list)]]...</span><br><span class="line"><span class="keyword">ON</span> [object_type] privilege_level</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>]...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建账户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改账户名</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="comment">-- 删除账户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br><span class="line"><span class="comment">-- 删除权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br><span class="line"><span class="comment">-- 更改密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> myuser <span class="operator">=</span> <span class="string">&#x27;mypass&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="游标CURSOR"><a href="#游标CURSOR" class="headerlink" title="游标CURSOR"></a>游标CURSOR</h3><p>游标(cursor)是一个存储在 DBMS 服务器上的数据库查询，它不是一条 <code>SELECT</code> 语句，而是被该语句检索出来的结果集。在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<h3 id="触发器TRIGGER"><a href="#触发器TRIGGER" class="headerlink" title="触发器TRIGGER"></a>触发器TRIGGER</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。触发器是一种特殊的存储过程，它是由一个事件触发的，一个事件可以是一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句。</p>
<p><strong>优点</strong></p>
<ul>
<li>SQL 触发器提供了另一种检查数据完整性的方法。</li>
<li>SQL 触发器可以捕获数据库层中业务逻辑中的错误。</li>
<li>SQL 触发器提供了另一种运行计划任务的方法。通过使用 SQL 触发器，不必等待运行计划任务，因为在对表中的数据进行更改之前或之后会自动调用触发器。</li>
<li>SQL 触发器对于审计表中数据的更改非常有用。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>SQL 触发器可能会增加数据库服务器的开销。</li>
<li>从客户端应用程序调用和执行 SQL 触发器是不可见的，因此很难弄清楚数据库层中发生了什么。</li>
</ul>
<p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器，之后版本可为同一触发事件和操作时间定义多个触发器。</p>
<ul>
<li><code>BEFORE INSERT</code>：在将数据插入表格之前激活。</li>
<li><code>AFTER INSERT</code>：将数据插入表格后激活。</li>
<li><code>BEFORE UPDATE</code>：在更新表中的数据之前激活。</li>
<li><code>AFTER UPDATE</code>：更新表中的数据后激活。</li>
<li><code>BEFORE DELETE</code>：在从表中删除数据之前激活。</li>
<li><code>AFTER DELETE</code>：从表中删除数据后激活。</li>
</ul>
<p><code>NEW</code> 和 <code>OLD</code>：</p>
<ul>
<li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>
<li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要(<code>BEFORE</code>)或已经(<code>AFTER</code>)插入的新数据；</li>
<li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li>
<li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li>
<li>使用方法：<code>NEW.columnName</code> (<code>columnName</code> 为相应数据表某一列名)</li>
</ul>
<h3 id="触发器语法"><a href="#触发器语法" class="headerlink" title="触发器语法"></a>触发器语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>trigger_name</code>：触发器名</li>
<li><code>trigger_time</code>：触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li>
<li><code>trigger_event</code>：触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li>
<li><code>table_name</code>：触发器的监听目标。指定在哪张表上建立触发器。</li>
<li><code>FOR EACH ROW</code>：行级监视，Mysql 固定写法，其他 DBMS 不同。</li>
<li><code>trigger_statements</code>：触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li>
</ul>
<p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_insert_user;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。MySQL 是开源免费并且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<code>3306</code>。</p>
<h3 id="MySQL基础✅"><a href="#MySQL基础✅" class="headerlink" title="MySQL基础✅"></a>MySQL基础✅</h3><h3 id="MySQL优点"><a href="#MySQL优点" class="headerlink" title="MySQL优点"></a>MySQL优点</h3><ul>
<li>成熟稳定，功能完善。开源免费。文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>
<li>开箱即用，操作简单，维护成本低。</li>
<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>
<li>社区活跃，生态完善。事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>
<li>支持分库分表、读写分离、高可用。</li>
</ul>
<h3 id="什么是关系型数据库"><a href="#什么是关系型数据库" class="headerlink" title="什么是关系型数据库"></a>什么是关系型数据库</h3><p>关系型数据库(<code>RDB，Relational Database</code>)是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。关系型数据库中，数据都被存放在了各种表中(比如用户表)，表中的每一行就存放着一条数据(比如一个用户的信息)。</p>
<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。常见关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite(微信本地的聊天记录的存储就是用的 SQLite) ……</p>
<h3 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h3><p>简单分为三大类：数值类型、字符串类型、日期和时间类型。</p>
<ul>
<li>数值类型：<ul>
<li>整形：<code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>。</li>
<li>浮点型：<code>FLOAT</code>、<code>DOUBLE</code>。</li>
<li>定点数：<code>DECIMAL</code>。</li>
</ul>
</li>
<li>字符串类型：<ul>
<li>常用：<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>。</li>
<li>不常用：<code>TINYTEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code> 和 <code>LONGBLOB</code> 等。</li>
</ul>
</li>
<li>日期和时间类型：<ul>
<li><code>DATE</code>、<code>TIME</code>、<code>YEAR</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>等。</li>
</ul>
</li>
</ul>
<h3 id="整数类型的UNSIGNED属性"><a href="#整数类型的UNSIGNED属性" class="headerlink" title="整数类型的UNSIGNED属性"></a>整数类型的UNSIGNED属性</h3><p>整数类型可以使用可选的 <code>UNSIGNED</code> 属性来表示不允许负值的无符号整数。使用 <code>UNSIGNED</code> 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>
<blockquote>
<p><code>TINYINT UNSIGNED</code> 取值范围是 0 ~ 255，<code>TINYINT</code> 是 -128 ~ 127。<br><code>INT UNSIGNED</code> 取值范围是 0 ~ 4,294,967,295，<code>INT</code> 是 -2,147,483,648 ~ 2,147,483,647。</p>
</blockquote>
<p>对于从 0 开始递增的 ID 列，使用 <code>UNSIGNED</code> 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>
<h3 id="CHAR-VARCHAR区别"><a href="#CHAR-VARCHAR区别" class="headerlink" title="CHAR&#x2F;VARCHAR区别"></a>CHAR&#x2F;VARCHAR区别</h3><ul>
<li><code>CHAR</code> 是一种固定长度的类型，<code>VARCHAR</code> 是一种可变长度的类型。</li>
<li><code>CHAR</code> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；<code>VARCHAR</code> 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</li>
<li><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</li>
<li><code>CHAR</code> 适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。<code>VARCHAR</code>适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li>
</ul>
<h3 id="VARCHAR-100-VARCHAR-10-区别"><a href="#VARCHAR-100-VARCHAR-10-区别" class="headerlink" title="VARCHAR(100)&#x2F;VARCHAR(10)区别"></a>VARCHAR(100)&#x2F;VARCHAR(10)区别</h3><ul>
<li>前者最大长度为 100，后者最大长度为 10。</li>
<li>二者存储相同的字符串所占用的存储空间是一样的。</li>
<li><code>VARCHAR</code> 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。<code>VARCHAR(100)</code>在内存中操作时会消耗更多内存，例如在排序的时候，每个元素都占用 100字节内存。</li>
</ul>
<h3 id="DECIMAL和FLOAT-DOUBLE区别"><a href="#DECIMAL和FLOAT-DOUBLE区别" class="headerlink" title="DECIMAL和FLOAT&#x2F;DOUBLE区别"></a>DECIMAL和FLOAT&#x2F;DOUBLE区别</h3><p><code>DECIMAL</code> 是定点数，<code>FLOAT/DOUBLE</code> 是浮点数。<code>DECIMAL</code> 可以存储精确的小数值，<code>FLOAT/DOUBLE</code> 只能存储近似的小数值。</p>
<h3 id="为什么没不推荐使用TEXT-BLOB类型"><a href="#为什么没不推荐使用TEXT-BLOB类型" class="headerlink" title="为什么没不推荐使用TEXT&#x2F;BLOB类型"></a>为什么没不推荐使用TEXT&#x2F;BLOB类型</h3><ul>
<li><code>TEXT</code>用于存储长文本数据，如博客数据。</li>
<li><code>BLOB</code>用于存储二进制大对象，例如图片、音视频等文件。</li>
</ul>
<p>这两种类型有如下缺陷：</p>
<ul>
<li>不能有默认值。</li>
<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。</li>
<li>检索效率较低。</li>
<li>不能直接创建索引，需要指定前缀长度。</li>
<li>可能会消耗大量的网络和 IO 带宽。</li>
<li>可能导致表上的 DML 操作变慢。</li>
</ul>
<h3 id="DATETIME-TIMESTAMP区别"><a href="#DATETIME-TIMESTAMP区别" class="headerlink" title="DATETIME&#x2F;TIMESTAMP区别"></a>DATETIME&#x2F;TIMESTAMP区别</h3><ul>
<li><code>DATETIME</code>没有时区信息，<code>TIMESTAMP</code> 和时区有关。</li>
<li><code>TIMESTAMP</code> 只需要使用 4 个字节的存储空间，但是 <code>DATETIME</code> 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，<code>TIMESTAMP</code> 表示的时间范围更小。<ul>
<li><code>DATETIME</code>：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li><code>TIMESTAMP</code>：1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC</li>
</ul>
</li>
<li><code>TIMESTAMP</code> 在存储时会自动转换为 UTC(Coordinated Universal Time, 全球标准时间) 时间，检索时会转换为当前时区的时间。</li>
</ul>
<h3 id="NULL和’’区别"><a href="#NULL和’’区别" class="headerlink" title="NULL和’’区别"></a>NULL和’’区别</h3><ul>
<li><code>NULL</code> 表示未知的值，<code>&#39;&#39;</code> 表示空字符串。<ul>
<li><code>SELECT NULL=NULL</code>的结果为 <code>false</code>，但在使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时又认为<code>NULL</code>是相等的。</li>
</ul>
</li>
<li><code>&#39;&#39;</code>长度为0，不占用空间，<code>NULL</code>占用空间。</li>
<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，而不能使用 <code>=</code>、<code>!=</code>、 <code>&lt;</code>、<code>&gt;</code> 之类的比较运算符。而<code>&#39;&#39;</code>是可以使用这些比较运算符的。</li>
<li><code>NULL</code> 会影响聚合函数的结果。<ul>
<li><code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。<code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*(COUNT(*))</code>，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名<code>(COUNT(列名))</code>，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>
</ul>
</li>
</ul>
<p>不推荐使用<code>NULL</code>作为列默认值。</p>
<h3 id="Boolean类型如何在MySQL中存储"><a href="#Boolean类型如何在MySQL中存储" class="headerlink" title="Boolean类型如何在MySQL中存储"></a>Boolean类型如何在MySQL中存储</h3><p>MySQL 中没有布尔类型，可以使用 <code>TINYINT</code> 类型来存储布尔值。<code>TINYINT(1)</code> 可以存储 0 或 1，分别表示 <code>false</code> 和 <code>true</code>。</p>
<h3 id="MySQL基础架构✅"><a href="#MySQL基础架构✅" class="headerlink" title="MySQL基础架构✅"></a>MySQL基础架构✅</h3><p>MySQL 基础架构主要分为 Server 层和存储引擎层：</p>
<ul>
<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 <code>binlog</code> 日志模块。</li>
<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code> 等多个存储引擎，其中 <code>InnoDB</code> 引擎有自有的日志模块 <code>redolog</code> 模块。现在最常用的存储引擎是 <code>InnoDB</code>，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li>
</ul>
<p><img src="/../image/Database-Interview/13526879-3037b144ed09eb88.png" alt="MySQL基础架构图"></p>
<ul>
<li>连接器：身份认证和权限相关(登录 MySQL 的时候)。</li>
<li>查询缓存：执行查询语句的时候，会先查询缓存(MySQL 8.0 版本后移除，因为这个功能不太实用)。</li>
<li>分析器：没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li>优化器：按照 MySQL 认为最优的方案去执行。</li>
<li>执行器：执行语句，然后从存储引擎返回数据。</li>
<li>插件式存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<ol>
<li><p>连接器。<br>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>
</li>
<li><p>查询缓存(MySQL 8.0 版本后移除)。<br>主要用来缓存所执行的 <code>SELECT</code> 语句以及该语句的结果集。连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 语句是否执行过，以 <code>Key-Value</code> 的形式缓存在内存中，<code>Key</code> 是查询语句，<code>Value</code> 是结果集。如果缓存 <code>Key</code> 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。<br>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
</li>
<li><p>分析器。<br>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的。分两步：</p>
<ul>
<li>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 SELECT，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</li>
<li>第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</li>
</ul>
</li>
<li><p>优化器。<br>优化器以它认为的最优的执行方案去执行(有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解)，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
</li>
<li><p>执行器。<br>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
</li>
</ol>
<h3 id="SQL语句在MySQL中的执行过程"><a href="#SQL语句在MySQL中的执行过程" class="headerlink" title="SQL语句在MySQL中的执行过程"></a>SQL语句在MySQL中的执行过程</h3><p><strong>查询语句</strong><br>查询语句的执行流程如下：权限校验(如果命中缓存)—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student  A <span class="keyword">WHERE</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">AND</span> A.name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 <code>key</code> 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>
<li>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询<code>SELECT</code>，提取需要查询的表名为 <code>tb_student</code>，需要查询所有的列，查询条件是这个表的 id&#x3D;’1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>
<li>优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：<ul>
<li>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</li>
<li>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定最好)。那么确认了执行计划后就准备开始执行了。</li>
</ul>
</li>
<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>
</ol>
<p><strong>更新语句(增加，修改，删除)</strong><br>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—<code>redo log</code>(<code>prepare</code> 状态)—&gt;<code>binlog</code>—&gt;<code>redo log</code>(<code>commit</code> 状态)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tb_student A <span class="keyword">SET</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">WHERE</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL自带的日志模块是 <code>binlog</code>，以 <code>InnoDB</code> 作为存储引擎介绍，其自带了一个<code>redo log</code> 日志模块，用来保证数据的一致性的。</p>
<ol>
<li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li>
<li>拿到查询的语句，把 <code>age</code> 改为 19，然后调用引擎 API 接口，写入这一行数据，<code>InnoDB</code> 引擎把数据保存在内存中，同时记录 <code>redo log</code>，此时 <code>redo log</code> 进入 <code>prepare</code> 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 <code>binlog</code>，然后调用引擎接口，提交 <code>redo log</code> 为提交状态。</li>
<li>更新完成。</li>
</ol>
<h3 id="MySQL存储引擎✅"><a href="#MySQL存储引擎✅" class="headerlink" title="MySQL存储引擎✅"></a>MySQL存储引擎✅</h3><h3 id="MySQL支持哪些存储引擎？"><a href="#MySQL支持哪些存储引擎？" class="headerlink" title="MySQL支持哪些存储引擎？"></a>MySQL支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，常见的存储引擎有 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>、<code>CSV</code>、<code>Archive</code>、<code>Blackhole</code>、<code>NDB</code>、<code>Merge</code>、<code>Federated</code>、<code>Example</code> 等。</p>
<p>MySQL 5.5.5 之前，<code>MyISAM</code> 是默认存储引擎。5.5.5 版本之后，InnoDB 是默认存储引擎。</p>
<h3 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h3><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。也可以自定义村吹引擎。</p>
<h3 id="MyISAM-InnoDB存储引擎区别"><a href="#MyISAM-InnoDB存储引擎区别" class="headerlink" title="MyISAM&#x2F;InnoDB存储引擎区别"></a>MyISAM&#x2F;InnoDB存储引擎区别</h3><ul>
<li><code>MyISAM</code>只支持表级锁，而 <code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>
<li><code>MyISAM</code> 不提供事务支持。<code>InnoDB</code> 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(<code>commit</code>)和回滚(<code>rollback</code>)事务的能力。并且，<code>InnoDB</code> 默认使用的 <code>REPEATABLE-READ</code>(可重读)隔离级别是可以解决幻读问题发生的(基于 <code>MVCC</code> 和 <code>Next-Key Lock</code>)。</li>
<li><code>MyISAM</code> 不支持外键，而 <code>InnoDB</code> 支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗，因此一般不建议使用。</li>
<li><code>MyISAM</code> 不支持数据库异常崩溃后的安全恢复，而 <code>InnoDB</code> 支持，恢复过程依赖于<code>redo log</code>。</li>
<li><code>InnoDB</code>支持 <code>MVCC</code>，<code>MyISAM</code> 不支持。<code>MVCC</code> 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</li>
<li><code>InnoDB</code>和<code>MyISAM</code>都使用<code>B+Tree</code> 作为索引结构，但二者实现方式不一样。<code>InnoDB</code> 引擎中，其数据文件本身就是索引文件。相比 <code>MyISAM</code>，索引文件和数据文件是分离的，其表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，树的叶节点 <code>data</code> 域保存了完整的数据记录。</li>
<li><code>InnoDB</code> 的性能比 <code>MyISAM</code> 更强大，随着 CPU 核数的增加，<code>InnoDB</code> 的读写能力呈线性增长。</li>
<li>数据缓存策略和机制实现不同。<code>InnoDB</code> 使用缓冲池(<code>Buffer Pool</code>)缓存数据页和索引页，<code>MyISAM</code> 使用键缓存(<code>Key Cache</code>)仅缓存索引页而不缓存数据页。</li>
</ul>
<h3 id="MySQL索引✅"><a href="#MySQL索引✅" class="headerlink" title="MySQL索引✅"></a>MySQL索引✅</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有： B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 <code>Innodb</code> 还是 <code>MyIsam</code>，都使用了 <strong>B+树</strong>作为索引结构。</p>
<p><strong>优点</strong></p>
<ul>
<li>大大加快数据的检索速度(大大减少检索的数据量)， 减少 IO 次数，这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<h3 id="索引底层数据类型选型"><a href="#索引底层数据类型选型" class="headerlink" title="索引底层数据类型选型"></a>索引底层数据类型选型</h3><ol>
<li><p><code>Hash</code>索引<br><code>InnoDB</code> 存储引擎不直接支持常规的哈希索引，但存在一种特殊的“自适应哈希索引”(<code>Adaptive Hash Index</code>)，结合了哈希索引和 B+ 树索引的优点，自适应哈希索引的每个哈希桶实际上是一个小型的 <code>B+Tree</code> 结构(不是传统的链表+红黑树)，这个 <code>B+Tree</code> 结构可以存储多个键值对，而不仅仅是一个键。<code>Hash</code> 索引不支持顺序和范围查询，因此 MySQL 没有使用其作为索引的数据结构。</p>
</li>
<li><p>二叉查找树<br>二叉查找树中，左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，左右子树也分别为二叉查找树。<br>当二叉查找树是平衡的时候(每个节点左右子树深度相差不超过 1 )，查询的时间复杂度为 <code>O(log2(N))</code>，具有比较高的效率。但其在最坏情况下(有序插入数据)会退化成线性链表，查询效率会降低到 <code>O(N)</code>。二叉查找树的性能非常依赖于它的平衡程度，不适合作为数据库索引。</p>
</li>
<li><p>AVL树<br>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。在使用 AVL 树时，每个树节点仅存储一个数据，每次磁盘 IO 只能读取一个节点的数据，如果要查询的数据在多个节点上，就需要进行多次磁盘 IO。磁盘 IO 是一项耗时的操作，在设计数据库索引时，优先需要考虑如何最大限度地减少磁盘 IO 操作的次数。因此，实际应用中 AVL 树并不常用作数据库索引。</p>
</li>
<li><p>红黑树<br>红黑树并不追求严格的平衡，而是大致的平衡。因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，导致树的高度较高，这可能会导致<strong>一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因</strong>。红黑树在插入和删除节点时只需进行 <code>O(1)</code> 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 <code>O(logn)</code> 次数的旋转操作，其插入和删除操作效率大大提高。</p>
</li>
<li><p>B树&amp;B+树<br>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced (平衡)的意思。<br>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。<br><strong>B树&amp;B+树区别</strong></p>
</li>
</ol>
<ul>
<li>B 树的所有节点既存放键(<code>key</code>) 也存放数据(<code>data</code>)，而 B+树只有叶子节点存放 <code>key</code> 和 <code>data</code>，其他内节点只存放 <code>key</code>。</li>
<li>B 树的叶子节点都是独立的;</li>
<li>B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<p>综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<h3 id="MyISAM-InnoDB索引区别"><a href="#MyISAM-InnoDB索引区别" class="headerlink" title="MyISAM&#x2F;InnoDB索引区别"></a>MyISAM&#x2F;InnoDB索引区别</h3><p><code>MyISAM</code> 引擎和 <code>InnoDB</code> 引擎都是使用 <code>B+Tree</code> 作为索引结构，但实现方式不太一样：</p>
<ul>
<li><code>MyISAM</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是数据记录的地址。在索引检索的时候，首先按照 <code>B+Tree</code> 搜索算法搜索索引，如果指定的 <code>Key</code> 存在，则取出其 <code>data</code> 域的值，然后以 <code>data</code> 域的值为地址读取相应的数据记录。这被称为“非聚簇索引(非聚集索引)”。</li>
<li><code>InnoDB</code> 引擎中，<code>B+Tree</code> 叶节点的 <code>data</code> 域存放的是完整的数据记录。这个数据记录其实就是数据表的主键索引，因此 <code>InnoDB</code> 表数据文件本身就是主索引。这被称为“聚簇索引(聚集索引)”。</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>按照数据结构维度划分：</p>
<ul>
<li><code>BTree</code> 索引：MySQL 里默认和最常用的索引类型。</li>
<li>哈希索引：类似键值对的形式，一次即可定位。</li>
</ul>
<p>按照底层存储方式角度划分：</p>
<ul>
<li>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>
<li>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。<code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>
</ul>
<p>按照应用维度划分：</p>
<ul>
<li>主键索引：加速查询 + 列值唯一(不可以有 <code>NULL</code>)+ 表中只有一个。</li>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一(可以有 <code>NULL</code>)。</li>
<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li>
</ul>
<p>MySQL 8.x 中实现的索引新特性：</p>
<ul>
<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏(包括显式设置或隐式设置)。</li>
<li>降序索引：之前的版本就支持通过 <code>DESC</code> 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引，且不再对 <code>GROUP BY</code> 语句进行隐式排序。</li>
<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>
</ul>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>数据表的主键列使用的就是主键索引(主键索引的 <code>data</code> 域值是完整的数据行)。 一张数据表有只能有一个主键，并且主键不能为 <code>null</code>，不能重复。</p>
<p>在 MySQL 的 <code>InnoDB</code> 的表中，当没有显示的指定表的主键时，<code>InnoDB</code> 会自动先检查表中是否有唯一索引且不允许存在 <code>null</code> 值的字段，如果有，则选择该字段为默认的主键，否则 <code>InnoDB</code> 将会自动创建一个 6Byte 的自增主键。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引的叶子节点存储的数据是主键的值(其实存储的是索引列的值和主键值)，也就是说，通过二级索引可以定位主键的位置，二级索引又称为辅助索引&#x2F;非主键索引。</p>
<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>
<ul>
<li>唯一索引(<code>Unique Key</code>)：唯一索引的属性列不能出现重复的数据，但是允许数据为 <code>NULL</code>，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li>普通索引(<code>Index</code>)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 <code>NULL</code>。</li>
<li>前缀索引(<code>Prefix</code>)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>
<li>全文索引(<code>Full Text</code>)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 <code>MYISAM</code> 引擎支持全文索引，5.6 之后 <code>InnoDB</code> 也支持了全文索引。</li>
</ul>
<h3 id="聚簇索引-非聚簇索引"><a href="#聚簇索引-非聚簇索引" class="headerlink" title="聚簇索引&#x2F;非聚簇索引"></a>聚簇索引&#x2F;非聚簇索引</h3><p>聚簇索引(聚集索引)：索引结构和数据一起存放的索引，<code>InnoDB</code> 中的主键索引就属于聚簇索引。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>
<li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>依赖于有序的数据：因为 B+树是多路平衡树，如果插入的索引无序，需要在插入时排序，像字符串&#x2F;UUID这类又长又难比较的数据，插入&#x2F;查找的速度较慢。</li>
<li>更新代价大：对索引列数据修改时，对应的索引也将会被修改，且聚簇索引的叶子节点还存放数据，修改代价较大，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<p>非聚簇索引(非聚集索引)：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 <code>MyISAM</code> 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>
<p><strong>优点</strong>：<br>更新代价比聚簇索引要小(非聚簇索引的叶子节点不存放数据)。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>依赖于有序的数据</li>
<li>可能会二次查询(回表)：非聚簇索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>在 <code>InnoDB</code> 存储引擎中，非主键索引的叶子节点包含的是主键的值。当使用非主键索引进行查询时，数据库会先找到对应的主键值，然后再通过主键索引来定位和检索完整的行数据。这个过程被称为“回表”。</p>
<h3 id="覆盖索引-联合索引"><a href="#覆盖索引-联合索引" class="headerlink" title="覆盖索引&#x2F;联合索引"></a>覆盖索引&#x2F;联合索引</h3><ul>
<li>覆盖索引：一个索引包含(或者说覆盖)所有需要查询的字段的值。当一个查询语句只需要从索引中就能够取得所需的数据，而不需要回表查询，这种情况就称为覆盖索引。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>
</ul>
<h3 id="联合索引最左前缀匹配原则"><a href="#联合索引最左前缀匹配原则" class="headerlink" title="联合索引最左前缀匹配原则"></a>联合索引最左前缀匹配原则</h3><p>在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用最左侧索引来过滤数据，这样可以提高查询效率。在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<h3 id="索引下推ICP"><a href="#索引下推ICP" class="headerlink" title="索引下推ICP"></a>索引下推ICP</h3><p>索引下推(<code>Index Condition Pushdown,ICP</code>) 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>语句中的判断条件，直接过滤掉不满足条件的记录，从而<strong>减少回表次数，提高查询效率，减少存储引擎层和 Server 层的数据传输量</strong>。</p>
<p><strong>原理</strong><br><img src="/../image/Database-Interview/13526879-3037b144ed09eb88.png" alt="MySQL基础架构图"></p>
<p>MySQL 分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取。</p>
<p>索引下推的下推其实就是指将部分上层(Server 层)负责的事情，交给下层(存储引擎层)去处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;431200&#x27;</span> <span class="keyword">AND</span> <span class="keyword">MONTH</span>(birthdate) <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有索引下推，存储引擎层<code>zipcode</code> 字段利用索引可以快速定位到 <code>zipcode = &#39;431200&#39;</code>的用户的主键ID，然后二次回表获取完整用户数据；存储引擎层把获取到的完整用户数据全交给 Server 层，Server 层根据<code>MONTH(birthdate) = 3</code>这一条件再进一步做筛选。</li>
<li>有索引下推，存储引擎层根据 <code>zipcode</code> 索引字段找到所有 <code>zipcode = &#39;431200&#39;</code> 的用户，然后直接判断 <code>MONTH(birthdate) = 3</code>，筛选出符合条件的主键ID；然后二次回表查询，根据符合条件的主键ID去获取完整的用户数据；最后把符合条件用户数据全部交给 Server 层。</li>
</ul>
<p>索引下推适用于 <code>InnoDB</code> 引擎和 <code>MyISAM</code> 引擎，且存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</p>
<h3 id="MySQL查询缓存✅"><a href="#MySQL查询缓存✅" class="headerlink" title="MySQL查询缓存✅"></a>MySQL查询缓存✅</h3><p>执行查询语句时，MySQL 会先检查查询缓存，若之前执行过相同的查询，且查询缓存中有这个查询的结果，那么 MySQL 就会直接返回查询缓存中的结果，而不会再去执行查询。MySQL 8.0 版本后移除，因为这个功能不太实用</p>
<p>查询缓存不命中的情况：</p>
<ul>
<li>两个查询在任何字符上的不同都会导致缓存不命中。</li>
<li>若查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>
<li>缓存建立之后，查询缓存系统会跟踪查询中涉及的每张表，若这些表(数据或结构)发生变化，那么和这张表相关的所有缓存数据都将失效。</li>
</ul>
<p>缓存虽然能够提升数据库的查询性能，但也带来了额外的开销，每次查询后都要做一次缓存操作，失效后要销毁。</p>
<h3 id="MySQL三大日志✅"><a href="#MySQL三大日志✅" class="headerlink" title="MySQL三大日志✅"></a>MySQL三大日志✅</h3><p>MySQL比较重要的日志有二进制日志 <code>binlog</code>(归档日志)和事务日志 <code>redo log</code>(重做日志)和 <code>undo log</code>(回滚日志)。</p>
<p>MySQL <code>InnoDB</code> 引擎使用 <code>redo log</code>(重做日志) 保证事务的持久性，使用 <code>undo log</code>(回滚日志) 来保证事务的原子性。MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code>(重做日志)是 <code>InnoDB</code> 存储引擎独有的物理日志，记录内容是“在某个数据页上做了什么修改”，它让 MySQL 拥有了崩溃恢复能力。若 MySQL 实例挂了或宕机了，重启时，<code>InnoDB</code> 存储引擎会使用 <code>redo log</code> 恢复数据，保证数据的持久性与完整性。</p>
<p>查询或更新一条数据时，会从硬盘把一页数据加载出来，存入 <code>Buffer Pool</code>中，后续查找先查找<code>Buffer Pool</code>，如果没有找到再去硬盘加载。更新数据的时候，若 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存(<code>redo log buffer</code>)里，接着刷盘到 <code>redo log</code> 文件里。</p>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p><code>InnoDB</code> 在多种情况下将 <code>redo log</code> 刷到磁盘上，以保证数据的持久性和一致性。</p>
<ul>
<li>事务提交：当事务提交时，<code>redo log buffer</code> 里的 <code>redo log</code> 会被刷新到磁盘的 <code>redo log</code> 文件里。</li>
<li><code>redo log buffer</code> 空间不足时：<code>redo log buffer</code> 中缓存的 <code>redo log</code> 已占了 <code>redo log buffer</code> 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>
<li><code>Checkpoint</code>(检查点)：<code>InnoDB</code> 定期会执行检查点操作，将内存中的脏数据(已修改但尚未写入磁盘的数据)刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>
<li>正常关闭服务器：MySQL 关闭的时候，<code>redo log</code> 都会刷入到磁盘里去。</li>
<li>后台线程：<code>InnoDB</code> 有一个后台线程，每隔1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</li>
</ul>
<h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p><code>innodb_flush_log_at_trx_commit</code>参数设置三种刷盘策略：</p>
<ul>
<li>0，每次事务提交时不进行刷盘操作。这种方式性能最高，也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。</li>
<li>1，每次事务提交时都将进行刷盘操作。这种方式性能最低，也最安全，因为只要事务提交成功，<code>redo log</code> 记录就一定在磁盘里，无论MySQL 挂了或宕机都不会有任何数据丢失。</li>
<li>2，每次事务提交时都只把 <code>log buffer</code> 里的 <code>redo log</code> 内容写入 <code>page cache</code>(文件系统缓存)。<code>page cache</code> 是专门用来缓存文件的，这里被缓存的文件就是 <code>redo log</code> 文件。这种方式的性能和安全性都介于前两者中间。如果 MySQL 挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</li>
</ul>
<p>默认策略为第二种。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志，且是顺序写。</p>
<p>MySQL 数据库的数据备份、主备、主主、主从都离不开 <code>binlog</code>，需要依靠 <code>binlog</code> 来同步数据，保证数据一致性。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p><code>binlog</code> 有三种记录格式：</p>
<ul>
<li><code>Statement</code>：记录的是 SQL 语句，如 <code>UPDATE t SET c=c+1 WHERE id=2</code>。<ul>
<li>同步数据时，会执行记录的SQL语句，比如获取系统时间、随机数等，会导致主从数据不一致。</li>
</ul>
</li>
<li><code>Row</code>：记录的是行数据，如 <code>id=2 c=2</code>。<ul>
<li>这里记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。比如上面问题，会记录具体系统时间、随机数等。</li>
</ul>
</li>
<li><code>Mixed</code>：记录的是上面两种的混合模式。<ul>
<li>MySQL 会判断这条SQL语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</li>
</ul>
</li>
</ul>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 <code>binlog</code> 文件中。一个事务的 <code>binlog</code> 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>通过 <code>write</code> 将<code>binlog cache</code>中的 <code>binlog</code>写入文件系统缓存(<code>page cache</code>)，然后调用 <code>fsync</code> 刷盘。</p>
<p><strong><code>write</code> 和 <code>fsync</code> 时机</strong> 由参数<code>sync_binlog</code>控制，默认是1。</p>
<ul>
<li>0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。<ul>
<li>虽然性能最高，但是机器宕机，<code>page cache</code>里面的 <code>binlog</code> 会丢失。</li>
</ul>
</li>
<li>1，每次提交事务都会执行<code>write</code>+<code>fsync</code>，和 <code>redo log</code> 日志刷盘流程一样。</li>
<li>N(&gt;1)，每次提交事务都会执行<code>write</code>，但是累计 <code>N</code>次事务后才执行 <code>fsync</code>。<ul>
<li>在出现 IO 瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。 但若机器宕机，会丢失最近<code>N</code>个事务的 <code>binlog</code> 日志。</li>
</ul>
</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p><code>redo log</code>(重做日志)让 <code>InnoDB</code> 存储引擎拥有了崩溃恢复能力。<code>binlog</code>(归档日志)保证了 MySQL 集群架构的数据一致性。</p>
<p><code>redo log</code> 与 <code>binlog</code> 的写入时机不一样，<code>redo log</code> 是事务执行过程中写入，<code>binlog</code> 是事务提交后写入。</p>
<p>写入机制不一样会导致日志不一致：<br>若某一事务(更新某一行的a值，从 0-&gt;1)执行过程中写完 <code>redo log</code> 日志后，<code>binlog</code> 日志写期间发生了异常，写入失败。此时使用<code>redo log</code>恢复的数据中，a值已经变为1，而<code>binlog</code>中记录的是a值为0，这样就导致了数据不一致。</p>
<p>为了解决数据不一致问题，<code>InnoDB</code> 存储引擎使用两阶段提交：将 <code>redo log</code> 的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>。</p>
<ul>
<li><code>prepare</code>：在事务执行过程中，先写入 <code>redo log</code>，但是不提交事务。</li>
<li><code>commit</code>：在事务提交后，再写入 <code>binlog</code>，然后提交<code>redo log</code>。</li>
</ul>
<p>使用两阶段提交后，写入 <code>binlog</code> 时发生异常也不会有影响。此时 MySQL 根据 <code>redo log</code> 日志恢复数据时，发现 <code>redo log</code> 还处于<code>prepare</code>阶段，并且没有对应 <code>binlog</code> 日志，就会回滚该事务。</p>
<p>如果<code>redo log</code> 在 <code>commit</code>阶段发生异常，虽然 <code>redo log</code> 处于<code>prepare</code>阶段，但是能通过事务id找到对应的 <code>binlog</code> 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code> 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 <code>DELETE</code> 语句，那 <code>undo log</code> 就会记录一条相对应的 <code>INSERT</code> 语句。每一个事务对数据的修改都会被记录到 <code>undo log</code> ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 <code>undo log</code> 将数据恢复到事务开始之前的状态。</p>
<p><code>undo log</code> 本身是会被删除清理的，例如 <code>INSERT</code> 操作，在事务提交之后就可以清除掉了；<code>UPDATE/DELETE</code> 操作在事务提交不会立即删除，会加入 <code>history list</code>，由后台线程 <code>purge</code> 进行清理。</p>
<p><code>undo log</code> 采用 <code>segment</code>(段)进行记录，事务开始时，需要为其分配一个 <code>rollback segment</code>。每个 <code>rollback segment</code> 有 1024 个 <code>undo log segment</code>(每个 <code>undo</code> 操作在记录的时候占用一个 <code>undo log segment</code>，多个有助于管理多个并发事务) 和 一个 <code>rollback segment header</code>(负责管理<code>rollback segment</code>)，<code>history list</code> 是<code>rollback segment header</code>的一部分，它的主要作用是记录所有已经提交但还没有被清理(<code>purge</code>)的事务的 <code>undo log</code>，<code>history list</code>列表使得 <code>purge</code> 线程能够找到并清理那些不再需要的 <code>undo log</code> 记录。</p>
<h3 id="MySQL事务✅"><a href="#MySQL事务✅" class="headerlink" title="MySQL事务✅"></a>MySQL事务✅</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul>
<li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>
<li>一致性(Consistency)：执行事务前后，数据保持一致。</li>
<li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性(Durability)：事务成功结束后，对数据库的修改是永久的，即使数据库发生故障也不应该丢失。</li>
</ul>
<blockquote>
<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>
</blockquote>
<h3 id="并发事务存在的问题"><a href="#并发事务存在的问题" class="headerlink" title="并发事务存在的问题"></a>并发事务存在的问题</h3><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取到了另一个事务未提交的数据，这个数据称为脏数据。</p>
<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>
<p>解决：</p>
<ul>
<li>设置事务隔离级别为 <code>Read Committed</code> 或更高。<code>Read Committed</code> 确保事务只能读取已经提交的数据，从而避免脏读。</li>
</ul>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>两个事务同时对同一数据进行修改，其中一个事务的修改被另一个事务覆盖，导致一个事务的修改被丢失。</p>
<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<p>解决：</p>
<ul>
<li>乐观锁(Optimistic Locking)： 在提交时检查数据的版本号或时间戳，如果版本号或时间戳已变化，则说明数据已经被修改过，此时事务需要重新读取数据并进行处理。</li>
<li>悲观锁(Pessimistic Locking)： 在读取数据时对数据加锁，直到事务结束才能释放锁，从而避免其他事务同时修改数据。</li>
</ul>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务内多次读取同一数据，由于另一个事务的修改，导致多次读取的数据不一致。</p>
<p>一个事务在读取某个数据后的某个时间，另外一个事务对这个数据进行了修改，那么第一个事务再次读取这个数据时，数据已经发生了变化，导致多次读取的数据不一致，这就是不可重复读。</p>
<p>解决：</p>
<ul>
<li>执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>
<li>设置事务隔离级别为 Repeatable Read 或更高。Repeatable Read 确保事务内多次读取的数据一致，避免不可重复读。</li>
</ul>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>一个事务读取到了另一个事务插入的数据，导致多次查询的结果不一致。</p>
<p>一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>解决：</p>
<ul>
<li>执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>
<li>事务隔离级别： 设置事务隔离级别为 Serializable。Serializable 级别确保事务完全隔离，避免幻读。</li>
</ul>
<h3 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h3><ul>
<li>不可重复读：多次读取同一数据，发现数据不一致。</li>
<li>幻读：多次执行同一条查询语句，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p>
<ul>
<li>解决不可重复读：执行 <code>DELETE</code> 和 <code>UPDATE</code> 操作的时候，可以直接对记录加锁，保证事务安全。</li>
<li>解决幻读：执行 <code>INDERT</code> 操作的时候，由于记录锁(<code>Record Lock</code>)只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁(<code>Gap Lock</code>)。也就是说执行 <code>INDERT</code> 操作的时候需要依赖 <code>Next-Key Lock(Record Lock+Gap Lock)</code> 进行加锁来保证不出现幻读。</li>
</ul>
<h3 id="并发事务的控制方式有哪些"><a href="#并发事务的控制方式有哪些" class="headerlink" title="并发事务的控制方式有哪些"></a>并发事务的控制方式有哪些</h3><p>MySQL 中并发事务的控制方式无非就两种：锁 和 <code>MVCC</code>。锁可以看作是悲观控制的模式，多版本并发控制(<code>MVCC，Multiversion concurrency control</code>)可以看作是乐观控制的模式。</p>
<ul>
<li>锁：<ul>
<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>
<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>
</ul>
</li>
<li><code>MVCC</code> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</li>
</ul>
<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。根据根据锁粒度的不同，又被分为 表级锁(<code>table-level locking</code>) 和 行级锁(<code>row-level locking</code>) 。<code>InnoDB</code> 默认为行级锁，也支持表级锁，所以并发性能比较高。</p>
<blockquote>
<p>注意：不论是表级锁还是行级锁，都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)这两类。</p>
</blockquote>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是：隐藏字段、<code>read view</code>、<code>undo log</code>。</p>
<ul>
<li><code>undo log</code>：<code>undo log</code> 用于记录某行数据的多个版本的数据。</li>
<li><code>read view</code> 和 隐藏字段： 用来判断当前版本数据的可见性。</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><code>READ-UNCOMMITTED</code>(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><code>READ-COMMITTED</code>(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><code>REPEATABLE-READ</code>(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><code>SERIALIZABLE</code>(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th align="center">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">基于 MVCC&#x2F;锁</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">基于 MVCC&#x2F;锁(当前读情况下需要使用加锁读来保证不会出现幻读)</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">基于 锁</td>
</tr>
</tbody></table>
<p>MySQL默认隔离级别是 <code>REPEATABLE-READ</code>。</p>
<p><code>InnoDB</code> 实现的 <code>REPEATABLE-READ</code> 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li>快照读：由 <code>MVCC</code> 机制来保证不出现幻读。</li>
<li>当前读：使用 <code>Next-Key Lock</code> 进行加锁来保证不出现幻读，<code>Next-Key Lock</code> 是行锁(<code>Record Lock</code>)和间隙锁(<code>Gap Lock</code>)的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li>
</ul>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code> ，不过 <code>InnoDB</code> 存储引擎默认使用 <code>REPEATABLE-READ</code>，这并不会有任何性能损失。<code>InnoDB</code> 存储引擎在分布式事务的情况下一般会用到 <code>SERIALIZABLE</code> 隔离级别。</p>
<h3 id="MVCC✅"><a href="#MVCC✅" class="headerlink" title="MVCC✅"></a>MVCC✅</h3><p>多版本并发控制(<code>Multi-Version Concurrency Control, MVCC</code>) 用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，<code>MVCC</code> 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>
<ol>
<li><p>读操作(<code>SELECT</code>)<br>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体情况如下：</p>
<ul>
<li>对读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li>
<li>如果数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li>
<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li>
</ul>
</li>
<li><p>写操作(<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>)<br>当事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体情况如下：</p>
<ul>
<li>对于写操作，事务为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>
<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li>
<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li>
</ul>
</li>
<li><p>事务提交和回滚</p>
<ul>
<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>
<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>
</ul>
</li>
<li><p>版本回收<br>为了防止数据库中的版本无限增长，<code>MVCC</code> 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p>
</li>
</ol>
<p><code>MVCC</code> 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读的实现，通常是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。</p>
<p><code>InnoDB</code>中，<code>MVCC</code>就是对一致性非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，则读取操作不会等待行锁释放，而是会读取行的一个快照数据，这种读取历史数据的方式叫快照读(<code>snapshot read</code>)。</p>
<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>SELECT</code> 语句(不包括 <code>SELECT ... lock in share mode</code> ，<code>SELECT ... FOR UPDATE</code>)则会使用一致性非锁定读(<code>MVCC</code>)。<code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p>
<h3 id="锁定读-当前读"><a href="#锁定读-当前读" class="headerlink" title="锁定读&#x2F;当前读"></a>锁定读&#x2F;当前读</h3><p>在锁定读下，读取的是数据的最新版本。下面语句都是锁定读&#x2F;当前读，会对读取到的记录加锁。</p>
<ul>
<li><code>SELECT ... lock in share mode</code>： 对读取到记录加共享锁，其他事务也可以加共享锁，加排他锁会阻塞。</li>
<li><code>SELECT ... FOR UPDATE</code>： 对读取到记录加排他锁，其他事务不能任何锁。</li>
<li><code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作：对读取到记录加排他锁，其他事务不能任何锁。</li>
</ul>
<p>当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以<code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据。</p>
<h3 id="InnoDB的MVCC实现"><a href="#InnoDB的MVCC实现" class="headerlink" title="InnoDB的MVCC实现"></a>InnoDB的MVCC实现</h3><p><code>MVCC</code> 的实现依赖于：隐藏字段、<code>Read View</code>、<code>undo log</code>。在内部实现中，<code>InnoDB</code> 通过数据行隐藏字段的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p>
<p><strong>隐藏字段</strong><br>InnoDB为每行数据添加了三个隐藏字段：</p>
<ul>
<li><code>DB_TRX_ID</code>：表示最后一次更新或插入操作的事务ID。<code>DELETE</code>操作也被视为更新。</li>
<li><code>DB_ROLL_PTR</code>：指向该行<code>undo log</code> 日志的指针。</li>
<li><code>DB_ROW_ID</code>：表示行的物理地址。若没有设置主键且该表没有唯一非空索引，则会使用 <code>DB_ROW_ID</code> 作为聚簇索引。</li>
</ul>
<p><strong>Read View</strong><br><code>Read View</code> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务” 的 ID。</p>
<ul>
<li><code>m_low_limit_id</code>(低限事务ID)：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>(上限事务ID)：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>(活跃事务列表)：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务(正在内存中)</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p><strong>undo log</strong><br>其有两个作用：</p>
<ul>
<li>事务回滚时用于将数据恢复到修改前的样子</li>
<li><code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前版本的快照数据，以此实现非锁定读</li>
</ul>
<h3 id="RC和RR隔离级别下MVCC的差异"><a href="#RC和RR隔离级别下MVCC的差异" class="headerlink" title="RC和RR隔离级别下MVCC的差异"></a>RC和RR隔离级别下MVCC的差异</h3><ul>
<li><code>Read Committed</code>：<code>MVCC</code> 会在每次<code>SELECT</code>读取数据时创建一个新的 <code>Read View</code>(<code>m_ids</code>列表)，这样可以确保读取到的数据是最新的。但是由于每次读取都需要创建新的 <code>Read View</code>，因此会导致一些不可重复读问题。</li>
<li><code>Repeatable Read</code>：<code>MVCC</code> 会在事务开始后第一次 <code>SELECT</code>创建一个 <code>Read View</code>，并在事务结束时销毁。这样可以确保事务内的读取操作都是一致的，这样解决了不可重复读，但是可能会导致一些幻读问题。</li>
</ul>
<h3 id="RR隔离级别下的MVCC如何解决幻读"><a href="#RR隔离级别下的MVCC如何解决幻读" class="headerlink" title="RR隔离级别下的MVCC如何解决幻读"></a>RR隔离级别下的MVCC如何解决幻读</h3><p><code>MVCC</code>+<code>Next-key-Lock</code> 防止幻读</p>
<ul>
<li>执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>
<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>
</ul>
</li>
<li>执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等当前读<ul>
<li>当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>
</ul>
</li>
</ul>
<h3 id="MySQL锁✅"><a href="#MySQL锁✅" class="headerlink" title="MySQL锁✅"></a>MySQL锁✅</h3><h3 id="表级锁-行级锁区别"><a href="#表级锁-行级锁区别" class="headerlink" title="表级锁&#x2F;行级锁区别"></a>表级锁&#x2F;行级锁区别</h3><ul>
<li><p>表级锁：MySQL 中锁定粒度最大的一种锁(全局锁除外)，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，<code>MyISAM</code> 和 <code>InnoDB</code> 引擎都支持表级锁。</p>
</li>
<li><p>行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</p>
</li>
<li><p><code>MyISAM</code> 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p>
</li>
<li><p><code>InnoDB</code> 不光支持表级锁和行级锁(默认)，仅对一行记录上锁，所以 <code>InnoDB</code>的并发性能更高</p>
</li>
</ul>
<h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><ul>
<li>记录锁(<code>Record Lock</code>)：也被称为记录锁，属于单个行记录上的锁。</li>
<li>间隙锁(<code>Gap Lock</code>)：锁定一个范围，不包括记录本身。</li>
<li>临键锁(<code>Next-Key Lock</code>)：<code>Record Lock</code>+<code>Gap Lock</code>，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<h3 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁&#x2F;排他锁"></a>共享锁&#x2F;排他锁</h3><p>表级锁和行级锁都存在共享锁(<code>Share Lock</code>，S 锁)和排他锁(<code>Exclusive Lock</code>，X 锁)两类。</p>
<ul>
<li>共享锁(S 锁)：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取(锁兼容)。</li>
<li>排他锁(X 锁)：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁(锁不兼容)。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。 </p>
<p>由于有<code>MVCC</code>机制，对于一般的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加任何锁。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁是为了解决行级锁的问题，当一个事务要对某一行加排他锁时，需要先对整张表加一个意向排他锁，这样可以避免多个事务同时对一行数据加排他锁。</p>
<p>意向锁是表级锁，有两种：</p>
<ul>
<li>意向共享锁(<code>Intention Shared Lock</code>，IS 锁)：事务有意向对表中的某些记录加共享锁(S 锁)，加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁(<code>Intention Exclusive Lock</code>，IX 锁)：事务有意向对表中的某些记录加排他锁(X 锁)，加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p>意向锁由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，<code>InnoDB</code> 会先获取该数据行所在在数据表的对应意向锁。</p>
<p>意向锁之间是互相兼容的。意向共享锁与表级共享锁兼容，和表级排他锁是不兼容的。意向排他锁与表级共享锁和表级排他锁都是不兼容的。</p>
<h3 id="当前读-快照读区别"><a href="#当前读-快照读区别" class="headerlink" title="当前读&#x2F;快照读区别"></a>当前读&#x2F;快照读区别</h3><ul>
<li>当前读(一致性锁定读)：执行 <code>SELECT...FOR UPDATE/lock in share mode</code>、<code>INDERT</code>、<code>UPDATE</code>、<code>DELETE</code><ul>
<li>当前读下， 就是给行记录加 X 锁或 S 锁，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据，这样就不会发生幻读。</li>
</ul>
</li>
<li>快照读(一致性非锁定读)：执行普通 <code>SELECT</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据<ul>
<li>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</li>
</ul>
</li>
</ul>
<h3 id="MySQL性能优化✅"><a href="#MySQL性能优化✅" class="headerlink" title="MySQL性能优化✅"></a>MySQL性能优化✅</h3><h3 id="可以用MySQL存储文件吗？"><a href="#可以用MySQL存储文件吗？" class="headerlink" title="可以用MySQL存储文件吗？"></a>可以用MySQL存储文件吗？</h3><p>可以直接存储文件对应的二进制数据即可。不过不建议在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。可以使用云服务厂商提供的开箱即用的文件存储服务，如阿里云的OSS、腾讯云的COS等。然后在数据库中存储文件的 URL 地址。</p>
<h3 id="MySQL如何存储IP地址"><a href="#MySQL如何存储IP地址" class="headerlink" title="MySQL如何存储IP地址"></a>MySQL如何存储IP地址</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。MySQL提供了两个方法来处理 ip 地址：</p>
<ul>
<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>
<li><code>INET_NTOA()</code>：把整型的 ip 转为地址</li>
</ul>
<p>存储数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，取出数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>
<h3 id="如何分析SQL性能"><a href="#如何分析SQL性能" class="headerlink" title="如何分析SQL性能"></a>如何分析SQL性能</h3><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 执行计划，该命令并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<h3 id="MySQL执行计划✅"><a href="#MySQL执行计划✅" class="headerlink" title="MySQL执行计划✅"></a>MySQL执行计划✅</h3><p>执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept_emp <span class="keyword">WHERE</span> emp_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no)<span class="operator">&gt;</span><span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys   <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">PRIMARY</span>,dept_no <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">16</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>各列含义如下：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody></table>
<p><strong>type(重要)</strong><br>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code><br>常见的几种类型具体含义如下：</p>
<ul>
<li><code>system</code>：如果表使用的引擎对于表行数统计是精确的(如：<code>MyISAM</code>)，且表中只有一行记录的情况下，访问方法是 <code>system</code>，是 <code>const</code> 的一种特例。</li>
<li><code>const</code>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
<li><code>eq_ref</code>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 <code>system</code> 与 <code>const</code> 之外最好的 <code>JOIN</code> 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>
<li><code>ref</code>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>
<li><code>index_merge</code>：当查询条件使用了多个索引时，表示开启了 <code>Index Merge</code> 优化，此时执行计划中的 <code>key</code> 列列出了使用到的索引。</li>
<li><code>range</code>：对索引列进行范围查询，执行计划中的 <code>key</code> 列表示哪个索引被使用了。</li>
<li><code>index</code>：查询遍历了整棵索引树，与 <code>ALL</code> 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>
<li><code>ALL</code>：全表扫描。</li>
</ul>
<p><strong>key(重要)</strong><br><code>key</code> 列表示 MySQL 实际使用到的索引。如果为 <code>NULL</code>，则表示未用到索引。</p>
<p><strong>Extra(重要)</strong></p>
<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>
<ul>
<li><code>Using filesort</code>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>
<li><code>Using temporary</code>：MySQL 需要创建临时表来存储查询的结果，常见于 <code>ORDER BY</code> 和 <code>GROUP BY</code>。</li>
<li><code>Using index</code>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>
<li><code>Using index condition</code>：表示查询优化器选择使用了索引条件下推这个特性。</li>
<li><code>Using where</code>：表明查询使用了 <code>WHERE</code> 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>
<li><code>Using join buffer (Block Nested Loop)</code>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 <code>join buffer</code> 中，再遍历被驱动表与驱动表进行查询。</li>
</ul>
<p>当 <code>Extra</code> 列包含 <code>Using filesort</code> 或 <code>Using temporary</code> 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>
<h3 id="MySQL读写分离✅"><a href="#MySQL读写分离✅" class="headerlink" title="MySQL读写分离✅"></a>MySQL读写分离✅</h3><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<p>一般情况下，会选择一主多从，一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<h3 id="如何实现读写分离"><a href="#如何实现读写分离" class="headerlink" title="如何实现读写分离"></a>如何实现读写分离</h3><ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，即主从复制。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<p>基于项目层面有两种方案：</p>
<ol>
<li>代理方式<br>可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 MySQL Router(官方， MySQL Proxy 的替代方案)、Atlas(基于 MySQL Proxy)、MaxScale、MyCat。</li>
<li>组件方式<br>可以通过引入第三方组件来实现读写分离，例如使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</li>
</ol>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>MySQL 主从复制是依赖于 <code>binlog</code> 。另外，常见的一些同步 MySQL 数据到其他数据源的工具(比如 <code>canal</code>)的底层一般也是依赖 <code>binlog</code>。具体如下：</p>
<ol>
<li>主库将数据库中数据的变化写入到 <code>binlog</code></li>
<li>从库连接主库</li>
<li>从库创建一个 I&#x2F;O 线程向主库请求更新的 <code>binlog</code></li>
<li>主库创建一个 <code>binlog dump</code> 线程来发送 <code>binlog</code>，从库中的 I&#x2F;O 线程负责接收</li>
<li>从库的 I&#x2F;O 线程将接收的 <code>binlog</code> 写入到中继日志<code>relay log</code> 中。</li>
<li>从库的 SQL 线程读取中继日志<code>relay log</code> 同步数据到本地(也就是再执行一遍 SQL )。</li>
</ol>
<blockquote>
<p><code>binlog</code>主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)<br><code>relay log</code> 是中继日志，是主从复制过程中关键的一环，负责在从库上中转和存储从主库获取的 binlog 数据，确保从库数据与主库数据一致。</p>
</blockquote>
<h3 id="如何避免主从延迟"><a href="#如何避免主从延迟" class="headerlink" title="如何避免主从延迟"></a>如何避免主从延迟</h3><p>主从同步延迟：写完主库之后，主库的数据同步到从库需要时间，这个时间差就导致了主库和从库的数据不一致性问题。</p>
<ul>
<li>强制将读请求路由到主库处理，这样可以保证数据的一致性，但是会增加主库的压力。</li>
<li>延迟读取，即从库的数据延迟一段时间后再读取，这样可以保证数据的一致性，但是会牺牲数据的实时性。比如支付，支付成功后，跳转到一个支付成功的页面，当点击返回之后才返回自己的账户。</li>
</ul>
<h3 id="什么情况下会出现主从延迟"><a href="#什么情况下会出现主从延迟" class="headerlink" title="什么情况下会出现主从延迟"></a>什么情况下会出现主从延迟</h3><p>主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：</p>
<ul>
<li>从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度跟不上主库写入 <code>binlog</code> 的速度，导致从库 <code>relay log</code> 的数据滞后于主库 <code>binlog</code> 的数据；</li>
<li>从库 SQL 线程执行 <code>relay log</code> 的速度跟不上从库 I&#x2F;O 线程接收 <code>binlog</code> 的速度，导致从库的数据滞后于从库 <code>relay log</code> 的数据。</li>
</ul>
<p>下面是一些可能导致主从延迟的原因及解决方案：</p>
<ol>
<li>从库机器性能比主库差：从库接收 <code>binlog</code> 写入 <code>relay log</code> 以及执行 SQL 语句的速度会比较慢，进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。 </li>
<li>从库处理的读请求过多：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率。解决方法是引入缓存(推荐)、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 <code>binlog</code> 接入到 <code>Hadoop</code>、<code>Elasticsearch</code> 等系统中。</li>
<li>大事务：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。</li>
<li>从库太多：主库需要将 <code>binlog</code> 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。</li>
<li>网络延迟：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 <code>binlog</code> 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。</li>
<li>单线程复制：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了多线程复制，MySQL 5.7 还进一步完善了多线程复制。</li>
<li>复制模式：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟(还是有一定程度的延迟)。MySQL 5.5 开始，MySQL 以插件的形式支持 <code>semi-sync</code> 半同步复制。并且，MySQL 5.7 引入了 增强半同步复制。</li>
</ol>
<h3 id="MySQL分库分表✅"><a href="#MySQL分库分表✅" class="headerlink" title="MySQL分库分表✅"></a>MySQL分库分表✅</h3><p>分库分表是指将一个数据库中的数据分散到多个数据库或多个表中，以减轻单个数据库或表的压力，提高数据库的性能。<br><strong>分库</strong><br>分库就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<ul>
<li>垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。<ul>
<li>如：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</li>
</ul>
</li>
<li>水平分库：把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。<ul>
<li>订单表数据量太大，对订单表进行了水平切分，第0-1000万订单数据存储在订单库1中，1000万-2000万订单数据存储在订单库2中，然后将切分后的 2 张订单表分别放在两个不同的数据库。</li>
</ul>
</li>
</ul>
<p><strong>分表</strong><br>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<ul>
<li>垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表。</li>
<li>水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</li>
</ul>
<h3 id="什么情况下需要分库分表"><a href="#什么情况下需要分库分表" class="headerlink" title="什么情况下需要分库分表"></a>什么情况下需要分库分表</h3><ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>
<li>应用的并发量太大(应该优先考虑其他性能优化方法，而非分库分表)。</li>
</ul>
<h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>
<p>常见的分片算法有：</p>
<ul>
<li>范围分片：按照特定的范围区间(比如时间区间、ID 区间)来分配数据，比如 将 id 为 1<del>299999 的记录分到第一个表， 300000</del>599999 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景(数据未被分散，容易出现热点数据的问题)。</li>
<li>哈希分片：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩(例如新增一个表或者库)不友好。</li>
<li>地理位置分片：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置(如城市、地域)来分配数据。</li>
<li>一致性哈希分片：将哈希空间组织成一个环形结构，将分片键和节点(数据库或表)都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</li>
</ul>
<h3 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h3><p>分片键是指用来决定数据分片的字段，可以是单个字段，也可以是多个字段的组合。分片键的选择非常重要，不同的分片键会导致数据分布不均匀，进而导致热点数据的问题。</p>
<h3 id="分库分表会带来什么问题"><a href="#分库分表会带来什么问题" class="headerlink" title="分库分表会带来什么问题"></a>分库分表会带来什么问题</h3><ul>
<li>事务问题：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求。这时要引入分布式事务。</li>
<li>跨库聚合查询问题：分库分表会导致常规聚合查询操作，如 <code>GROUP BY</code>，<code>ORDER BY</code> 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。</li>
<li>数据迁移问题：当数据量过大时，需要对数据进行迁移，这个过程可能会导致数据不一致。</li>
<li>。。。</li>
</ul>
<h3 id="分库分表中数据如何迁移"><a href="#分库分表中数据如何迁移" class="headerlink" title="分库分表中数据如何迁移"></a>分库分表中数据如何迁移</h3><ul>
<li>停机迁移：停机后，写一个脚本将老库的数据都同步到新库中。</li>
<li>双写方案：在写入数据的时候，同时写入到新库中，然后再定时将老库的数据同步到新库中。</li>
</ul>
<h3 id="MySQL数据冷热分离✅"><a href="#MySQL数据冷热分离✅" class="headerlink" title="MySQL数据冷热分离✅"></a>MySQL数据冷热分离✅</h3><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点：热数据的查询性能得到优化(用户的绝大部分操作体验会更好)、节约成本(可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上)</li>
<li>缺点：系统复杂性和风险增加(需要分离冷热数据，数据错误的风险增加)、统计效率低(统计的时候可能需要用到冷库的数据)。</li>
</ul>
<h3 id="冷数据和热数据"><a href="#冷数据和热数据" class="headerlink" title="冷数据和热数据"></a>冷数据和热数据</h3><ul>
<li>热数据是指经常被访问和修改且需要快速访问的数据。</li>
<li>冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</li>
</ul>
<p><strong>冷热数据如何区分</strong></p>
<ol>
<li>时间维度区分：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。<ul>
<li>例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li>
</ul>
</li>
<li>访问频率区分：将高频访问的数据视为热数据，低频访问的数据视为冷数据。<ul>
<li>例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li>
</ul>
</li>
</ol>
<h3 id="冷数据如何迁移"><a href="#冷数据如何迁移" class="headerlink" title="冷数据如何迁移"></a>冷数据如何迁移</h3><ul>
<li>任务调度：可以利用 <code>xxl-job</code> 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li>
<li>监听数据库的变更日志 <code>binlog</code> ：将满足冷数据条件的数据从 <code>binlog</code> 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li>
</ul>
<h3 id="冷数据如何存储"><a href="#冷数据如何存储" class="headerlink" title="冷数据如何存储"></a>冷数据如何存储</h3><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。冷数据存储方案：</p>
<ul>
<li>中小厂：直接使用 MySQL&#x2F;PostgreSQL 即可(不改变数据库选型和项目当前使用的数据库保持一致)，比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据(涉及跨库查询，增加了系统复杂性和维护难度)</li>
<li>大厂：Hbase(常用)、RocksDB、Doris、Cassandra</li>
</ul>
<h3 id="MySQL字符集"><a href="#MySQL字符集" class="headerlink" title="MySQL字符集"></a>MySQL字符集</h3><p>MySQL 支持很多种字符集的方式，比如 GB2312、GBK、BIG5、多种 Unicode 字符集(UTF-8 编码、UTF-16 编码、UCS-2 编码、UTF-32 编码等等)。 在 MySQL5.7 中，默认字符集是 <code>latin1</code> ；在 MySQL8.0 中，默认字符集是 <code>utf8mb4</code></p>
<h3 id="MySQL字符集层次级别"><a href="#MySQL字符集层次级别" class="headerlink" title="MySQL字符集层次级别"></a>MySQL字符集层次级别</h3><ul>
<li>MySQL 中的字符集分为四个层次：<ul>
<li>server(MySQL 实例级别)</li>
<li>database(库级别)</li>
<li>table(表级别)</li>
<li>column(字段级别)</li>
</ul>
</li>
</ul>
<p>其优先级可以简单的认为是从上往下依次增大，也即 <code>column</code> 的优先级会大于 <code>table</code> 等其余层次的。如指定 MySQL 实例级别字符集是<code>utf8mb4</code>，指定某个表字符集是<code>latin1</code>，那么这个表的所有字段如果不指定的话，编码就是<code>latin1</code>。</p>
<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>
<ul>
<li><code>utf8</code>：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>
<li><code>utf8mb4</code>：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redisopen in new window (REmote DIctionary Server)是一个基于 C 语言开发的开源 NoSQL 数据库(BSD 许可)。与传统数据库不同的是，Redis 的数据是保存在内存中的(内存数据库，支持持久化)，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<h3 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h3><ul>
<li>Redis 基于内存，内存的访问速度比磁盘快很多；</li>
<li>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环</strong>和 <strong>IO 多路复用</strong></li>
<li>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</li>
<li>Redis 通信协议实现简单且解析高效。</li>
</ul>
<h3 id="Redis-Memcached"><a href="#Redis-Memcached" class="headerlink" title="Redis&#x2F;Memcached"></a>Redis&#x2F;Memcached</h3><p>共同点：</p>
<ul>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ul>
<p>区别：</p>
<ul>
<li>Redis 支持更丰富的数据结构，如 <code>string</code>、<code>list</code>、<code>set</code>、<code>zset</code>、<code>hash</code> 等，而 Memcached 只支持 <code>key-value</code> 的数据结构。</li>
<li>Redis 支持持久化，而 Memcached 不支持持久化。也就是说 Redis 有崩溃恢复的能力，Memcached没有。</li>
<li>Redis 支持集群模式，而 Memcached 不支持集群模式。</li>
<li>Redis 支持事务，而 Memcached 不支持事务。</li>
<li>Redis 支持发布订阅，而 Memcached 不支持发布订阅。</li>
<li>Redis 是单线程，而 Memcached 是多线程。</li>
</ul>
<h3 id="为什么用Redis"><a href="#为什么用Redis" class="headerlink" title="为什么用Redis"></a>为什么用Redis</h3><ol>
<li>高性能：Redis 是基于内存的，读写速度非常快。</li>
<li>高并发：可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。大大提高了并发量。</li>
<li>功能齐全：除了可以用作缓存之外，Redis还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！</li>
</ol>
<h3 id="三种常用缓存读写策略"><a href="#三种常用缓存读写策略" class="headerlink" title="三种常用缓存读写策略"></a>三种常用缓存读写策略</h3><p><strong>旁路缓存模式</strong>(<code>Cache Aside Pattern</code>)<br>适合读请求比较多的场景，该模式下服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。<br>读：</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>把 db 中读取到的数据写入 cache 中。</li>
</ul>
<p>写：</p>
<ul>
<li>先更新 db</li>
<li>再删除 cache 中的数据</li>
</ul>
<blockquote>
<p>在写的过程中可以先删除cache，再更新 db 吗？<br>不可以。这样可能会造成 数据库(db)和缓存(Cache)数据不一致的问题。<br>如场景：请求 1 先写数据 A，请求 2 随后读数据 A。<br>执行过程为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
<p>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？<br>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。<br>如场景：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。<br>执行过程为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A(此时缓存中无数据 A ，故不用执行删除缓存操作 ) -&gt; 请求 1 将数据 A 写入 cache</p>
</blockquote>
<p>这种策略有一些缺陷：</p>
<ul>
<li>首次请求数据一定不在 cache 的问题<ul>
<li>解决办法：可以将热点数据可以提前放入 cache 中。</li>
</ul>
</li>
<li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。<ul>
<li>解决办法：可以使用Write Through 或者 Write Behind 策略。<br><strong>读写穿透</strong>(<code>Read/Write Through Pattern</code>)<br>服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li>
</ul>
</li>
</ul>
<p>读：</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回。</li>
<li>读取不到的话，先从 db 读取数据然后写入到cache 中，再返回。</li>
</ul>
<p>写：</p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db(同步更新 cache 和 db)</li>
</ul>
<blockquote>
<p>该模式也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
</blockquote>
<p><strong>异步缓存写入</strong>(<code>Write Behind Pattern</code>)</p>
<p><code>Write Behind Pattern</code> 和 <code>Read/Write Through Pattern</code> 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。但是，两个又有很大的不同：<code>Read/Write Through</code> 是同步更新 cache 和 db，而 <code>Write Behind</code> 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。这种方式db的写性能非常高，但对数据一致性带来了更大挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<blockquote>
<p>应用场景：消息队列中消息的异步写入磁盘、MySQL 的 <code>Innodb Buffer Pool </code>机制都用到了这种策略。</p>
</blockquote>
<h3 id="Redis除了做缓存还有哪些应用场景"><a href="#Redis除了做缓存还有哪些应用场景" class="headerlink" title="Redis除了做缓存还有哪些应用场景"></a>Redis除了做缓存还有哪些应用场景</h3><ul>
<li>分布式锁：基于 <code>Redisson</code> 来实现分布式锁。</li>
<li>限流：通过 Redis + Lua 脚本的方式来实现限流，也可以直接利用 <code>Redisson</code> 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</li>
<li>消息队列：Redis 自带的 <code>List</code> 数据结构可以作为一个简单的队列使用。</li>
<li>延时队列：<code>Redisson</code> 内置了延时队列(基于 <code>Sorted Set</code> 实现的)。</li>
<li>分布式 <code>Session</code> ：利用 <code>String</code> 或者 <code>Hash</code> 数据类型保存 <code>Session</code> 数据，所有的服务器都可以访问。</li>
<li>热点数据存储：将热点数据放入 Redis 中，减少数据库的压力。</li>
</ul>
<h3 id="Redis可以做消息队列吗"><a href="#Redis可以做消息队列吗" class="headerlink" title="Redis可以做消息队列吗"></a>Redis可以做消息队列吗</h3><p>可以。Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 <code>List</code> 来实现。Redis 2.0 之后，Redis 提供了 <code>PUBLISH</code> 和 <code>SUBSCRIBE</code> 命令，可以实现发布订阅模式，也就是说 Redis 也可以做消息队列。</p>
<p>和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此通常建议不要使用 Redis 来做消息队列，完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<h3 id="Redis可以做搜索引擎吗"><a href="#Redis可以做搜索引擎吗" class="headerlink" title="Redis可以做搜索引擎吗"></a>Redis可以做搜索引擎吗</h3><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <code>RediSearch</code>，这是一个基于 Redis 的搜索引擎模块。</p>
<p><code>RediSearch</code> 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。相比较于 <code>Elasticsearch</code> 来说，<code>RediSearch</code> 有如下优势：</p>
<ul>
<li>性能更优秀：依赖 Redis 自身的高性能，基于内存操作(<code>Elasticsearch</code> 基于磁盘)。</li>
<li>较低内存占用实现快速索引：<code>RediSearch</code> 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。</li>
</ul>
<p><code>RediSearch</code> 适用于小型项目的简单搜索场景，对于大型项目的搜索场景，还是推荐使用 <code>Elasticsearch</code>。</p>
<ul>
<li>数据量限制：<code>RedisSearch</code> 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不适合存储大量数据。</li>
<li>分布式能力较差：<code>RedisSearch</code> 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。<code>Elasticsearch</code> 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。</li>
<li><code>RediSearch</code>聚合功能相较于 <code>Elasticsearch</code> 功能较弱。</li>
<li>生态较差：<code>Elasticsearch</code> 可以轻松和常见的一些系统&#x2F;软件集成比如 <code>Hadoop</code>、<code>Spark</code>、<code>Kibana</code>，而 <code>RedisSearch</code> 则不具备该优势。</li>
</ul>
<h3 id="基于Redis实现延时任务✅"><a href="#基于Redis实现延时任务✅" class="headerlink" title="基于Redis实现延时任务✅"></a>基于Redis实现延时任务✅</h3><blockquote>
<p>类似问题：订单在 10 分钟后未支付就失效，如何用 Redis 实现？ 红包 24 小时未被查收自动退还，如何用 Redis 实现？</p>
</blockquote>
<p>两种方案：</p>
<ol>
<li>Redis 过期事件监听 </li>
<li><code>Redisson</code> 内置的延时队列</li>
</ol>
<p>Redis 过期事件监听的存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。<br><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>
<ul>
<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>
<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ul>
<h3 id="Redis过期事件监听实现延时任务的原理"><a href="#Redis过期事件监听实现延时任务的原理" class="headerlink" title="Redis过期事件监听实现延时任务的原理"></a>Redis过期事件监听实现延时任务的原理</h3><p>Redis 2.0 引入了发布订阅 (<code>pub/sub</code>) 功能(其中有一个叫做 <code>channel</code>的概念)，涉及发布者(<code>publisher</code>)和订阅者(<code>subscriber</code>，也叫消费者)两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 <code>channel</code>。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 <code>channel</code>。并且，订阅者可以订阅一个或者多个 <code>channel</code>。</li>
</ul>
<p>在 <code>pub/sub</code> 模式下，生产者需要指定消息发送到哪个 <code>channel</code> 中，而消费者则订阅对应的 <code>channel</code> 以获取消息。</p>
<p>Redis 中有很多默认的 <code>channel</code>，Redis 本身向它们发送一些消息，比如 <code>__keyevent@0__:expired</code>，这个 <code>channel</code> 用来监听 Redis 中的 key 过期事件。</p>
<p>实现延时任务的原理就是：在 Redis 中设置一个 key，然后设置过期时间，当 <code>key</code> 过期时，Redis 会向 <code>__keyevent@0__:expired</code> 这个<code>channel</code>发送一条消息，这时候就可以在这个 <code>channel</code> 上监听到这个消息，从而实现延时任务。</p>
<h3 id="Redis过期事件监听实现延时任务有什么缺陷"><a href="#Redis过期事件监听实现延时任务有什么缺陷" class="headerlink" title="Redis过期事件监听实现延时任务有什么缺陷"></a>Redis过期事件监听实现延时任务有什么缺陷</h3><ol>
<li>时效性差：过期事件消息是在 Redis 服务器删除 <code>key</code> 时发布的，而不是一个 <code>key</code> 过期之后就会就会直接发布。Redis 采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>。 因此会存在设置了 <code>key</code> 的过期时间，但到了指定时间 <code>key</code> 还未被删除，进而没有发布过期事件的情况。</li>
<li>丢消息：Redis 的 <code>pub/sub</code> 模式中的消息并不支持持久化，如果 Redis 服务器宕机了，过期事件就会丢失。</li>
<li>多服务实例下消息重复消费：pub&#x2F;sub 模式目前只有广播模式，当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。如果有多个服务实例，每个订阅相关频道的实例都会监听到过期事件，这样就会导致消息重复消费的问题。</li>
</ol>
<h3 id="Redisson内置的延时队列实现延时任务的原理及优势"><a href="#Redisson内置的延时队列实现延时任务的原理及优势" class="headerlink" title="Redisson内置的延时队列实现延时任务的原理及优势"></a>Redisson内置的延时队列实现延时任务的原理及优势</h3><p>可以借助 <code>Redisson</code> 内置的延时队列 <code>RDelayedQueue</code> 来实现延时任务功能。<code>RDelayedQueue</code> 基于 Redis 的 <code>SortedSet</code> 来实现，<code>SortedSet</code> 是一个有序集合，可以为每个元素设置一个分数作为权重。利用这一特性，将需要延迟执行的任务设置相应的过期时间作为分数，然后插入到 <code>SortedSet</code> 中，使用<code>zrangebyscore</code> 命令扫描 <code>SortedSet</code> 中过期的元素，将过期元素从中移除并添加到到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样避免了对 <code>SortedSet</code> 的轮询，提高了执行效率。</p>
<p><code>Redisson</code> 内置的延时队列具备下面这些优势：</p>
<ul>
<li>减少了丢消息的可能：<code>DelayedQueue</code> 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大，也可以使用扫描数据库的方法作为补偿机制。</li>
<li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ul>
<h3 id="Redis数据类型✅"><a href="#Redis数据类型✅" class="headerlink" title="Redis数据类型✅"></a>Redis数据类型✅</h3><ul>
<li>5种基本数据类型：<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">底层实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String</code>(字符串)</td>
<td align="left"><code>SDS</code>(简单动态字符串)</td>
</tr>
<tr>
<td align="left"><code>List</code>(列表)</td>
<td align="left"><code>LinkedList</code>(双向链表)、<code>ZipList</code>(压缩列表)、<code>QuickList</code>(快速列表)</td>
</tr>
<tr>
<td align="left"><code>Hash</code>(哈希)</td>
<td align="left"><code>Dict</code>(哈希表&#x2F;字典)、<code>ZipList</code>(压缩列表)</td>
</tr>
<tr>
<td align="left"><code>Set</code>(集合)</td>
<td align="left"><code>Dict</code>(哈希表&#x2F;字典)、<code>Intset</code>(整数集合)</td>
</tr>
<tr>
<td align="left"><code>Zset</code>(有序集合)</td>
<td align="left"><code>ZipList</code>(压缩列表)、<code>SkipList</code>(跳表)</td>
</tr>
</tbody></table>
</li>
<li>3种特殊数据类型：<ul>
<li><code>Bitmap</code>：位图</li>
<li><code>HyperLogLog</code>：基数统计</li>
<li><code>Geo</code>：地理位置</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><code>String</code> 的实现并没有使用 C语言的字符串类型，而是自己构建了一种 简单动态字符串(<code>Simple Dynamic String，SDS</code>)。SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)(C 字符串为 O(N))，除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>MSET key1 value1 key2 value2 ……</td>
<td>设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td>MGET key1 key2 …</td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断指定 key 是否存在</td>
</tr>
<tr>
<td>DEL key(通用)</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td>EXPIRE key seconds(通用)</td>
<td>给指定 key 设置过期时间</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong><br><code>String</code> 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片(图片的 <code>base64</code> 编码或者解码或者图片的路径)、序列化后的对象。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的 <code>List</code> 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>RPUSH key value1 value2 …</td>
<td>在指定列表的尾部(右边)添加一个或多个元素</td>
</tr>
<tr>
<td>LPUSH key value1 value2 …</td>
<td>在指定列表的头部(左边)添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>信息流展示，如最新文章、最新动态。</li>
<li>消息队列，只是与专业的消息队列相比，<code>List</code> 功能较弱。</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p> <code>Hash</code> 是一个 <code>String</code> 类型的 <code>field-value</code>(键值对) 的映射表，适合用于存储对象，后续操作可以直接修改这个对象中的某些字段的值。</p>
<p><code>Hash</code> 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)，不过做了更多优化。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>HSET key field value</td>
<td>设置指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 …</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 …</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 …</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>对指定哈希中的指定字段做运算操作(正数为加，负数为减)</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>存储对象，如用户信息、商品信息、文章信息、购物车信息.</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，类似于 Java 中的 <code>HashSet</code> 。当需要存储无重复列表数据时，<code>Set</code> 是一个很好的选择，且 <code>Set</code> 提供了判断某个元素是否在其内的重要接口，这个也是 <code>List</code> 所不能提供的。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member1 member2 …</td>
<td>向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取指定集合中的所有元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取指定集合的元素数量</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断指定元素是否在指定集合中</td>
</tr>
<tr>
<td>SINTER key1 key2 …</td>
<td>获取给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 key2 …</td>
<td>将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td>SUNION key1 key2 …</td>
<td>获取给定所有集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 key2 …</td>
<td>将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td>SDIFF key1 key2 …</td>
<td>获取给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 key2 …</td>
<td>将给定所有集合的差集存储在 destination 中</td>
</tr>
<tr>
<td>SPOP key count</td>
<td>随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td>SRANDMEMBER key count</td>
<td>随机获取指定集合中指定数量的元素</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>存放无重复数据：如文章点赞、用户收藏、共同好友等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：如共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐(差集)、音乐推荐(差集)、订阅号推荐(差集+交集) 等场景。</li>
<li>随机获取数据源：如抽奖、随机推荐等。</li>
</ul>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p><code>Zset</code>相较于<code>Set</code>增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score1 member1 score2 member2 …</td>
<td>向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td>ZCARD KEY</td>
<td>获取指定有序集合的元素数量</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key1 key2 …</td>
<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key1 key2 …</td>
<td>求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZDIFFSTORE destination numkeys key1 key2 …</td>
<td>求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素(score 从低到高)</td>
</tr>
<tr>
<td>ZREVRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素(score 从高到底)</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>需要随机获取数据源中的元素根据某个权重进行排序的场景：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>需要存储的数据有优先级或者重要程度的场景：如任务优先级、消息优先级、商品价格、商品销量等。</li>
</ul>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p><code>Bitmap</code>存储的是连续的二进制数据(1&#x2F;0)，只需要一个 <code>bit</code> 位来表示某个元素对应的值或者状态，非常节省内存。可以将<code>Bitmap</code> 看作是一个存储二进制数字(0和1)的数组，数组中每个元素的下标叫做 <code>offset</code>(偏移量)。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SETBIT key offset value</td>
<td>设置指定 offset 位置的值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>获取指定 offset 位置的值</td>
</tr>
<tr>
<td>BITCOUNT key start end</td>
<td>获取 start 和 end 之前值为 1 的元素个数</td>
</tr>
<tr>
<td>BITOP operation destkey key1 key2 …</td>
<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND，OR，XOR 以及 NOT</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>用户签到：每天签到的用户用一个 <code>bit</code> 位来表示，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为签到状态(1&#x2F;0)。</li>
<li>用户在线状态：用一个 <code>bit</code> 位来表示用户的在线状态，<code>offset</code> 为用户的 <code>id</code>，<code>value</code> 为在线状态(1&#x2F;0)。</li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p><code>HyperLogLog</code> 是一种基数统计算法，用于估计一个集合中不重复元素的个数。<code>HyperLogLog</code> 的优势在于占用的内存空间固定，并且不随着统计的元素数量增加而增加。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>PFADD key element1 element2 …</td>
<td>添加一个或多个元素到 HyperLogLog 中</td>
</tr>
<tr>
<td>PFCOUNT key1 key2</td>
<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey1 sourcekey2 …</td>
<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>数量量巨大(百万、千万级别以上)的计数场景：如热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、热门商品 uv 统计等。</li>
</ul>
<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p><code>Geospatial index</code>(地理空间索引，简称 GEO) 主要用于存储地理位置信息，基于 <code>Sorted Set</code> 实现。 通过 GEO 可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>GEOADD key longitude1 latitude1 member1 …</td>
<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
</tr>
<tr>
<td>GEOPOS key member1 member2 …</td>
<td>返回给定元素的经纬度信息</td>
</tr>
<tr>
<td>GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI</td>
<td>返回两个给定元素之间的距离</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius distance</td>
<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC(由远到近)、Count(数量) 等参数</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius distance</td>
<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<ul>
<li>附近的人：根据用户的经纬度信息，获取附近的人。</li>
<li>附近的商家：根据用户的经纬度信息，获取附近的商家。</li>
<li>附近的车辆：根据用户的经纬度信息，获取附近的车辆。</li>
</ul>
<h3 id="使用String存储对象还是Hash"><a href="#使用String存储对象还是Hash" class="headerlink" title="使用String存储对象还是Hash"></a>使用String存储对象还是Hash</h3><ul>
<li><code>String</code> 存储的是序列化后的对象数据，存放的是整个对象。<code>Hash</code> 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或常需单独查询对象中个别字段信息，使用 <code>Hash</code>。</li>
<li><code>String</code> 存储相对来说更加节省内存，缓存相同数量的对象数据，<code>String</code> 消耗的内存约是 <code>Hash</code> 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，用<code>String</code>。</li>
</ul>
<h3 id="购物车信息用String还是Hash存储"><a href="#购物车信息用String还是Hash存储" class="headerlink" title="购物车信息用String还是Hash存储"></a>购物车信息用String还是Hash存储</h3><p>购物车中的商品频繁修改和变动，建议使用 <code>Hash</code>储存。</p>
<ul>
<li>用户 id 为 <code>key</code></li>
<li>商品 id 为 <code>field</code>，商品数量为 <code>value</code></li>
</ul>
<p>具体维护：</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值(直接 set 或者做运算皆可)；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<h3 id="Zset为什么要用跳表"><a href="#Zset为什么要用跳表" class="headerlink" title="Zset为什么要用跳表"></a>Zset为什么要用跳表</h3><ul>
<li>跳表 vs 平衡树<ul>
<li>跳表和平衡书的插入、查询、删除操作的时间复杂度都是 O(logN)，但平衡树每一次插入、删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，插入、删除操作只需要修改相邻节点的指针，不需进行旋转操作，因此跳表的插入、删除操作效率更高。</li>
</ul>
</li>
<li>跳表 vs 红黑树<ul>
<li>跳表不需要通过旋转和染色(红黑变换)来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
</ul>
</li>
<li>跳表 vs B+ 树<ul>
<li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis数据存储在内存中，必不可能需要存储大量数据，因此 B+ 树的优势并不明显。</li>
</ul>
</li>
</ul>
<h3 id="用Set实现抽奖系统"><a href="#用Set实现抽奖系统" class="headerlink" title="用Set实现抽奖系统"></a>用Set实现抽奖系统</h3><ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code>： 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h3 id="Bitmap统计活跃用户"><a href="#Bitmap统计活跃用户" class="headerlink" title="Bitmap统计活跃用户"></a>Bitmap统计活跃用户</h3><p>用日期(精确到天)作为 <code>key</code>，用户 ID 为 <code>offset</code>，如果当日活跃过就设置为 1，否则为 0。通过 <code>BITCOUNT</code> 命令统计某个时间段内的活跃用户数。</p>
<h3 id="HyperLogLog统计网站-UV"><a href="#HyperLogLog统计网站-UV" class="headerlink" title="HyperLogLog统计网站 UV"></a>HyperLogLog统计网站 UV</h3><ul>
<li><code>PFADD PAGE_1:UV USER1 USER2 ...... USERn</code>：将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</li>
<li><code>PFCOUNT PAGE_1:UV</code>：统计指定页面的 UV。</li>
</ul>
<h3 id="Redis持久化机制✅"><a href="#Redis持久化机制✅" class="headerlink" title="Redis持久化机制✅"></a>Redis持久化机制✅</h3><p>使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。</p>
<h3 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h3><ul>
<li>重用数据(比如重启机器、机器故障之后恢复数据)</li>
<li>数据同步(比如 Redis 集群的主从节点通过 RDB 文件同步数据)。</li>
</ul>
<h3 id="三种持久化方式"><a href="#三种持久化方式" class="headerlink" title="三种持久化方式"></a>三种持久化方式</h3><ul>
<li>快照(<code>snapshotting</code>, RDB)</li>
<li>只追加文件(<code>append-only file</code>, AOF)</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis通过创建快照获取存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。快照创建后，可以对其进行备份，也可以将其复制到其他服务器，从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器时使用。</p>
<h3 id="RDB创建时会阻塞主线程吗"><a href="#RDB创建时会阻塞主线程吗" class="headerlink" title="RDB创建时会阻塞主线程吗"></a>RDB创建时会阻塞主线程吗</h3><p>有两个命令生成 RDB 快照文件</p>
<ul>
<li><code>save</code>：同步保存操作，会阻塞 Redis 主线程； </li>
<li><code>bgsave</code>：<code>fork</code> 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>与快照持久化相比，AOF 持久化的实时性更好。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中(此时还在系统内核缓存区未同步到磁盘)，最后再根据持久化方式(<code>fsync</code>策略)的配置决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险(系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了)。</p>
<h3 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h3><ol>
<li>命令追加(<code>append</code>)：所有的写命令会追加到 AOF 缓冲区中。</li>
<li>文件写入(<code>write</code>)：将 AOF 缓冲区的数据写入到<strong>系统内核缓冲区</strong>中。这一步系统调用<code>write</code>函数，将数据写入到了<strong>系统内核缓冲区</strong>之后直接返回(延迟写)。</li>
<li>文件同步(<code>fsync</code>)：<strong>系统内核缓冲区</strong>根据对应的持久化方式(<code>fsync</code>策略)向硬盘做同步操作。这一步系统调用 <code>fsync</code> 函数， <code>fsync</code> 用于强制刷新系统内核缓冲区(同步到到磁盘)，它将阻塞直到写入磁盘完成后返回，确保写磁盘操作结束才会返回。</li>
<li>文件重写(<code>rewrite</code>)：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li>重启加载(<code>load</code>)：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<p><img src="/./image/Database-Interview/aof-work-process.png" alt="AOF工作流程"></p>
<h3 id="AOF持久化的三种同步策略"><a href="#AOF持久化的三种同步策略" class="headerlink" title="AOF持久化的三种同步策略"></a>AOF持久化的三种同步策略</h3><p>即 <code>fsync</code> 策略，用于控制系统内核缓冲区的数据何时同步到硬盘中。</p>
<ul>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程( <code>aof_fsync</code> 线程)立即会调用 <code>fsync</code> 函数同步 AOF 文件(刷盘)，<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能(<code>write + fsync</code>)。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程( <code>aof_fsync</code> 线程)每秒钟调用 <code>fsync</code> 函数同步一次 AOF 文件(<code>write+fsync</code>，<code>fsync</code>间隔为 1 秒)</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次(<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定)。</li>
</ul>
<blockquote>
<p>刷盘：将内存中的数据写入到磁盘中。</p>
</blockquote>
<h3 id="AOF为什么是执行完命令后记录日志"><a href="#AOF为什么是执行完命令后记录日志" class="headerlink" title="AOF为什么是执行完命令后记录日志"></a>AOF为什么是执行完命令后记录日志</h3><p>不同于 MySQL 先记录日志再执行命令(方便故障恢复)，Redis 先执行命令再记录日志(追求性能)。</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>但也存在风险：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； </li>
<li>可能会阻塞后续其他命令的执行(AOF 记录日志是在 Redis 主线程中进行的)。</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>当 AOF 变得太大时，Redis 在后台创建一个子线程，自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>重写期间，AOF维护一个<strong>AOF重写缓冲区</strong>，记录创建新AOF文件期间执行的所有写命令，当创建新AOF文件完成后，将<strong>AOF重写缓冲区</strong>内容追加到新AOF文件末尾。最后用新AOF文件替换旧AOF文件。</p>
<p>可以配置如下参数：<br><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;<br><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小(<code>aof_current_size</code>)和上一次重写时 AOF 大小(<code>aof_base_size</code>)的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</p>
<h3 id="AOF校验机制"><a href="#AOF校验机制" class="headerlink" title="AOF校验机制"></a>AOF校验机制</h3><p>Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。具体原理就是使用校验和(checksum) 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 <code>CRC64</code> 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。</p>
<p>Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和(计算的时候会把最后一行保存校验和的内容给忽略点)，从而判断 AOF 文件是否完整。</p>
<h3 id="Redis4-0对持久化的优化"><a href="#Redis4-0对持久化的优化" class="headerlink" title="Redis4.0对持久化的优化"></a>Redis4.0对持久化的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点， 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="如何选择RDB和AOF"><a href="#如何选择RDB和AOF" class="headerlink" title="如何选择RDB和AOF"></a>如何选择RDB和AOF</h3><p>RDB优势：</p>
<ul>
<li>RDB文件存储的内容是经过压缩的二进制数据，非常适合用于备份和恢复数据。而 AOF 文件存储的内容是每次写命令，会比RDB文件大。</li>
<li>RDB文件恢复数据快，直接解析还原数据即可，而AOF文件需要逐行执行命令来恢复数据。</li>
</ul>
<p>AOF优势：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。AOF 支持秒级数据丢失，仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB文件以二进制格式保存数据，且Redis 版本迭代中存在多版本的 RDB，可能存在兼容性问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。可以方便地导出 AOF 文件进行分析。</li>
</ul>
<p>综上：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
</ul>
<h3 id="Redis单线程模型✅"><a href="#Redis单线程模型✅" class="headerlink" title="Redis单线程模型✅"></a>Redis单线程模型✅</h3><p>Redis 基于 <code>Reactor</code> 模式设计开发了一套高效的事件处理模型，对应的是 Redis 中的文件事件处理器(<code>file event handler</code>)，是单线程方式运行的，所以说 Redis 是单线程模型。</p>
<h3 id="如何监听大量客户端链接"><a href="#如何监听大量客户端链接" class="headerlink" title="如何监听大量客户端链接"></a>如何监听大量客户端链接</h3><p>通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接(或者说是监听多个 <code>socket</code>)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。</p>
<p>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p>
<p>文件事件处理器主要是包含 4 个部分：</p>
<ul>
<li>多个 socket(客户端连接)</li>
<li>IO 多路复用程序(支持多个客户端连接的关键)</li>
<li>文件事件分派器(将 <code>socket</code> 关联到相应的事件处理器)</li>
<li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li>
</ul>
<p><img src="/./image/Database-Interview/redis-event-handler.png" alt="文件事件处理器"></p>
<h3 id="Redis4-0多线程"><a href="#Redis4-0多线程" class="headerlink" title="Redis4.0多线程"></a>Redis4.0多线程</h3><p>在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作。这里引入的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”，从而减少对主线程的影响。</p>
<p>异步命令：</p>
<ul>
<li><code>UNLINK</code>：可以看作是 <code>DEL</code> 命令的异步版本。</li>
<li><code>FLUSHALL ASYNC</code>：用于清空所有数据库的所有键，不限于当前 <code>SELECT</code> 的数据库。</li>
<li><code>FLUSHDB ASYNC</code>：用于清空当前 <code>SELECT</code> 数据库中的所有键。</li>
</ul>
<p>总得来说，Redis 6.0 之前，Redis 的主要操作仍然是单线程处理的。</p>
<h3 id="Redis6-0之前为什么不用多线程"><a href="#Redis6-0之前为什么不用多线程" class="headerlink" title="Redis6.0之前为什么不用多线程"></a>Redis6.0之前为什么不用多线程</h3><ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h3 id="Redis6-0之后为何引入多线程"><a href="#Redis6-0之后为何引入多线程" class="headerlink" title="Redis6.0之后为何引入多线程"></a>Redis6.0之后为何引入多线程</h3><p>Redis 6.0 版本之后引入了多线程来处理网络请求(提高网络 IO 读写性能)。这里的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。</p>
<h3 id="Redis后台线程"><a href="#Redis后台线程" class="headerlink" title="Redis后台线程"></a>Redis后台线程</h3><p>Redis 是单线程模型(主要逻辑是单线程完成的)，但实际还有一些后台线程用于执行比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF&#x2F;RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘( AOF 文件)。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象(已删除)占用的内存空间.</li>
</ul>
<h3 id="Redis内存管理✅"><a href="#Redis内存管理✅" class="headerlink" title="Redis内存管理✅"></a>Redis内存管理✅</h3><h3 id="Redis给缓存数据设置过期时间有啥用"><a href="#Redis给缓存数据设置过期时间有啥用" class="headerlink" title="Redis给缓存数据设置过期时间有啥用"></a>Redis给缓存数据设置过期时间有啥用</h3><ul>
<li>因为Redis是内存数据库，内存有限，如果数据一直不过期，会导致内存被耗尽，进而影响系统的正常运行。</li>
<li>某些业务场景就是需要某个数据只在某一时间段内存在，过期后就没用了，比如验证码、短信验证码等。若传统的数据库，一般都是自己判断过期，这样更麻烦并且性能要差很多。</li>
</ul>
<h3 id="Redis如何判断数据过期"><a href="#Redis如何判断数据过期" class="headerlink" title="Redis如何判断数据过期"></a>Redis如何判断数据过期</h3><p>Redis 通过一个叫做<strong>过期字典</strong>(可以看作是 <code>hash</code> 表)来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 <code>key</code>(键)，过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了 <code>key</code> 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。</p>
<p>在查询一个 <code>key</code> 的时候，Redis 首先检查该 <code>key</code> 是否存在于过期字典中(时间复杂度为 O(1))，如果不在就直接返回，在的话需要判断一下这个 <code>key</code> 是否过期，过期直接删除 <code>key</code> 然后返回 <code>null</code>。</p>
<h3 id="Redis过期key删除策略"><a href="#Redis过期key删除策略" class="headerlink" title="Redis过期key删除策略"></a>Redis过期key删除策略</h3><ul>
<li>惰性删除：只会在取出&#x2F;查询 <code>key</code> 的时候才对数据进行过期检查。这样对 CPU 最友好，但可能会造成太多过期 <code>key</code> 没有删除。</li>
<li>定期删除：周期性地随机从设置了过期时间的 <code>key</code> 中抽查一批，然后逐个检查这些 <code>key</code> 是否过期，过期就删除 <code>key</code>。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>
<li>延迟队列：把设置过期时间的 <code>key</code> 放到一个延迟队列里，到期之后就删除 <code>key</code>。这样可保证每个过期 <code>key</code> 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>
<li>定时删除：每个设置了过期时间的 <code>key</code> 都会在设置的时间到达时立即被删除。这样可确保内存中不会有过期的键，但它对 CPU 压力最大，因为它需要为每个键都设一个定时器。</li>
</ul>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。两者结合使用既能 CPU 友好，又能内存友好。</p>
<h3 id="定期删除策略详细细节"><a href="#定期删除策略详细细节" class="headerlink" title="定期删除策略详细细节"></a>定期删除策略详细细节</h3><ul>
<li>Redis 默认每 100ms 检查 20 个随机的过期 <code>key</code>，如果有过期的 <code>key</code> 就删除。如果执行时间超过阈值 25ms，就中断这一次定期删除循环，以避免使用过多的 CPU 时间。如果在这一批中过期 <code>key</code> 超过10%，就会重复执行此删除流程，以更积极地清理过期 key。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环，避免做过多的工作而获得很少的内存回收。</li>
</ul>
<p><strong>大量key集中过期如何处理</strong><br>如果大量 <code>key</code> 集中过期的问题，可能会使 Redis 的请求延迟变高。解决：</p>
<ul>
<li>尽量避免 <code>key</code> 集中过期，在设置键的过期时间时尽量随机一点。</li>
<li>对过期的 <code>key</code> 开启 <code>lazyfree</code> 机制，这样会在后台异步删除过期的 key，不会阻塞主线程的运行。</li>
</ul>
<h3 id="Redis内存淘汰策略✅"><a href="#Redis内存淘汰策略✅" class="headerlink" title="Redis内存淘汰策略✅"></a>Redis内存淘汰策略✅</h3><p>当 Redis 内存不足时，会根据配置的内存淘汰策略来删除一些数据，以释放内存空间。Redis有 6 种内存淘汰策略：</p>
<ul>
<li><code>volatile-lru</code>(least recently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最近最少使用的数据淘汰。</li>
<li><code>volatile-ttl</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选将要过期的数据淘汰。</li>
<li><code>volatile-random</code>：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中任意选择数据淘汰。</li>
<li><code>allkeys-lru</code>(least recently used)：从数据集(<code>server.db[i].dict</code>)中移除最近最少使用的数据淘汰。</li>
<li><code>allkeys-random</code>：从数据集(<code>server.db[i].dict</code>)中任意选择数据淘汰。</li>
<li><code>no-eviction</code>(默认内存淘汰策略)：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<p>4.0 版本后增加以下两种：</p>
<ul>
<li><code>volatile-lfu</code>(least frequently used)：从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰。</li>
<li><code>allkeys-lfu</code>(least frequently used)：从数据集(<code>server.db[i].dict</code>)中移除最不经常使用的数据淘汰。</li>
</ul>
<p><code>allkeys-xxx</code> 表示从所有的键值中淘汰数据，而 <code>volatile-xxx</code> 表示从设置了过期时间的键值中淘汰数据。</p>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。Redis 事务实际开发中使用的非常少，功能比较鸡肋，不满足原子性(Redis不支持回滚)和持久性(always持久化策略性能太差，其他策略都会有数据丢失)，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p>
<h3 id="如何解决Redis事务的缺陷"><a href="#如何解决Redis事务的缺陷" class="headerlink" title="如何解决Redis事务的缺陷"></a>如何解决Redis事务的缺陷</h3><p>可以使用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。不过严格来说，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</p>
<h3 id="Redis性能优化✅"><a href="#Redis性能优化✅" class="headerlink" title="Redis性能优化✅"></a>Redis性能优化✅</h3><h3 id="批量操作减少网络传输"><a href="#批量操作减少网络传输" class="headerlink" title="批量操作减少网络传输"></a>批量操作减少网络传输</h3><p>Redis 是基于内存的数据库，网络传输是 Redis 性能的瓶颈之一。可以通过批量操作来减少网络传输次数，提高 Redis 性能。</p>
<p>批量操作的三种方式</p>
<ul>
<li>原生批量操作：Redis 提供了一些原生的批量操作命令，如 <code>MSET</code>、<code>MGET</code>、<code>DEL</code> 等。</li>
<li>Pipeline：通过 <code>pipeline</code> 可以将多个命令打包成一个请求一次性发送给 Redis 服务器，减少网络传输次数。</li>
<li>Lua脚本：</li>
</ul>
<h3 id="大量key集中过期"><a href="#大量key集中过期" class="headerlink" title="大量key集中过期"></a>大量key集中过期</h3><p>Redis采用<strong>定期删除+惰性&#x2F;懒汉式删除</strong>清理过期<code>key</code>。如果大量 <code>key</code> 集中过期的问题，客户端请求必须等待定期清理过期 <code>key</code> 任务线程执行完成(定期任务线程是在主线程中执行的)，这可能会使 Redis 的请求延迟变高。解决：</p>
<ul>
<li>给 <code>key</code> 设置随机过期时间。</li>
<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)，让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将删除<code>key</code>的操作该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ul>
<h3 id="bigkey-大key"><a href="#bigkey-大key" class="headerlink" title="bigkey(大key)"></a>bigkey(大key)</h3><p>如果一个 <code>key</code> 对应的 <code>value</code> 所占用的内存比较大，那这个 <code>key</code> 就可以看作是 <code>bigkey</code>。<code>bigkey</code>的标准：</p>
<ul>
<li><code>String</code> 类型的 <code>value</code> 超过 1MB</li>
<li>复合类型(<code>List</code>、<code>Hash</code>、<code>Set</code>、<code>Sorted Set</code> 等)的 <code>value</code> 包含的元素超过 5000 个(不过，对于复合类型的 <code>value</code> 来说，不一定包含的元素越多，占用的内存就越多)。</li>
</ul>
<p><strong>产生原因</strong></p>
<ul>
<li>程序设计不当，比如直接使用 <code>String</code> 类型存储较大的文件对应的二进制数据。</li>
<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>
<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>
</ul>
<p><strong>危害</strong></p>
<ul>
<li>单线程的Redis 在操作<code>bigkey</code> 时候比较耗时，造成客户端超时阻塞。</li>
<li>网络拥塞：获取<code>bigkey</code>需要较多的流量。</li>
<li>工作线程阻塞：如果使用 <code>del</code> 删除大 <code>key</code> 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><code>bigkey</code>会进一步影响主从同步。</li>
</ul>
<p><strong>bigkey发现</strong></p>
<ul>
<li><code>--bigkeys</code>：执行<code>redis-cli -p 6379 --bigkeys</code>扫描所有key，只能找到<code>top 1 bigkey</code>(占用内存最大的 <code>String</code> 数据类型，包含元素最多的复合数据类型)。</li>
<li><code>SCAN+STRLEN/HLEN/LLEN</code>：Redis 自带的 <code>SCAN</code> 命令按指定模式扫描匹配的<code>key</code>，然后结合<code>STRLEN/HLEN/LLEN</code>返回<code>key</code>的长度或者成员数量。</li>
<li>集合类型可以使用<code>MEMORY USAGE</code></li>
<li>借助开源工具分析 RDB 文件。如<code>redis-rdb-tools</code>、<code>rdb_bigkeys</code></li>
<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>
</ul>
<p><strong>处理bigkey</strong></p>
<ul>
<li>分割 <code>bigkey</code>：将<code>bigkey</code>分割为多个小 <code>key</code>。例如，将一个含有上万字段数量的 <code>Hash</code> 按照一定策略(比如二次哈希)拆分为多个 <code>Hash</code>。</li>
<li>手动清理：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 <code>key</code>。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>
<li>采用合适的数据结构：例如，文件二进制数据不使用 <code>String</code> 保存、使用 <code>HyperLogLog</code> 统计页面 <code>UV</code>、<code>Bitmap</code> 保存状态信息(0&#x2F;1)。</li>
<li>开启 <code>lazy-free</code>(惰性删除&#x2F;延迟释放)：<code>lazy-free</code> 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 <code>key</code> 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ul>
<p>也可以配合使用上述方法</p>
<h3 id="hotkey-热key"><a href="#hotkey-热key" class="headerlink" title="hotkey(热key)"></a>hotkey(热key)</h3><p>如果一个 <code>key</code> 的访问次数比较多且明显多于其他 <code>key</code>，就可以看作是 <code>hotkey</code>。</p>
<p><strong>产生原因</strong><br>某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<p><strong>危害</strong></p>
<ul>
<li><code>hotkey</code> 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。</li>
<li>如果突然访问 <code>hotkey</code> 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</li>
</ul>
<p><code>hotkey</code> 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>
<p><strong>发现hotkey</strong></p>
<ul>
<li><code>--hotkeys</code>：执行<code>redis-cli -p 6379 --hotkeys</code>命令</li>
<li><code>MONITOR</code>： Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。该命令对性能影响很大，禁止长时间开启。<ul>
<li>可在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，关闭命令后通过对文件中请求进行归类分析即可找出这段时间中的 <code>hotkey</code>。</li>
</ul>
</li>
<li>根据业务情况提前预估。比如参与秒杀活动的商品数据等。无法预估所有 <code>hotkey</code>，比如突发的热点新闻事件等。</li>
<li>使用公有云的 Redis 分析服务，如阿里云、腾讯云等。</li>
</ul>
<p><strong>处理hotkey</strong></p>
<ul>
<li>读写分离：主节点处理写请求，从节点处理读请求。</li>
<li>使用 <code>Redis Cluster</code>：将热点数据分散存储在多个 Redis 节点上。</li>
<li>二级缓存：<code>hotkey</code> 采用二级缓存的方式进行处理，将 <code>hotkey</code> 存放一份到 JVM 本地内存中(可以用 Caffeine)。</li>
<li>使用公有云的 Redis 服务中的解决方案。</li>
</ul>
<p>也可以配合使用上述方法。</p>
<h3 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h3><p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，如<code>KEYS *</code>、<code>HGETALL</code>等。这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</p>
<h3 id="Redis内存碎片✅"><a href="#Redis内存碎片✅" class="headerlink" title="Redis内存碎片✅"></a>Redis内存碎片✅</h3><p>Redis内存碎片就是内存中的一些不连续的小块内存，这些小块内存无法被利用，但又无法释放，造成内存浪费。内存碎片不会影响性能，但会增加内存消耗。</p>
<h3 id="内存碎片产生原因"><a href="#内存碎片产生原因" class="headerlink" title="内存碎片产生原因"></a>内存碎片产生原因</h3><ol>
<li>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。<ul>
<li>Redis 采用多种内存分配器分配内存，默认采用 <code>jemalloc</code>，其按照 2 的幂次方分配内存，可能会导致内存浪费。</li>
</ul>
</li>
<li>频繁修改 Redis 中的数据也会产生内存碎片。</li>
</ol>
<h3 id="查看内存碎片率"><a href="#查看内存碎片率" class="headerlink" title="查看内存碎片率"></a>查看内存碎片率</h3><p>使用 <code>info memory</code> 命令查看 Redis 内存碎片率。</p>
<p><code>mem_fragmentation_ratio</code> (内存碎片率)&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>内粗碎片率越大，说明 Redis 中的内存碎片越多。<code>used_memory_rss</code> 减去 <code>used_memory</code> 的值不仅包括内粗碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>通常内存碎片率<code>mem_fragmentation_ratio</code> &gt; 1.5(使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存)就需要清理内存碎片了</p>
<h3 id="Redis内存碎片清理"><a href="#Redis内存碎片清理" class="headerlink" title="Redis内存碎片清理"></a>Redis内存碎片清理</h3><ol>
<li>重启节点可以做到内存碎片重新整理。如果采用的是高可用架构的 Redis 集群的话，可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</li>
<li>Redis4.0-RC3可以通过<code>config set activedefrag yes</code>开启主动碎片整理功能，Redis 会在后台自动整理内存碎片。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span> <span class="comment"># 开启主动碎片整理功能</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb <span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50 <span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-min 20 <span class="comment"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-max 50 <span class="comment"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Redis生产问题✅"><a href="#Redis生产问题✅" class="headerlink" title="Redis生产问题✅"></a>Redis生产问题✅</h3><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是大量请求的 <code>key</code> 是不合理的，根本不存在于缓存中，也不存在于数据库中。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><strong>举例</strong><br>某个黑客故意制造一些非法的 <code>key</code> 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>做参数校验。一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</li>
<li>缓存无效 <code>key</code>。短暂地缓存无效<code>key</code>，并设置一个较短的过期时间，这样就可以防止缓存穿透。</li>
<li>布隆过滤器。布隆过滤器是一种数据结构，对所有可能查询的参数以 <code>hash</code> 形式存储在布隆过滤器中，当一个请求过来时，首先通过布隆过滤器判断这个请求的参数是否存在，如果不存在，直接返回，如果存在再去查询数据库。</li>
<li>接口限流。根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><strong>举例</strong><br>秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>永不过期(不推荐)：设置热点数据永不过期或者过期时间比较长。</li>
<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>加锁(看情况)：在缓存失效后，设置互斥锁确保只有一个请求去查询数据库并更新缓存。</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p><strong>举例</strong><br>数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p><strong>解决方案</strong><br>针对大量缓存同时失效的情况：</p>
<ol>
<li>设置随机失效时间(可选)：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li>
<li>提前预热(推荐)：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>持久缓存策略(看情况)：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li>
</ol>
<p>针对 Redis 服务不可用的情况：</p>
<ol>
<li>Redis 集群：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li>
<li>多级缓存：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>
</ol>
<h3 id="缓存穿透-缓存击穿区别"><a href="#缓存穿透-缓存击穿区别" class="headerlink" title="缓存穿透&#x2F;缓存击穿区别"></a>缓存穿透&#x2F;缓存击穿区别</h3><ul>
<li>缓存穿透中，请求的 <code>key</code> 既不存在于缓存中，也不存在于数据库中。</li>
<li>缓存击穿中，请求的 <code>key</code> 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中(通常是因为缓存中的那份数据已经过期) 。</li>
</ul>
<h3 id="缓存预热如何实现"><a href="#缓存预热如何实现" class="headerlink" title="缓存预热如何实现"></a>缓存预热如何实现</h3><ol>
<li>使用定时任务，比如 <code>xxl-job</code>，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>
<li>使用消息队列，比如 <code>Kafka</code>，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>
</ol>
<h3 id="缓存击穿-缓存雪崩区别"><a href="#缓存击穿-缓存雪崩区别" class="headerlink" title="缓存击穿&#x2F;缓存雪崩区别"></a>缓存击穿&#x2F;缓存雪崩区别</h3><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中(通常是因为缓存中的那份数据已经过期)。</p>
<h3 id="Redis常见阻塞原因"><a href="#Redis常见阻塞原因" class="headerlink" title="Redis常见阻塞原因"></a>Redis常见阻塞原因</h3><ol>
<li>O(n)命令：如<code>KEYS *</code>(返回所有符合规则的 <code>key</code>)、<code>HGETALL</code>(会返回一个 <code>Hash</code> 中所有的键值对)等，这些命令可能会导致 Redis 阻塞，影响 Redis 的性能。</li>
<li><code>Save</code>创建RDB快照：<code>save</code> 命令会使用 Redis 服务器主进程，直到 RDB 快照创建完成，从而阻塞了主进程的其他操作。</li>
<li>AOF记录AOF文件阻塞：AOF 在执行完命令后，记录 AOF 文件，这个记录过程是在 Redis 主线程中进行的。</li>
<li>AOF刷盘阻塞：开启 AOF 持久化后，每执行一条命令，都会<code>append</code>到AOF缓冲区，然后<code>write</code> 到系统内核缓冲区，最后 <code>fsync</code> 刷到磁盘。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。</li>
<li>AOF重写阻塞：AOF文件重写后，会把存储在AOF重写缓冲区中的创建新AOF文件期间的写命令追加到新的 AOF 文件末尾，这个追加操作是在主线程中进行的，可能会阻塞主线程。</li>
<li>查找和删除<code>bigkey</code>：查找<code>bigkey</code>时，Redis 会遍历所有的 <code>key</code>，这个操作是阻塞的。删除<code>bigkey</code>时，会先释放<code>bigkey</code>内存，然后将这块内存插入到内存空闲链表中，如果短时间释放大量的<code>bigkey</code>，空闲内存块插入链表的操作就会阻塞主线程。</li>
<li>清空数据库：<code>flushall</code> 和 <code>flushdb</code> 命令会删除和释放所有键值对，然后将内存插入空闲内存链表中，这个操作是阻塞的。</li>
<li>CPU竞争：Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</li>
<li>网络问题：连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</li>
</ol>
<h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>MongoDB 是一个基于 <strong>分布式文件存储</strong> 的开源 NoSQL 数据库系统，由 C++ 编写。MongoDB 提供<strong>面向文档</strong>的存储方式，支持“无模式”的数据建模，可存储较复杂的数据类型，是一款非常流行的 <strong>文档类型数据库</strong>。</p>
<p>在高负荷下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点&#x2F;实例，以保证服务性能和可用性。</p>
<h3 id="mongodb的存储结构是什么"><a href="#mongodb的存储结构是什么" class="headerlink" title="mongodb的存储结构是什么"></a>mongodb的存储结构是什么</h3><p>主要由三个单元组成：</p>
<ul>
<li>数据库(Database)：一个 MongoDB 可以有多个数据库，每个数据库都有自己的集合和文档。</li>
<li>集合(Collection)：一个数据库可以有多个集合，每个集合可以有多个文档。类似于关系型数据库中的表(<code>Table</code>)。</li>
<li>文档(Document)：MongoDB 中最基本的单元，由 BSON(Binary JSON) 键值对(<code>key-value</code>)组成，类似于关系型数据库中的行(<code>Row</code>)。</li>
</ul>
<p><strong>SQL 与 MongoDB 常见术语对比</strong>：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>表(Table)</td>
<td>集合(Collection)</td>
</tr>
<tr>
<td>行(Row)</td>
<td>文档(Document)</td>
</tr>
<tr>
<td>列(Col)</td>
<td>字段(Field)</td>
</tr>
<tr>
<td>主键(Primary Key)</td>
<td>对象 ID(Objectid)</td>
</tr>
<tr>
<td>索引(Index)</td>
<td>索引(Index)</td>
</tr>
<tr>
<td>嵌套表(Embedded Table)</td>
<td>嵌入式文档(Embedded Document)</td>
</tr>
<tr>
<td>数组(Array)</td>
<td>数组(Array)</td>
</tr>
</tbody></table>
<p><strong>集合</strong><br>集合存储于数据库中，<strong>没有固定的结构</strong>，也就是 <strong>无模式</strong> 的，这意味着可以往集合插入不同格式和类型的数据。</p>
<p>集合不需要事先创建，当第一个文档插入或者第一个索引创建时，如果该集合不存在，则会创建一个新的集合。</p>
<p><strong>文档</strong><br>BSON 文档由键值对组成的数据结构，BJSON 的遍历速度优于 JSON，但 BJSON 需要更多的存储空间。</p>
<h3 id="mongodb特点"><a href="#mongodb特点" class="headerlink" title="mongodb特点"></a>mongodb特点</h3><ul>
<li>数据被存储为文档：记录被存在 BSON 文档里面，文档是mongodb的基本数据单元。</li>
<li>数据模型自由：不需要设计表结构，可以存储不同结构的文档。</li>
<li>支持多种查询方式：支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。</li>
<li>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</li>
<li>高效的二进制存储：文档以键值对的形式存储在集合中，键(<code>ObjectId</code>类型)唯一标识文件，值是以 BSON 形式存在。</li>
<li>自带数据压缩功能：MongoDB 3.0 版本开始支持 <code>WiredTiger</code> 存储引擎，支持数据压缩，减少磁盘空间占用。</li>
<li>支持多种类型索引：支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等。</li>
<li>支持自动故障恢复：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。</li>
<li>支持分片集群：支持集群自动切分数据，在数据插入和更新时，能够自动路由和存储。</li>
<li>支持存储大文件：单文档要求不大于 16MB，对于大于 16MB 的文件，使用 <code>GridFS</code> 存储。</li>
</ul>
<h3 id="mongodb适合什么场景"><a href="#mongodb适合什么场景" class="headerlink" title="mongodb适合什么场景"></a>mongodb适合什么场景</h3><p>MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。适用于大数据量的存储、多类型索引、高性能读写、高可用性和可扩展性的场景。</p>
<h3 id="mongodb存储引擎"><a href="#mongodb存储引擎" class="headerlink" title="mongodb存储引擎"></a>mongodb存储引擎</h3><p>MongoDB 采用的是 <strong>插件式的存储引擎架构</strong>，现在主要使用两种存储引擎：</p>
<ul>
<li><code>MMAPv1</code> 存储引擎：使用了内存映射文件技术，支持复制集和分片集群，4.x 版本已经不再支持。</li>
<li><code>WiredTiger</code> 存储引擎：自 MongoDB 3.2 以后，默认的存储引擎为 <code>WiredTiger</code> 存储引擎，它提供文档级并发模型、检查点和数据压缩(后文会介绍到)等功能。</li>
<li><code>In-Memory</code> 存储引擎：In-Memory 存储引擎在 MongoDB Enterprise 中可用。它不是将文档存储在磁盘上，而是保留在内存中以获得更可预测的数据延迟。</li>
</ul>
<h3 id="WiredTiger存储引擎"><a href="#WiredTiger存储引擎" class="headerlink" title="WiredTiger存储引擎"></a>WiredTiger存储引擎</h3><p><code>WiredTiger</code> 存储引擎自 3.2 版本后成为 MongoDB 的默认存储引擎，其默认使用B+树作为索引结构，但也支持 LSM(Log Structured Merge) 树。</p>
<p>使用 B+ 树时，<code>WiredTiger</code> 以 <code>page</code> 为基本单位往磁盘读写数据。B+ 树的每个节点为一个 <code>page</code>，共有三种类型的 <code>page</code>：</p>
<ul>
<li><code>root page</code>(根节点)：B+ 树的根节点。</li>
<li><code>internal page</code>(内部节点)：不实际存储数据的中间索引节点。</li>
<li><code>leaf page</code>(叶子节点)：真正存储数据的叶子节点，包含一个页头(<code>page header</code>)、块头(<code>block header</code>)和真正的数据(<code>key/value</code>)，其中页头定义了页的类型、页中实际载荷数据的大小、页中记录条数等信息；块头定义了此页的 <code>checksum</code>、块在磁盘上的寻址位置等信息。</li>
</ul>
<h3 id="mongodb聚合"><a href="#mongodb聚合" class="headerlink" title="mongodb聚合"></a>mongodb聚合</h3><p>将多个文档甚至是多个集合汇总到一起计算分析(比如求和、取最大值)并返回计算后的结果，这个过程被称为聚合操作。通过聚合可以：</p>
<ul>
<li>将来自多个文档的值组合在一起。 </li>
<li>对集合中的数据进行的一系列运算。 </li>
<li>分析数据随时间的变化。</li>
</ul>
<p>两种聚合方法：</p>
<ul>
<li>聚合管道(Aggregation Pipeline)：执行聚合操作的首选方法。</li>
<li>单一目的聚合方法(Single purpose aggregation methods)：也就是单一作用的聚合函数比如 <code>count()</code>、<code>distinct()</code>、<code>estimatedDocumentCount()</code>。</li>
</ul>
<p>聚合管道由多个阶段组成，每个阶段在文档通过管道时转换文档。每个阶段接收前一个阶段的输出，进一步处理数据，并将其作为输入数据发送到下一个阶段。管道工作流程：</p>
<ul>
<li>接受一系列原始数据文档</li>
<li>对这些文档进行一系列运算</li>
<li>结果文档输出给下一个阶段</li>
</ul>
<h3 id="mongodb事务"><a href="#mongodb事务" class="headerlink" title="mongodb事务"></a>mongodb事务</h3><p>支持ACID事务：MongoDB单文档具备原子性，也具备事务特性， 4.0 版本开始支持多文档事务，4.2 版本开始支持分布式事务。</p>
<h3 id="mongodb数据压缩"><a href="#mongodb数据压缩" class="headerlink" title="mongodb数据压缩"></a>mongodb数据压缩</h3><p>借助 <code>WiredTiger</code> 存储引擎，MongoDB 支持数据压缩，减少磁盘空间占用。<code>WiredTiger</code> 存储引擎支持以下压缩算法：</p>
<ul>
<li><code>snappy</code>：快速压缩算法，压缩比(3～5倍)较低，但速度快。</li>
<li><code>zlib</code>：压缩比(5～7倍)较高，但速度较慢。</li>
<li><code>Zstandard</code>：针对实时压缩场景，具有更好的压缩比，提供更高的压缩率和更低的 CPU 使用率，MongoDB 4.2 开始可用。</li>
</ul>
<p><code>WiredTiger</code> 日志也会被压缩(大于128kb)，默认使用的也是 Snappy 压缩算法。</p>
<h3 id="mongodb索引"><a href="#mongodb索引" class="headerlink" title="mongodb索引"></a>mongodb索引</h3><p>索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量，并且可以使用索引中的排序返回排序后的结果。</p>
<p>索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。</p>
<p><strong>索引类型</strong></p>
<ul>
<li>单字段索引：建立在单个字段上的索引。</li>
<li>复合索引：建立在多个字段上的索引，也可以称之为组合索引、联合索引。</li>
<li>多键索引：MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。</li>
<li>哈希索引：按数据的哈希值索引，用在哈希分片集群上。</li>
<li>文本索引：支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。</li>
<li>地理位置索引：基于经纬度的索引，适合 2D 和 3D 的位置查询。</li>
<li>唯一索引：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。</li>
<li>TTL 索引：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除.</li>
</ul>
<h3 id="复合索引中字段顺序"><a href="#复合索引中字段顺序" class="headerlink" title="复合索引中字段顺序"></a>复合索引中字段顺序</h3><p>复合索引中字段的顺序非常重要，MongoDB 会按照复合索引中字段的顺序来建立索引。如果查询条件中的字段顺序和复合索引中的字段顺序一致，那么 MongoDB 可以使用该索引。</p>
<p>复合索引遵循最左前缀原则，拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。</p>
<blockquote>
<p>有一个类似 <code>&#123;a: 1, b: 1, c: 1, ..., z: 1&#125;</code> 这样的索引，那么实际上也等于有了 <code>&#123;a: 1&#125;</code>、<code>&#123;a: 1, b: 1&#125;</code>、<code>&#123;a: 1, b: 1, c: 1&#125;</code> 等一系列索引，但是不会有 <code>&#123;b: 1&#125;</code> 这样的非左前缀的索引。</p>
</blockquote>
<h3 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h3><p>TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间 <code>expireAfterSeconds</code>，当一个文档达到预设的过期时间之后就会被删除。TTL 索引除了有 <code>expireAfterSeconds</code> 属性外，和普通索引一样。</p>
<p>数据过期对于某些类型的信息很有用，比如机器生成的事件数据、日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>
<p><strong>原理</strong></p>
<ul>
<li>MongoDB 会开启一个后台线程读取该 TTL 索引的值判断文档是否过期，但不保证已过期的数据立马被删除，因后台线程每 60 秒触发一次删除任务，且如果删除的数据量较大，会存在上一次的删除未完成，而下一次的任务已经开启的情况，导致过期的数据也会出现超过了数据保留时间 60 秒以上的现象。</li>
<li>对于副本集而言，TTL 索引的后台进程只会在 Primary 节点开启，在从节点会始终处于空闲状态，从节点的数据删除由主库删除后产生的 <code>oplog</code> 做同步。</li>
</ul>
<p><strong>TTL索引限制</strong></p>
<ul>
<li>TTL 索引是单字段索引。复合索引不支持 TTL</li>
<li>如果某个字段已经存在非 TTL 索引，那么在该字段上无法再创建 TTL 索引。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://cwp0.github.io">cwp0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://cwp0.github.io/posts/17769.html">https://cwp0.github.io/posts/17769.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/SQL/">SQL</a><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/mongodb/">mongodb</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png" data-sites="facebook,twitter,wechat,weibo,qq,google,linkedin,douban"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.JPG" target="_blank"><img class="post-qr-code-img" src="/img/wechat.JPG" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.JPG" target="_blank"><img class="post-qr-code-img" src="/img/alipay.JPG" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/17771.html" title="框架等面经"><img class="cover" src="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">框架等面经</div></div></a></div><div class="next-post pull-right"><a href="/posts/17770.html" title="计算机基础"><img class="cover" src="https://s2.loli.net/2024/06/12/WHlmQVSb9NM8oXe.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">计算机基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/17766.html" title="Java后端面经"><img class="cover" src="https://s2.loli.net/2024/05/27/6wWObXhdZL13pqo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">Java后端面经</div></div></a></div><div><a href="/posts/17767.html" title="前端&amp;移动端面经"><img class="cover" src="https://s2.loli.net/2024/05/27/QygHftOujrEodTW.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="title">前端&amp;移动端面经</div></div></a></div><div><a href="/posts/17771.html" title="框架等面经"><img class="cover" src="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">框架等面经</div></div></a></div><div><a href="/posts/17772.html" title="手撕相关"><img class="cover" src="https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-13</div><div class="title">手撕相关</div></div></a></div><div><a href="/posts/17770.html" title="计算机基础"><img class="cover" src="https://s2.loli.net/2024/06/12/WHlmQVSb9NM8oXe.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-12</div><div class="title">计算机基础</div></div></a></div><div><a href="/posts/17773.html" title="面经汇总"><img class="cover" src="https://s2.loli.net/2024/06/25/Jfpxsi8HXMwbC29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-25</div><div class="title">面经汇总</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment"> Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/assets/%E5%A4%B4%E5%83%8F.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cwp0</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cwp0"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cwp0" target="_blank" title="Github"><i class="fab fa-github" style="color: #9F9F9F;"></i></a><a class="social-icon" href="mailto:wenpengchen@njust.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: 9F9F9F;"></i></a><a class="social-icon" href="/img/alipay.JPG" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #9F9F9F;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This site is under construction...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-NoSQL%E5%9F%BA%E7%A1%80"><span class="toc-text">SQL&#x2F;NoSQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL"><span class="toc-text">什么是SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DB-DBMS-DBS-DBA"><span class="toc-text">DB&#x2F;DBMS&#x2F;DBS&#x2F;DBA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD"><span class="toc-text">数据库术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84-%E7%A0%81-%E5%80%99%E9%80%89%E7%A0%81-%E4%B8%BB%E7%A0%81-%E5%A4%96%E7%A0%81-%E4%B8%BB%E5%B1%9E%E6%80%A7-%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="toc-text">元组&#x2F;码&#x2F;候选码&#x2F;主码&#x2F;外码&#x2F;主属性&#x2F;非主属性概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ER%E5%9B%BE"><span class="toc-text">ER图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-text">数据库三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE-%E5%A4%96%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-text">主键&#x2F;外键区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E5%92%8C%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="toc-text">为什么不推荐使用外键和级联操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DROP-TRUNCATE-DELETE%E5%8C%BA%E5%88%AB"><span class="toc-text">DROP&#x2F;TRUNCATE&#x2F;DELETE区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E6%AD%A5"><span class="toc-text">数据库设计分为哪几个步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNoSQL"><span class="toc-text">什么是NoSQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-NoSQL%E5%8C%BA%E5%88%AB"><span class="toc-text">SQL&#x2F;NoSQL区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E4%BC%98%E5%8A%A3"><span class="toc-text">NoSQL优劣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E5%88%86%E7%B1%BB"><span class="toc-text">NoSQL分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB"><span class="toc-text">数据库分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E6%96%B9%E5%BC%8F"><span class="toc-text">SQL三种注释方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML%E8%AF%AD%E5%8F%A5%E2%9C%85"><span class="toc-text">DML语句✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5CRUD"><span class="toc-text">增删改查CRUD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-text">分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HAVING"><span class="toc-text">HAVING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WHERE-HAVING%E5%AF%B9%E6%AF%94"><span class="toc-text">WHERE&#x2F;HAVING对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WHERE"><span class="toc-text">WHERE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IN-BETWEEN"><span class="toc-text">IN&#x2F;BETWEEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AND-OR-NOT"><span class="toc-text">AND&#x2F;OR&#x2F;NOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE"><span class="toc-text">LIKE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5JOIN"><span class="toc-text">连接JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5-%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">内连接&#x2F;外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ON-WHERE%E5%8C%BA%E5%88%AB"><span class="toc-text">ON&#x2F;WHERE区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88UNION"><span class="toc-text">组合UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL%E8%AF%AD%E8%A8%80%E2%9C%85"><span class="toc-text">DDL语言✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93DATABSE"><span class="toc-text">数据库DATABSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8TABLE"><span class="toc-text">数据表TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BEVIEW"><span class="toc-text">视图VIEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95INDEX"><span class="toc-text">索引INDEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-text">约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCL%E8%AF%AD%E5%8F%A5%E2%9C%85"><span class="toc-text">TCL语句✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1TRANSACTION"><span class="toc-text">事务TRANSACTION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCL%E8%AF%AD%E5%8F%A5%E2%9C%85"><span class="toc-text">DCL语句✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87CURSOR"><span class="toc-text">游标CURSOR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8TRIGGER"><span class="toc-text">触发器TRIGGER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">触发器语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80%E2%9C%85"><span class="toc-text">MySQL基础✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%BC%98%E7%82%B9"><span class="toc-text">MySQL优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">什么是关系型数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-text">MySQL字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84UNSIGNED%E5%B1%9E%E6%80%A7"><span class="toc-text">整数类型的UNSIGNED属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CHAR-VARCHAR%E5%8C%BA%E5%88%AB"><span class="toc-text">CHAR&#x2F;VARCHAR区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VARCHAR-100-VARCHAR-10-%E5%8C%BA%E5%88%AB"><span class="toc-text">VARCHAR(100)&#x2F;VARCHAR(10)区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DECIMAL%E5%92%8CFLOAT-DOUBLE%E5%8C%BA%E5%88%AB"><span class="toc-text">DECIMAL和FLOAT&#x2F;DOUBLE区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8TEXT-BLOB%E7%B1%BB%E5%9E%8B"><span class="toc-text">为什么没不推荐使用TEXT&#x2F;BLOB类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DATETIME-TIMESTAMP%E5%8C%BA%E5%88%AB"><span class="toc-text">DATETIME&#x2F;TIMESTAMP区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NULL%E5%92%8C%E2%80%99%E2%80%99%E5%8C%BA%E5%88%AB"><span class="toc-text">NULL和’’区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E5%9C%A8MySQL%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-text">Boolean类型如何在MySQL中存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E2%9C%85"><span class="toc-text">MySQL基础架构✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">SQL语句在MySQL中的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E2%9C%85"><span class="toc-text">MySQL存储引擎✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-text">MySQL支持哪些存储引擎？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">MySQL存储引擎架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">MyISAM&#x2F;InnoDB存储引擎区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E2%9C%85"><span class="toc-text">MySQL索引✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E5%9E%8B"><span class="toc-text">索引底层数据类型选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-InnoDB%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-text">MyISAM&#x2F;InnoDB索引区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引&#x2F;非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8"><span class="toc-text">回表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">覆盖索引&#x2F;联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">联合索引最左前缀匹配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8ICP"><span class="toc-text">索引下推ICP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E2%9C%85"><span class="toc-text">MySQL查询缓存✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E2%9C%85"><span class="toc-text">MySQL三大日志✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-text">刷盘策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog"><span class="toc-text">binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">写入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E2%9C%85"><span class="toc-text">MySQL事务✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">事务的四大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">并发事务存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-text">丢失修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">不可重复读和幻读有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">并发事务的控制方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E2%9C%85"><span class="toc-text">MVCC✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB-%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-text">锁定读&#x2F;当前读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0"><span class="toc-text">InnoDB的MVCC实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8BMVCC%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">RC和RR隔离级别下MVCC的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84MVCC%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-text">RR隔离级别下的MVCC如何解决幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%94%81%E2%9C%85"><span class="toc-text">MySQL锁✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81-%E8%A1%8C%E7%BA%A7%E9%94%81%E5%8C%BA%E5%88%AB"><span class="toc-text">表级锁&#x2F;行级锁区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">InnoDB的行级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-text">共享锁&#x2F;排他锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB-%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-text">当前读&#x2F;快照读区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%9C%85"><span class="toc-text">MySQL性能优化✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%94%A8MySQL%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%90%97%EF%BC%9F"><span class="toc-text">可以用MySQL存储文件吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8IP%E5%9C%B0%E5%9D%80"><span class="toc-text">MySQL如何存储IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90SQL%E6%80%A7%E8%83%BD"><span class="toc-text">如何分析SQL性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E2%9C%85"><span class="toc-text">MySQL执行计划✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E2%9C%85"><span class="toc-text">MySQL读写分离✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">如何实现读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-text">如何避免主从延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-text">什么情况下会出现主从延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%9C%85"><span class="toc-text">MySQL分库分表✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">什么情况下需要分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95"><span class="toc-text">分片算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%94%AE"><span class="toc-text">分片键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">分库分表会带来什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB"><span class="toc-text">分库分表中数据如何迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB%E2%9C%85"><span class="toc-text">MySQL数据冷热分离✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%83%AD%E6%95%B0%E6%8D%AE"><span class="toc-text">冷数据和热数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB"><span class="toc-text">冷数据如何迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8"><span class="toc-text">冷数据如何存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">MySQL字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B1%82%E6%AC%A1%E7%BA%A7%E5%88%AB"><span class="toc-text">MySQL字符集层次级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-text">Redis为什么这么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Memcached"><span class="toc-text">Redis&#x2F;Memcached</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis"><span class="toc-text">为什么用Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-text">三种常用缓存读写策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Redis除了做缓存还有哪些应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97"><span class="toc-text">Redis可以做消息队列吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%90%97"><span class="toc-text">Redis可以做搜索引擎吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E2%9C%85"><span class="toc-text">基于Redis实现延时任务✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">Redis过期事件监听实现延时任务的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="toc-text">Redis过期事件监听实现延时任务有什么缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson%E5%86%85%E7%BD%AE%E7%9A%84%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%BF"><span class="toc-text">Redisson内置的延时队列实现延时任务的原理及优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%9C%85"><span class="toc-text">Redis数据类型✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset"><span class="toc-text">Zset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap"><span class="toc-text">Bitmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geospatial"><span class="toc-text">Geospatial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8String%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AFHash"><span class="toc-text">使用String存储对象还是Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%E5%AD%98%E5%82%A8"><span class="toc-text">购物车信息用String还是Hash存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8"><span class="toc-text">Zset为什么要用跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8Set%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F"><span class="toc-text">用Set实现抽奖系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7"><span class="toc-text">Bitmap统计活跃用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99-UV"><span class="toc-text">HyperLogLog统计网站 UV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E2%9C%85"><span class="toc-text">Redis持久化机制✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">为什么要持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">三种持久化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">RDB持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%88%9B%E5%BB%BA%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-text">RDB创建时会阻塞主线程吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">AOF持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">AOF工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-text">AOF持久化的三种同步策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%91%BD%E4%BB%A4%E5%90%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-text">AOF为什么是执行完命令后记录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99"><span class="toc-text">AOF重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">AOF校验机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis4-0%E5%AF%B9%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">Redis4.0对持久化的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9RDB%E5%92%8CAOF"><span class="toc-text">如何选择RDB和AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E2%9C%85"><span class="toc-text">Redis单线程模型✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%A4%A7%E9%87%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%93%BE%E6%8E%A5"><span class="toc-text">如何监听大量客户端链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis4-0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Redis4.0多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Redis6.0之前为什么不用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">Redis6.0之后为何引入多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">Redis后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E2%9C%85"><span class="toc-text">Redis内存管理✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8"><span class="toc-text">Redis给缓存数据设置过期时间有啥用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F"><span class="toc-text">Redis如何判断数据过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9Fkey%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">Redis过期key删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E8%AF%A6%E7%BB%86%E7%BB%86%E8%8A%82"><span class="toc-text">定期删除策略详细细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E2%9C%85"><span class="toc-text">Redis内存淘汰策略✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-text">Redis事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">如何解决Redis事务的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%9C%85"><span class="toc-text">Redis性能优化✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-text">批量操作减少网络传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F"><span class="toc-text">大量key集中过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bigkey-%E5%A4%A7key"><span class="toc-text">bigkey(大key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hotkey-%E7%83%ADkey"><span class="toc-text">hotkey(热key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-text">慢查询命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E2%9C%85"><span class="toc-text">Redis内存碎片✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-text">内存碎片产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87"><span class="toc-text">查看内存碎片率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%B8%85%E7%90%86"><span class="toc-text">Redis内存碎片清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E2%9C%85"><span class="toc-text">Redis生产问题✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%8C%BA%E5%88%AB"><span class="toc-text">缓存穿透&#x2F;缓存击穿区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">缓存预热如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB"><span class="toc-text">缓存击穿&#x2F;缓存雪崩区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0"><span class="toc-text">Redis常见阻塞原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mongodb"><span class="toc-text">mongodb</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">mongodb的存储结构是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E7%89%B9%E7%82%B9"><span class="toc-text">mongodb特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-text">mongodb适合什么场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">mongodb存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WiredTiger%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">WiredTiger存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E8%81%9A%E5%90%88"><span class="toc-text">mongodb聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E4%BA%8B%E5%8A%A1"><span class="toc-text">mongodb事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-text">mongodb数据压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodb%E7%B4%A2%E5%BC%95"><span class="toc-text">mongodb索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%AD%97%E6%AE%B5%E9%A1%BA%E5%BA%8F"><span class="toc-text">复合索引中字段顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TTL%E7%B4%A2%E5%BC%95"><span class="toc-text">TTL索引</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/17773.html" title="面经汇总"><img src="https://s2.loli.net/2024/06/25/Jfpxsi8HXMwbC29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面经汇总"/></a><div class="content"><a class="title" href="/posts/17773.html" title="面经汇总">面经汇总</a><time datetime="2024-06-25T11:52:15.000Z" title="Created 2024-06-25 19:52:15">2024-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17772.html" title="手撕相关"><img src="https://s2.loli.net/2024/06/13/pjr3CuksNxU9ZJK.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撕相关"/></a><div class="content"><a class="title" href="/posts/17772.html" title="手撕相关">手撕相关</a><time datetime="2024-06-13T08:18:26.000Z" title="Created 2024-06-13 16:18:26">2024-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17771.html" title="框架等面经"><img src="https://s2.loli.net/2024/06/12/tSWPZr1EQH6XRAm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="框架等面经"/></a><div class="content"><a class="title" href="/posts/17771.html" title="框架等面经">框架等面经</a><time datetime="2024-06-12T14:49:36.000Z" title="Created 2024-06-12 22:49:36">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17769.html" title="数据库"><img src="https://s2.loli.net/2024/06/12/cKiSbvguBp27oq8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库"/></a><div class="content"><a class="title" href="/posts/17769.html" title="数据库">数据库</a><time datetime="2024-06-12T14:47:36.000Z" title="Created 2024-06-12 22:47:36">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17770.html" title="计算机基础"><img src="https://s2.loli.net/2024/06/12/WHlmQVSb9NM8oXe.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机基础"/></a><div class="content"><a class="title" href="/posts/17770.html" title="计算机基础">计算机基础</a><time datetime="2024-06-12T14:47:24.000Z" title="Created 2024-06-12 22:47:24">2024-06-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> cwp0</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'nfRxTBEmIAeb6gP2K0LOdLqw-gzGzoHsz',
      appKey: 'vmeDN8k58dVdPv5Yz7NEkvSN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      tagMeta: ["博主", "小伙伴", "访客"],
      master: ['fb5b8162294f5bda9321f095ee3a5857', '8c0fcea8917ddba8e86ee8a88c2a15a9'],
      friends:  [],
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine()
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  window.$crisp = [];
  window.CRISP_WEBSITE_ID = "19701af9-3bff-41b9-919e-742aca557e36";
  (function () {
    d = document;
    s = d.createElement("script");
    s.src = "https://client.crisp.chat/l.js";
    s.async = 1;
    d.getElementsByTagName("head")[0].appendChild(s);
  })();
  $crisp.push(["safe", true])

  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const open = () => {
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])
    }

    const close = () => {
      $crisp.push(["do", "chat:hide"])
    }

    close()
    $crisp.push(["on", "chat:closed", function() {
      close()
    }])

    window.chatBtnFn = () => {
      $crisp.is("chat:visible") ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        $crisp.push(["do", "chat:hide"])
      },
      show: () => {
        $crisp.push(["do", "chat:show"])
      }
    }
  }
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>